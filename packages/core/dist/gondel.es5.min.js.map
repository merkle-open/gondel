{"version":3,"file":"gondel.es5.min.js","sources":["GondelPluginUtils.js","GondelEventEmitter.js","GondelComponentStarter.js","GondelComponentRegistry.js","GondelAutoStart.js","GondelDomUtils.js","GondelEventRegistry.js","GondelDecorators.js","GondelComponent.js"],"sourcesContent":["var basePluginListener = function (result, data, next) { return next(result); };\n// Global plugin events registry\nvar pluginEventRegistry = window.__gondelPluginEvents || { pluginMapping: {}, pluginEvents: {} };\nwindow.__gondelPluginEvents = pluginEventRegistry;\n/** Global Plugin Event Handler Registry */\nexport var pluginEvents = pluginEventRegistry.pluginEvents;\n// Mapping to track if plugin was already registered to prevent double registrations\nvar pluginMapping = pluginEventRegistry.pluginMapping;\nexport function fireGondelPluginEvent(eventName, initialValue, data, callback) {\n    var isSyncron = false;\n    var callbackResult;\n    // Execute all bound events for the given name\n    // if they exist\n    (pluginEvents[eventName] || basePluginListener)(initialValue, data, function (processedResult) {\n        isSyncron = true;\n        callbackResult = callback ? callback(processedResult) : processedResult;\n    });\n    // Add a guard to prevent asyncron plugin listeners\n    // to simplify the usage of fireGondelPluginEvent\n    if (!isSyncron) {\n        throw new Error('Async plugin listener');\n    }\n    return callbackResult;\n}\n/**\n * Fire an async event which allows gondel plugins to add features to gondel\n */\nexport function fireAsyncGondelPluginEvent(eventName, initialValue, data) {\n    return new Promise(function (resolve) {\n        (pluginEvents[eventName] || basePluginListener)(initialValue, data, function (result) {\n            resolve(result);\n        });\n    });\n}\n/**\n * Allow plugins to hook into the gondel event system\n */\nexport function addGondelPluginEventListener(pluginName, eventName, eventListenerCallback) {\n    // Prevent any event registration if this pluginHandlerName\n    // has already been used\n    var pluginHandlerNamePerEvent = \"\".concat(eventName, \"#\").concat(pluginName);\n    if (pluginMapping[pluginHandlerNamePerEvent]) {\n        return;\n    }\n    // Flag plugin as registered\n    pluginMapping[pluginHandlerNamePerEvent] = true;\n    // Ensure that an entry for the given event name exists\n    if (!pluginEvents[eventName]) {\n        pluginEvents[eventName] = basePluginListener;\n    }\n    var previousEventHandler = pluginEvents[eventName];\n    pluginEvents[eventName] = function wrapCallback(result, data, next) {\n        previousEventHandler(result, data, function callNextPlugin(modifiedResult, _, firstNext) {\n            eventListenerCallback(modifiedResult, data, function bindData(result) {\n                next(result, data, firstNext);\n            });\n        });\n    };\n}\n//# sourceMappingURL=GondelPluginUtils.js.map","import { getFirstDomNode } from './GondelDomUtils';\n/**\n * Submit an event which might be caught by foreign gondel, angular or react components\n */\nexport function triggerPublicEvent(eventName, gondelComponent, target, eventData, canBubble) {\n    if (eventData === void 0) { eventData = {}; }\n    if (canBubble === void 0) { canBubble = true; }\n    var event = document.createEvent('Event');\n    var eventTarget = target ? getFirstDomNode(target) : gondelComponent._ctx;\n    var namespace = gondelComponent._namespace;\n    if (eventName.substr(0, namespace.length) !== namespace) {\n        throw new Error(\"Invalid event name '\" +\n            eventName +\n            \"' - use '\" +\n            namespace +\n            eventName.charAt(0).toUpperCase() +\n            eventName.slice(1) +\n            \"'\");\n    }\n    event.initEvent(eventName, canBubble, true);\n    event.data = {\n        component: gondelComponent,\n        name: gondelComponent._componentName,\n        namespace: gondelComponent._namespace,\n        eventData: eventData,\n    };\n    return eventTarget.dispatchEvent(event);\n}\n//# sourceMappingURL=GondelEventEmitter.js.map","import { internalGondelAsyncRefAttribute, internalGondelRefAttribute } from './GondelDomUtils';\nimport { triggerPublicEvent } from './GondelEventEmitter';\nimport { fireGondelPluginEvent } from './GondelPluginUtils';\nvar noop = function () { };\nvar Deferred = function () {\n    var _this = this;\n    this.promise = new Promise(function (resolve) {\n        _this.resolve = resolve;\n    });\n};\n/**\n * Start all components of the gondel component registry\n * for the given dom context\n */\nexport function startComponentsFromRegistry(gondelComponentRegistry, domContext, namespace) {\n    // Get an array of all nodes which match the namespace\n    var gondelDomNodeList = Array.prototype.slice.call(domContext.querySelectorAll(\"[data-\".concat(namespace, \"-name]\")));\n    if (domContext.hasAttribute(\"data-\".concat(namespace, \"-name\"))) {\n        gondelDomNodeList.push(domContext);\n    }\n    // Remove already booted nodes\n    var pristineGondelDomNodes = gondelDomNodeList.filter(function (gondelDomNode) {\n        return isPristineGondelDomNode(gondelDomNode, namespace);\n    });\n    var bootingDeferred = new Deferred();\n    // Mark all nodes as booting\n    pristineGondelDomNodes.forEach(function (gondelDomNode) {\n        attachGondelBootingFlag(gondelDomNode, bootingDeferred.promise, namespace);\n    });\n    // Create instances\n    var gondelComponents = fireGondelPluginEvent('boot', pristineGondelDomNodes, { namespace: namespace }, function (pristineGondelDomNodes) {\n        return pristineGondelDomNodes.map(function (gondelDomNode) {\n            return constructComponent(gondelDomNode, gondelComponentRegistry, namespace);\n        });\n    });\n    // Get all component names\n    var newComponentNames = getNewComponents(gondelComponents, gondelComponentRegistry);\n    newComponentNames.forEach(function (componentName) { return gondelComponentRegistry.setActiveState(componentName, true); });\n    // Start all components\n    var gondelComponentStartPromise = fireGondelPluginEvent('start', gondelComponents, { newComponentNames: newComponentNames, namespace: namespace, gondelComponentRegistry: gondelComponentRegistry }, function (gondelComponents) {\n        // Wait for async started components\n        return Promise.all(gondelComponents.map(startConstructedComponent));\n    })\n        // Let all plugins know that the components are now all ready to use\n        .then(function () {\n        gondelComponents.forEach(function (gondelComponent) {\n            if (gondelComponent.sync) {\n                gondelComponent.sync();\n            }\n        });\n        return fireGondelPluginEvent('sync', gondelComponents, { namespace: namespace });\n    });\n    // Resolve the booting deferred\n    gondelComponentStartPromise\n        .then(bootingDeferred.resolve, bootingDeferred.resolve)\n        // Rethrow errors (if any)\n        // otherwise the browser dev tools won't show\n        // important bootstrap errors\n        .then(function () { return gondelComponentStartPromise; });\n    // Return a promise of all started components\n    return gondelComponentStartPromise;\n}\n/**\n * Returns true if the given domNode is neither booting nor booted\n */\nexport function isPristineGondelDomNode(domNode, namespace) {\n    return !domNode.hasOwnProperty(internalGondelAsyncRefAttribute + namespace);\n}\n/**\n * Mark the given dom node as controlled by gondel\n */\nexport function attachGondelBootingFlag(domNode, bootingFlag, namespace) {\n    // The name `A` mean async\n    // to allow waiting for asyncronous booted components\n    domNode[internalGondelAsyncRefAttribute + namespace] = bootingFlag;\n}\n/**\n * Constructs a new component\n */\nexport function constructComponent(domNode, gondelComponentRegistry, namespace) {\n    var componentName = domNode.getAttribute(\"data-\".concat(namespace, \"-name\"));\n    var GondelComponent = gondelComponentRegistry.getComponent(componentName);\n    if (GondelComponent === undefined) {\n        throw new Error(\"Failed to boot component - \".concat(componentName, \" is not registred\"));\n    }\n    var componentInstance = new GondelComponent(domNode, componentName);\n    componentInstance._ctx = domNode;\n    componentInstance._namespace = namespace;\n    componentInstance._componentName = componentName;\n    // Add stop method\n    componentInstance.stop = stopStartedComponent.bind(null, componentInstance, componentInstance.stop || noop, namespace);\n    // Create a circular reference which will allow access to the componentInstance from ctx\n    domNode['_gondel_' + namespace] = componentInstance;\n    return componentInstance;\n}\n/**\n * Start a component after it was constructed\n */\nexport function startConstructedComponent(component) {\n    // Skip if the start method is missing\n    if (!component.start) {\n        return;\n    }\n    var expectsNoArguments = component.start.length === 0;\n    // Start the component and expect a promise or a syncronous return value\n    // if the function expects no arguments\n    if (expectsNoArguments) {\n        return component.start();\n    }\n    return new Promise(function (resolve, reject) { return component.start(resolve, reject); });\n}\n/**\n * Stops a started component\n */\nexport function stopStartedComponent(component, internalStopMethod, namespace) {\n    triggerPublicEvent(\"\".concat(namespace, \"Stop\"), component, component._ctx);\n    // Remove the component instance from the html element\n    delete component._ctx[internalGondelRefAttribute + namespace];\n    delete component._ctx[internalGondelAsyncRefAttribute + namespace];\n    component._stopped = true;\n    fireGondelPluginEvent('stop', component, { namespace: namespace }, internalStopMethod.bind(component));\n}\n/**\n * Filters the given component list and returns the names of those components which have never been started before\n */\nfunction getNewComponents(components, registry) {\n    var componentNameHelper = {};\n    components.forEach(function (component) { return (componentNameHelper[component._componentName] = true); });\n    var componentNames = Object.keys(componentNameHelper);\n    return componentNames.filter(function (componentName) { return !registry._activeComponents[componentName]; });\n}\n//# sourceMappingURL=GondelComponentStarter.js.map","import { fireGondelPluginEvent } from './GondelPluginUtils';\nimport { addRegistryToBootloader } from './GondelAutoStart';\nvar GLOBAL_GONDEL_REGISTRY_NAMESPACE = '__\\ud83d\\udea1Registries';\nvar GondelComponentRegistry = /** @class */ (function () {\n    function GondelComponentRegistry() {\n        this._components = {};\n        this._activeComponents = {};\n        this._bootMode = 2 /* RegistryBootMode.onDomReady */;\n    }\n    GondelComponentRegistry.prototype.registerComponent = function (name, gondelComponent) {\n        this._components[name] = gondelComponent;\n    };\n    GondelComponentRegistry.prototype.unregisterComponent = function (name) {\n        delete this._components[name];\n    };\n    GondelComponentRegistry.prototype.getComponent = function (name) {\n        return this._components[name];\n    };\n    /**\n     * Set if a component is used\n     */\n    GondelComponentRegistry.prototype.setActiveState = function (name, isActive) {\n        this._activeComponents[name] = isActive;\n    };\n    GondelComponentRegistry.prototype.setBootMode = function (bootMode) {\n        this._bootMode = bootMode;\n    };\n    return GondelComponentRegistry;\n}());\nexport { GondelComponentRegistry };\nvar _componentRegistries;\nexport function getComponentRegistry(namespace) {\n    if (!_componentRegistries) {\n        _componentRegistries = window[GLOBAL_GONDEL_REGISTRY_NAMESPACE] || {};\n        window[GLOBAL_GONDEL_REGISTRY_NAMESPACE] = _componentRegistries;\n    }\n    if (!_componentRegistries[namespace]) {\n        _componentRegistries[namespace] = new GondelComponentRegistry();\n        addRegistryToBootloader(namespace);\n    }\n    return _componentRegistries[namespace];\n}\nexport function registerComponent() {\n    var args = arguments;\n    // The componentName is always the first argument\n    var componentName = args[0];\n    // Use namespace from the second argument or fallback to the default \"g\" if it is missing\n    var namespace = typeof args[1] === 'string' ? args[1] : 'g';\n    // The last argument is always the component class\n    var component = args[args.length - 1];\n    var gondelComponentRegistry = getComponentRegistry(namespace);\n    // If this component was already registered we remove the previous one\n    // and notify all plugins - this is especially usefull for hot component replacement\n    if (gondelComponentRegistry.getComponent(componentName)) {\n        fireGondelPluginEvent('unregister', component, { componentName: componentName, namespace: namespace });\n    }\n    // Let plugins know about the new component\n    fireGondelPluginEvent('register', component, {\n        componentName: componentName,\n        namespace: namespace,\n        gondelComponentRegistry: gondelComponentRegistry,\n    }, function (component) {\n        gondelComponentRegistry.registerComponent(componentName, component);\n    });\n}\n//# sourceMappingURL=GondelComponentRegistry.js.map","import { getComponentRegistry } from './GondelComponentRegistry';\nimport { startComponentsFromRegistry } from './GondelComponentStarter';\n/**\n * By default Gondel will run startComponents on DOMContentLoaded\n * To gain more controll over the boot behaviour tihs function can be called\n * to disable the auto start\n */\nexport function disableAutoStart(namespace) {\n    if (namespace === void 0) { namespace = 'g'; }\n    getComponentRegistry(namespace).setBootMode(1 /* RegistryBootMode.manual */);\n}\n/**\n * Wait for document ready and boot the registry\n */\nexport function addRegistryToBootloader(namespace) {\n    // Use new Promise to wait for the next tick\n    var boot = function () {\n        Promise.resolve().then(function () {\n            var gondelComponentRegistry = getComponentRegistry(namespace);\n            if (gondelComponentRegistry._bootMode === 2 /* RegistryBootMode.onDomReady */) {\n                gondelComponentRegistry.setBootMode(0 /* RegistryBootMode.alreadyBooted */);\n                startComponentsFromRegistry(gondelComponentRegistry, document.documentElement, namespace);\n            }\n        });\n    };\n    // Boot if document is complete or once it completes\n    if (document.readyState == 'complete') {\n        boot();\n    }\n    else {\n        document.addEventListener('DOMContentLoaded', boot, false);\n    }\n}\n//# sourceMappingURL=GondelAutoStart.js.map","import { getComponentRegistry } from './GondelComponentRegistry';\nimport { startComponentsFromRegistry } from './GondelComponentStarter';\nexport var internalGondelRefAttribute = '_gondel_';\nexport var internalGondelAsyncRefAttribute = '_gondelA_';\n/**\n * Returns true if the given object is a single Element\n */\nfunction isElement(domNode) {\n    return domNode.nodeType !== undefined;\n}\n/**\n * This function normalizes takes one of the following:\n *  + document query result\n *  + dom node array\n *  + jquery object\n *  + a single dom node\n * and turns it into a single dom node\n */\nexport function getFirstDomNode(domNode) {\n    if (isElement(domNode)) {\n        return domNode;\n    }\n    return domNode[0];\n}\n/**\n * Start all nodes in the given context\n */\nexport function startComponents(domContext, namespace) {\n    if (namespace === void 0) { namespace = 'g'; }\n    var registry = getComponentRegistry(namespace);\n    return startComponentsFromRegistry(registry, domContext ? getFirstDomNode(domContext) : document.documentElement, namespace);\n}\n/**\n * Stop all nodes in the given context\n */\nexport function stopComponents(domContext, namespace) {\n    if (namespace === void 0) { namespace = 'g'; }\n    var components = findComponents(domContext, undefined, namespace);\n    if (domContext && hasMountedGondelComponent(domContext)) {\n        components.unshift(getComponentByDomNode(domContext));\n    }\n    components.forEach(function (component) { return component.stop(); });\n}\n/**\n * Checks if a component is mounted on a certain DOM node\n */\nexport function hasMountedGondelComponent(domNode, namespace) {\n    if (namespace === void 0) { namespace = 'g'; }\n    var firstNode = getFirstDomNode(domNode);\n    var gondelComponent = firstNode[internalGondelRefAttribute + namespace];\n    if (!gondelComponent || !gondelComponent._ctx) {\n        // no anchor prop found or ctx missing. function is needed\n        // that we can type the `getComponentByDomNode` without possible\n        // returnal of undefined.\n        return false;\n    }\n    return true;\n}\n/**\n * Returns the gondel instance for the given HtmlELement\n */\nexport function getComponentByDomNode(domNode, namespace) {\n    if (namespace === void 0) { namespace = 'g'; }\n    var gondelComponent = extractComponent(getFirstDomNode(domNode), namespace);\n    if (!gondelComponent) {\n        throw new Error(\"Could not find a started gondel component in namespace \\\"\".concat(namespace, \"\\\",\\nplease check if your component is mounted via 'hasMountedGondelComponent'\"));\n    }\n    return gondelComponent;\n}\n/**\n * Internal helper function of getComponentByDomNode\n *\n * Returns the gondel instance from a known HtmlElement\n * This function is an internal helper with a possible undefined\n * return value.\n */\nexport function extractComponent(element, namespace) {\n    var gondelComponent = element[internalGondelRefAttribute + namespace];\n    // Stop if this dom node is not known to gondel\n    if (gondelComponent && gondelComponent._ctx) {\n        return gondelComponent;\n    }\n}\n/**\n * Returns the gondel instance for the given HtmlELement once it is booted\n */\nexport function getComponentByDomNodeAsync(domNode, namespace) {\n    if (namespace === void 0) { namespace = 'g'; }\n    var firstNode = getFirstDomNode(domNode);\n    var gondelComponent = firstNode[internalGondelAsyncRefAttribute + namespace];\n    // Stop if this dom node is not known to gondel\n    if (!gondelComponent) {\n        return Promise.reject(undefined);\n    }\n    // or the component is already booted up return it\n    if (gondelComponent._ctx) {\n        return Promise.resolve(gondelComponent);\n    }\n    // Wait the component to boot up and return it\n    return gondelComponent.then(function () { return firstNode[internalGondelRefAttribute + namespace]; });\n}\n/**\n * Returns all components inside the given node\n */\nexport function findComponents(domNode, componentName, namespace) {\n    if (domNode === void 0) { domNode = document.documentElement; }\n    if (namespace === void 0) { namespace = 'g'; }\n    var firstNode = getFirstDomNode(domNode);\n    var components = [];\n    var attribute = \"_gondel_\".concat(namespace);\n    var nodes = firstNode.querySelectorAll(\"[data-\".concat(namespace, \"-name\").concat(componentName ? \"=\\\"\".concat(componentName, \"\\\"\") : '', \"]\"));\n    for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var gondelComponentInstance = node[attribute];\n        // Verify that the component is fully booted\n        if (gondelComponentInstance && gondelComponentInstance._ctx === node) {\n            components.push(gondelComponentInstance);\n        }\n    }\n    return components;\n}\n//# sourceMappingURL=GondelDomUtils.js.map","/**\n * The event registry provides a way to bind events ahead of time\n * with a very small foot print during launch to improve the time to interaction\n */\nimport { extractComponent } from './GondelDomUtils';\nimport { fireGondelPluginEvent } from './GondelPluginUtils';\n/**\n * Only real browser events are supported.\n * Unfortunately focus and blur do not bubble so a special mapping is needed.\n */\nvar eventNameMapping = {\n    focus: 'focusin',\n    blur: 'focusout',\n};\n// Polyfill for element.prototype.matches\nvar matchesCssSelector = function (element, selector) {\n    var elementPrototype = window.Element.prototype;\n    /* istanbul ignore next : Browser polyfill can't be tested */\n    var elementMatches = elementPrototype.matches ||\n        elementPrototype.matchesSelector ||\n        elementPrototype.mozMatchesSelector ||\n        elementPrototype.msMatchesSelector ||\n        elementPrototype.webkitMatchesSelector;\n    // Cache the function and call it\n    return (matchesCssSelector = function (element, selector) {\n        return elementMatches.call(element, selector);\n    })(element, selector);\n};\nfunction getParentElements(startElement) {\n    var nodes = [];\n    for (var element = startElement; element; element = element.parentElement) {\n        nodes.push(element);\n    }\n    return nodes;\n}\n/**\n * Returns an array of all handlers which would apply for the current target\n */\nexport function getHandlers(attributeName, eventHandlerRegistry, target) {\n    var parents = getParentElements(target);\n    // Find all selectors which have been registred for this event type\n    // and which have a gondel component in one of the parrent nodes\n    var selectorsOfFoundComponents = [];\n    parents.forEach(function (parent, i) {\n        var componentName = parent.getAttribute(attributeName);\n        var handlers = componentName && eventHandlerRegistry[componentName];\n        if (handlers) {\n            // Store the index where the component was found to know in which part\n            // of the dom tree the selectors could be found\n            selectorsOfFoundComponents.push({ index: i, handlers: handlers });\n        }\n    });\n    // Iterate over all possible selectors to find out if the current event\n    // should fire any gondel handler\n    var handlerQueue = [];\n    selectorsOfFoundComponents.forEach(function (_a) {\n        var index = _a.index, handlers = _a.handlers;\n        var selectorNames = Object.keys(handlers);\n        selectorNames.forEach(function (selectorName) {\n            // If no selector is given the handler does always match\n            if (!selectorName) {\n                return handlerQueue.push({\n                    index: index,\n                    ctx: parents[index],\n                    target: parents[index],\n                    handlerOptions: handlers[selectorName],\n                });\n            }\n            // Iterate backwards over the children of the component to find an element\n            // which matches the selector for the current handler\n            for (var i = index; --i >= 0;) {\n                if (matchesCssSelector(parents[i], selectorName)) {\n                    return handlerQueue.push({\n                        index: i,\n                        ctx: parents[index],\n                        target: parents[i],\n                        handlerOptions: handlers[selectorName],\n                    });\n                }\n            }\n        });\n    });\n    // Break if we couldn't find any matching element\n    if (handlerQueue.length === 0) {\n        return [];\n    }\n    // Sort the queue so events which are further up the dom are fired first\n    handlerQueue.sort(function (handlerA, handlerB) {\n        return handlerA.index > handlerB.index ? 1 : handlerA.index === handlerB.index ? 0 : -1;\n    });\n    return handlerQueue;\n}\n/**\n * The handler which will catch every event at the documentElement\n */\nfunction handleEvent(namespace, attributeName, eventHandlerRegistry, event) {\n    var target = event.target;\n    var handlers = getHandlers(attributeName, eventHandlerRegistry, target);\n    executeHandlers(handlers, event, namespace);\n}\nvar _domEventRegistry;\n/**\n * Returns the namespace registry for the given namespace..\n * This function must be used only by core or plugins\n */\nexport function getEventRegistry(namespace) {\n    if (!_domEventRegistry) {\n        _domEventRegistry = window['__\\ud83d\\udea1DomEvents'] || {};\n        window['__\\ud83d\\udea1DomEvents'] = _domEventRegistry;\n    }\n    if (!_domEventRegistry[namespace]) {\n        _domEventRegistry[namespace] = {};\n    }\n    return _domEventRegistry[namespace];\n}\n/**\n * Notify components\n * This function must be used by core or only by plugins\n */\nexport function executeHandlers(handlers, event, namespace) {\n    /** Store wether the original Event was modified to provide the correct currentTarget */\n    var eventObjectRequiresCleanup = false;\n    /** Store optional callback results which are executed together to allow grouped redraws */\n    var results = [];\n    var _loop_1 = function (i) {\n        var handlerObject = handlers[i];\n        var handlerOptions = handlerObject.handlerOptions;\n        var gondelComponent = extractComponent(handlerObject.ctx, namespace);\n        // Skip if the component wasn't started or if it was stopped\n        if (gondelComponent) {\n            // See https://stackoverflow.com/questions/52057726/what-is-the-best-way-to-alter-a-native-browser-event\n            Object.defineProperty(event, 'currentTarget', {\n                get: function () { return handlerObject.target; },\n                configurable: true,\n            });\n            eventObjectRequiresCleanup = true;\n            for (var j = 0; j < handlerOptions.length && !event.cancelBubble; j++) {\n                var handlerResult = gondelComponent[handlerOptions[j].handlerName].call(gondelComponent, event);\n                if (typeof handlerResult === 'function') {\n                    results.push(handlerResult);\n                }\n            }\n        }\n    };\n    for (var i = 0; i < handlers.length && !event.cancelBubble; i++) {\n        _loop_1(i);\n    }\n    // Execute all callbacks to allow grouping write events\n    results.forEach(function (result) {\n        result();\n    });\n    // Cleanup the event object\n    if (eventObjectRequiresCleanup) {\n        // See https://stackoverflow.com/questions/52057726/what-is-the-best-way-to-alter-a-native-browser-event\n        delete event.currentTarget;\n    }\n}\n/**\n * Add a event lister to the <html> element\n * The listener will always call handleEvent with the domEventRegistry for the given event\n */\nfunction startListeningForEvent(eventName, namespace) {\n    document.documentElement.addEventListener(eventNameMapping[eventName] || eventName, handleEvent.bind(null, namespace, \"data-\".concat(namespace, \"-name\"), getEventRegistry(namespace)[eventName]));\n}\n/**\n * Add an event to the Gondel EventRegistry\n */\nexport function addRootEventListener(namespace, domEventName, gondelComponentName, handlerName, handlerOption) {\n    // Create namespace if neededi\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\n    // Notify all plugins to allow taking over the event handling for a specific event name\n    // This notification is only triggered if a event name e.g. 'click' is used for the first time\n    if (!namespacedDomEventRegistry[domEventName]) {\n        namespacedDomEventRegistry[domEventName] = {};\n        fireGondelPluginEvent('registerEvent', true, {\n            eventName: domEventName,\n            namespace: namespace,\n            eventRegistry: namespacedDomEventRegistry[domEventName],\n        }, function (isNativeEvent) {\n            // If no plugin registered the event\n            // register a native browser event\n            if (isNativeEvent) {\n                startListeningForEvent(domEventName, namespace);\n            }\n        });\n    }\n    if (!namespacedDomEventRegistry[domEventName][gondelComponentName]) {\n        namespacedDomEventRegistry[domEventName][gondelComponentName] = {};\n    }\n    var handlerOptionObject = typeof handlerOption === 'object' ? handlerOption : { selector: handlerOption };\n    var selectorKey = handlerOptionObject.selector || '';\n    if (!namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey]) {\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey] = [];\n    }\n    namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey].push(Object.assign({ handlerName: handlerName, handlerOption: handlerOption }));\n}\n/**\n * Remove an event from the Gondel EventRegistry\n */\nexport function removeRootEventListener(namespace, domEventName, gondelComponentName, handlerName, selector) {\n    var selectorKey = selector || '';\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\n    if (namespacedDomEventRegistry[domEventName] &&\n        namespacedDomEventRegistry[domEventName][gondelComponentName] &&\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey]) {\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey] = namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey].filter(function (handlerOption) {\n            return handlerOption.handlerName !== handlerName || handlerName === undefined;\n        });\n    }\n}\n/**\n * Remove all events for a given Component (e.g. a Button) from the Gondel EventRegistry\n */\nexport function removeRootEventListernerForComponent(namespace, gondelComponentName) {\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\n    for (var eventName in namespacedDomEventRegistry) {\n        /* istanbul ignore else: for in savety check */\n        if (namespacedDomEventRegistry.hasOwnProperty(eventName)) {\n            delete namespacedDomEventRegistry[eventName][gondelComponentName];\n        }\n    }\n}\n//# sourceMappingURL=GondelEventRegistry.js.map","import { addRootEventListener, removeRootEventListernerForComponent } from './GondelEventRegistry';\n// Because of how decorators work @EventListeners is executed before the class is registred\n// so we need to provide a hrm compatible approch initialize and reinitialize the events\nimport { addGondelPluginEventListener } from './GondelPluginUtils';\nimport { registerComponent } from './index';\nexport function Component(componentName, namespace) {\n    return function (constructor) {\n        registerComponent(componentName, namespace, constructor);\n    };\n}\nfunction hookEventDecoratorInCore() {\n    addGondelPluginEventListener('GondelDecorators', 'register', function (component, _a, next) {\n        var componentName = _a.componentName, namespace = _a.namespace, gondelComponentRegistry = _a.gondelComponentRegistry;\n        // Only apply in case the component is already active in the DOM\n        // this will only happen during hot module replacement\n        if (!gondelComponentRegistry._activeComponents[componentName]) {\n            return next(component);\n        }\n        // The decorator will store the event information in two different places.\n        // For ES6 classes it is using __events\n        // For ES5 prototype classes and transpiled ES6 classes it is using prototype.__events\n        var componentEventOptions = (component.prototype && component.prototype.__events) || component.__events;\n        if (componentEventOptions) {\n            componentEventOptions.forEach(function (eventOptions) {\n                addRootEventListener(namespace, \n                /* event name: */ eventOptions[0], componentName, \n                /* handler: */ eventOptions[1], \n                /* selector: */ eventOptions[2]);\n            });\n        }\n        next(component);\n    });\n    addGondelPluginEventListener('GondelDecorators', 'unregister', function (component, _a, next) {\n        var componentName = _a.componentName, namespace = _a.namespace;\n        removeRootEventListernerForComponent(namespace, componentName);\n        next(component);\n    });\n    addGondelPluginEventListener('GondelDecorators', 'start', function (gondelComponents, _a, next) {\n        var newComponentNames = _a.newComponentNames, gondelComponentRegistry = _a.gondelComponentRegistry, namespace = _a.namespace;\n        newComponentNames.forEach(function (componentName) {\n            var gondelComponent = gondelComponentRegistry.getComponent(componentName);\n            // The decorator will store the event information in two different places.\n            // For ES6 classes it is using __events\n            // For ES5 prototype classes and transpiled ES6 classes it is using prototype.__events\n            var componentEventOptions = (gondelComponent.prototype && gondelComponent.prototype.__events) ||\n                gondelComponent.__events;\n            if (componentEventOptions) {\n                componentEventOptions.forEach(function (eventOptions) {\n                    addRootEventListener(namespace, \n                    /* event name: */ eventOptions[0], componentName, \n                    /* handler: */ eventOptions[1], \n                    /* selector: */ eventOptions[2]);\n                });\n            }\n        });\n        next(gondelComponents);\n    });\n}\n/**\n * The @EventListener decorator will add all event names to a static variable\n */\nexport function EventListener(eventName, selector) {\n    return function (target, handler) {\n        hookEventDecoratorInCore();\n        if (handler.substr(0, 1) !== '_') {\n            throw new Error(\"Invalid handler name '\".concat(handler, \"' use '_\").concat(handler, \"' instead.\"));\n        }\n        if (!target.__events) {\n            target.__events = [];\n        }\n        target.__events.push([eventName, handler, selector]);\n    };\n}\n//# sourceMappingURL=GondelDecorators.js.map","var GondelBaseComponent = /** @class */ (function () {\n    function GondelBaseComponent(domNode, componentName) {\n    }\n    /**\n     * Stop method\n     */\n    GondelBaseComponent.prototype.stop = function () { };\n    return GondelBaseComponent;\n}());\nexport { GondelBaseComponent };\n//# sourceMappingURL=GondelComponent.js.map"],"names":["basePluginListener","result","data","next","pluginEventRegistry","window","__gondelPluginEvents","pluginMapping","pluginEvents","fireGondelPluginEvent","eventName","initialValue","callback","callbackResult","isSyncron","processedResult","Error","addGondelPluginEventListener","pluginName","eventListenerCallback","pluginHandlerNamePerEvent","concat","previousEventHandler","modifiedResult","_","firstNext","triggerPublicEvent","gondelComponent","target","eventData","canBubble","event","document","createEvent","eventTarget","getFirstDomNode","_ctx","namespace","_namespace","substr","length","charAt","toUpperCase","slice","initEvent","component","name","_componentName","dispatchEvent","noop","Deferred","_this","this","promise","Promise","resolve","startComponentsFromRegistry","gondelComponentRegistry","domContext","gondelDomNodeList","Array","prototype","call","querySelectorAll","hasAttribute","push","pristineGondelDomNodes","filter","gondelDomNode","domNode","hasOwnProperty","internalGondelAsyncRefAttribute","isPristineGondelDomNode","bootingDeferred","forEach","bootingFlag","attachGondelBootingFlag","registry","componentNameHelper","gondelComponents","map","componentName","getAttribute","GondelComponent","getComponent","undefined","componentInstance","stop","stopStartedComponent","bind","constructComponent","newComponentNames","Object","keys","_activeComponents","setActiveState","gondelComponentStartPromise","all","startConstructedComponent","then","sync","start","reject","internalStopMethod","internalGondelRefAttribute","_stopped","_componentRegistries","GLOBAL_GONDEL_REGISTRY_NAMESPACE","GondelComponentRegistry","_components","_bootMode","registerComponent","unregisterComponent","isActive","setBootMode","bootMode","getComponentRegistry","boot","documentElement","readyState","addEventListener","addRegistryToBootloader","args","arguments","nodeType","isElement","hasMountedGondelComponent","getComponentByDomNode","extractComponent","element","findComponents","firstNode","components","attribute","nodes","i","node","gondelComponentInstance","_domEventRegistry","eventNameMapping","focus","blur","matchesCssSelector","selector","elementPrototype","Element","elementMatches","matches","matchesSelector","mozMatchesSelector","msMatchesSelector","webkitMatchesSelector","handleEvent","attributeName","eventHandlerRegistry","handlers","parents","startElement","parentElement","getParentElements","selectorsOfFoundComponents","parent","index","handlerQueue","_a","selectorName","ctx","handlerOptions","sort","handlerA","handlerB","getHandlers","eventObjectRequiresCleanup","results","_loop_1","handlerObject","defineProperty","get","configurable","j","cancelBubble","handlerResult","handlerName","currentTarget","executeHandlers","getEventRegistry","addRootEventListener","domEventName","gondelComponentName","handlerOption","namespacedDomEventRegistry","eventRegistry","isNativeEvent","startListeningForEvent","selectorKey","assign","hookEventDecoratorInCore","componentEventOptions","__events","eventOptions","removeRootEventListernerForComponent","GondelBaseComponent","constructor","handler","unshift"],"mappings":"6OAAA,IAAIA,EAAqB,SAAUC,EAAQC,EAAMC,GAAQ,OAAOA,EAAKF,EAAS,EAE1EG,EAAsBC,OAAOC,sBAAwB,CAAEC,cAAe,CAAA,EAAIC,aAAc,IAC5FH,OAAOC,qBAAuBF,EAEvB,IAAII,EAAeJ,EAAoBI,aAE1CD,EAAgBH,EAAoBG,cACjC,SAASE,EAAsBC,EAAWC,EAAcT,EAAMU,GACjE,IACIC,EADAC,GAAY,EAUhB,IANCN,EAAaE,IAAcV,GAAoBW,EAAcT,EAAM,SAAUa,GAC1ED,GAAY,EACZD,EAAiBD,EAAWA,EAASG,GAAmBA,CAC5D,IAGKD,EACD,MAAM,IAAIE,MAAM,yBAEpB,OAAOH,CACX,CAcO,SAASI,EAA6BC,EAAYR,EAAWS,GAGhE,IAAIC,EAA4B,GAAGC,OAAOX,EAAW,KAAKW,OAAOH,GACjE,IAAIX,EAAca,GAAlB,CAIAb,EAAca,IAA6B,EAEtCZ,EAAaE,KACdF,EAAaE,GAAaV,GAE9B,IAAIsB,EAAuBd,EAAaE,GACxCF,EAAaE,GAAa,SAAsBT,EAAQC,EAAMC,GAC1DmB,EAAqBrB,EAAQC,EAAM,SAAwBqB,EAAgBC,EAAGC,GAC1EN,EAAsBI,EAAgBrB,EAAM,SAAkBD,GAC1DE,EAAKF,EAAQC,EAAMuB,EACvB,EACJ,EACJ,CAdA,CAeJ,CCtDO,SAASC,EAAmBhB,EAAWiB,EAAiBC,EAAQC,EAAWC,QAC5D,IAAdD,IAAwBA,EAAY,CAAA,QACtB,IAAdC,IAAwBA,GAAY,GACxC,IAAIC,EAAQC,SAASC,YAAY,SAC7BC,EAAcN,EAASO,EAAgBP,GAAUD,EAAgBS,KACjEC,EAAYV,EAAgBW,WAChC,GAAI5B,EAAU6B,OAAO,EAAGF,EAAUG,UAAYH,EAC1C,MAAM,IAAIrB,MAAM,uBACZN,EACA,YACA2B,EACA3B,EAAU+B,OAAO,GAAGC,cACpBhC,EAAUiC,MAAM,GAChB,KASR,OAPAZ,EAAMa,UAAUlC,EAAWoB,GAAW,GACtCC,EAAM7B,KAAO,CACT2C,UAAWlB,EACXmB,KAAMnB,EAAgBoB,eACtBV,UAAWV,EAAgBW,WAC3BT,UAAWA,GAERK,EAAYc,cAAcjB,EACrC,CCxBA,IAAIkB,EAAO,WAAc,EACrBC,EAAW,WACX,IAAIC,EAAQC,KACZA,KAAKC,QAAU,IAAIC,QAAQ,SAAUC,GACjCJ,EAAMI,QAAUA,CACpB,EACJ,EAKO,SAASC,EAA4BC,EAAyBC,EAAYrB,GAE7E,IAAIsB,EAAoBC,MAAMC,UAAUlB,MAAMmB,KAAKJ,EAAWK,iBAAiB,SAAS1C,OAAOgB,EAAW,YACtGqB,EAAWM,aAAa,QAAQ3C,OAAOgB,EAAW,WAClDsB,EAAkBM,KAAKP,GAG3B,IAAIQ,EAAyBP,EAAkBQ,OAAO,SAAUC,GAC5D,OA2CD,SAAiCC,EAAShC,GAC7C,OAAQgC,EAAQC,eAAeC,EAAkClC,EACrE,CA7CemC,CAAwBJ,EAAe/B,EAClD,GACIoC,EAAkB,IAAIvB,EAE1BgB,EAAuBQ,QAAQ,SAAUN,IA6CtC,SAAiCC,EAASM,EAAatC,GAG1DgC,EAAQE,EAAkClC,GAAasC,CAC3D,CAhDQC,CAAwBR,EAAeK,EAAgBpB,QAAShB,EACpE,GAEA,IA+FkCwC,EAC9BC,EAhGAC,EAAmBtE,EAAsB,OAAQyD,EAAwB,CAAE7B,UAAWA,GAAa,SAAU6B,GAC7G,OAAOA,EAAuBc,IAAI,SAAUZ,GACxC,OA+CL,SAA4BC,EAASZ,EAAyBpB,GACjE,IAAI4C,EAAgBZ,EAAQa,aAAa,QAAQ7D,OAAOgB,EAAW,UAC/D8C,EAAkB1B,EAAwB2B,aAAaH,GAC3D,QAAwBI,IAApBF,EACA,MAAM,IAAInE,MAAM,8BAA8BK,OAAO4D,EAAe,sBAExE,IAAIK,EAAoB,IAAIH,EAAgBd,EAASY,GAQrD,OAPAK,EAAkBlD,KAAOiC,EACzBiB,EAAkBhD,WAAaD,EAC/BiD,EAAkBvC,eAAiBkC,EAEnCK,EAAkBC,KAAOC,EAAqBC,KAAK,KAAMH,EAAmBA,EAAkBC,MAAQtC,EAAMZ,GAE5GgC,EAAQ,WAAahC,GAAaiD,EAC3BA,CACX,CA9DmBI,CAAmBtB,EAAeX,EAAyBpB,EACtE,EACJ,GAEIsD,GAyF8Bd,EAzFyBpB,EA0FvDqB,EAAsB,CAAA,EA1FeC,EA2F9BL,QAAQ,SAAU7B,GAAa,OAAQiC,EAAoBjC,EAAUE,iBAAkB,CAAO,GACpF6C,OAAOC,KAAKf,GACXX,OAAO,SAAUc,GAAiB,OAAQJ,EAASiB,kBAAkBb,EAAgB,IA5F3GU,EAAkBjB,QAAQ,SAAUO,GAAiB,OAAOxB,EAAwBsC,eAAed,GAAe,EAAO,GAEzH,IAAIe,EAA8BvF,EAAsB,QAASsE,EAAkB,CAAEY,kBAAmBA,EAAmBtD,UAAWA,EAAWoB,wBAAyBA,GAA2B,SAAUsB,GAE3M,OAAOzB,QAAQ2C,IAAIlB,EAAiBC,IAAIkB,GAC5C,GAEKC,KAAK,WAMN,OALApB,EAAiBL,QAAQ,SAAU/C,GAC3BA,EAAgByE,MAChBzE,EAAgByE,MAExB,GACO3F,EAAsB,OAAQsE,EAAkB,CAAE1C,UAAWA,GACxE,GASA,OAPA2D,EACKG,KAAK1B,EAAgBlB,QAASkB,EAAgBlB,SAI9C4C,KAAK,WAAc,OAAOH,CAA6B,GAErDA,CACX,CAqCO,SAASE,EAA0BrD,GAEtC,GAAKA,EAAUwD,MAMf,OAHoD,IAA3BxD,EAAUwD,MAAM7D,OAI9BK,EAAUwD,QAEd,IAAI/C,QAAQ,SAAUC,EAAS+C,GAAU,OAAOzD,EAAUwD,MAAM9C,EAAS+C,EAAS,EAC7F,CAIO,SAASd,EAAqB3C,EAAW0D,EAAoBlE,GAChEX,EAAmB,GAAGL,OAAOgB,EAAW,QAASQ,EAAWA,EAAUT,aAE/DS,EAAUT,KAAKoE,EAA6BnE,UAC5CQ,EAAUT,KAAKmC,EAAkClC,GACxDQ,EAAU4D,UAAW,EACrBhG,EAAsB,OAAQoC,EAAW,CAAER,UAAWA,GAAakE,EAAmBd,KAAK5C,GAC/F,CCvHA,IA4BI6D,EA5BAC,EAAmC,iBACnCC,EAAyC,WACzC,SAASA,IACLxD,KAAKyD,YAAc,CAAA,EACnBzD,KAAK0C,kBAAoB,CAAA,EACzB1C,KAAK0D,UAAY,CACrB,CAmBA,OAlBAF,EAAwB/C,UAAUkD,kBAAoB,SAAUjE,EAAMnB,GAClEyB,KAAKyD,YAAY/D,GAAQnB,CAC7B,EACAiF,EAAwB/C,UAAUmD,oBAAsB,SAAUlE,UACvDM,KAAKyD,YAAY/D,EAC5B,EACA8D,EAAwB/C,UAAUuB,aAAe,SAAUtC,GACvD,OAAOM,KAAKyD,YAAY/D,EAC5B,EAIA8D,EAAwB/C,UAAUkC,eAAiB,SAAUjD,EAAMmE,GAC/D7D,KAAK0C,kBAAkBhD,GAAQmE,CACnC,EACAL,EAAwB/C,UAAUqD,YAAc,SAAUC,GACtD/D,KAAK0D,UAAYK,CACrB,EACOP,CACX,IAGO,SAASQ,EAAqB/E,GASjC,OARKqE,IACDA,EAAuBrG,OAAOsG,IAAqC,CAAA,EACnEtG,OAAOsG,GAAoCD,GAE1CA,EAAqBrE,KACtBqE,EAAqBrE,GAAa,IAAIuE,ECvBvC,SAAiCvE,GAEpC,IAAIgF,EAAO,WACP/D,QAAQC,UAAU4C,KAAK,WACnB,IAAI1C,EAA0B2D,EAAqB/E,GACT,IAAtCoB,EAAwBqD,YACxBrD,EAAwByD,YAAY,GACpC1D,EAA4BC,EAAyBzB,SAASsF,gBAAiBjF,GAEvF,EACJ,EAE2B,YAAvBL,SAASuF,WACTF,IAGArF,SAASwF,iBAAiB,mBAAoBH,GAAM,EAE5D,CDMQI,CAAwBpF,IAErBqE,EAAqBrE,EAChC,CACO,SAAS0E,IACZ,IAAIW,EAAOC,UAEP1C,EAAgByC,EAAK,GAErBrF,EAA+B,iBAAZqF,EAAK,GAAkBA,EAAK,GAAK,IAEpD7E,EAAY6E,EAAKA,EAAKlF,OAAS,GAC/BiB,EAA0B2D,EAAqB/E,GAG/CoB,EAAwB2B,aAAaH,IACrCxE,EAAsB,aAAcoC,EAAW,CAAEoC,cAAeA,EAAe5C,UAAWA,IAG9F5B,EAAsB,WAAYoC,EAAW,CACzCoC,cAAeA,EACf5C,UAAWA,EACXoB,wBAAyBA,GAC1B,SAAUZ,GACTY,EAAwBsD,kBAAkB9B,EAAepC,EAC7D,EACJ,CE9DO,IAAI2D,EAA6B,WAC7BjC,EAAkC,YAetC,SAASpC,EAAgBkC,GAC5B,OAZJ,SAAmBA,GACf,YAA4BgB,IAArBhB,EAAQuD,QACnB,CAUQC,CAAUxD,GACHA,EAEJA,EAAQ,EACnB,CAuBO,SAASyD,EAA0BzD,EAAShC,QAC7B,IAAdA,IAAwBA,EAAY,KACxC,IACIV,EADYQ,EAAgBkC,GACAmC,EAA6BnE,GAC7D,SAAKV,IAAoBA,EAAgBS,KAO7C,CAIO,SAAS2F,EAAsB1D,EAAShC,QACzB,IAAdA,IAAwBA,EAAY,KACxC,IAAIV,EAAkBqG,EAAiB7F,EAAgBkC,GAAUhC,GACjE,IAAKV,EACD,MAAM,IAAIX,MAAM,2DAA4DK,OAAOgB,EAAW,mFAElG,OAAOV,CACX,CAQO,SAASqG,EAAiBC,EAAS5F,GACtC,IAAIV,EAAkBsG,EAAQzB,EAA6BnE,GAE3D,GAAIV,GAAmBA,EAAgBS,KACnC,OAAOT,CAEf,CAsBO,SAASuG,EAAe7D,EAASY,EAAe5C,QACnC,IAAZgC,IAAsBA,EAAUrC,SAASsF,sBAC3B,IAAdjF,IAAwBA,EAAY,KAKxC,IAJA,IAAI8F,EAAYhG,EAAgBkC,GAC5B+D,EAAa,GACbC,EAAY,WAAWhH,OAAOgB,GAC9BiG,EAAQH,EAAUpE,iBAAiB,SAAS1C,OAAOgB,EAAW,SAAShB,OAAO4D,EAAgB,KAAM5D,OAAO4D,EAAe,KAAQ,GAAI,MACjIsD,EAAI,EAAGA,EAAID,EAAM9F,OAAQ+F,IAAK,CACnC,IAAIC,EAAOF,EAAMC,GACbE,EAA0BD,EAAKH,GAE/BI,GAA2BA,EAAwBrG,OAASoG,GAC5DJ,EAAWnE,KAAKwE,EAExB,CACA,OAAOL,CACX,CC9GA,IA0FIM,EA1FAC,EAAmB,CACnBC,MAAO,UACPC,KAAM,YAGNC,EAAqB,SAAUb,EAASc,GACxC,IAAIC,EAAmB3I,OAAO4I,QAAQpF,UAElCqF,EAAiBF,EAAiBG,SAClCH,EAAiBI,iBACjBJ,EAAiBK,oBACjBL,EAAiBM,mBACjBN,EAAiBO,sBAErB,OAAQT,EAAqB,SAAUb,EAASc,GAC5C,OAAOG,EAAepF,KAAKmE,EAASc,EACxC,GAAGd,EAASc,EAChB,EAoEA,SAASS,EAAYnH,EAAWoH,EAAeC,EAAsB3H,GACjE,IACI4H,EA3DD,SAAqBF,EAAeC,EAAsB9H,GAC7D,IAAIgI,EAXR,SAA2BC,GAEvB,IADA,IAAIvB,EAAQ,GACHL,EAAU4B,EAAc5B,EAASA,EAAUA,EAAQ6B,cACxDxB,EAAMrE,KAAKgE,GAEf,OAAOK,CACX,CAKkByB,CAAkBnI,GAG5BoI,EAA6B,GACjCJ,EAAQlF,QAAQ,SAAUuF,EAAQ1B,GAC9B,IAAItD,EAAgBgF,EAAO/E,aAAauE,GACpCE,EAAW1E,GAAiByE,EAAqBzE,GACjD0E,GAGAK,EAA2B/F,KAAK,CAAEiG,MAAO3B,EAAGoB,SAAUA,GAE9D,GAGA,IAAIQ,EAAe,GA6BnB,OA5BAH,EAA2BtF,QAAQ,SAAU0F,GACzC,IAAIF,EAAQE,EAAGF,MAAOP,EAAWS,EAAGT,SAChB/D,OAAOC,KAAK8D,GAClBjF,QAAQ,SAAU2F,GAE5B,IAAKA,EACD,OAAOF,EAAalG,KAAK,CACrBiG,MAAOA,EACPI,IAAKV,EAAQM,GACbtI,OAAQgI,EAAQM,GAChBK,eAAgBZ,EAASU,KAKjC,IAAK,IAAI9B,EAAI2B,IAAS3B,GAAK,GACvB,GAAIO,EAAmBc,EAAQrB,GAAI8B,GAC/B,OAAOF,EAAalG,KAAK,CACrBiG,MAAO3B,EACP+B,IAAKV,EAAQM,GACbtI,OAAQgI,EAAQrB,GAChBgC,eAAgBZ,EAASU,IAIzC,EACJ,GAE4B,IAAxBF,EAAa3H,OACN,IAGX2H,EAAaK,KAAK,SAAUC,EAAUC,GAClC,OAAOD,EAASP,MAAQQ,EAASR,MAAQ,EAAIO,EAASP,QAAUQ,EAASR,MAAQ,GAAI,CACzF,GACOC,EACX,CAMmBQ,CAAYlB,EAAeC,EAD7B3H,EAAMH,SAuBhB,SAAyB+H,EAAU5H,EAAOM,GAyB7C,IAvBA,IAAIuI,GAA6B,EAE7BC,EAAU,GACVC,EAAU,SAAUvC,GACpB,IAAIwC,EAAgBpB,EAASpB,GACzBgC,EAAiBQ,EAAcR,eAC/B5I,EAAkBqG,EAAiB+C,EAAcT,IAAKjI,GAE1D,GAAIV,EAAiB,CAEjBiE,OAAOoF,eAAejJ,EAAO,gBAAiB,CAC1CkJ,IAAK,WAAc,OAAOF,EAAcnJ,MAAQ,EAChDsJ,cAAc,IAElBN,GAA6B,EAC7B,IAAK,IAAIO,EAAI,EAAGA,EAAIZ,EAAe/H,SAAWT,EAAMqJ,aAAcD,IAAK,CACnE,IAAIE,EAAgB1J,EAAgB4I,EAAeY,GAAGG,aAAaxH,KAAKnC,EAAiBI,GAC5D,mBAAlBsJ,GACPR,EAAQ5G,KAAKoH,EAErB,CACJ,CACJ,EACS9C,EAAI,EAAGA,EAAIoB,EAASnH,SAAWT,EAAMqJ,aAAc7C,IACxDuC,EAAQvC,GAGZsC,EAAQnG,QAAQ,SAAUzE,GACtBA,GACJ,GAEI2K,UAEO7I,EAAMwJ,aAErB,CA1DIC,CAAgB7B,EAAU5H,EAAOM,EACrC,CAMO,SAASoJ,EAAiBpJ,GAQ7B,OAPKqG,IACDA,EAAoBrI,OAAO,kBAA8B,CAAA,EACzDA,OAAO,iBAA6BqI,GAEnCA,EAAkBrG,KACnBqG,EAAkBrG,GAAa,CAAA,GAE5BqG,EAAkBrG,EAC7B,CAqDO,SAASqJ,EAAqBrJ,EAAWsJ,EAAcC,EAAqBN,EAAaO,GAE5F,IAAIC,EAA6BL,EAAiBpJ,GAG7CyJ,EAA2BH,KAC5BG,EAA2BH,GAAgB,CAAA,EAC3ClL,EAAsB,iBAAiB,EAAM,CACzCC,UAAWiL,EACXtJ,UAAWA,EACX0J,cAAeD,EAA2BH,IAC3C,SAAUK,GAGLA,GApBhB,SAAgCtL,EAAW2B,GACvCL,SAASsF,gBAAgBE,iBAAiBmB,EAAiBjI,IAAcA,EAAW8I,EAAY/D,KAAK,KAAMpD,EAAW,QAAQhB,OAAOgB,EAAW,SAAUoJ,EAAiBpJ,GAAW3B,IAC1L,CAmBgBuL,CAAuBN,EAActJ,EAE7C,IAECyJ,EAA2BH,GAAcC,KAC1CE,EAA2BH,GAAcC,GAAuB,CAAA,GAEpE,IACIM,GAD+C,iBAAlBL,EAA6BA,EAAgB,CAAE9C,SAAU8C,IACpD9C,UAAY,GAC7C+C,EAA2BH,GAAcC,GAAqBM,KAC/DJ,EAA2BH,GAAcC,GAAqBM,GAAe,IAEjFJ,EAA2BH,GAAcC,GAAqBM,GAAajI,KAAK2B,OAAOuG,OAAO,CAAEb,YAAaA,EAAaO,cAAeA,IAC7I,CCzLA,SAASO,IACLnL,EAA6B,mBAAoB,WAAY,SAAU4B,EAAWuH,EAAIjK,GAClF,IAAI8E,EAAgBmF,EAAGnF,cAAe5C,EAAY+H,EAAG/H,UAGrD,IAH0F+H,EAAG3G,wBAGhEqC,kBAAkBb,GAC3C,OAAO9E,EAAK0C,GAKhB,IAAIwJ,EAAyBxJ,EAAUgB,WAAahB,EAAUgB,UAAUyI,UAAazJ,EAAUyJ,SAC3FD,GACAA,EAAsB3H,QAAQ,SAAU6H,GACpCb,EAAqBrJ,EACHkK,EAAa,GAAItH,EACpBsH,EAAa,GACZA,EAAa,GACjC,GAEJpM,EAAK0C,EACT,GACA5B,EAA6B,mBAAoB,aAAc,SAAU4B,EAAWuH,EAAIjK,GACpF,IAAI8E,EAAgBmF,EAAGnF,eDoLxB,SAA8C5C,EAAWuJ,GAC5D,IAAIE,EAA6BL,EAAiBpJ,GAClD,IAAK,IAAI3B,KAAaoL,EAEdA,EAA2BxH,eAAe5D,WACnCoL,EAA2BpL,GAAWkL,EAGzD,CC3LQY,CADkDpC,EAAG/H,UACL4C,GAChD9E,EAAK0C,EACT,GACA5B,EAA6B,mBAAoB,QAAS,SAAU8D,EAAkBqF,EAAIjK,GACtF,IAAIwF,EAAoByE,EAAGzE,kBAAmBlC,EAA0B2G,EAAG3G,wBAAyBpB,EAAY+H,EAAG/H,UACnHsD,EAAkBjB,QAAQ,SAAUO,GAChC,IAAItD,EAAkB8B,EAAwB2B,aAAaH,GAIvDoH,EAAyB1K,EAAgBkC,WAAalC,EAAgBkC,UAAUyI,UAChF3K,EAAgB2K,SAChBD,GACAA,EAAsB3H,QAAQ,SAAU6H,GACpCb,EAAqBrJ,EACHkK,EAAa,GAAItH,EACpBsH,EAAa,GACZA,EAAa,GACjC,EAER,GACApM,EAAK4E,EACT,EACJ,CCzDG,IAAC0H,EAAqC,WACrC,SAASA,EAAoBpI,EAASY,GACtC,CAKA,OADAwH,EAAoB5I,UAAU0B,KAAO,WAAc,EAC5CkH,CACX,gBDHO,SAAmBxH,EAAe5C,GACrC,OAAO,SAAUqK,GACb3F,EAAkB9B,EAAe5C,EAAWqK,EAChD,CACJ,kBAoDO,SAAuBhM,EAAWqI,GACrC,OAAO,SAAUnH,EAAQ+K,GAErB,GADAP,IAC6B,MAAzBO,EAAQpK,OAAO,EAAG,GAClB,MAAM,IAAIvB,MAAM,yBAAyBK,OAAOsL,EAAS,YAAYtL,OAAOsL,EAAS,eAEpF/K,EAAO0K,WACR1K,EAAO0K,SAAW,IAEtB1K,EAAO0K,SAASrI,KAAK,CAACvD,EAAWiM,EAAS5D,GAC9C,CACJ,8EHjEO,SAA0B1G,QACX,IAAdA,IAAwBA,EAAY,KACxC+E,EAAqB/E,GAAW6E,YAAY,EAChD,4EC4EO,SAAoC7C,EAAShC,QAC9B,IAAdA,IAAwBA,EAAY,KACxC,IAAI8F,EAAYhG,EAAgBkC,GAC5B1C,EAAkBwG,EAAU5D,EAAkClC,GAElE,OAAKV,EAIDA,EAAgBS,KACTkB,QAAQC,QAAQ5B,GAGpBA,EAAgBwE,KAAK,WAAc,OAAOgC,EAAU3B,EAA6BnE,EAAY,GAPzFiB,QAAQgD,YAAOjB,EAQ9B,4FAzEO,SAAyB3B,EAAYrB,GAGxC,YAFkB,IAAdA,IAAwBA,EAAY,KAEjCmB,EADQ4D,EAAqB/E,GACSqB,EAAavB,EAAgBuB,GAAc1B,SAASsF,gBAAiBjF,EACtH,mBAIO,SAAwBqB,EAAYrB,QACrB,IAAdA,IAAwBA,EAAY,KACxC,IAAI+F,EAAaF,EAAexE,OAAY2B,EAAWhD,GACnDqB,GAAcoE,EAA0BpE,IACxC0E,EAAWwE,QAAQ7E,EAAsBrE,IAE7C0E,EAAW1D,QAAQ,SAAU7B,GAAa,OAAOA,EAAU0C,MAAQ,EACvE"}