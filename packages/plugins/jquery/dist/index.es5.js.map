{"version":3,"file":"index.es5.js","sources":["../../../core/dist/GondelPluginUtils.js","../../../core/dist/GondelComponentRegistry.js","../../../core/dist/GondelEventRegistry.js","index.js"],"sourcesContent":["var basePluginListener = function (result, data, next) { return next(result); };\n// Global plugin events registry\nexport var pluginEvents = window.__gondelPluginEvents || {};\nwindow.__gondelPluginEvents = pluginEvents;\nexport function fireGondelPluginEvent(eventName, initialValue, data, callback) {\n    var isSyncron = false;\n    var callbackResult;\n    // Execute all bound events for the given name\n    // if they exist\n    (pluginEvents[eventName] || basePluginListener)(initialValue, data, function (processedResult) {\n        isSyncron = true;\n        callbackResult = callback ? callback(processedResult) : processedResult;\n    });\n    // Add a guard to prevent asyncron plugin listeners\n    // to simplify the usage of fireGondelPluginEvent\n    if (!isSyncron) {\n        throw new Error(\"Async plugin listener\");\n    }\n    return callbackResult;\n}\n/**\n * Fire an async event which allows gondel plugins to add features to gondel\n */\nexport function fireAsyncGondelPluginEvent(eventName, initialValue, data) {\n    return new Promise(function (resolve) {\n        (pluginEvents[eventName] || basePluginListener)(initialValue, data, function (result) {\n            resolve(result);\n        });\n    });\n}\n/**\n * Allow plugins to hook into the gondel event system\n */\nexport function addGondelPluginEventListener(eventName, eventListenerCallback) {\n    if (!pluginEvents[eventName]) {\n        pluginEvents[eventName] = basePluginListener;\n    }\n    var previousEventHandler = pluginEvents[eventName];\n    pluginEvents[eventName] = function wrapCallback(result, data, next) {\n        previousEventHandler(result, data, function callNextPlugin(modifiedResult, _, firstNext) {\n            eventListenerCallback(modifiedResult, data, function bindData(result) {\n                next(result, data, firstNext);\n            });\n        });\n    };\n}\n//# sourceMappingURL=GondelPluginUtils.js.map","import { fireGondelPluginEvent } from \"./GondelPluginUtils\";\nvar GondelComponentRegistry = /** @class */ (function () {\n    function GondelComponentRegistry() {\n        this._components = {};\n        this._activeComponents = {};\n    }\n    GondelComponentRegistry.prototype.registerComponent = function (name, gondelComponent) {\n        this._components[name] = gondelComponent;\n    };\n    GondelComponentRegistry.prototype.unregisterComponent = function (name) {\n        delete this._components[name];\n    };\n    GondelComponentRegistry.prototype.getComponent = function (name) {\n        return this._components[name];\n    };\n    /**\n     * Set if a component is used\n     */\n    GondelComponentRegistry.prototype.setActiveState = function (name, isActive) {\n        this._activeComponents[name] = isActive;\n    };\n    return GondelComponentRegistry;\n}());\nexport { GondelComponentRegistry };\nexport var componentRegistries = (window.__gondelRegistries = window.__gondelRegistries || {});\nexport function registerComponent() {\n    var args = arguments;\n    // The componentName is always the first argument\n    var componentName = args[0];\n    // Use namespace from the second argument or fallback to the default \"g\" if it is missing\n    var namespace = typeof args[1] === \"string\" ? args[1] : \"g\";\n    // The last argument is always the component class\n    var component = args[args.length - 1];\n    if (!componentRegistries[namespace]) {\n        componentRegistries[namespace] = new GondelComponentRegistry();\n    }\n    // If this component was already registered we remove the previous one\n    // and notify all plugins - this is especially usefull for hot component replacement\n    if (componentRegistries[namespace].getComponent(componentName)) {\n        fireGondelPluginEvent(\"unregister\", component, { componentName: componentName, namespace: namespace });\n    }\n    // Let plugins know about the new component\n    fireGondelPluginEvent(\"register\", component, {\n        componentName: componentName,\n        namespace: namespace,\n        gondelComponentRegistry: componentRegistries[namespace]\n    }, function (component) {\n        componentRegistries[namespace].registerComponent(componentName, component);\n    });\n}\n//# sourceMappingURL=GondelComponentRegistry.js.map","/**\n * The event registry provides a way to bind events ahead of time\n * with a very small foot print during launch to improve the time to interaction\n */\nimport { getComponentByDomNode } from \"./GondelDomUtils\";\nimport { fireGondelPluginEvent } from \"./GondelPluginUtils\";\n/**\n * Only real browser events are supported.\n * Unfortunately focus and blur do not bubble so a special mapping is needed.\n */\nvar eventNameMapping = {\n    focus: \"focusin\",\n    blur: \"focusout\"\n};\nvar domEventRegistry = window.__gondelDomEvents || {};\nwindow.__gondelDomEvents = domEventRegistry;\n/* istanbul ignore next : Browser polyfill can't be tested */\nvar matches = Element.prototype.matches ||\n    Element.prototype.matchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.oMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\nfunction getParentElements(startElement) {\n    var nodes = [];\n    for (var element = startElement; element; element = element.parentElement) {\n        nodes.push(element);\n    }\n    return nodes;\n}\n/**\n * Returns an array of all handlers which would apply for the current target\n */\nexport function getHandlers(attributeName, eventHandlerRegistry, target) {\n    var parents = getParentElements(target);\n    // Find all selectors which have been registred for this event type\n    // and which have a gondel component in one of the parrent nodes\n    var selectorsOfFoundComponents = [];\n    parents.forEach(function (parent, i) {\n        var componentName = parent.getAttribute(attributeName);\n        var handlers = componentName && eventHandlerRegistry[componentName];\n        if (handlers) {\n            // Store the index where the component was found to know in which part\n            // of the dom tree the selectors could be found\n            selectorsOfFoundComponents.push({ index: i, handlers: handlers });\n        }\n    });\n    // Iterate over all possible selectors to find out if the current event\n    // should fire any gondel handler\n    var handlerQueue = [];\n    selectorsOfFoundComponents.forEach(function (_a) {\n        var index = _a.index, handlers = _a.handlers;\n        var selectorNames = Object.keys(handlers);\n        selectorNames.forEach(function (selectorName) {\n            // If no selector is given the handler does always match\n            if (!selectorName) {\n                return handlerQueue.push({\n                    index: index,\n                    ctx: parents[index],\n                    target: parents[index],\n                    handlerOptions: handlers[selectorName]\n                });\n            }\n            // Iterate backwards over the children of the component to find an element\n            // which matches the selector for the current handler\n            for (var i = index; --i >= 0;) {\n                if (matches.call(parents[i], selectorName)) {\n                    return handlerQueue.push({\n                        index: i,\n                        ctx: parents[index],\n                        target: parents[i],\n                        handlerOptions: handlers[selectorName]\n                    });\n                }\n            }\n        });\n    });\n    // Break if we couldn't find any matching element\n    if (handlerQueue.length === 0) {\n        return [];\n    }\n    // Sort the queue so events which are further up the dom are fired first\n    handlerQueue.sort(function (handlerA, handlerB) {\n        return handlerA.index > handlerB.index ? 1 : handlerA.index === handlerB.index ? 0 : -1;\n    });\n    return handlerQueue;\n}\n/**\n * The handler which will catch every event at the documentElement\n */\nfunction handleEvent(namespace, attributeName, eventHandlerRegistry, event) {\n    var target = event.target;\n    var handlers = getHandlers(attributeName, eventHandlerRegistry, target);\n    executeHandlers(handlers, event, namespace);\n}\n/**\n * Returns the namespace registry for the given namespace..\n * This function must be used only by core or plugins\n */\nexport function getEventRegistry(namespace) {\n    if (!domEventRegistry[namespace]) {\n        domEventRegistry[namespace] = {};\n    }\n    return domEventRegistry[namespace];\n}\n/**\n * Notify components\n * This function must be used by core or only by plugins\n */\nexport function executeHandlers(handlers, event, namespace) {\n    /** Store wether the original Event was modified to provide the correct currentTarget */\n    var eventObjectRequiresCleanup = false;\n    /** Store optional callback results which are executed together to allow grouped redraws */\n    var results = [];\n    for (var i = 0; i < handlers.length && !event.cancelBubble; i++) {\n        var handlerObject = handlers[i];\n        var handlerOptions = handlerObject.handlerOptions;\n        var gondelComponent = getComponentByDomNode(handlerObject.ctx, namespace);\n        // Skip if the component wasn't started or if it was stopped\n        if (gondelComponent) {\n            // See https://stackoverflow.com/questions/52057726/what-is-the-best-way-to-alter-a-native-browser-event\n            Object.defineProperty(event, \"currentTarget\", {\n                value: handlerObject.target,\n                configurable: true\n            });\n            eventObjectRequiresCleanup = true;\n            for (var j = 0; j < handlerOptions.length && !event.cancelBubble; j++) {\n                var handlerResult = gondelComponent[handlerOptions[j].handlerName].call(gondelComponent, event);\n                if (typeof handlerResult === \"function\") {\n                    results.push(handlerResult);\n                }\n            }\n        }\n    }\n    // Execute all callbacks to allow grouping write events\n    results.forEach(function (result) {\n        result();\n    });\n    // Cleanup the event object\n    if (eventObjectRequiresCleanup) {\n        // See https://stackoverflow.com/questions/52057726/what-is-the-best-way-to-alter-a-native-browser-event\n        delete event.currentTarget;\n    }\n}\n/**\n * Add a event lister to the <html> element\n * The listener will always call handleEvent with the domEventRegistry for the given event\n */\nfunction startListeningForEvent(eventName, namespace) {\n    document.documentElement.addEventListener(eventNameMapping[eventName] || eventName, handleEvent.bind(null, namespace, \"data-\" + namespace + \"-name\", domEventRegistry[namespace][eventName]));\n}\n/**\n * Add an event to the Gondel EventRegistry\n */\nexport function addRootEventListener(namespace, domEventName, gondelComponentName, handlerName, handlerOption) {\n    // Create namespace if neededi\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\n    // Notify all plugins to allow taking over the event handling for a specific event name\n    // This notification is only triggered if a event name e.g. 'click' is used for the first time\n    if (!namespacedDomEventRegistry[domEventName]) {\n        namespacedDomEventRegistry[domEventName] = {};\n        fireGondelPluginEvent(\"registerEvent\", true, {\n            eventName: domEventName,\n            namespace: namespace,\n            eventRegistry: namespacedDomEventRegistry[domEventName]\n        }, function (isNativeEvent) {\n            // If no plugin registered the event\n            // register a native browser event\n            if (isNativeEvent) {\n                startListeningForEvent(domEventName, namespace);\n            }\n        });\n    }\n    if (!namespacedDomEventRegistry[domEventName][gondelComponentName]) {\n        namespacedDomEventRegistry[domEventName][gondelComponentName] = {};\n    }\n    var handlerOptionObject = typeof handlerOption === \"object\" ? handlerOption : { selector: handlerOption };\n    var selectorKey = handlerOptionObject.selector || \"\";\n    if (!namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey]) {\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey] = [];\n    }\n    namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey].push(Object.assign({ handlerName: handlerName, handlerOption: handlerOption }));\n}\n/**\n * Remove an event from the Gondel EventRegistry\n */\nexport function removeRootEventListener(namespace, domEventName, gondelComponentName, handlerName, selector) {\n    var selectorKey = selector || \"\";\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\n    if (namespacedDomEventRegistry[domEventName] &&\n        namespacedDomEventRegistry[domEventName][gondelComponentName] &&\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey]) {\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey] = namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey].filter(function (handlerOption) {\n            return handlerOption.handlerName !== handlerName || handlerName === undefined;\n        });\n    }\n}\n/**\n * Remove all events for a given Component (e.g. a Button) from the Gondel EventRegistry\n */\nexport function removeRootEventListernerForComponent(namespace, gondelComponentName) {\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\n    for (var eventName in namespacedDomEventRegistry) {\n        /* istanbul ignore else: for in savety check */\n        if (namespacedDomEventRegistry.hasOwnProperty(eventName)) {\n            delete namespacedDomEventRegistry[eventName][gondelComponentName];\n        }\n    }\n}\n//# sourceMappingURL=GondelEventRegistry.js.map","/**\n * This is a demo plugin which adds a _$ctx for demonstration purposes\n */\nimport { addGondelPluginEventListener } from \"@gondel/core\";\nimport $ from \"jquery\";\nexport function init() {\n    addGondelPluginEventListener(\"start\", function addJquery(components, data, resolve) {\n        components.forEach(function (component) {\n            component.$ctx = $(component._ctx);\n        });\n        resolve(components);\n    });\n}\n//# sourceMappingURL=index.js.map"],"names":["basePluginListener","result","data","next","pluginEvents","window","__gondelPluginEvents","__gondelRegistries","domEventRegistry","__gondelDomEvents","Element","prototype","matches","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","eventName","eventListenerCallback","previousEventHandler","modifiedResult","_","firstNext","addGondelPluginEventListener","components","resolve","forEach","component","$ctx","$","_ctx"],"mappings":"mRAAA,IAAIA,EAAqB,SAAUC,EAAQC,EAAMC,GAAQ,OAAOA,EAAKF,IAE1DG,EAAeC,OAAOC,sBAAwB,GACzDD,OAAOC,qBAAuBF,ECqBIC,OAAOE,mBAAqBF,OAAOE,oBAAsB,GAApF,ICVHC,EAAmBH,OAAOI,mBAAqB,GACnDJ,OAAOI,kBAAoBD,EAEbE,QAAQC,UAAUC,SAC5BF,QAAQC,UAAUE,iBAClBH,QAAQC,UAAUG,oBAClBJ,QAAQC,UAAUI,mBAClBL,QAAQC,UAAUK,kBAClBN,QAAQC,UAAUM,6BCjBf,YH4BA,SAAsCC,EAAWC,GAC/Cf,EAAac,KACdd,EAAac,GAAalB,GAE9B,IAAIoB,EAAuBhB,EAAac,GACxCd,EAAac,GAAa,SAAsBjB,EAAQC,EAAMC,GAC1DiB,EAAqBnB,EAAQC,EAAM,SAAwBmB,EAAgBC,EAAGC,GAC1EJ,EAAsBE,EAAgBnB,EAAM,SAAkBD,GAC1DE,EAAKF,EAAQC,EAAMqB,QGnC/BC,CAA6B,QAAS,SAAmBC,EAAYvB,EAAMwB,GACvED,EAAWE,QAAQ,SAAUC,GACzBA,EAAUC,KAAOC,EAAEF,EAAUG,QAEjCL,EAAQD"}