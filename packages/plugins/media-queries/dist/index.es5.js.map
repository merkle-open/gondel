{"version":3,"file":"index.es5.js","sources":["../../../core/dist/GondelPluginUtils.js","../../../core/dist/GondelComponentRegistry.js","../../../core/dist/GondelDomUtils.js","../../../core/dist/GondelEventRegistry.js","../../../core/dist/index.js","index.js"],"sourcesContent":["var basePluginListener = function (result, data, next) { return next(result); };\n// Global plugin events registry\nexport var pluginEvents = window.__gondelPluginEvents || {};\nwindow.__gondelPluginEvents = pluginEvents;\nexport function fireGondelPluginEvent(eventName, initialValue, data, callback) {\n    var isSyncron = false;\n    var callbackResult;\n    // Execute all bound events for the given name\n    // if they exist\n    (pluginEvents[eventName] || basePluginListener)(initialValue, data, function (processedResult) {\n        isSyncron = true;\n        callbackResult = callback ? callback(processedResult) : processedResult;\n    });\n    // Add a guard to prevent asyncron plugin listeners\n    // to simplify the usage of fireGondelPluginEvent\n    if (!isSyncron) {\n        throw new Error(\"Async plugin listener\");\n    }\n    return callbackResult;\n}\n/**\n * Fire an async event which allows gondel plugins to add features to gondel\n */\nexport function fireAsyncGondelPluginEvent(eventName, initialValue, data) {\n    return new Promise(function (resolve) {\n        (pluginEvents[eventName] || basePluginListener)(initialValue, data, function (result) {\n            resolve(result);\n        });\n    });\n}\n/**\n * Allow plugins to hook into the gondel event system\n */\nexport function addGondelPluginEventListener(eventName, eventListenerCallback) {\n    if (!pluginEvents[eventName]) {\n        pluginEvents[eventName] = basePluginListener;\n    }\n    var previousEventHandler = pluginEvents[eventName];\n    pluginEvents[eventName] = function wrapCallback(result, data, next) {\n        previousEventHandler(result, data, function callNextPlugin(modifiedResult, _, firstNext) {\n            eventListenerCallback(modifiedResult, data, function bindData(result) {\n                next(result, data, firstNext);\n            });\n        });\n    };\n}\n//# sourceMappingURL=GondelPluginUtils.js.map","import { fireGondelPluginEvent } from \"./GondelPluginUtils\";\nvar GondelComponentRegistry = /** @class */ (function () {\n    function GondelComponentRegistry() {\n        this._components = {};\n        this._activeComponents = {};\n    }\n    GondelComponentRegistry.prototype.registerComponent = function (name, gondelComponent) {\n        this._components[name] = gondelComponent;\n    };\n    GondelComponentRegistry.prototype.unregisterComponent = function (name) {\n        delete this._components[name];\n    };\n    GondelComponentRegistry.prototype.getComponent = function (name) {\n        return this._components[name];\n    };\n    /**\n     * Set if a component is used\n     */\n    GondelComponentRegistry.prototype.setActiveState = function (name, isActive) {\n        this._activeComponents[name] = isActive;\n    };\n    return GondelComponentRegistry;\n}());\nexport { GondelComponentRegistry };\nexport var componentRegistries = (window.__gondelRegistries = window.__gondelRegistries || {});\nexport function registerComponent() {\n    var args = arguments;\n    // The componentName is always the first argument\n    var componentName = args[0];\n    // Use namespace from the second argument or fallback to the default \"g\" if it is missing\n    var namespace = typeof args[1] === \"string\" ? args[1] : \"g\";\n    // The last argument is always the component class\n    var component = args[args.length - 1];\n    if (!componentRegistries[namespace]) {\n        componentRegistries[namespace] = new GondelComponentRegistry();\n    }\n    // If this component was already registered we remove the previous one\n    // and notify all plugins - this is especially usefull for hot component replacement\n    if (componentRegistries[namespace].getComponent(componentName)) {\n        fireGondelPluginEvent(\"unregister\", component, { componentName: componentName, namespace: namespace });\n    }\n    // Let plugins know about the new component\n    fireGondelPluginEvent(\"register\", component, {\n        componentName: componentName,\n        namespace: namespace,\n        gondelComponentRegistry: componentRegistries[namespace]\n    }, function (component) {\n        componentRegistries[namespace].registerComponent(componentName, component);\n    });\n}\n//# sourceMappingURL=GondelComponentRegistry.js.map","import { componentRegistries } from \"./GondelComponentRegistry\";\nimport { startComponentsFromRegistry } from \"./GondelComponentStarter\";\nexport var internalGondelRefAttribute = \"_gondel_\";\nexport var internalGondelAsyncRefAttribute = \"_gondelA_\";\n/**\n * Returns true if the given object is a single Element\n */\nfunction isElement(domNode) {\n    return domNode.nodeType !== undefined;\n}\n/**\n * This function normalizes takes one of the following:\n *  + document query result\n *  + dom node array\n *  + jquery object\n *  + a single dom node\n * and turns it into a single dom node\n */\nexport function getFirstDomNode(domNode) {\n    if (isElement(domNode)) {\n        return domNode;\n    }\n    return domNode[0];\n}\n/**\n * Start all nodes in the given context\n */\nexport function startComponents(domContext, namespace) {\n    if (namespace === void 0) { namespace = \"g\"; }\n    if (!componentRegistries[namespace]) {\n        return Promise.resolve([]);\n    }\n    var registry = componentRegistries[namespace];\n    return startComponentsFromRegistry(registry, domContext ? getFirstDomNode(domContext) : document.documentElement, namespace);\n}\n/**\n * Stop all nodes in the given context\n */\nexport function stopComponents(domContext, namespace) {\n    if (namespace === void 0) { namespace = \"g\"; }\n    var components = findComponents(domContext, undefined, namespace);\n    var rootComponent = domContext && getComponentByDomNode(domContext);\n    if (rootComponent) {\n        components.unshift(rootComponent);\n    }\n    components.forEach(function (component) { return component.stop(); });\n}\n/**\n * Returns the gondel instance for the given HtmlELement\n */\nexport function getComponentByDomNode(domNode, namespace) {\n    if (namespace === void 0) { namespace = \"g\"; }\n    var firstNode = getFirstDomNode(domNode);\n    var gondelComponent = firstNode[internalGondelRefAttribute + namespace];\n    // Stop if this dom node is not known to gondel\n    if (gondelComponent && gondelComponent._ctx) {\n        return gondelComponent;\n    }\n    return;\n}\n/**\n * Returns the gondel instance for the given HtmlELement once it is booted\n */\nexport function getComponentByDomNodeAsync(domNode, namespace) {\n    if (namespace === void 0) { namespace = \"g\"; }\n    var firstNode = getFirstDomNode(domNode);\n    var gondelComponent = firstNode[internalGondelAsyncRefAttribute + namespace];\n    // Stop if this dom node is not known to gondel\n    if (!gondelComponent) {\n        return Promise.reject(undefined);\n    }\n    // or the component is already booted up return it\n    if (gondelComponent._ctx) {\n        return Promise.resolve(gondelComponent);\n    }\n    // Wait the component to boot up and return it\n    return gondelComponent.then(function () { return firstNode[internalGondelRefAttribute + namespace]; });\n}\n/**\n * Returns all components inside the given node\n */\nexport function findComponents(domNode, componentName, namespace) {\n    if (domNode === void 0) { domNode = document.documentElement; }\n    if (namespace === void 0) { namespace = \"g\"; }\n    var firstNode = getFirstDomNode(domNode);\n    var components = [];\n    var attribute = \"_gondel_\" + namespace;\n    var nodes = firstNode.querySelectorAll(\"[data-\" + namespace + \"-name\" + (componentName ? \"=\\\"\" + componentName + \"\\\"\" : \"\") + \"]\");\n    for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var gondelComponentInstance = node[attribute];\n        // Verify that the component is fully booted\n        if (gondelComponentInstance && gondelComponentInstance._ctx === node) {\n            components.push(gondelComponentInstance);\n        }\n    }\n    return components;\n}\n//# sourceMappingURL=GondelDomUtils.js.map","/**\n * The event registry provides a way to bind events ahead of time\n * with a very small foot print during launch to improve the time to interaction\n */\nimport { getComponentByDomNode } from \"./GondelDomUtils\";\nimport { fireGondelPluginEvent } from \"./GondelPluginUtils\";\n/**\n * Only real browser events are supported.\n * Unfortunately focus and blur do not bubble so a special mapping is needed.\n */\nvar eventNameMapping = {\n    focus: \"focusin\",\n    blur: \"focusout\"\n};\nvar domEventRegistry = window.__gondelDomEvents || {};\nwindow.__gondelDomEvents = domEventRegistry;\n/* istanbul ignore next : Browser polyfill can't be tested */\nvar matches = Element.prototype.matches ||\n    Element.prototype.matchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.oMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\nfunction getParentElements(startElement) {\n    var nodes = [];\n    for (var element = startElement; element; element = element.parentElement) {\n        nodes.push(element);\n    }\n    return nodes;\n}\n/**\n * Returns an array of all handlers which would apply for the current target\n */\nexport function getHandlers(attributeName, eventHandlerRegistry, target) {\n    var parents = getParentElements(target);\n    // Find all selectors which have been registred for this event type\n    // and which have a gondel component in one of the parrent nodes\n    var selectorsOfFoundComponents = [];\n    parents.forEach(function (parent, i) {\n        var componentName = parent.getAttribute(attributeName);\n        var handlers = componentName && eventHandlerRegistry[componentName];\n        if (handlers) {\n            // Store the index where the component was found to know in which part\n            // of the dom tree the selectors could be found\n            selectorsOfFoundComponents.push({ index: i, handlers: handlers });\n        }\n    });\n    // Iterate over all possible selectors to find out if the current event\n    // should fire any gondel handler\n    var handlerQueue = [];\n    selectorsOfFoundComponents.forEach(function (_a) {\n        var index = _a.index, handlers = _a.handlers;\n        var selectorNames = Object.keys(handlers);\n        selectorNames.forEach(function (selectorName) {\n            // If no selector is given the handler does always match\n            if (!selectorName) {\n                return handlerQueue.push({\n                    index: index,\n                    ctx: parents[index],\n                    handlerOptions: handlers[selectorName]\n                });\n            }\n            // Iterate backwards over the children of the component to find an element\n            // which matches the selector for the current handler\n            for (var i = index; --i >= 0;) {\n                if (matches.call(parents[i], selectorName)) {\n                    return handlerQueue.push({\n                        index: i,\n                        ctx: parents[index],\n                        handlerOptions: handlers[selectorName]\n                    });\n                }\n            }\n        });\n    });\n    // Break if we couldn't find any matching element\n    if (handlerQueue.length === 0) {\n        return [];\n    }\n    // Sort the queue so events which are further up the dom are fired first\n    handlerQueue.sort(function (handlerA, handlerB) {\n        return handlerA.index > handlerB.index ? 1 : handlerA.index === handlerB.index ? 0 : -1;\n    });\n    return handlerQueue;\n}\n/**\n * The handler which will catch every event at the documentElement\n */\nfunction handleEvent(namespace, attributeName, eventHandlerRegistry, event) {\n    var target = event.target;\n    var handlers = getHandlers(attributeName, eventHandlerRegistry, target);\n    executeHandlers(handlers, event, namespace);\n}\n/**\n * Returns the namespace registry for the given namespace..\n * This function must be used only by core or plugins\n */\nexport function getEventRegistry(namespace) {\n    if (!domEventRegistry[namespace]) {\n        domEventRegistry[namespace] = {};\n    }\n    return domEventRegistry[namespace];\n}\n/**\n * Notify components\n * This function must be used by core or only by plugins\n */\nexport function executeHandlers(handlers, event, namespace) {\n    var results = [];\n    for (var i = 0; i < handlers.length && !event.cancelBubble; i++) {\n        var handlerObject = handlers[i];\n        var handlerOptions = handlerObject.handlerOptions;\n        var gondelComponent = getComponentByDomNode(handlerObject.ctx, namespace);\n        // Skip if the component wasn't started or if it was stopped\n        if (gondelComponent) {\n            for (var j = 0; j < handlerOptions.length && !event.cancelBubble; j++) {\n                var handlerResult = gondelComponent[handlerOptions[j].handlerName].call(gondelComponent, event);\n                if (typeof handlerResult === \"function\") {\n                    results.push(handlerResult);\n                }\n            }\n        }\n    }\n    // Execute all callbacks to allow grouping write events\n    results.forEach(function (result) {\n        result();\n    });\n}\n/**\n * Add a event lister to the <html> element\n * The listener will always call handleEvent with the domEventRegistry for the given event\n */\nfunction startListeningForEvent(eventName, namespace) {\n    document.documentElement.addEventListener(eventNameMapping[eventName] || eventName, handleEvent.bind(null, namespace, \"data-\" + namespace + \"-name\", domEventRegistry[namespace][eventName]));\n}\n/**\n * Add an event to the Gondel EventRegistry\n */\nexport function addRootEventListener(namespace, domEventName, gondelComponentName, handlerName, handlerOption) {\n    // Create namespace if neededi\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\n    // Notify all plugins to allow taking over the event handling for a specific event name\n    // This notification is only triggered if a event name e.g. 'click' is used for the first time\n    if (!namespacedDomEventRegistry[domEventName]) {\n        namespacedDomEventRegistry[domEventName] = {};\n        fireGondelPluginEvent(\"registerEvent\", true, {\n            eventName: domEventName,\n            namespace: namespace,\n            eventRegistry: namespacedDomEventRegistry[domEventName]\n        }, function (isNativeEvent) {\n            // If no plugin registered the event\n            // register a native browser event\n            if (isNativeEvent) {\n                startListeningForEvent(domEventName, namespace);\n            }\n        });\n    }\n    if (!namespacedDomEventRegistry[domEventName][gondelComponentName]) {\n        namespacedDomEventRegistry[domEventName][gondelComponentName] = {};\n    }\n    var handlerOptionObject = typeof handlerOption === \"object\" ? handlerOption : { selector: handlerOption };\n    var selectorKey = handlerOptionObject.selector || \"\";\n    if (!namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey]) {\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey] = [];\n    }\n    namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey].push(Object.assign({ handlerName: handlerName, handlerOption: handlerOption }));\n}\n/**\n * Remove an event from the Gondel EventRegistry\n */\nexport function removeRootEventListener(namespace, domEventName, gondelComponentName, handlerName, selector) {\n    var selectorKey = selector || \"\";\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\n    if (namespacedDomEventRegistry[domEventName] &&\n        namespacedDomEventRegistry[domEventName][gondelComponentName] &&\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey]) {\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey] = namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey].filter(function (handlerOption) {\n            return handlerOption.handlerName !== handlerName || handlerName === undefined;\n        });\n    }\n}\n/**\n * Remove all events for a given Component (e.g. a Button) from the Gondel EventRegistry\n */\nexport function removeRootEventListernerForComponent(namespace, gondelComponentName) {\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\n    for (var eventName in namespacedDomEventRegistry) {\n        /* istanbul ignore else: for in savety check */\n        if (namespacedDomEventRegistry.hasOwnProperty(eventName)) {\n            delete namespacedDomEventRegistry[eventName][gondelComponentName];\n        }\n    }\n}\n//# sourceMappingURL=GondelEventRegistry.js.map","// Export helpers to hook into the gondel frameworks (should only be used by plugins)\nexport { addGondelPluginEventListener } from \"./GondelPluginUtils\";\n// Export helpers to interact with DOM e.g. start a gondel component for a given DOM node\n// or get a running gondel component instance for a given DOM node\nexport * from \"./GondelDomUtils\";\n// Export https://github.com/tc39/proposal-decorators decorators e.g. @EventListener or @Component\nexport * from \"./GondelDecorators\";\n// Export event helpers to send custom events to React/Angular or foreign gondel components\nexport * from \"./GondelEventEmitter\";\n// Export types of the Gondel Component instance\nexport * from \"./GondelComponent\";\n// Export a helper which allows registring components without using decorators\nexport { registerComponent } from \"./GondelComponentRegistry\";\n//# sourceMappingURL=index.js.map","/**\n * This is a plugin to initialize enquire.js and fire a viewportChange event when triggering a breakpoint\n */\nimport { addGondelPluginEventListener, getComponentByDomNode } from \"@gondel/core\";\n/**\n * The VIEWPORT_ENTERED will be fired if a new viewport is entered\n */\nexport var VIEWPORT_ENTERED = \"@gondel/plugin-media-queries--viewport-entered\";\nvar currentViewport;\n/**\n * This function returns all components for the given eventRegistry which can be found in the dom.\n */\nfunction getComponentsInEventRegistry(eventRegistry, namespace) {\n    var selector = Object.keys(eventRegistry)\n        .map(function (componentName) { return \"[data-\" + namespace + \"-name=\\\"\" + componentName + \"\\\"]\"; })\n        .join(\",\");\n    if (!selector) {\n        return [];\n    }\n    var componentElements = document.documentElement.querySelectorAll(selector);\n    var components = [];\n    for (var i = 0; i < componentElements.length; i++) {\n        var component = getComponentByDomNode(componentElements[i], namespace);\n        if (component) {\n            components.push(component);\n        }\n    }\n    return components;\n}\n/**\n * This function fire's a custom gondel event to all registered components\n */\nfunction fireViewportChangeEvent(viewport, eventRegistry, namespace) {\n    var components = getComponentsInEventRegistry(eventRegistry, namespace);\n    var handlerResults = [];\n    components.forEach(function (component) {\n        Object.keys(eventRegistry[component._componentName]).forEach(function (selector) {\n            if (selector === \"\" || viewport === selector) {\n                eventRegistry[component._componentName][selector].forEach(function (handlerOption) {\n                    handlerResults.push(component[handlerOption.handlerName].call(component, { viewport: viewport }));\n                });\n            }\n        });\n    });\n    handlerResults.forEach(function (handlerResults) { return function () {\n        if (typeof handlerResults === \"function\") {\n            handlerResults();\n        }\n    }; });\n}\n/**\n * This function returns the current viewport\n */\nexport function getCurrentViewport() {\n    return currentViewport;\n}\n/**\n * Converts the given pixel breakpoint object into a em breakpoint object\n */\nfunction convertBreakpointsToEm(breakpointsInPx) {\n    var breakpointsInEm = {};\n    var breakpointNames = Object.keys(breakpointsInPx);\n    breakpointNames.forEach(function (breakpointName) {\n        breakpointsInEm[breakpointName] = px2em(breakpointsInPx[breakpointName]);\n    });\n    return breakpointsInEm;\n}\n/**\n * Convert pixel to em\n */\nfunction px2em(pixelValue) {\n    return Math.round(pixelValue / 16 * 100) / 1000;\n}\n/**\n * This function generate mediaQueries from breakPoints\n */\nfunction generateMediaQueries(breakPoints, unit) {\n    // Sort breakpoints by size\n    var breakpointNames = Object.keys(breakPoints).sort(function (breakpointNameA, breakpointNameB) {\n        if (breakPoints[breakpointNameA] > breakPoints[breakpointNameB]) {\n            return 1;\n        }\n        if (breakPoints[breakpointNameA] < breakPoints[breakpointNameB]) {\n            return -1;\n        }\n        return 0;\n    });\n    // Convert breakpoints from 980 into (min-width: 700) and (max-width: 980)\n    // by using the previous breakpoint\n    return breakpointNames.map(function (breakpointName, i) {\n        // If this is the first breakpoint we don't need a min value\n        var min = breakpointNames[i - 1] === undefined ? undefined : breakPoints[breakpointNames[i - 1]] + 1;\n        // If this is the last breakpoint we don't need a max value\n        var max = breakPoints[breakpointName] === Infinity ? undefined : breakPoints[breakpointName];\n        var queryString;\n        if (min && max) {\n            queryString = \"(min-width: \" + min + unit + \") and (max-width: \" + max + unit + \")\";\n        }\n        else if (min) {\n            queryString = \"(min-width: \" + min + unit + \")\";\n        }\n        else if (max) {\n            queryString = \"(max-width: \" + max + unit + \")\";\n        }\n        else {\n            // This should only happen if the user did a miss configuration\n            // with only a single breakpoint which is set to infinity\n            throw new Error(\"The smallest provided viewport must not be set to Infinity\");\n        }\n        return { name: breakpointName, query: queryString, min: min, max: max };\n    });\n}\n/**\n * Use enquire.js to listen for viewport changes\n * Once a viewport changed call all gondel plugins which are listening\n */\nfunction setupViewportChangeEvent(mediaQueries, eventRegistry, namespace) {\n    var _loop_1 = function (viewport) {\n        matchMedia(viewport.query).addListener(function (mediaQueryList) {\n            if (mediaQueryList.matches) {\n                fireViewportChangeEvent(viewport.name, eventRegistry, namespace);\n            }\n        });\n    };\n    for (var _i = 0, mediaQueries_1 = mediaQueries; _i < mediaQueries_1.length; _i++) {\n        var viewport = mediaQueries_1[_i];\n        _loop_1(viewport);\n    }\n}\n/**\n * Use enquire.js to listen for viewport changes\n * for the getCurrentViewport helper method\n */\nfunction setupCurrentViewportHelper(mediaQueries) {\n    var _loop_2 = function (viewport) {\n        var viewportMediaQueryList = matchMedia(viewport.query);\n        // Set initial viewport\n        if (viewportMediaQueryList.matches) {\n            currentViewport = viewport.name;\n        }\n        // Watch for media query changes\n        viewportMediaQueryList.addListener(function (mediaQueryList) {\n            if (mediaQueryList.matches) {\n                currentViewport = viewport.name;\n            }\n        });\n    };\n    for (var _i = 0, mediaQueries_2 = mediaQueries; _i < mediaQueries_2.length; _i++) {\n        var viewport = mediaQueries_2[_i];\n        _loop_2(viewport);\n    }\n}\n/**\n * This function creates a custom gondel event\n */\nexport function initMediaQueriesPlugin(options) {\n    // Get the converted breakpoint values\n    var breakPoints = options.convertToEm\n        ? convertBreakpointsToEm(options.breakPoints)\n        : options.breakPoints;\n    // Get the unit\n    var unit = options.unit || (options.convertToEm ? \"em\" : \"px\");\n    var mediaQueries = generateMediaQueries(breakPoints, unit);\n    // Setup the viewport helper independently so it will\n    // also be avialiable if no component is listening to events:\n    setupCurrentViewportHelper(mediaQueries);\n    addGondelPluginEventListener(\"registerEvent\", function addViewportChangeEvent(isNativeEvent, _a, resolve) {\n        var eventName = _a.eventName, namespace = _a.namespace, eventRegistry = _a.eventRegistry;\n        // Ignore all events but the viewportChange event\n        if (eventName !== VIEWPORT_ENTERED) {\n            resolve(isNativeEvent);\n            return;\n        }\n        setupViewportChangeEvent(mediaQueries, eventRegistry, namespace);\n        // Tell the event system that it should not listen for the event:\n        resolve(false);\n    });\n}\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":"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"}