{"version":3,"file":"index.es5.js","sources":["../../../core/dist/GondelPluginUtils.js","../../../core/dist/GondelDomUtils.js","../../../core/dist/GondelEventRegistry.js","../../../core/dist/index.js","index.js"],"sourcesContent":["var basePluginListener = function (result, data, next) { return next(result); };\r\n// Global plugin events registry\r\nexport var pluginEvents = window.__gondelPluginEvents || {};\r\nwindow.__gondelPluginEvents = pluginEvents;\r\nexport function fireGondelPluginEvent(eventName, initialValue, data, callback) {\r\n    var isSyncron = false;\r\n    var callbackResult;\r\n    // Execute all bound events for the given name\r\n    // if they exist\r\n    (pluginEvents[eventName] || basePluginListener)(initialValue, data, function (processedResult) {\r\n        isSyncron = true;\r\n        callbackResult = callback ? callback(processedResult) : processedResult;\r\n    });\r\n    // Add a guard to prevent asyncron plugin listeners\r\n    // to simplify the usage of fireGondelPluginEvent\r\n    if (!isSyncron) {\r\n        throw new Error(\"Async plugin listener\");\r\n    }\r\n    return callbackResult;\r\n}\r\n/**\r\n * Fire an async event which allows gondel plugins to add features to gondel\r\n */\r\nexport function fireAsyncGondelPluginEvent(eventName, initialValue, data) {\r\n    return new Promise(function (resolve) {\r\n        (pluginEvents[eventName] || basePluginListener)(initialValue, data, function (result) {\r\n            resolve(result);\r\n        });\r\n    });\r\n}\r\n/**\r\n * Allow plugins to hook into the gondel event system\r\n */\r\nexport function addGondelPluginEventListener(eventName, eventListenerCallback) {\r\n    if (!pluginEvents[eventName]) {\r\n        pluginEvents[eventName] = basePluginListener;\r\n    }\r\n    var previousEventHandler = pluginEvents[eventName];\r\n    pluginEvents[eventName] = function wrapCallback(result, data, next) {\r\n        previousEventHandler(result, data, function callNextPlugin(modifiedResult, _, firstNext) {\r\n            eventListenerCallback(modifiedResult, data, function bindData(result) {\r\n                next(result, data, firstNext);\r\n            });\r\n        });\r\n    };\r\n}\r\n//# sourceMappingURL=GondelPluginUtils.js.map","import { getComponentRegistry } from \"./GondelComponentRegistry\";\r\nimport { startComponentsFromRegistry } from \"./GondelComponentStarter\";\r\nexport var internalGondelRefAttribute = \"_gondel_\";\r\nexport var internalGondelAsyncRefAttribute = \"_gondelA_\";\r\n/**\r\n * Returns true if the given object is a single Element\r\n */\r\nfunction isElement(domNode) {\r\n    return domNode.nodeType !== undefined;\r\n}\r\n/**\r\n * This function normalizes takes one of the following:\r\n *  + document query result\r\n *  + dom node array\r\n *  + jquery object\r\n *  + a single dom node\r\n * and turns it into a single dom node\r\n */\r\nexport function getFirstDomNode(domNode) {\r\n    if (isElement(domNode)) {\r\n        return domNode;\r\n    }\r\n    return domNode[0];\r\n}\r\n/**\r\n * Start all nodes in the given context\r\n */\r\nexport function startComponents(domContext, namespace) {\r\n    if (namespace === void 0) { namespace = \"g\"; }\r\n    var registry = getComponentRegistry(namespace);\r\n    return startComponentsFromRegistry(registry, domContext ? getFirstDomNode(domContext) : document.documentElement, namespace);\r\n}\r\n/**\r\n * Stop all nodes in the given context\r\n */\r\nexport function stopComponents(domContext, namespace) {\r\n    if (namespace === void 0) { namespace = \"g\"; }\r\n    var components = findComponents(domContext, undefined, namespace);\r\n    if (domContext && hasMountedGondelComponent(domContext)) {\r\n        components.unshift(getComponentByDomNode(domContext));\r\n    }\r\n    components.forEach(function (component) { return component.stop(); });\r\n}\r\n/**\r\n * Checks if a component is mounted on a certain DOM node\r\n */\r\nexport function hasMountedGondelComponent(domNode, namespace) {\r\n    if (namespace === void 0) { namespace = \"g\"; }\r\n    var firstNode = getFirstDomNode(domNode);\r\n    var gondelComponent = firstNode[internalGondelRefAttribute + namespace];\r\n    if (!gondelComponent || !gondelComponent._ctx) {\r\n        // no anchor prop found or ctx missing. function is needed\r\n        // that we can type the `getComponentByDomNode` without possible\r\n        // returnal of undefined.\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Returns the gondel instance for the given HtmlELement\r\n */\r\nexport function getComponentByDomNode(domNode, namespace) {\r\n    if (namespace === void 0) { namespace = \"g\"; }\r\n    var gondelComponent = extractComponent(getFirstDomNode(domNode), namespace);\r\n    if (!gondelComponent) {\r\n        throw new Error(\"Could not find a started gondel component in namespace \\\"\" + namespace + \"\\\",\\nplease check if your component is mounted via 'hasMountedGondelComponent'\");\r\n    }\r\n    return gondelComponent;\r\n}\r\n/**\r\n * Internal helper function of getComponentByDomNode\r\n *\r\n * Returns the gondel instance from a known HtmlElement\r\n * This function is an internal helper with a possible undefined\r\n * return value.\r\n */\r\nexport function extractComponent(element, namespace) {\r\n    var gondelComponent = element[internalGondelRefAttribute + namespace];\r\n    // Stop if this dom node is not known to gondel\r\n    if (gondelComponent && gondelComponent._ctx) {\r\n        return gondelComponent;\r\n    }\r\n}\r\n/**\r\n * Returns the gondel instance for the given HtmlELement once it is booted\r\n */\r\nexport function getComponentByDomNodeAsync(domNode, namespace) {\r\n    if (namespace === void 0) { namespace = \"g\"; }\r\n    var firstNode = getFirstDomNode(domNode);\r\n    var gondelComponent = firstNode[internalGondelAsyncRefAttribute + namespace];\r\n    // Stop if this dom node is not known to gondel\r\n    if (!gondelComponent) {\r\n        return Promise.reject(undefined);\r\n    }\r\n    // or the component is already booted up return it\r\n    if (gondelComponent._ctx) {\r\n        return Promise.resolve(gondelComponent);\r\n    }\r\n    // Wait the component to boot up and return it\r\n    return gondelComponent.then(function () { return firstNode[internalGondelRefAttribute + namespace]; });\r\n}\r\n/**\r\n * Returns all components inside the given node\r\n */\r\nexport function findComponents(domNode, componentName, namespace) {\r\n    if (domNode === void 0) { domNode = document.documentElement; }\r\n    if (namespace === void 0) { namespace = \"g\"; }\r\n    var firstNode = getFirstDomNode(domNode);\r\n    var components = [];\r\n    var attribute = \"_gondel_\" + namespace;\r\n    var nodes = firstNode.querySelectorAll(\"[data-\" + namespace + \"-name\" + (componentName ? \"=\\\"\" + componentName + \"\\\"\" : \"\") + \"]\");\r\n    for (var i = 0; i < nodes.length; i++) {\r\n        var node = nodes[i];\r\n        var gondelComponentInstance = node[attribute];\r\n        // Verify that the component is fully booted\r\n        if (gondelComponentInstance && gondelComponentInstance._ctx === node) {\r\n            components.push(gondelComponentInstance);\r\n        }\r\n    }\r\n    return components;\r\n}\r\n//# sourceMappingURL=GondelDomUtils.js.map","/**\r\n * The event registry provides a way to bind events ahead of time\r\n * with a very small foot print during launch to improve the time to interaction\r\n */\r\nimport { extractComponent } from \"./GondelDomUtils\";\r\nimport { fireGondelPluginEvent } from \"./GondelPluginUtils\";\r\n/**\r\n * Only real browser events are supported.\r\n * Unfortunately focus and blur do not bubble so a special mapping is needed.\r\n */\r\nvar eventNameMapping = {\r\n    focus: \"focusin\",\r\n    blur: \"focusout\"\r\n};\r\n// Polyfill for element.prototype.matches\r\nvar matchesCssSelector = function (element, selector) {\r\n    var elementPrototype = window.Element.prototype;\r\n    /* istanbul ignore next : Browser polyfill can't be tested */\r\n    var elementMatches = elementPrototype.matches ||\r\n        elementPrototype.matchesSelector ||\r\n        elementPrototype.mozMatchesSelector ||\r\n        elementPrototype.msMatchesSelector ||\r\n        elementPrototype.webkitMatchesSelector;\r\n    // Cache the function and call it\r\n    return (matchesCssSelector = function (element, selector) {\r\n        return elementMatches.call(element, selector);\r\n    })(element, selector);\r\n};\r\nfunction getParentElements(startElement) {\r\n    var nodes = [];\r\n    for (var element = startElement; element; element = element.parentElement) {\r\n        nodes.push(element);\r\n    }\r\n    return nodes;\r\n}\r\n/**\r\n * Returns an array of all handlers which would apply for the current target\r\n */\r\nexport function getHandlers(attributeName, eventHandlerRegistry, target) {\r\n    var parents = getParentElements(target);\r\n    // Find all selectors which have been registred for this event type\r\n    // and which have a gondel component in one of the parrent nodes\r\n    var selectorsOfFoundComponents = [];\r\n    parents.forEach(function (parent, i) {\r\n        var componentName = parent.getAttribute(attributeName);\r\n        var handlers = componentName && eventHandlerRegistry[componentName];\r\n        if (handlers) {\r\n            // Store the index where the component was found to know in which part\r\n            // of the dom tree the selectors could be found\r\n            selectorsOfFoundComponents.push({ index: i, handlers: handlers });\r\n        }\r\n    });\r\n    // Iterate over all possible selectors to find out if the current event\r\n    // should fire any gondel handler\r\n    var handlerQueue = [];\r\n    selectorsOfFoundComponents.forEach(function (_a) {\r\n        var index = _a.index, handlers = _a.handlers;\r\n        var selectorNames = Object.keys(handlers);\r\n        selectorNames.forEach(function (selectorName) {\r\n            // If no selector is given the handler does always match\r\n            if (!selectorName) {\r\n                return handlerQueue.push({\r\n                    index: index,\r\n                    ctx: parents[index],\r\n                    target: parents[index],\r\n                    handlerOptions: handlers[selectorName]\r\n                });\r\n            }\r\n            // Iterate backwards over the children of the component to find an element\r\n            // which matches the selector for the current handler\r\n            for (var i = index; --i >= 0;) {\r\n                if (matchesCssSelector(parents[i], selectorName)) {\r\n                    return handlerQueue.push({\r\n                        index: i,\r\n                        ctx: parents[index],\r\n                        target: parents[i],\r\n                        handlerOptions: handlers[selectorName]\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    });\r\n    // Break if we couldn't find any matching element\r\n    if (handlerQueue.length === 0) {\r\n        return [];\r\n    }\r\n    // Sort the queue so events which are further up the dom are fired first\r\n    handlerQueue.sort(function (handlerA, handlerB) {\r\n        return handlerA.index > handlerB.index ? 1 : handlerA.index === handlerB.index ? 0 : -1;\r\n    });\r\n    return handlerQueue;\r\n}\r\n/**\r\n * The handler which will catch every event at the documentElement\r\n */\r\nfunction handleEvent(namespace, attributeName, eventHandlerRegistry, event) {\r\n    var target = event.target;\r\n    var handlers = getHandlers(attributeName, eventHandlerRegistry, target);\r\n    executeHandlers(handlers, event, namespace);\r\n}\r\nvar _domEventRegistry;\r\n/**\r\n * Returns the namespace registry for the given namespace..\r\n * This function must be used only by core or plugins\r\n */\r\nexport function getEventRegistry(namespace) {\r\n    if (!_domEventRegistry) {\r\n        _domEventRegistry = window[\"__\\ud83d\\udea1DomEvents\"] || {};\r\n        window[\"__\\ud83d\\udea1DomEvents\"] = _domEventRegistry;\r\n    }\r\n    if (!_domEventRegistry[namespace]) {\r\n        _domEventRegistry[namespace] = {};\r\n    }\r\n    return _domEventRegistry[namespace];\r\n}\r\n/**\r\n * Notify components\r\n * This function must be used by core or only by plugins\r\n */\r\nexport function executeHandlers(handlers, event, namespace) {\r\n    /** Store wether the original Event was modified to provide the correct currentTarget */\r\n    var eventObjectRequiresCleanup = false;\r\n    /** Store optional callback results which are executed together to allow grouped redraws */\r\n    var results = [];\r\n    var _loop_1 = function (i) {\r\n        var handlerObject = handlers[i];\r\n        var handlerOptions = handlerObject.handlerOptions;\r\n        var gondelComponent = extractComponent(handlerObject.ctx, namespace);\r\n        // Skip if the component wasn't started or if it was stopped\r\n        if (gondelComponent) {\r\n            // See https://stackoverflow.com/questions/52057726/what-is-the-best-way-to-alter-a-native-browser-event\r\n            Object.defineProperty(event, \"currentTarget\", {\r\n                get: function () { return handlerObject.target; },\r\n                configurable: true\r\n            });\r\n            eventObjectRequiresCleanup = true;\r\n            for (var j = 0; j < handlerOptions.length && !event.cancelBubble; j++) {\r\n                var handlerResult = gondelComponent[handlerOptions[j].handlerName].call(gondelComponent, event);\r\n                if (typeof handlerResult === \"function\") {\r\n                    results.push(handlerResult);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    for (var i = 0; i < handlers.length && !event.cancelBubble; i++) {\r\n        _loop_1(i);\r\n    }\r\n    // Execute all callbacks to allow grouping write events\r\n    results.forEach(function (result) {\r\n        result();\r\n    });\r\n    // Cleanup the event object\r\n    if (eventObjectRequiresCleanup) {\r\n        // See https://stackoverflow.com/questions/52057726/what-is-the-best-way-to-alter-a-native-browser-event\r\n        delete event.currentTarget;\r\n    }\r\n}\r\n/**\r\n * Add a event lister to the <html> element\r\n * The listener will always call handleEvent with the domEventRegistry for the given event\r\n */\r\nfunction startListeningForEvent(eventName, namespace) {\r\n    document.documentElement.addEventListener(eventNameMapping[eventName] || eventName, handleEvent.bind(null, namespace, \"data-\" + namespace + \"-name\", getEventRegistry(namespace)[eventName]));\r\n}\r\n/**\r\n * Add an event to the Gondel EventRegistry\r\n */\r\nexport function addRootEventListener(namespace, domEventName, gondelComponentName, handlerName, handlerOption) {\r\n    // Create namespace if neededi\r\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\r\n    // Notify all plugins to allow taking over the event handling for a specific event name\r\n    // This notification is only triggered if a event name e.g. 'click' is used for the first time\r\n    if (!namespacedDomEventRegistry[domEventName]) {\r\n        namespacedDomEventRegistry[domEventName] = {};\r\n        fireGondelPluginEvent(\"registerEvent\", true, {\r\n            eventName: domEventName,\r\n            namespace: namespace,\r\n            eventRegistry: namespacedDomEventRegistry[domEventName]\r\n        }, function (isNativeEvent) {\r\n            // If no plugin registered the event\r\n            // register a native browser event\r\n            if (isNativeEvent) {\r\n                startListeningForEvent(domEventName, namespace);\r\n            }\r\n        });\r\n    }\r\n    if (!namespacedDomEventRegistry[domEventName][gondelComponentName]) {\r\n        namespacedDomEventRegistry[domEventName][gondelComponentName] = {};\r\n    }\r\n    var handlerOptionObject = typeof handlerOption === \"object\" ? handlerOption : { selector: handlerOption };\r\n    var selectorKey = handlerOptionObject.selector || \"\";\r\n    if (!namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey]) {\r\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey] = [];\r\n    }\r\n    namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey].push(Object.assign({ handlerName: handlerName, handlerOption: handlerOption }));\r\n}\r\n/**\r\n * Remove an event from the Gondel EventRegistry\r\n */\r\nexport function removeRootEventListener(namespace, domEventName, gondelComponentName, handlerName, selector) {\r\n    var selectorKey = selector || \"\";\r\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\r\n    if (namespacedDomEventRegistry[domEventName] &&\r\n        namespacedDomEventRegistry[domEventName][gondelComponentName] &&\r\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey]) {\r\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey] = namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey].filter(function (handlerOption) {\r\n            return handlerOption.handlerName !== handlerName || handlerName === undefined;\r\n        });\r\n    }\r\n}\r\n/**\r\n * Remove all events for a given Component (e.g. a Button) from the Gondel EventRegistry\r\n */\r\nexport function removeRootEventListernerForComponent(namespace, gondelComponentName) {\r\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\r\n    for (var eventName in namespacedDomEventRegistry) {\r\n        /* istanbul ignore else: for in savety check */\r\n        if (namespacedDomEventRegistry.hasOwnProperty(eventName)) {\r\n            delete namespacedDomEventRegistry[eventName][gondelComponentName];\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=GondelEventRegistry.js.map","// Export helpers to hook into the gondel frameworks (should only be used by plugins)\r\nexport { addGondelPluginEventListener } from \"./GondelPluginUtils\";\r\n// Export helpers to interact with DOM e.g. start a gondel component for a given DOM node\r\n// or get a running gondel component instance for a given DOM node\r\nexport { getFirstDomNode, startComponents, stopComponents, hasMountedGondelComponent, getComponentByDomNode, getComponentByDomNodeAsync, findComponents } from \"./GondelDomUtils\";\r\n// Export https://github.com/tc39/proposal-decorators decorators e.g. @EventListener or @Component\r\nexport * from \"./GondelDecorators\";\r\n// Export event helpers to send custom events to React/Angular or foreign gondel components\r\nexport * from \"./GondelEventEmitter\";\r\n// Export types of the Gondel Component instance\r\nexport * from \"./GondelComponent\";\r\n// Export a helper which allows registring components without using decorators\r\nexport { registerComponent } from \"./GondelComponentRegistry\";\r\n// Allow to disable the autobooting feature\r\nexport { disableAutoStart } from \"./GondelAutoStart\";\r\n//# sourceMappingURL=index.js.map","/**\r\n * This is a gondel plugin which add a custom gondel resize event\r\n */\r\nimport { addGondelPluginEventListener, getComponentByDomNode } from \"@gondel/core\";\r\n/**\r\n * This function returns all components for the given eventRegistry which can be found in the dom.\r\n */\r\nfunction getComponentsInEventRegistry(eventRegistry, namespace) {\r\n    var selector = Object.keys(eventRegistry)\r\n        .map(function (componentName) { return \"[data-\" + namespace + \"-name=\\\"\" + componentName + \"\\\"]\"; })\r\n        .join(\",\");\r\n    if (!selector) {\r\n        return [];\r\n    }\r\n    var componentElements = document.documentElement.querySelectorAll(selector);\r\n    var components = [];\r\n    for (var i = 0; i < componentElements.length; i++) {\r\n        var component = getComponentByDomNode(componentElements[i], namespace);\r\n        if (component) {\r\n            components.push(component);\r\n        }\r\n    }\r\n    return components;\r\n}\r\n/**\r\n * Add @EventListener('resize')\r\n *\r\n * This will allow components to listen for throttled window resize events\r\n * The resize event will only be fired for a component if the width or the height of the component changed\r\n */\r\nvar resize = function (eventRegistry, namespace) {\r\n    var isRunning = false;\r\n    var frameIsRequested = false;\r\n    var resizeDoneTimer;\r\n    var componentInformation;\r\n    /**\r\n     * This handler is called if a new resize event happens.\r\n     * A resize event is new if no resize occured for 250ms\r\n     */\r\n    function startResizeWatching(event) {\r\n        var components = getComponentsInEventRegistry(eventRegistry, namespace);\r\n        isRunning = true;\r\n        // The resize listener is fired very often\r\n        // for performance optimisations we search and store\r\n        // all components during the initial start event\r\n        componentInformation = components.map(function (component) {\r\n            var size = component.__resizeSize || {\r\n                width: 0,\r\n                height: 0\r\n            };\r\n            var gondelComponentHandlers = eventRegistry[component._componentName];\r\n            return {\r\n                component: component,\r\n                node: component._ctx,\r\n                selectors: Object.keys(gondelComponentHandlers).map(function (selector) {\r\n                    return gondelComponentHandlers[selector].map(function (handlerOption) { return component[handlerOption.handlerName]; });\r\n                }),\r\n                width: size.width,\r\n                height: size.height\r\n            };\r\n        });\r\n        fireResizeEvent(event);\r\n    }\r\n    /**\r\n     * Clean up after no resize event happened for 250ms\r\n     */\r\n    function stopResizeWatching() {\r\n        // If there is still a throttled resize handler\r\n        // wait until it is done\r\n        if (frameIsRequested) {\r\n            requestAnimationFrame(stopResizeWatching);\r\n            return;\r\n        }\r\n        // Memory cleanup\r\n        isRunning = false;\r\n        componentInformation = undefined;\r\n    }\r\n    /**\r\n     * Check which modules changed in size an call their event handler\r\n     */\r\n    function fireResizeEvent(event) {\r\n        frameIsRequested = false;\r\n        if (!componentInformation) {\r\n            return;\r\n        }\r\n        var newSizes = componentInformation.map(function (_a) {\r\n            var node = _a.node;\r\n            return ({\r\n                width: node.clientWidth,\r\n                height: node.clientHeight\r\n            });\r\n        });\r\n        var handlerResults = [];\r\n        componentInformation.forEach(function (componentInformation, i) {\r\n            var newSize = newSizes[i];\r\n            // Skip if the size did not change\r\n            if (newSize.width === componentInformation.width &&\r\n                newSize.height === componentInformation.height) {\r\n                return;\r\n            }\r\n            // Skip if the component is not running anymore\r\n            if (componentInformation.component._stopped) {\r\n                return;\r\n            }\r\n            componentInformation.component.__resizeSize = newSize;\r\n            componentInformation.width = newSize.width;\r\n            componentInformation.height = newSize.height;\r\n            componentInformation.selectors.forEach(function (selector) {\r\n                return selector.forEach(function (handler) {\r\n                    return handlerResults.push(handler.call(componentInformation.component, event, newSize));\r\n                });\r\n            });\r\n        });\r\n        handlerResults.forEach(function (handlerResult) {\r\n            if (typeof handlerResult === \"function\") {\r\n                handlerResult();\r\n            }\r\n        });\r\n    }\r\n    window.addEventListener(\"resize\", function (event) {\r\n        if (!isRunning) {\r\n            startResizeWatching(event);\r\n        }\r\n        else if (!frameIsRequested) {\r\n            frameIsRequested = true;\r\n            window.requestAnimationFrame(fireResizeEvent.bind(null, event));\r\n        }\r\n        clearTimeout(resizeDoneTimer);\r\n        resizeDoneTimer = setTimeout(stopResizeWatching, 250);\r\n    });\r\n};\r\n/**\r\n * The VIEWPORT_ENTERED will be fired if a new viewport is entered\r\n */\r\nexport var WINDOW_RESIZED = \"@gondel/plugin-resize--window-resized\";\r\n/**\r\n * This function creates a custom gondel event\r\n */\r\nexport function initResizePlugin() {\r\n    addGondelPluginEventListener(\"registerEvent\", function addResizeEvent(isNativeEvent, _a, resolve) {\r\n        var eventName = _a.eventName, namespace = _a.namespace, eventRegistry = _a.eventRegistry;\r\n        // Ignore all events but the resize event\r\n        if (eventName !== WINDOW_RESIZED) {\r\n            resolve(isNativeEvent);\r\n            return;\r\n        }\r\n        resize(eventRegistry, namespace);\r\n        // Tell the event system that it should not listen for the event:\r\n        resolve(false);\r\n    });\r\n    addGondelPluginEventListener(\"sync\", function addResizeEvent(components, data, resolve) {\r\n        setTimeout(function () {\r\n            components.forEach(function (component) {\r\n                component.__resizeSize = {\r\n                    width: component._ctx.clientWidth,\r\n                    height: component._ctx.clientHeight\r\n                };\r\n            });\r\n        });\r\n        resolve(components);\r\n    });\r\n}\r\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":"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"}