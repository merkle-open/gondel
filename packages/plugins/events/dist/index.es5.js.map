{"version":3,"file":"index.es5.js","sources":["../../../core/dist/GondelPluginUtils.js","../../../core/dist/GondelComponentRegistry.js","../../../core/dist/GondelDomUtils.js","../../../core/dist/GondelEventRegistry.js","index.js"],"sourcesContent":["var basePluginListener = function (result, data, next) { return next(result); };\n// Global plugin events registry\nexport var pluginEvents = window.__gondelPluginEvents || {};\nwindow.__gondelPluginEvents = pluginEvents;\nexport function fireGondelPluginEvent(eventName, initialValue, data, callback) {\n    var isSyncron = false;\n    var callbackResult;\n    // Execute all bound events for the given name\n    // if they exist\n    (pluginEvents[eventName] || basePluginListener)(initialValue, data, function (processedResult) {\n        isSyncron = true;\n        callbackResult = callback ? callback(processedResult) : processedResult;\n    });\n    // Add a guard to prevent asyncron plugin listeners\n    // to simplify the usage of fireGondelPluginEvent\n    if (!isSyncron) {\n        throw new Error(\"Async plugin listener\");\n    }\n    return callbackResult;\n}\n/**\n * Fire an async event which allows gondel plugins to add features to gondel\n */\nexport function fireAsyncGondelPluginEvent(eventName, initialValue, data) {\n    return new Promise(function (resolve) {\n        (pluginEvents[eventName] || basePluginListener)(initialValue, data, function (result) {\n            resolve(result);\n        });\n    });\n}\n/**\n * Allow plugins to hook into the gondel event system\n */\nexport function addGondelPluginEventListener(eventName, eventListenerCallback) {\n    if (!pluginEvents[eventName]) {\n        pluginEvents[eventName] = basePluginListener;\n    }\n    var previousEventHandler = pluginEvents[eventName];\n    pluginEvents[eventName] = function wrapCallback(result, data, next) {\n        previousEventHandler(result, data, function callNextPlugin(modifiedResult, _, firstNext) {\n            eventListenerCallback(modifiedResult, data, function bindData(result) {\n                next(result, data, firstNext);\n            });\n        });\n    };\n}\n//# sourceMappingURL=GondelPluginUtils.js.map","import { fireGondelPluginEvent } from \"./GondelPluginUtils\";\nvar GondelComponentRegistry = /** @class */ (function () {\n    function GondelComponentRegistry() {\n        this._components = {};\n        this._activeComponents = {};\n    }\n    GondelComponentRegistry.prototype.registerComponent = function (name, gondelComponent) {\n        this._components[name] = gondelComponent;\n    };\n    GondelComponentRegistry.prototype.unregisterComponent = function (name) {\n        delete this._components[name];\n    };\n    GondelComponentRegistry.prototype.getComponent = function (name) {\n        return this._components[name];\n    };\n    /**\n     * Set if a component is used\n     */\n    GondelComponentRegistry.prototype.setActiveState = function (name, isActive) {\n        this._activeComponents[name] = isActive;\n    };\n    return GondelComponentRegistry;\n}());\nexport { GondelComponentRegistry };\nexport var componentRegistries = (window.__gondelRegistries = window.__gondelRegistries || {});\nexport function registerComponent() {\n    var args = arguments;\n    // The componentName is always the first argument\n    var componentName = args[0];\n    // Use namespace from the second argument or fallback to the default \"g\" if it is missing\n    var namespace = typeof args[1] === \"string\" ? args[1] : \"g\";\n    // The last argument is always the component class\n    var component = args[args.length - 1];\n    if (!componentRegistries[namespace]) {\n        componentRegistries[namespace] = new GondelComponentRegistry();\n    }\n    // If this component was already registered we remove the previous one\n    // and notify all plugins - this is especially usefull for hot component replacement\n    if (componentRegistries[namespace].getComponent(componentName)) {\n        fireGondelPluginEvent(\"unregister\", component, { componentName: componentName, namespace: namespace });\n    }\n    // Let plugins know about the new component\n    fireGondelPluginEvent(\"register\", component, {\n        componentName: componentName,\n        namespace: namespace,\n        gondelComponentRegistry: componentRegistries[namespace]\n    }, function (component) {\n        componentRegistries[namespace].registerComponent(componentName, component);\n    });\n}\n//# sourceMappingURL=GondelComponentRegistry.js.map","import { componentRegistries } from \"./GondelComponentRegistry\";\nimport { startComponentsFromRegistry } from \"./GondelComponentStarter\";\nexport var internalGondelRefAttribute = \"_gondel_\";\nexport var internalGondelAsyncRefAttribute = \"_gondelA_\";\n/**\n * Returns true if the given object is a single Element\n */\nfunction isElement(domNode) {\n    return domNode.nodeType !== undefined;\n}\n/**\n * This function normalizes takes one of the following:\n *  + document query result\n *  + dom node array\n *  + jquery object\n *  + a single dom node\n * and turns it into a single dom node\n */\nexport function getFirstDomNode(domNode) {\n    if (isElement(domNode)) {\n        return domNode;\n    }\n    return domNode[0];\n}\n/**\n * Start all nodes in the given context\n */\nexport function startComponents(domContext, namespace) {\n    if (namespace === void 0) { namespace = \"g\"; }\n    if (!componentRegistries[namespace]) {\n        return Promise.resolve([]);\n    }\n    var registry = componentRegistries[namespace];\n    return startComponentsFromRegistry(registry, domContext ? getFirstDomNode(domContext) : document.documentElement, namespace);\n}\n/**\n * Stop all nodes in the given context\n */\nexport function stopComponents(domContext, namespace) {\n    if (namespace === void 0) { namespace = \"g\"; }\n    var components = findComponents(domContext, undefined, namespace);\n    var rootComponent = domContext && getComponentByDomNode(domContext);\n    if (rootComponent) {\n        components.unshift(rootComponent);\n    }\n    components.forEach(function (component) { return component.stop(); });\n}\n/**\n * Returns the gondel instance for the given HtmlELement\n */\nexport function getComponentByDomNode(domNode, namespace) {\n    if (namespace === void 0) { namespace = \"g\"; }\n    var firstNode = getFirstDomNode(domNode);\n    var gondelComponent = firstNode[internalGondelRefAttribute + namespace];\n    // Stop if this dom node is not known to gondel\n    if (gondelComponent && gondelComponent._ctx) {\n        return gondelComponent;\n    }\n    return;\n}\n/**\n * Returns the gondel instance for the given HtmlELement once it is booted\n */\nexport function getComponentByDomNodeAsync(domNode, namespace) {\n    if (namespace === void 0) { namespace = \"g\"; }\n    var firstNode = getFirstDomNode(domNode);\n    var gondelComponent = firstNode[internalGondelAsyncRefAttribute + namespace];\n    // Stop if this dom node is not known to gondel\n    if (!gondelComponent) {\n        return Promise.reject(undefined);\n    }\n    // or the component is already booted up return it\n    if (gondelComponent._ctx) {\n        return Promise.resolve(gondelComponent);\n    }\n    // Wait the component to boot up and return it\n    return gondelComponent.then(function () { return firstNode[internalGondelRefAttribute + namespace]; });\n}\n/**\n * Returns all components inside the given node\n */\nexport function findComponents(domNode, componentName, namespace) {\n    if (domNode === void 0) { domNode = document.documentElement; }\n    if (namespace === void 0) { namespace = \"g\"; }\n    var firstNode = getFirstDomNode(domNode);\n    var components = [];\n    var attribute = \"_gondel_\" + namespace;\n    var nodes = firstNode.querySelectorAll(\"[data-\" + namespace + \"-name\" + (componentName ? \"=\\\"\" + componentName + \"\\\"\" : \"\") + \"]\");\n    for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var gondelComponentInstance = node[attribute];\n        // Verify that the component is fully booted\n        if (gondelComponentInstance && gondelComponentInstance._ctx === node) {\n            components.push(gondelComponentInstance);\n        }\n    }\n    return components;\n}\n//# sourceMappingURL=GondelDomUtils.js.map","/**\n * The event registry provides a way to bind events ahead of time\n * with a very small foot print during launch to improve the time to interaction\n */\nimport { getComponentByDomNode } from \"./GondelDomUtils\";\nimport { fireGondelPluginEvent } from \"./GondelPluginUtils\";\n/**\n * Only real browser events are supported.\n * Unfortunately focus and blur do not bubble so a special mapping is needed.\n */\nvar eventNameMapping = {\n    focus: \"focusin\",\n    blur: \"focusout\"\n};\nvar domEventRegistry = window.__gondelDomEvents || {};\nwindow.__gondelDomEvents = domEventRegistry;\n/* istanbul ignore next : Browser polyfill can't be tested */\nvar matches = Element.prototype.matches ||\n    Element.prototype.matchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.oMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\nfunction getParentElements(startElement) {\n    var nodes = [];\n    for (var element = startElement; element; element = element.parentElement) {\n        nodes.push(element);\n    }\n    return nodes;\n}\n/**\n * Returns an array of all handlers which would apply for the current target\n */\nexport function getHandlers(attributeName, eventHandlerRegistry, target) {\n    var parents = getParentElements(target);\n    // Find all selectors which have been registred for this event type\n    // and which have a gondel component in one of the parrent nodes\n    var selectorsOfFoundComponents = [];\n    parents.forEach(function (parent, i) {\n        var componentName = parent.getAttribute(attributeName);\n        var handlers = componentName && eventHandlerRegistry[componentName];\n        if (handlers) {\n            // Store the index where the component was found to know in which part\n            // of the dom tree the selectors could be found\n            selectorsOfFoundComponents.push({ index: i, handlers: handlers });\n        }\n    });\n    // Iterate over all possible selectors to find out if the current event\n    // should fire any gondel handler\n    var handlerQueue = [];\n    selectorsOfFoundComponents.forEach(function (_a) {\n        var index = _a.index, handlers = _a.handlers;\n        var selectorNames = Object.keys(handlers);\n        selectorNames.forEach(function (selectorName) {\n            // If no selector is given the handler does always match\n            if (!selectorName) {\n                return handlerQueue.push({\n                    index: index,\n                    ctx: parents[index],\n                    handlerOptions: handlers[selectorName]\n                });\n            }\n            // Iterate backwards over the children of the component to find an element\n            // which matches the selector for the current handler\n            for (var i = index; --i >= 0;) {\n                if (matches.call(parents[i], selectorName)) {\n                    return handlerQueue.push({\n                        index: i,\n                        ctx: parents[index],\n                        handlerOptions: handlers[selectorName]\n                    });\n                }\n            }\n        });\n    });\n    // Break if we couldn't find any matching element\n    if (handlerQueue.length === 0) {\n        return [];\n    }\n    // Sort the queue so events which are further up the dom are fired first\n    handlerQueue.sort(function (handlerA, handlerB) {\n        return handlerA.index > handlerB.index ? 1 : handlerA.index === handlerB.index ? 0 : -1;\n    });\n    return handlerQueue;\n}\n/**\n * The handler which will catch every event at the documentElement\n */\nfunction handleEvent(namespace, attributeName, eventHandlerRegistry, event) {\n    var target = event.target;\n    var handlers = getHandlers(attributeName, eventHandlerRegistry, target);\n    executeHandlers(handlers, event, namespace);\n}\n/**\n * Returns the namespace registry for the given namespace..\n * This function must be used only by core or plugins\n */\nexport function getEventRegistry(namespace) {\n    if (!domEventRegistry[namespace]) {\n        domEventRegistry[namespace] = {};\n    }\n    return domEventRegistry[namespace];\n}\n/**\n * Notify components\n * This function must be used by core or only by plugins\n */\nexport function executeHandlers(handlers, event, namespace) {\n    var results = [];\n    for (var i = 0; i < handlers.length && !event.cancelBubble; i++) {\n        var handlerObject = handlers[i];\n        var handlerOptions = handlerObject.handlerOptions;\n        var gondelComponent = getComponentByDomNode(handlerObject.ctx, namespace);\n        // Skip if the component wasn't started or if it was stopped\n        if (gondelComponent) {\n            for (var j = 0; j < handlerOptions.length && !event.cancelBubble; j++) {\n                var handlerResult = gondelComponent[handlerOptions[j].handlerName].call(gondelComponent, event);\n                if (typeof handlerResult === \"function\") {\n                    results.push(handlerResult);\n                }\n            }\n        }\n    }\n    // Execute all callbacks to allow grouping write events\n    results.forEach(function (result) {\n        result();\n    });\n}\n/**\n * Add a event lister to the <html> element\n * The listener will always call handleEvent with the domEventRegistry for the given event\n */\nfunction startListeningForEvent(eventName, namespace) {\n    document.documentElement.addEventListener(eventNameMapping[eventName] || eventName, handleEvent.bind(null, namespace, \"data-\" + namespace + \"-name\", domEventRegistry[namespace][eventName]));\n}\n/**\n * Add an event to the Gondel EventRegistry\n */\nexport function addRootEventListener(namespace, domEventName, gondelComponentName, handlerName, handlerOption) {\n    // Create namespace if neededi\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\n    // Notify all plugins to allow taking over the event handling for a specific event name\n    // This notification is only triggered if a event name e.g. 'click' is used for the first time\n    if (!namespacedDomEventRegistry[domEventName]) {\n        namespacedDomEventRegistry[domEventName] = {};\n        fireGondelPluginEvent(\"registerEvent\", true, {\n            eventName: domEventName,\n            namespace: namespace,\n            eventRegistry: namespacedDomEventRegistry[domEventName]\n        }, function (isNativeEvent) {\n            // If no plugin registered the event\n            // register a native browser event\n            if (isNativeEvent) {\n                startListeningForEvent(domEventName, namespace);\n            }\n        });\n    }\n    if (!namespacedDomEventRegistry[domEventName][gondelComponentName]) {\n        namespacedDomEventRegistry[domEventName][gondelComponentName] = {};\n    }\n    var handlerOptionObject = typeof handlerOption === \"object\" ? handlerOption : { selector: handlerOption };\n    var selectorKey = handlerOptionObject.selector || \"\";\n    if (!namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey]) {\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey] = [];\n    }\n    namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey].push(Object.assign({ handlerName: handlerName, handlerOption: handlerOption }));\n}\n/**\n * Remove an event from the Gondel EventRegistry\n */\nexport function removeRootEventListener(namespace, domEventName, gondelComponentName, handlerName, selector) {\n    var selectorKey = selector || \"\";\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\n    if (namespacedDomEventRegistry[domEventName] &&\n        namespacedDomEventRegistry[domEventName][gondelComponentName] &&\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey]) {\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey] = namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey].filter(function (handlerOption) {\n            return handlerOption.handlerName !== handlerName || handlerName === undefined;\n        });\n    }\n}\n/**\n * Remove all events for a given Component (e.g. a Button) from the Gondel EventRegistry\n */\nexport function removeRootEventListernerForComponent(namespace, gondelComponentName) {\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\n    for (var eventName in namespacedDomEventRegistry) {\n        /* istanbul ignore else: for in savety check */\n        if (namespacedDomEventRegistry.hasOwnProperty(eventName)) {\n            delete namespacedDomEventRegistry[eventName][gondelComponentName];\n        }\n    }\n}\n//# sourceMappingURL=GondelEventRegistry.js.map","/**\n * This is a demo plugin which adds custom events\n */\nimport { addGondelPluginEventListener, getComponentByDomNode } from \"@gondel/core\";\nimport { getHandlers, executeHandlers } from \"@gondel/core/dist/GondelEventRegistry\";\n/**\n * This function returns all components for the given eventRegistry which can be found in the dom.\n */\nfunction getComponentsInEventRegistry(eventRegistry, namespace) {\n    var selector = Object.keys(eventRegistry)\n        .map(function (componentName) { return \"[data-\" + namespace + \"-name=\\\"\" + componentName + \"\\\"]\"; })\n        .join(\",\");\n    if (!selector) {\n        return [];\n    }\n    var componentElements = document.documentElement.querySelectorAll(selector);\n    var components = [];\n    for (var i = 0; i < componentElements.length; i++) {\n        var component = getComponentByDomNode(componentElements[i], namespace);\n        if (component) {\n            components.push(component);\n        }\n    }\n    return components;\n}\nvar customEvents = {\n    /**\n     * Add @EventListener('resize')\n     *\n     * This will allow components to listen for throttled window resize events\n     * The resize event will only be fired for a component if the width or the height of the component changed\n     */\n    resize: function (eventRegistry, namespace) {\n        var isRunning = false;\n        var frameIsRequested = false;\n        var resizeDoneTimer;\n        var componentInformation;\n        /**\n         * This handler is called if a new resize event happens.\n         * A resize event is new if no resize occured for 250ms\n         */\n        function startResizeWatching(event) {\n            var components = getComponentsInEventRegistry(eventRegistry, namespace);\n            isRunning = true;\n            // The resize listener is fired very often\n            // for performance optimisations we search and store\n            // all components during the initial start event\n            componentInformation = components.map(function (component) {\n                var size = component.__resizeSize || {\n                    width: 0,\n                    height: 0\n                };\n                var gondelComponentHandlers = eventRegistry[component._componentName];\n                return {\n                    component: component,\n                    node: component._ctx,\n                    selectors: Object.keys(gondelComponentHandlers).map(function (selector) {\n                        return gondelComponentHandlers[selector].map(function (handlerOption) { return component[handlerOption.handlerName]; });\n                    }),\n                    width: size.width,\n                    height: size.height\n                };\n            });\n            fireResizeEvent(event);\n        }\n        /**\n         * Clean up after no resize event happened for 250ms\n         */\n        function stopResizeWatching() {\n            // If there is still a throttled resize handler\n            // wait until it is done\n            if (frameIsRequested) {\n                requestAnimationFrame(stopResizeWatching);\n                return;\n            }\n            // Memory cleanup\n            isRunning = false;\n            componentInformation = undefined;\n        }\n        /**\n         * Check which modules changed in size an call their event handler\n         */\n        function fireResizeEvent(event) {\n            frameIsRequested = false;\n            if (!componentInformation) {\n                return;\n            }\n            var newSizes = componentInformation.map(function (_a) {\n                var node = _a.node;\n                return ({\n                    width: node.clientWidth,\n                    height: node.clientHeight\n                });\n            });\n            var handlerResults = [];\n            componentInformation.forEach(function (componentInformation, i) {\n                var newSize = newSizes[i];\n                // Skip if the size did not change\n                if (newSize.width === componentInformation.width &&\n                    newSize.height === componentInformation.height) {\n                    return;\n                }\n                // Skip if the component is not running anymore\n                if (componentInformation.component._stopped) {\n                    return;\n                }\n                componentInformation.component.__resizeSize = newSize;\n                componentInformation.width = newSize.width;\n                componentInformation.height = newSize.height;\n                componentInformation.selectors.forEach(function (selector) {\n                    return selector.forEach(function (handler) {\n                        return handlerResults.push(handler.call(componentInformation.component, event, newSize));\n                    });\n                });\n            });\n            handlerResults.forEach(function (handlerResult) {\n                if (typeof handlerResult === \"function\") {\n                    handlerResult();\n                }\n            });\n        }\n        window.addEventListener(\"resize\", function (event) {\n            if (!isRunning) {\n                startResizeWatching(event);\n            }\n            else if (!frameIsRequested) {\n                frameIsRequested = true;\n                window.requestAnimationFrame(fireResizeEvent.bind(event));\n            }\n            clearTimeout(resizeDoneTimer);\n            resizeDoneTimer = setTimeout(stopResizeWatching, 250);\n        });\n    },\n    /**\n     * Add @EventListener('key')\n     * Add @EventListener('key', 'Escape')\n     *\n     * This will allow components to listen for global key press events\n     * For a full list of possible keys see:\n     * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n     */\n    key: function (eventRegistry, namespace) {\n        window.addEventListener(\"keydown\", function (event) {\n            var components = getComponentsInEventRegistry(eventRegistry, namespace);\n            var handlerResults = [];\n            components.forEach(function (component) {\n                var gondelComponentHandlers = Object.keys(eventRegistry[component._componentName]).forEach(function (selector) {\n                    if (selector === \"\" || event.key === selector) {\n                        eventRegistry[component._componentName][selector].forEach(function (handlerOption) {\n                            handlerResults.push(component[handlerOption.handlerName].call(component, event));\n                        });\n                    }\n                });\n            });\n            handlerResults.forEach(function (handlerResult) {\n                if (typeof handlerResult === \"function\") {\n                    handlerResult();\n                }\n            });\n        });\n    },\n    /**\n     * Add @EventListener('swipe-left')\n     *\n     * This will allow components to listen for mouse swipe events\n     */\n    \"swipe-left\": function (eventRegistry, namespace) {\n        document.documentElement.addEventListener(\"mousedown\", function (mouseDownEvent) {\n            var handlers = getHandlers(\"data-\" + namespace + \"-name\", eventRegistry, mouseDownEvent.target);\n            var latestMouseMoveEvent;\n            var frameListernerId;\n            if (handlers.length === 0) {\n                return;\n            }\n            mouseDownEvent.preventDefault();\n            function handleMouseMove(mouseMoveEvent) {\n                latestMouseMoveEvent = mouseMoveEvent;\n                mouseMoveEvent.preventDefault();\n                if (!frameListernerId) {\n                    frameListernerId = requestAnimationFrame(handleMouseMoveThrottled);\n                }\n            }\n            function handleMouseMoveThrottled() {\n                frameListernerId = undefined;\n                var deltaX = latestMouseMoveEvent.x - mouseDownEvent.x;\n                if (deltaX < -100) {\n                    executeHandlers(handlers, latestMouseMoveEvent, namespace);\n                    stopMouseMoveTracking();\n                }\n            }\n            function stopMouseMoveTracking() {\n                document.documentElement.removeEventListener(\"mousemove\", handleMouseMove);\n                document.documentElement.removeEventListener(\"mouseup\", handleMouseUp);\n                if (frameListernerId) {\n                    cancelAnimationFrame(frameListernerId);\n                }\n            }\n            function handleMouseUp(mouseMoveUpEvent) {\n                mouseMoveUpEvent.preventDefault();\n                stopMouseMoveTracking();\n            }\n            document.documentElement.addEventListener(\"mousemove\", handleMouseMove);\n            document.documentElement.addEventListener(\"mouseup\", handleMouseUp);\n        });\n    },\n    /**\n     * Add @EventListener('swipe-right')\n     *\n     * This will allow components to listen for mouse swipe events\n     */\n    \"swipe-right\": function (eventRegistry, namespace) {\n        document.documentElement.addEventListener(\"mousedown\", function (mouseDownEvent) {\n            var handlers = getHandlers(\"data-\" + namespace + \"-name\", eventRegistry, mouseDownEvent.target);\n            var latestMouseMoveEvent;\n            var frameListernerId;\n            if (handlers.length === 0) {\n                return;\n            }\n            mouseDownEvent.preventDefault();\n            function handleMouseMove(mouseMoveEvent) {\n                latestMouseMoveEvent = mouseMoveEvent;\n                mouseMoveEvent.preventDefault();\n                if (!frameListernerId) {\n                    frameListernerId = requestAnimationFrame(handleMouseMoveThrottled);\n                }\n            }\n            function handleMouseMoveThrottled() {\n                frameListernerId = undefined;\n                var deltaX = latestMouseMoveEvent.x - mouseDownEvent.x;\n                if (deltaX > 100) {\n                    executeHandlers(handlers, latestMouseMoveEvent, namespace);\n                    stopMouseMoveTracking();\n                }\n            }\n            function stopMouseMoveTracking() {\n                document.documentElement.removeEventListener(\"mousemove\", handleMouseMove);\n                document.documentElement.removeEventListener(\"mouseup\", handleMouseUp);\n                if (frameListernerId) {\n                    cancelAnimationFrame(frameListernerId);\n                }\n            }\n            function handleMouseUp(mouseMoveUpEvent) {\n                mouseMoveUpEvent.preventDefault();\n                stopMouseMoveTracking();\n            }\n            document.documentElement.addEventListener(\"mousemove\", handleMouseMove);\n            document.documentElement.addEventListener(\"mouseup\", handleMouseUp);\n        });\n    }\n};\nexport function initEventPlugin() {\n    addGondelPluginEventListener(\"registerEvent\", function addResizeEvent(isNativeEvent, _a, resolve) {\n        var eventName = _a.eventName, namespace = _a.namespace, eventRegistry = _a.eventRegistry;\n        if (customEvents[eventName]) {\n            customEvents[eventName](eventRegistry, namespace);\n            // Tell the event system that it should not listen for the event:\n            resolve(false);\n        }\n        else {\n            resolve(isNativeEvent);\n        }\n    });\n    addGondelPluginEventListener(\"sync\", function addResizeEvent(components, data, resolve) {\n        setTimeout(function () {\n            components.forEach(function (component) {\n                component.__resizeSize = {\n                    width: component._ctx.clientWidth,\n                    height: component._ctx.clientHeight\n                };\n            });\n        });\n        resolve(components);\n    });\n}\n//# sourceMappingURL=index.js.map"],"names":["basePluginListener","result","data","next","pluginEvents","window","__gondelPluginEvents","addGondelPluginEventListener","eventName","eventListenerCallback","previousEventHandler","modifiedResult","_","firstNext","__gondelRegistries","internalGondelRefAttribute","getComponentByDomNode","domNode","namespace","gondelComponent","undefined","nodeType","_ctx","domEventRegistry","__gondelDomEvents","matches","Element","prototype","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","getHandlers","attributeName","eventHandlerRegistry","target","parents","startElement","nodes","element","parentElement","push","getParentElements","selectorsOfFoundComponents","forEach","parent","i","componentName","getAttribute","handlers","index","handlerQueue","_a","Object","keys","selectorName","ctx","handlerOptions","call","length","sort","handlerA","handlerB","executeHandlers","event","results","cancelBubble","handlerObject","j","handlerResult","handlerName","getComponentsInEventRegistry","eventRegistry","selector","map","join","componentElements","document","documentElement","querySelectorAll","components","component","customEvents","resize","resizeDoneTimer","componentInformation","isRunning","frameIsRequested","stopResizeWatching","requestAnimationFrame","fireResizeEvent","newSizes","node","width","clientWidth","height","clientHeight","handlerResults","newSize","_stopped","__resizeSize","selectors","handler","addEventListener","bind","size","gondelComponentHandlers","_componentName","handlerOption","clearTimeout","setTimeout","key","swipe-left","mouseDownEvent","latestMouseMoveEvent","frameListernerId","handleMouseMove","mouseMoveEvent","preventDefault","handleMouseMoveThrottled","x","stopMouseMoveTracking","removeEventListener","handleMouseUp","cancelAnimationFrame","mouseMoveUpEvent","swipe-right","isNativeEvent","resolve"],"mappings":"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"}