{"version":3,"file":"index.es5.js","sources":["../../../core/dist/GondelPluginUtils.js","../../../core/dist/GondelDomUtils.js","../../../core/dist/GondelEventRegistry.js","index.js"],"sourcesContent":["var basePluginListener = function (result, data, next) { return next(result); };\r\n// Global plugin events registry\r\nvar pluginEventRegistry = window.__gondelPluginEvents || { pluginMapping: {}, pluginEvents: {} };\r\nwindow.__gondelPluginEvents = pluginEventRegistry;\r\n/** Global Plugin Event Handler Registry */\r\nexport var pluginEvents = pluginEventRegistry.pluginEvents;\r\n// Mapping to track if plugin was already registered to prevent double registrations\r\nvar pluginMapping = pluginEventRegistry.pluginMapping;\r\nexport function fireGondelPluginEvent(eventName, initialValue, data, callback) {\r\n    var isSyncron = false;\r\n    var callbackResult;\r\n    // Execute all bound events for the given name\r\n    // if they exist\r\n    (pluginEvents[eventName] || basePluginListener)(initialValue, data, function (processedResult) {\r\n        isSyncron = true;\r\n        callbackResult = callback ? callback(processedResult) : processedResult;\r\n    });\r\n    // Add a guard to prevent asyncron plugin listeners\r\n    // to simplify the usage of fireGondelPluginEvent\r\n    if (!isSyncron) {\r\n        throw new Error('Async plugin listener');\r\n    }\r\n    return callbackResult;\r\n}\r\n/**\r\n * Fire an async event which allows gondel plugins to add features to gondel\r\n */\r\nexport function fireAsyncGondelPluginEvent(eventName, initialValue, data) {\r\n    return new Promise(function (resolve) {\r\n        (pluginEvents[eventName] || basePluginListener)(initialValue, data, function (result) {\r\n            resolve(result);\r\n        });\r\n    });\r\n}\r\n/**\r\n * Allow plugins to hook into the gondel event system\r\n */\r\nexport function addGondelPluginEventListener(pluginName, eventName, eventListenerCallback) {\r\n    // Prevent any event registration if this pluginHandlerName\r\n    // has already been used\r\n    var pluginHandlerNamePerEvent = eventName + \"#\" + pluginName;\r\n    if (pluginMapping[pluginHandlerNamePerEvent]) {\r\n        return;\r\n    }\r\n    // Flag plugin as registered\r\n    pluginMapping[pluginHandlerNamePerEvent] = true;\r\n    // Ensure that an entry for the given event name exists\r\n    if (!pluginEvents[eventName]) {\r\n        pluginEvents[eventName] = basePluginListener;\r\n    }\r\n    var previousEventHandler = pluginEvents[eventName];\r\n    pluginEvents[eventName] = function wrapCallback(result, data, next) {\r\n        previousEventHandler(result, data, function callNextPlugin(modifiedResult, _, firstNext) {\r\n            eventListenerCallback(modifiedResult, data, function bindData(result) {\r\n                next(result, data, firstNext);\r\n            });\r\n        });\r\n    };\r\n}\r\n//# sourceMappingURL=GondelPluginUtils.js.map","import { getComponentRegistry } from './GondelComponentRegistry';\r\nimport { startComponentsFromRegistry } from './GondelComponentStarter';\r\nexport var internalGondelRefAttribute = '_gondel_';\r\nexport var internalGondelAsyncRefAttribute = '_gondelA_';\r\n/**\r\n * Returns true if the given object is a single Element\r\n */\r\nfunction isElement(domNode) {\r\n    return domNode.nodeType !== undefined;\r\n}\r\n/**\r\n * This function normalizes takes one of the following:\r\n *  + document query result\r\n *  + dom node array\r\n *  + jquery object\r\n *  + a single dom node\r\n * and turns it into a single dom node\r\n */\r\nexport function getFirstDomNode(domNode) {\r\n    if (isElement(domNode)) {\r\n        return domNode;\r\n    }\r\n    return domNode[0];\r\n}\r\n/**\r\n * Start all nodes in the given context\r\n */\r\nexport function startComponents(domContext, namespace) {\r\n    if (namespace === void 0) { namespace = 'g'; }\r\n    var registry = getComponentRegistry(namespace);\r\n    return startComponentsFromRegistry(registry, domContext ? getFirstDomNode(domContext) : document.documentElement, namespace);\r\n}\r\n/**\r\n * Stop all nodes in the given context\r\n */\r\nexport function stopComponents(domContext, namespace) {\r\n    if (namespace === void 0) { namespace = 'g'; }\r\n    var components = findComponents(domContext, undefined, namespace);\r\n    if (domContext && hasMountedGondelComponent(domContext)) {\r\n        components.unshift(getComponentByDomNode(domContext));\r\n    }\r\n    components.forEach(function (component) { return component.stop(); });\r\n}\r\n/**\r\n * Checks if a component is mounted on a certain DOM node\r\n */\r\nexport function hasMountedGondelComponent(domNode, namespace) {\r\n    if (namespace === void 0) { namespace = 'g'; }\r\n    var firstNode = getFirstDomNode(domNode);\r\n    var gondelComponent = firstNode[internalGondelRefAttribute + namespace];\r\n    if (!gondelComponent || !gondelComponent._ctx) {\r\n        // no anchor prop found or ctx missing. function is needed\r\n        // that we can type the `getComponentByDomNode` without possible\r\n        // returnal of undefined.\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Returns the gondel instance for the given HtmlELement\r\n */\r\nexport function getComponentByDomNode(domNode, namespace) {\r\n    if (namespace === void 0) { namespace = 'g'; }\r\n    var gondelComponent = extractComponent(getFirstDomNode(domNode), namespace);\r\n    if (!gondelComponent) {\r\n        throw new Error(\"Could not find a started gondel component in namespace \\\"\" + namespace + \"\\\",\\nplease check if your component is mounted via 'hasMountedGondelComponent'\");\r\n    }\r\n    return gondelComponent;\r\n}\r\n/**\r\n * Internal helper function of getComponentByDomNode\r\n *\r\n * Returns the gondel instance from a known HtmlElement\r\n * This function is an internal helper with a possible undefined\r\n * return value.\r\n */\r\nexport function extractComponent(element, namespace) {\r\n    var gondelComponent = element[internalGondelRefAttribute + namespace];\r\n    // Stop if this dom node is not known to gondel\r\n    if (gondelComponent && gondelComponent._ctx) {\r\n        return gondelComponent;\r\n    }\r\n}\r\n/**\r\n * Returns the gondel instance for the given HtmlELement once it is booted\r\n */\r\nexport function getComponentByDomNodeAsync(domNode, namespace) {\r\n    if (namespace === void 0) { namespace = 'g'; }\r\n    var firstNode = getFirstDomNode(domNode);\r\n    var gondelComponent = firstNode[internalGondelAsyncRefAttribute + namespace];\r\n    // Stop if this dom node is not known to gondel\r\n    if (!gondelComponent) {\r\n        return Promise.reject(undefined);\r\n    }\r\n    // or the component is already booted up return it\r\n    if (gondelComponent._ctx) {\r\n        return Promise.resolve(gondelComponent);\r\n    }\r\n    // Wait the component to boot up and return it\r\n    return gondelComponent.then(function () { return firstNode[internalGondelRefAttribute + namespace]; });\r\n}\r\n/**\r\n * Returns all components inside the given node\r\n */\r\nexport function findComponents(domNode, componentName, namespace) {\r\n    if (domNode === void 0) { domNode = document.documentElement; }\r\n    if (namespace === void 0) { namespace = 'g'; }\r\n    var firstNode = getFirstDomNode(domNode);\r\n    var components = [];\r\n    var attribute = \"_gondel_\" + namespace;\r\n    var nodes = firstNode.querySelectorAll(\"[data-\" + namespace + \"-name\" + (componentName ? \"=\\\"\" + componentName + \"\\\"\" : '') + \"]\");\r\n    for (var i = 0; i < nodes.length; i++) {\r\n        var node = nodes[i];\r\n        var gondelComponentInstance = node[attribute];\r\n        // Verify that the component is fully booted\r\n        if (gondelComponentInstance && gondelComponentInstance._ctx === node) {\r\n            components.push(gondelComponentInstance);\r\n        }\r\n    }\r\n    return components;\r\n}\r\n//# sourceMappingURL=GondelDomUtils.js.map","/**\r\n * The event registry provides a way to bind events ahead of time\r\n * with a very small foot print during launch to improve the time to interaction\r\n */\r\nimport { extractComponent } from './GondelDomUtils';\r\nimport { fireGondelPluginEvent } from './GondelPluginUtils';\r\n/**\r\n * Only real browser events are supported.\r\n * Unfortunately focus and blur do not bubble so a special mapping is needed.\r\n */\r\nvar eventNameMapping = {\r\n    focus: 'focusin',\r\n    blur: 'focusout',\r\n};\r\n// Polyfill for element.prototype.matches\r\nvar matchesCssSelector = function (element, selector) {\r\n    var elementPrototype = window.Element.prototype;\r\n    /* istanbul ignore next : Browser polyfill can't be tested */\r\n    var elementMatches = elementPrototype.matches ||\r\n        elementPrototype.matchesSelector ||\r\n        elementPrototype.mozMatchesSelector ||\r\n        elementPrototype.msMatchesSelector ||\r\n        elementPrototype.webkitMatchesSelector;\r\n    // Cache the function and call it\r\n    return (matchesCssSelector = function (element, selector) {\r\n        return elementMatches.call(element, selector);\r\n    })(element, selector);\r\n};\r\nfunction getParentElements(startElement) {\r\n    var nodes = [];\r\n    for (var element = startElement; element; element = element.parentElement) {\r\n        nodes.push(element);\r\n    }\r\n    return nodes;\r\n}\r\n/**\r\n * Returns an array of all handlers which would apply for the current target\r\n */\r\nexport function getHandlers(attributeName, eventHandlerRegistry, target) {\r\n    var parents = getParentElements(target);\r\n    // Find all selectors which have been registred for this event type\r\n    // and which have a gondel component in one of the parrent nodes\r\n    var selectorsOfFoundComponents = [];\r\n    parents.forEach(function (parent, i) {\r\n        var componentName = parent.getAttribute(attributeName);\r\n        var handlers = componentName && eventHandlerRegistry[componentName];\r\n        if (handlers) {\r\n            // Store the index where the component was found to know in which part\r\n            // of the dom tree the selectors could be found\r\n            selectorsOfFoundComponents.push({ index: i, handlers: handlers });\r\n        }\r\n    });\r\n    // Iterate over all possible selectors to find out if the current event\r\n    // should fire any gondel handler\r\n    var handlerQueue = [];\r\n    selectorsOfFoundComponents.forEach(function (_a) {\r\n        var index = _a.index, handlers = _a.handlers;\r\n        var selectorNames = Object.keys(handlers);\r\n        selectorNames.forEach(function (selectorName) {\r\n            // If no selector is given the handler does always match\r\n            if (!selectorName) {\r\n                return handlerQueue.push({\r\n                    index: index,\r\n                    ctx: parents[index],\r\n                    target: parents[index],\r\n                    handlerOptions: handlers[selectorName],\r\n                });\r\n            }\r\n            // Iterate backwards over the children of the component to find an element\r\n            // which matches the selector for the current handler\r\n            for (var i = index; --i >= 0;) {\r\n                if (matchesCssSelector(parents[i], selectorName)) {\r\n                    return handlerQueue.push({\r\n                        index: i,\r\n                        ctx: parents[index],\r\n                        target: parents[i],\r\n                        handlerOptions: handlers[selectorName],\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    });\r\n    // Break if we couldn't find any matching element\r\n    if (handlerQueue.length === 0) {\r\n        return [];\r\n    }\r\n    // Sort the queue so events which are further up the dom are fired first\r\n    handlerQueue.sort(function (handlerA, handlerB) {\r\n        return handlerA.index > handlerB.index ? 1 : handlerA.index === handlerB.index ? 0 : -1;\r\n    });\r\n    return handlerQueue;\r\n}\r\n/**\r\n * The handler which will catch every event at the documentElement\r\n */\r\nfunction handleEvent(namespace, attributeName, eventHandlerRegistry, event) {\r\n    var target = event.target;\r\n    var handlers = getHandlers(attributeName, eventHandlerRegistry, target);\r\n    executeHandlers(handlers, event, namespace);\r\n}\r\nvar _domEventRegistry;\r\n/**\r\n * Returns the namespace registry for the given namespace..\r\n * This function must be used only by core or plugins\r\n */\r\nexport function getEventRegistry(namespace) {\r\n    if (!_domEventRegistry) {\r\n        _domEventRegistry = window['__\\ud83d\\udea1DomEvents'] || {};\r\n        window['__\\ud83d\\udea1DomEvents'] = _domEventRegistry;\r\n    }\r\n    if (!_domEventRegistry[namespace]) {\r\n        _domEventRegistry[namespace] = {};\r\n    }\r\n    return _domEventRegistry[namespace];\r\n}\r\n/**\r\n * Notify components\r\n * This function must be used by core or only by plugins\r\n */\r\nexport function executeHandlers(handlers, event, namespace) {\r\n    /** Store wether the original Event was modified to provide the correct currentTarget */\r\n    var eventObjectRequiresCleanup = false;\r\n    /** Store optional callback results which are executed together to allow grouped redraws */\r\n    var results = [];\r\n    var _loop_1 = function (i) {\r\n        var handlerObject = handlers[i];\r\n        var handlerOptions = handlerObject.handlerOptions;\r\n        var gondelComponent = extractComponent(handlerObject.ctx, namespace);\r\n        // Skip if the component wasn't started or if it was stopped\r\n        if (gondelComponent) {\r\n            // See https://stackoverflow.com/questions/52057726/what-is-the-best-way-to-alter-a-native-browser-event\r\n            Object.defineProperty(event, 'currentTarget', {\r\n                get: function () { return handlerObject.target; },\r\n                configurable: true,\r\n            });\r\n            eventObjectRequiresCleanup = true;\r\n            for (var j = 0; j < handlerOptions.length && !event.cancelBubble; j++) {\r\n                var handlerResult = gondelComponent[handlerOptions[j].handlerName].call(gondelComponent, event);\r\n                if (typeof handlerResult === 'function') {\r\n                    results.push(handlerResult);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    for (var i = 0; i < handlers.length && !event.cancelBubble; i++) {\r\n        _loop_1(i);\r\n    }\r\n    // Execute all callbacks to allow grouping write events\r\n    results.forEach(function (result) {\r\n        result();\r\n    });\r\n    // Cleanup the event object\r\n    if (eventObjectRequiresCleanup) {\r\n        // See https://stackoverflow.com/questions/52057726/what-is-the-best-way-to-alter-a-native-browser-event\r\n        delete event.currentTarget;\r\n    }\r\n}\r\n/**\r\n * Add a event lister to the <html> element\r\n * The listener will always call handleEvent with the domEventRegistry for the given event\r\n */\r\nfunction startListeningForEvent(eventName, namespace) {\r\n    document.documentElement.addEventListener(eventNameMapping[eventName] || eventName, handleEvent.bind(null, namespace, \"data-\" + namespace + \"-name\", getEventRegistry(namespace)[eventName]));\r\n}\r\n/**\r\n * Add an event to the Gondel EventRegistry\r\n */\r\nexport function addRootEventListener(namespace, domEventName, gondelComponentName, handlerName, handlerOption) {\r\n    // Create namespace if neededi\r\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\r\n    // Notify all plugins to allow taking over the event handling for a specific event name\r\n    // This notification is only triggered if a event name e.g. 'click' is used for the first time\r\n    if (!namespacedDomEventRegistry[domEventName]) {\r\n        namespacedDomEventRegistry[domEventName] = {};\r\n        fireGondelPluginEvent('registerEvent', true, {\r\n            eventName: domEventName,\r\n            namespace: namespace,\r\n            eventRegistry: namespacedDomEventRegistry[domEventName],\r\n        }, function (isNativeEvent) {\r\n            // If no plugin registered the event\r\n            // register a native browser event\r\n            if (isNativeEvent) {\r\n                startListeningForEvent(domEventName, namespace);\r\n            }\r\n        });\r\n    }\r\n    if (!namespacedDomEventRegistry[domEventName][gondelComponentName]) {\r\n        namespacedDomEventRegistry[domEventName][gondelComponentName] = {};\r\n    }\r\n    var handlerOptionObject = typeof handlerOption === 'object' ? handlerOption : { selector: handlerOption };\r\n    var selectorKey = handlerOptionObject.selector || '';\r\n    if (!namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey]) {\r\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey] = [];\r\n    }\r\n    namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey].push(Object.assign({ handlerName: handlerName, handlerOption: handlerOption }));\r\n}\r\n/**\r\n * Remove an event from the Gondel EventRegistry\r\n */\r\nexport function removeRootEventListener(namespace, domEventName, gondelComponentName, handlerName, selector) {\r\n    var selectorKey = selector || '';\r\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\r\n    if (namespacedDomEventRegistry[domEventName] &&\r\n        namespacedDomEventRegistry[domEventName][gondelComponentName] &&\r\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey]) {\r\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey] = namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey].filter(function (handlerOption) {\r\n            return handlerOption.handlerName !== handlerName || handlerName === undefined;\r\n        });\r\n    }\r\n}\r\n/**\r\n * Remove all events for a given Component (e.g. a Button) from the Gondel EventRegistry\r\n */\r\nexport function removeRootEventListernerForComponent(namespace, gondelComponentName) {\r\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\r\n    for (var eventName in namespacedDomEventRegistry) {\r\n        /* istanbul ignore else: for in savety check */\r\n        if (namespacedDomEventRegistry.hasOwnProperty(eventName)) {\r\n            delete namespacedDomEventRegistry[eventName][gondelComponentName];\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=GondelEventRegistry.js.map","/**\r\n * This is a demo plugin which adds custom events\r\n */\r\nimport { addGondelPluginEventListener, getComponentByDomNode } from '@gondel/core';\r\nimport { getHandlers, executeHandlers } from '@gondel/core/dist/GondelEventRegistry';\r\n/**\r\n * This function returns all components for the given eventRegistry which can be found in the dom.\r\n */\r\nfunction getComponentsInEventRegistry(eventRegistry, namespace) {\r\n    var selector = Object.keys(eventRegistry)\r\n        .map(function (componentName) { return \"[data-\" + namespace + \"-name=\\\"\" + componentName + \"\\\"]\"; })\r\n        .join(',');\r\n    if (!selector) {\r\n        return [];\r\n    }\r\n    var componentElements = document.documentElement.querySelectorAll(selector);\r\n    var components = [];\r\n    for (var i = 0; i < componentElements.length; i++) {\r\n        var component = getComponentByDomNode(componentElements[i], namespace);\r\n        if (component) {\r\n            components.push(component);\r\n        }\r\n    }\r\n    return components;\r\n}\r\nvar customEvents = {\r\n    /**\r\n     * Add @EventListener('resize')\r\n     *\r\n     * This will allow components to listen for throttled window resize events\r\n     * The resize event will only be fired for a component if the width or the height of the component changed\r\n     */\r\n    resize: function (eventRegistry, namespace) {\r\n        var isRunning = false;\r\n        var frameIsRequested = false;\r\n        var resizeDoneTimer;\r\n        var componentInformation;\r\n        /**\r\n         * This handler is called if a new resize event happens.\r\n         * A resize event is new if no resize occured for 250ms\r\n         */\r\n        function startResizeWatching(event) {\r\n            var components = getComponentsInEventRegistry(eventRegistry, namespace);\r\n            isRunning = true;\r\n            // The resize listener is fired very often\r\n            // for performance optimisations we search and store\r\n            // all components during the initial start event\r\n            componentInformation = components.map(function (component) {\r\n                var size = component.__resizeSize || {\r\n                    width: 0,\r\n                    height: 0,\r\n                };\r\n                var gondelComponentHandlers = eventRegistry[component._componentName];\r\n                return {\r\n                    component: component,\r\n                    node: component._ctx,\r\n                    selectors: Object.keys(gondelComponentHandlers).map(function (selector) {\r\n                        return gondelComponentHandlers[selector].map(function (handlerOption) { return component[handlerOption.handlerName]; });\r\n                    }),\r\n                    width: size.width,\r\n                    height: size.height,\r\n                };\r\n            });\r\n            fireResizeEvent(event);\r\n        }\r\n        /**\r\n         * Clean up after no resize event happened for 250ms\r\n         */\r\n        function stopResizeWatching() {\r\n            // If there is still a throttled resize handler\r\n            // wait until it is done\r\n            if (frameIsRequested) {\r\n                requestAnimationFrame(stopResizeWatching);\r\n                return;\r\n            }\r\n            // Memory cleanup\r\n            isRunning = false;\r\n            componentInformation = undefined;\r\n        }\r\n        /**\r\n         * Check which modules changed in size an call their event handler\r\n         */\r\n        function fireResizeEvent(event) {\r\n            frameIsRequested = false;\r\n            if (!componentInformation) {\r\n                return;\r\n            }\r\n            var newSizes = componentInformation.map(function (_a) {\r\n                var node = _a.node;\r\n                return ({\r\n                    width: node.clientWidth,\r\n                    height: node.clientHeight,\r\n                });\r\n            });\r\n            var handlerResults = [];\r\n            componentInformation.forEach(function (componentInformation, i) {\r\n                var newSize = newSizes[i];\r\n                // Skip if the size did not change\r\n                if (newSize.width === componentInformation.width && newSize.height === componentInformation.height) {\r\n                    return;\r\n                }\r\n                // Skip if the component is not running anymore\r\n                if (componentInformation.component._stopped) {\r\n                    return;\r\n                }\r\n                componentInformation.component.__resizeSize = newSize;\r\n                componentInformation.width = newSize.width;\r\n                componentInformation.height = newSize.height;\r\n                componentInformation.selectors.forEach(function (selector) {\r\n                    return selector.forEach(function (handler) {\r\n                        return handlerResults.push(handler.call(componentInformation.component, event, newSize));\r\n                    });\r\n                });\r\n            });\r\n            handlerResults.forEach(function (handlerResult) {\r\n                if (typeof handlerResult === 'function') {\r\n                    handlerResult();\r\n                }\r\n            });\r\n        }\r\n        window.addEventListener('resize', function (event) {\r\n            if (!isRunning) {\r\n                startResizeWatching(event);\r\n            }\r\n            else if (!frameIsRequested) {\r\n                frameIsRequested = true;\r\n                window.requestAnimationFrame(fireResizeEvent.bind(event));\r\n            }\r\n            clearTimeout(resizeDoneTimer);\r\n            resizeDoneTimer = setTimeout(stopResizeWatching, 250);\r\n        });\r\n    },\r\n    /**\r\n     * Add @EventListener('key')\r\n     * Add @EventListener('key', 'Escape')\r\n     *\r\n     * This will allow components to listen for global key press events\r\n     * For a full list of possible keys see:\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n     */\r\n    key: function (eventRegistry, namespace) {\r\n        window.addEventListener('keydown', function (event) {\r\n            var components = getComponentsInEventRegistry(eventRegistry, namespace);\r\n            var handlerResults = [];\r\n            components.forEach(function (component) {\r\n                var gondelComponentHandlers = Object.keys(eventRegistry[component._componentName]).forEach(function (selector) {\r\n                    if (selector === '' || event.key === selector) {\r\n                        eventRegistry[component._componentName][selector].forEach(function (handlerOption) {\r\n                            handlerResults.push(component[handlerOption.handlerName].call(component, event));\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n            handlerResults.forEach(function (handlerResult) {\r\n                if (typeof handlerResult === 'function') {\r\n                    handlerResult();\r\n                }\r\n            });\r\n        });\r\n    },\r\n    /**\r\n     * Add @EventListener('swipe-left')\r\n     *\r\n     * This will allow components to listen for mouse swipe events\r\n     */\r\n    'swipe-left': function (eventRegistry, namespace) {\r\n        document.documentElement.addEventListener('mousedown', function (mouseDownEvent) {\r\n            var handlers = getHandlers(\"data-\" + namespace + \"-name\", eventRegistry, mouseDownEvent.target);\r\n            var latestMouseMoveEvent;\r\n            var frameListernerId;\r\n            if (handlers.length === 0) {\r\n                return;\r\n            }\r\n            mouseDownEvent.preventDefault();\r\n            function handleMouseMove(mouseMoveEvent) {\r\n                latestMouseMoveEvent = mouseMoveEvent;\r\n                mouseMoveEvent.preventDefault();\r\n                if (!frameListernerId) {\r\n                    frameListernerId = requestAnimationFrame(handleMouseMoveThrottled);\r\n                }\r\n            }\r\n            function handleMouseMoveThrottled() {\r\n                frameListernerId = undefined;\r\n                var deltaX = latestMouseMoveEvent.x - mouseDownEvent.x;\r\n                if (deltaX < -100) {\r\n                    executeHandlers(handlers, latestMouseMoveEvent, namespace);\r\n                    stopMouseMoveTracking();\r\n                }\r\n            }\r\n            function stopMouseMoveTracking() {\r\n                document.documentElement.removeEventListener('mousemove', handleMouseMove);\r\n                document.documentElement.removeEventListener('mouseup', handleMouseUp);\r\n                if (frameListernerId) {\r\n                    cancelAnimationFrame(frameListernerId);\r\n                }\r\n            }\r\n            function handleMouseUp(mouseMoveUpEvent) {\r\n                mouseMoveUpEvent.preventDefault();\r\n                stopMouseMoveTracking();\r\n            }\r\n            document.documentElement.addEventListener('mousemove', handleMouseMove);\r\n            document.documentElement.addEventListener('mouseup', handleMouseUp);\r\n        });\r\n    },\r\n    /**\r\n     * Add @EventListener('swipe-right')\r\n     *\r\n     * This will allow components to listen for mouse swipe events\r\n     */\r\n    'swipe-right': function (eventRegistry, namespace) {\r\n        document.documentElement.addEventListener('mousedown', function (mouseDownEvent) {\r\n            var handlers = getHandlers(\"data-\" + namespace + \"-name\", eventRegistry, mouseDownEvent.target);\r\n            var latestMouseMoveEvent;\r\n            var frameListernerId;\r\n            if (handlers.length === 0) {\r\n                return;\r\n            }\r\n            mouseDownEvent.preventDefault();\r\n            function handleMouseMove(mouseMoveEvent) {\r\n                latestMouseMoveEvent = mouseMoveEvent;\r\n                mouseMoveEvent.preventDefault();\r\n                if (!frameListernerId) {\r\n                    frameListernerId = requestAnimationFrame(handleMouseMoveThrottled);\r\n                }\r\n            }\r\n            function handleMouseMoveThrottled() {\r\n                frameListernerId = undefined;\r\n                var deltaX = latestMouseMoveEvent.x - mouseDownEvent.x;\r\n                if (deltaX > 100) {\r\n                    executeHandlers(handlers, latestMouseMoveEvent, namespace);\r\n                    stopMouseMoveTracking();\r\n                }\r\n            }\r\n            function stopMouseMoveTracking() {\r\n                document.documentElement.removeEventListener('mousemove', handleMouseMove);\r\n                document.documentElement.removeEventListener('mouseup', handleMouseUp);\r\n                if (frameListernerId) {\r\n                    cancelAnimationFrame(frameListernerId);\r\n                }\r\n            }\r\n            function handleMouseUp(mouseMoveUpEvent) {\r\n                mouseMoveUpEvent.preventDefault();\r\n                stopMouseMoveTracking();\r\n            }\r\n            document.documentElement.addEventListener('mousemove', handleMouseMove);\r\n            document.documentElement.addEventListener('mouseup', handleMouseUp);\r\n        });\r\n    },\r\n};\r\nexport function initEventPlugin() {\r\n    addGondelPluginEventListener('Events', 'registerEvent', function addResizeEvent(isNativeEvent, _a, resolve) {\r\n        var eventName = _a.eventName, namespace = _a.namespace, eventRegistry = _a.eventRegistry;\r\n        if (customEvents[eventName]) {\r\n            customEvents[eventName](eventRegistry, namespace);\r\n            // Tell the event system that it should not listen for the event:\r\n            resolve(false);\r\n        }\r\n        else {\r\n            resolve(isNativeEvent);\r\n        }\r\n    });\r\n    addGondelPluginEventListener('Events', 'sync', function addResizeEvent(components, data, resolve) {\r\n        setTimeout(function () {\r\n            components.forEach(function (component) {\r\n                component.__resizeSize = {\r\n                    width: component._ctx.clientWidth,\r\n                    height: component._ctx.clientHeight,\r\n                };\r\n            });\r\n        });\r\n        resolve(components);\r\n    });\r\n}\r\n//# sourceMappingURL=index.js.map"],"names":["basePluginListener","result","data","next","pluginEventRegistry","window","__gondelPluginEvents","pluginMapping","pluginEvents","addGondelPluginEventListener","pluginName","eventName","eventListenerCallback","previousEventHandler","pluginHandlerNamePerEvent","modifiedResult","_","firstNext","internalGondelRefAttribute","extractComponent","element","namespace","gondelComponent","_ctx","matchesCssSelector","selector","elementPrototype","Element","prototype","elementMatches","matches","matchesSelector","mozMatchesSelector","msMatchesSelector","webkitMatchesSelector","call","getHandlers","attributeName","eventHandlerRegistry","target","parents","startElement","nodes","parentElement","push","getParentElements","selectorsOfFoundComponents","forEach","parent","i","componentName","getAttribute","handlers","index","handlerQueue","_a","Object","keys","selectorName","ctx","handlerOptions","length","sort","handlerA","handlerB","executeHandlers","event","eventObjectRequiresCleanup","results","cancelBubble","handlerObject","defineProperty","get","configurable","j","handlerResult","handlerName","_loop_1","currentTarget","getComponentsInEventRegistry","eventRegistry","map","join","componentElements","document","documentElement","querySelectorAll","components","component","domNode","undefined","nodeType","Error","getComponentByDomNode","customEvents","resize","resizeDoneTimer","componentInformation","isRunning","frameIsRequested","stopResizeWatching","requestAnimationFrame","fireResizeEvent","newSizes","handlerResults","node","width","clientWidth","height","clientHeight","newSize","_stopped","__resizeSize","selectors","handler","addEventListener","bind","size","gondelComponentHandlers","_componentName","handlerOption","clearTimeout","setTimeout","key","swipe-left","mouseDownEvent","latestMouseMoveEvent","frameListernerId","handleMouseMove","mouseMoveEvent","preventDefault","handleMouseMoveThrottled","x","stopMouseMoveTracking","removeEventListener","handleMouseUp","cancelAnimationFrame","mouseMoveUpEvent","swipe-right","isNativeEvent","resolve"],"mappings":"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"}