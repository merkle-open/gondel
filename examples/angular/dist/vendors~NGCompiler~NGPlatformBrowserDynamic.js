(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~NGCompiler~NGPlatformBrowserDynamic"],{

/***/ "../../node_modules/@angular/compiler/fesm5/compiler.js":
/*!***********************************************************************************************!*\
  !*** /Users/jbiasi/Namics/OpenSource/gondel/node_modules/@angular/compiler/fesm5/compiler.js ***!
  \***********************************************************************************************/
/*! exports provided: core, CompilerConfig, preserveWhitespacesDefault, isLoweredSymbol, createLoweredSymbol, Identifiers, JitCompiler, ConstantPool, DirectiveResolver, PipeResolver, NgModuleResolver, DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig, NgModuleCompiler, ArrayType, AssertNotNull, DYNAMIC_TYPE, BinaryOperator, BinaryOperatorExpr, BuiltinMethod, BuiltinType, BuiltinTypeName, BuiltinVar, CastExpr, ClassField, ClassMethod, ClassStmt, CommaExpr, CommentStmt, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExternalExpr, ExternalReference, literalMap, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, JSDocCommentStmt, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, ThrowStmt, TryCatchStmt, Type, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, StmtModifier, Statement, STRING_TYPE, TypeofExpr, collectExternalReferences, EmitterVisitorContext, JitEvaluator, ViewCompiler, findStaticQueryIds, staticViewQueryIds, getParseErrors, isSyntaxError, syntaxError, Version, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstBoundText, TmplAstContent, TmplAstElement, TmplAstRecursiveVisitor, TmplAstReference, TmplAstTemplate, TmplAstText, TmplAstTextAttribute, TmplAstVariable, R3Identifiers, R3ResolvedDependencyType, compileInjector, compileNgModule, compilePipeFromMetadata, makeBindingParser, parseTemplate, compileBaseDefFromMetadata, compileComponentFromMetadata, compileDirectiveFromMetadata, parseHostBindings, verifyHostBindings, publishFacade, VERSION, TextAst, BoundTextAst, AttrAst, BoundElementPropertyAst, BoundEventAst, ReferenceAst, VariableAst, ElementAst, EmbeddedTemplateAst, BoundDirectivePropertyAst, DirectiveAst, ProviderAst, ProviderAstType, NgContentAst, NullTemplateVisitor, RecursiveTemplateAstVisitor, templateVisitAll, sanitizeIdentifier, identifierName, identifierModuleUrl, viewClassName, rendererTypeName, hostViewClassName, componentFactoryName, CompileSummaryKind, tokenName, tokenReference, CompileStylesheetMetadata, CompileTemplateMetadata, CompileDirectiveMetadata, CompilePipeMetadata, CompileShallowModuleMetadata, CompileNgModuleMetadata, TransitiveCompileNgModuleMetadata, ProviderMeta, flatten, templateSourceUrl, sharedStylesheetJitUrl, ngModuleJitUrl, templateJitUrl, createAotUrlResolver, createAotCompiler, AotCompiler, analyzeNgModules, analyzeAndValidateNgModules, analyzeFile, analyzeFileForInjectables, mergeAnalyzedFiles, GeneratedFile, toTypeScript, formattedError, isFormattedError, StaticReflector, StaticSymbol, StaticSymbolCache, ResolvedStaticSymbol, StaticSymbolResolver, unescapeIdentifier, unwrapResolvedMetadata, AotSummaryResolver, AstPath, SummaryResolver, JitSummaryResolver, CompileReflector, createUrlResolverWithoutPackagePrefix, createOfflineCompileUrlResolver, UrlResolver, getUrlScheme, ResourceLoader, ElementSchemaRegistry, Extractor, I18NHtmlParser, MessageBundle, Serializer, Xliff, Xliff2, Xmb, Xtb, DirectiveNormalizer, ParserError, ParseSpan, AST, Quote, EmptyExpr, ImplicitReceiver, Chain, Conditional, PropertyRead, PropertyWrite, SafePropertyRead, KeyedRead, KeyedWrite, BindingPipe, LiteralPrimitive, LiteralArray, LiteralMap, Interpolation, Binary, PrefixNot, NonNullAssert, MethodCall, SafeMethodCall, FunctionCall, AbsoluteSourceSpan, ASTWithSource, TemplateBinding, NullAstVisitor, RecursiveAstVisitor, AstTransformer, AstMemoryEfficientTransformer, visitAstChildren, ParsedProperty, ParsedPropertyType, ParsedEvent, ParsedVariable, BoundElementProperty, TokenType, Lexer, Token, EOF, isIdentifier, isQuote, SplitInterpolation, TemplateBindingParseResult, Parser, _ParseAST, ERROR_COMPONENT_TYPE, CompileMetadataResolver, Text, Expansion, ExpansionCase, Attribute, Element, Comment, visitAll, RecursiveVisitor, findNode, HtmlParser, ParseTreeResult, TreeError, HtmlTagDefinition, getHtmlTagDefinition, TagContentType, splitNsName, isNgContainer, isNgContent, isNgTemplate, getNsPrefix, mergeNsAndName, NAMED_ENTITIES, NGSP_UNICODE, debugOutputAstAsTypeScript, TypeScriptEmitter, ParseLocation, ParseSourceFile, ParseSourceSpan, EMPTY_PARSE_LOCATION, EMPTY_SOURCE_SPAN, ParseErrorLevel, ParseError, typeSourceSpan, r3JitTypeSourceSpan, DomElementSchemaRegistry, CssSelector, SelectorMatcher, SelectorListContext, SelectorContext, HOST_ATTR, CONTENT_ATTR, StylesCompileDependency, CompiledStylesheet, StyleCompiler, TemplateParseError, TemplateParseResult, TemplateParser, splitClasses, createElementCssSelector, removeSummaryDuplicates, isEmptyExpression, compileInjectable, R3TargetBinder, R3BoundTarget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"core\", function() { return core; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompilerConfig\", function() { return CompilerConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"preserveWhitespacesDefault\", function() { return preserveWhitespacesDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isLoweredSymbol\", function() { return isLoweredSymbol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createLoweredSymbol\", function() { return createLoweredSymbol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Identifiers\", function() { return Identifiers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JitCompiler\", function() { return JitCompiler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConstantPool\", function() { return ConstantPool; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DirectiveResolver\", function() { return DirectiveResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PipeResolver\", function() { return PipeResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NgModuleResolver\", function() { return NgModuleResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_INTERPOLATION_CONFIG\", function() { return DEFAULT_INTERPOLATION_CONFIG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterpolationConfig\", function() { return InterpolationConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NgModuleCompiler\", function() { return NgModuleCompiler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArrayType\", function() { return ArrayType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AssertNotNull\", function() { return AssertNotNull; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DYNAMIC_TYPE\", function() { return DYNAMIC_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BinaryOperator\", function() { return BinaryOperator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BinaryOperatorExpr\", function() { return BinaryOperatorExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BuiltinMethod\", function() { return BuiltinMethod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BuiltinType\", function() { return BuiltinType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BuiltinTypeName\", function() { return BuiltinTypeName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BuiltinVar\", function() { return BuiltinVar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CastExpr\", function() { return CastExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClassField\", function() { return ClassField; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClassMethod\", function() { return ClassMethod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClassStmt\", function() { return ClassStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CommaExpr\", function() { return CommaExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CommentStmt\", function() { return CommentStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConditionalExpr\", function() { return ConditionalExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeclareFunctionStmt\", function() { return DeclareFunctionStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeclareVarStmt\", function() { return DeclareVarStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Expression\", function() { return Expression; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExpressionStatement\", function() { return ExpressionStatement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExpressionType\", function() { return ExpressionType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExternalExpr\", function() { return ExternalExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExternalReference\", function() { return ExternalReference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"literalMap\", function() { return literalMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionExpr\", function() { return FunctionExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IfStmt\", function() { return IfStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InstantiateExpr\", function() { return InstantiateExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InvokeFunctionExpr\", function() { return InvokeFunctionExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InvokeMethodExpr\", function() { return InvokeMethodExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JSDocCommentStmt\", function() { return JSDocCommentStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralArrayExpr\", function() { return LiteralArrayExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralExpr\", function() { return LiteralExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralMapExpr\", function() { return LiteralMapExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MapType\", function() { return MapType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NotExpr\", function() { return NotExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReadKeyExpr\", function() { return ReadKeyExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReadPropExpr\", function() { return ReadPropExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReadVarExpr\", function() { return ReadVarExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReturnStatement\", function() { return ReturnStatement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ThrowStmt\", function() { return ThrowStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TryCatchStmt\", function() { return TryCatchStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Type\", function() { return Type$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WrappedNodeExpr\", function() { return WrappedNodeExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WriteKeyExpr\", function() { return WriteKeyExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WritePropExpr\", function() { return WritePropExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WriteVarExpr\", function() { return WriteVarExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StmtModifier\", function() { return StmtModifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Statement\", function() { return Statement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STRING_TYPE\", function() { return STRING_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeofExpr\", function() { return TypeofExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"collectExternalReferences\", function() { return collectExternalReferences; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmitterVisitorContext\", function() { return EmitterVisitorContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JitEvaluator\", function() { return JitEvaluator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewCompiler\", function() { return ViewCompiler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findStaticQueryIds\", function() { return findStaticQueryIds; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticViewQueryIds\", function() { return staticViewQueryIds; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getParseErrors\", function() { return getParseErrors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isSyntaxError\", function() { return isSyntaxError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"syntaxError\", function() { return syntaxError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Version\", function() { return Version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstBoundAttribute\", function() { return BoundAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstBoundEvent\", function() { return BoundEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstBoundText\", function() { return BoundText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstContent\", function() { return Content; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstElement\", function() { return Element; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstRecursiveVisitor\", function() { return RecursiveVisitor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstReference\", function() { return Reference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstTemplate\", function() { return Template; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstText\", function() { return Text; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstTextAttribute\", function() { return TextAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstVariable\", function() { return Variable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R3Identifiers\", function() { return Identifiers$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R3ResolvedDependencyType\", function() { return R3ResolvedDependencyType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileInjector\", function() { return compileInjector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileNgModule\", function() { return compileNgModule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compilePipeFromMetadata\", function() { return compilePipeFromMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeBindingParser\", function() { return makeBindingParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseTemplate\", function() { return parseTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileBaseDefFromMetadata\", function() { return compileBaseDefFromMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileComponentFromMetadata\", function() { return compileComponentFromMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileDirectiveFromMetadata\", function() { return compileDirectiveFromMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseHostBindings\", function() { return parseHostBindings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"verifyHostBindings\", function() { return verifyHostBindings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"publishFacade\", function() { return publishFacade; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return VERSION$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextAst\", function() { return TextAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundTextAst\", function() { return BoundTextAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AttrAst\", function() { return AttrAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundElementPropertyAst\", function() { return BoundElementPropertyAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundEventAst\", function() { return BoundEventAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReferenceAst\", function() { return ReferenceAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VariableAst\", function() { return VariableAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementAst\", function() { return ElementAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmbeddedTemplateAst\", function() { return EmbeddedTemplateAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundDirectivePropertyAst\", function() { return BoundDirectivePropertyAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DirectiveAst\", function() { return DirectiveAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ProviderAst\", function() { return ProviderAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ProviderAstType\", function() { return ProviderAstType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NgContentAst\", function() { return NgContentAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NullTemplateVisitor\", function() { return NullTemplateVisitor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RecursiveTemplateAstVisitor\", function() { return RecursiveTemplateAstVisitor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"templateVisitAll\", function() { return templateVisitAll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sanitizeIdentifier\", function() { return sanitizeIdentifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identifierName\", function() { return identifierName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identifierModuleUrl\", function() { return identifierModuleUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"viewClassName\", function() { return viewClassName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rendererTypeName\", function() { return rendererTypeName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hostViewClassName\", function() { return hostViewClassName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"componentFactoryName\", function() { return componentFactoryName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompileSummaryKind\", function() { return CompileSummaryKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokenName\", function() { return tokenName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokenReference\", function() { return tokenReference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompileStylesheetMetadata\", function() { return CompileStylesheetMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompileTemplateMetadata\", function() { return CompileTemplateMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompileDirectiveMetadata\", function() { return CompileDirectiveMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompilePipeMetadata\", function() { return CompilePipeMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompileShallowModuleMetadata\", function() { return CompileShallowModuleMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompileNgModuleMetadata\", function() { return CompileNgModuleMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransitiveCompileNgModuleMetadata\", function() { return TransitiveCompileNgModuleMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ProviderMeta\", function() { return ProviderMeta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"flatten\", function() { return flatten; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"templateSourceUrl\", function() { return templateSourceUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sharedStylesheetJitUrl\", function() { return sharedStylesheetJitUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ngModuleJitUrl\", function() { return ngModuleJitUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"templateJitUrl\", function() { return templateJitUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createAotUrlResolver\", function() { return createAotUrlResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createAotCompiler\", function() { return createAotCompiler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AotCompiler\", function() { return AotCompiler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"analyzeNgModules\", function() { return analyzeNgModules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"analyzeAndValidateNgModules\", function() { return analyzeAndValidateNgModules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"analyzeFile\", function() { return analyzeFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"analyzeFileForInjectables\", function() { return analyzeFileForInjectables; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeAnalyzedFiles\", function() { return mergeAnalyzedFiles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeneratedFile\", function() { return GeneratedFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toTypeScript\", function() { return toTypeScript; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formattedError\", function() { return formattedError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isFormattedError\", function() { return isFormattedError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StaticReflector\", function() { return StaticReflector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StaticSymbol\", function() { return StaticSymbol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StaticSymbolCache\", function() { return StaticSymbolCache; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResolvedStaticSymbol\", function() { return ResolvedStaticSymbol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StaticSymbolResolver\", function() { return StaticSymbolResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unescapeIdentifier\", function() { return unescapeIdentifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unwrapResolvedMetadata\", function() { return unwrapResolvedMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AotSummaryResolver\", function() { return AotSummaryResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AstPath\", function() { return AstPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SummaryResolver\", function() { return SummaryResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JitSummaryResolver\", function() { return JitSummaryResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompileReflector\", function() { return CompileReflector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createUrlResolverWithoutPackagePrefix\", function() { return createUrlResolverWithoutPackagePrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createOfflineCompileUrlResolver\", function() { return createOfflineCompileUrlResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UrlResolver\", function() { return UrlResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getUrlScheme\", function() { return getUrlScheme; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResourceLoader\", function() { return ResourceLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementSchemaRegistry\", function() { return ElementSchemaRegistry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Extractor\", function() { return Extractor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"I18NHtmlParser\", function() { return I18NHtmlParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MessageBundle\", function() { return MessageBundle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Serializer\", function() { return Serializer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Xliff\", function() { return Xliff; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Xliff2\", function() { return Xliff2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Xmb\", function() { return Xmb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Xtb\", function() { return Xtb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DirectiveNormalizer\", function() { return DirectiveNormalizer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParserError\", function() { return ParserError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseSpan\", function() { return ParseSpan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AST\", function() { return AST; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Quote\", function() { return Quote; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmptyExpr\", function() { return EmptyExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImplicitReceiver\", function() { return ImplicitReceiver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Chain\", function() { return Chain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Conditional\", function() { return Conditional; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropertyRead\", function() { return PropertyRead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropertyWrite\", function() { return PropertyWrite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SafePropertyRead\", function() { return SafePropertyRead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KeyedRead\", function() { return KeyedRead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KeyedWrite\", function() { return KeyedWrite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BindingPipe\", function() { return BindingPipe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralPrimitive\", function() { return LiteralPrimitive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralArray\", function() { return LiteralArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralMap\", function() { return LiteralMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Interpolation\", function() { return Interpolation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Binary\", function() { return Binary; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PrefixNot\", function() { return PrefixNot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NonNullAssert\", function() { return NonNullAssert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MethodCall\", function() { return MethodCall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SafeMethodCall\", function() { return SafeMethodCall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionCall\", function() { return FunctionCall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbsoluteSourceSpan\", function() { return AbsoluteSourceSpan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ASTWithSource\", function() { return ASTWithSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TemplateBinding\", function() { return TemplateBinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NullAstVisitor\", function() { return NullAstVisitor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RecursiveAstVisitor\", function() { return RecursiveAstVisitor$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AstTransformer\", function() { return AstTransformer$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AstMemoryEfficientTransformer\", function() { return AstMemoryEfficientTransformer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"visitAstChildren\", function() { return visitAstChildren; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParsedProperty\", function() { return ParsedProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParsedPropertyType\", function() { return ParsedPropertyType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParsedEvent\", function() { return ParsedEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParsedVariable\", function() { return ParsedVariable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundElementProperty\", function() { return BoundElementProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TokenType\", function() { return TokenType$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Lexer\", function() { return Lexer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Token\", function() { return Token$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EOF\", function() { return EOF; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIdentifier\", function() { return isIdentifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isQuote\", function() { return isQuote; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SplitInterpolation\", function() { return SplitInterpolation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TemplateBindingParseResult\", function() { return TemplateBindingParseResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Parser\", function() { return Parser$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_ParseAST\", function() { return _ParseAST; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ERROR_COMPONENT_TYPE\", function() { return ERROR_COMPONENT_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompileMetadataResolver\", function() { return CompileMetadataResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Text\", function() { return Text$3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Expansion\", function() { return Expansion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExpansionCase\", function() { return ExpansionCase; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Attribute\", function() { return Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Element\", function() { return Element$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Comment\", function() { return Comment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"visitAll\", function() { return visitAll$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RecursiveVisitor\", function() { return RecursiveVisitor$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findNode\", function() { return findNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HtmlParser\", function() { return HtmlParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseTreeResult\", function() { return ParseTreeResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TreeError\", function() { return TreeError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HtmlTagDefinition\", function() { return HtmlTagDefinition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getHtmlTagDefinition\", function() { return getHtmlTagDefinition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TagContentType\", function() { return TagContentType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitNsName\", function() { return splitNsName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNgContainer\", function() { return isNgContainer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNgContent\", function() { return isNgContent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNgTemplate\", function() { return isNgTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getNsPrefix\", function() { return getNsPrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeNsAndName\", function() { return mergeNsAndName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NAMED_ENTITIES\", function() { return NAMED_ENTITIES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NGSP_UNICODE\", function() { return NGSP_UNICODE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"debugOutputAstAsTypeScript\", function() { return debugOutputAstAsTypeScript; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeScriptEmitter\", function() { return TypeScriptEmitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseLocation\", function() { return ParseLocation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseSourceFile\", function() { return ParseSourceFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseSourceSpan\", function() { return ParseSourceSpan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EMPTY_PARSE_LOCATION\", function() { return EMPTY_PARSE_LOCATION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EMPTY_SOURCE_SPAN\", function() { return EMPTY_SOURCE_SPAN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseErrorLevel\", function() { return ParseErrorLevel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseError\", function() { return ParseError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"typeSourceSpan\", function() { return typeSourceSpan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"r3JitTypeSourceSpan\", function() { return r3JitTypeSourceSpan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DomElementSchemaRegistry\", function() { return DomElementSchemaRegistry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CssSelector\", function() { return CssSelector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectorMatcher\", function() { return SelectorMatcher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectorListContext\", function() { return SelectorListContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectorContext\", function() { return SelectorContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HOST_ATTR\", function() { return HOST_ATTR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CONTENT_ATTR\", function() { return CONTENT_ATTR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StylesCompileDependency\", function() { return StylesCompileDependency; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompiledStylesheet\", function() { return CompiledStylesheet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StyleCompiler\", function() { return StyleCompiler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TemplateParseError\", function() { return TemplateParseError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TemplateParseResult\", function() { return TemplateParseResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TemplateParser\", function() { return TemplateParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitClasses\", function() { return splitClasses; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createElementCssSelector\", function() { return createElementCssSelector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeSummaryDuplicates\", function() { return removeSummaryDuplicates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isEmptyExpression\", function() { return isEmptyExpression; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileInjectable\", function() { return compileInjectable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R3TargetBinder\", function() { return R3TargetBinder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R3BoundTarget\", function() { return R3BoundTarget; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"../../node_modules/tslib/tslib.es6.js\");\n/**\n * @license Angular v8.2.14\n * (c) 2010-2019 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TagContentType;\n(function (TagContentType) {\n    TagContentType[TagContentType[\"RAW_TEXT\"] = 0] = \"RAW_TEXT\";\n    TagContentType[TagContentType[\"ESCAPABLE_RAW_TEXT\"] = 1] = \"ESCAPABLE_RAW_TEXT\";\n    TagContentType[TagContentType[\"PARSABLE_DATA\"] = 2] = \"PARSABLE_DATA\";\n})(TagContentType || (TagContentType = {}));\nfunction splitNsName(elementName) {\n    if (elementName[0] != ':') {\n        return [null, elementName];\n    }\n    var colonIndex = elementName.indexOf(':', 1);\n    if (colonIndex == -1) {\n        throw new Error(\"Unsupported format \\\"\" + elementName + \"\\\" expecting \\\":namespace:name\\\"\");\n    }\n    return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n// `<ng-container>` tags work the same regardless the namespace\nfunction isNgContainer(tagName) {\n    return splitNsName(tagName)[1] === 'ng-container';\n}\n// `<ng-content>` tags work the same regardless the namespace\nfunction isNgContent(tagName) {\n    return splitNsName(tagName)[1] === 'ng-content';\n}\n// `<ng-template>` tags work the same regardless the namespace\nfunction isNgTemplate(tagName) {\n    return splitNsName(tagName)[1] === 'ng-template';\n}\nfunction getNsPrefix(fullName) {\n    return fullName === null ? null : splitNsName(fullName)[0];\n}\nfunction mergeNsAndName(prefix, localName) {\n    return prefix ? \":\" + prefix + \":\" + localName : localName;\n}\n// see http://www.w3.org/TR/html51/syntax.html#named-character-references\n// see https://html.spec.whatwg.org/multipage/entities.json\n// This list is not exhaustive to keep the compiler footprint low.\n// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not\n// exist.\nvar NAMED_ENTITIES = {\n    'Aacute': '\\u00C1',\n    'aacute': '\\u00E1',\n    'Acirc': '\\u00C2',\n    'acirc': '\\u00E2',\n    'acute': '\\u00B4',\n    'AElig': '\\u00C6',\n    'aelig': '\\u00E6',\n    'Agrave': '\\u00C0',\n    'agrave': '\\u00E0',\n    'alefsym': '\\u2135',\n    'Alpha': '\\u0391',\n    'alpha': '\\u03B1',\n    'amp': '&',\n    'and': '\\u2227',\n    'ang': '\\u2220',\n    'apos': '\\u0027',\n    'Aring': '\\u00C5',\n    'aring': '\\u00E5',\n    'asymp': '\\u2248',\n    'Atilde': '\\u00C3',\n    'atilde': '\\u00E3',\n    'Auml': '\\u00C4',\n    'auml': '\\u00E4',\n    'bdquo': '\\u201E',\n    'Beta': '\\u0392',\n    'beta': '\\u03B2',\n    'brvbar': '\\u00A6',\n    'bull': '\\u2022',\n    'cap': '\\u2229',\n    'Ccedil': '\\u00C7',\n    'ccedil': '\\u00E7',\n    'cedil': '\\u00B8',\n    'cent': '\\u00A2',\n    'Chi': '\\u03A7',\n    'chi': '\\u03C7',\n    'circ': '\\u02C6',\n    'clubs': '\\u2663',\n    'cong': '\\u2245',\n    'copy': '\\u00A9',\n    'crarr': '\\u21B5',\n    'cup': '\\u222A',\n    'curren': '\\u00A4',\n    'dagger': '\\u2020',\n    'Dagger': '\\u2021',\n    'darr': '\\u2193',\n    'dArr': '\\u21D3',\n    'deg': '\\u00B0',\n    'Delta': '\\u0394',\n    'delta': '\\u03B4',\n    'diams': '\\u2666',\n    'divide': '\\u00F7',\n    'Eacute': '\\u00C9',\n    'eacute': '\\u00E9',\n    'Ecirc': '\\u00CA',\n    'ecirc': '\\u00EA',\n    'Egrave': '\\u00C8',\n    'egrave': '\\u00E8',\n    'empty': '\\u2205',\n    'emsp': '\\u2003',\n    'ensp': '\\u2002',\n    'Epsilon': '\\u0395',\n    'epsilon': '\\u03B5',\n    'equiv': '\\u2261',\n    'Eta': '\\u0397',\n    'eta': '\\u03B7',\n    'ETH': '\\u00D0',\n    'eth': '\\u00F0',\n    'Euml': '\\u00CB',\n    'euml': '\\u00EB',\n    'euro': '\\u20AC',\n    'exist': '\\u2203',\n    'fnof': '\\u0192',\n    'forall': '\\u2200',\n    'frac12': '\\u00BD',\n    'frac14': '\\u00BC',\n    'frac34': '\\u00BE',\n    'frasl': '\\u2044',\n    'Gamma': '\\u0393',\n    'gamma': '\\u03B3',\n    'ge': '\\u2265',\n    'gt': '>',\n    'harr': '\\u2194',\n    'hArr': '\\u21D4',\n    'hearts': '\\u2665',\n    'hellip': '\\u2026',\n    'Iacute': '\\u00CD',\n    'iacute': '\\u00ED',\n    'Icirc': '\\u00CE',\n    'icirc': '\\u00EE',\n    'iexcl': '\\u00A1',\n    'Igrave': '\\u00CC',\n    'igrave': '\\u00EC',\n    'image': '\\u2111',\n    'infin': '\\u221E',\n    'int': '\\u222B',\n    'Iota': '\\u0399',\n    'iota': '\\u03B9',\n    'iquest': '\\u00BF',\n    'isin': '\\u2208',\n    'Iuml': '\\u00CF',\n    'iuml': '\\u00EF',\n    'Kappa': '\\u039A',\n    'kappa': '\\u03BA',\n    'Lambda': '\\u039B',\n    'lambda': '\\u03BB',\n    'lang': '\\u27E8',\n    'laquo': '\\u00AB',\n    'larr': '\\u2190',\n    'lArr': '\\u21D0',\n    'lceil': '\\u2308',\n    'ldquo': '\\u201C',\n    'le': '\\u2264',\n    'lfloor': '\\u230A',\n    'lowast': '\\u2217',\n    'loz': '\\u25CA',\n    'lrm': '\\u200E',\n    'lsaquo': '\\u2039',\n    'lsquo': '\\u2018',\n    'lt': '<',\n    'macr': '\\u00AF',\n    'mdash': '\\u2014',\n    'micro': '\\u00B5',\n    'middot': '\\u00B7',\n    'minus': '\\u2212',\n    'Mu': '\\u039C',\n    'mu': '\\u03BC',\n    'nabla': '\\u2207',\n    'nbsp': '\\u00A0',\n    'ndash': '\\u2013',\n    'ne': '\\u2260',\n    'ni': '\\u220B',\n    'not': '\\u00AC',\n    'notin': '\\u2209',\n    'nsub': '\\u2284',\n    'Ntilde': '\\u00D1',\n    'ntilde': '\\u00F1',\n    'Nu': '\\u039D',\n    'nu': '\\u03BD',\n    'Oacute': '\\u00D3',\n    'oacute': '\\u00F3',\n    'Ocirc': '\\u00D4',\n    'ocirc': '\\u00F4',\n    'OElig': '\\u0152',\n    'oelig': '\\u0153',\n    'Ograve': '\\u00D2',\n    'ograve': '\\u00F2',\n    'oline': '\\u203E',\n    'Omega': '\\u03A9',\n    'omega': '\\u03C9',\n    'Omicron': '\\u039F',\n    'omicron': '\\u03BF',\n    'oplus': '\\u2295',\n    'or': '\\u2228',\n    'ordf': '\\u00AA',\n    'ordm': '\\u00BA',\n    'Oslash': '\\u00D8',\n    'oslash': '\\u00F8',\n    'Otilde': '\\u00D5',\n    'otilde': '\\u00F5',\n    'otimes': '\\u2297',\n    'Ouml': '\\u00D6',\n    'ouml': '\\u00F6',\n    'para': '\\u00B6',\n    'permil': '\\u2030',\n    'perp': '\\u22A5',\n    'Phi': '\\u03A6',\n    'phi': '\\u03C6',\n    'Pi': '\\u03A0',\n    'pi': '\\u03C0',\n    'piv': '\\u03D6',\n    'plusmn': '\\u00B1',\n    'pound': '\\u00A3',\n    'prime': '\\u2032',\n    'Prime': '\\u2033',\n    'prod': '\\u220F',\n    'prop': '\\u221D',\n    'Psi': '\\u03A8',\n    'psi': '\\u03C8',\n    'quot': '\\u0022',\n    'radic': '\\u221A',\n    'rang': '\\u27E9',\n    'raquo': '\\u00BB',\n    'rarr': '\\u2192',\n    'rArr': '\\u21D2',\n    'rceil': '\\u2309',\n    'rdquo': '\\u201D',\n    'real': '\\u211C',\n    'reg': '\\u00AE',\n    'rfloor': '\\u230B',\n    'Rho': '\\u03A1',\n    'rho': '\\u03C1',\n    'rlm': '\\u200F',\n    'rsaquo': '\\u203A',\n    'rsquo': '\\u2019',\n    'sbquo': '\\u201A',\n    'Scaron': '\\u0160',\n    'scaron': '\\u0161',\n    'sdot': '\\u22C5',\n    'sect': '\\u00A7',\n    'shy': '\\u00AD',\n    'Sigma': '\\u03A3',\n    'sigma': '\\u03C3',\n    'sigmaf': '\\u03C2',\n    'sim': '\\u223C',\n    'spades': '\\u2660',\n    'sub': '\\u2282',\n    'sube': '\\u2286',\n    'sum': '\\u2211',\n    'sup': '\\u2283',\n    'sup1': '\\u00B9',\n    'sup2': '\\u00B2',\n    'sup3': '\\u00B3',\n    'supe': '\\u2287',\n    'szlig': '\\u00DF',\n    'Tau': '\\u03A4',\n    'tau': '\\u03C4',\n    'there4': '\\u2234',\n    'Theta': '\\u0398',\n    'theta': '\\u03B8',\n    'thetasym': '\\u03D1',\n    'thinsp': '\\u2009',\n    'THORN': '\\u00DE',\n    'thorn': '\\u00FE',\n    'tilde': '\\u02DC',\n    'times': '\\u00D7',\n    'trade': '\\u2122',\n    'Uacute': '\\u00DA',\n    'uacute': '\\u00FA',\n    'uarr': '\\u2191',\n    'uArr': '\\u21D1',\n    'Ucirc': '\\u00DB',\n    'ucirc': '\\u00FB',\n    'Ugrave': '\\u00D9',\n    'ugrave': '\\u00F9',\n    'uml': '\\u00A8',\n    'upsih': '\\u03D2',\n    'Upsilon': '\\u03A5',\n    'upsilon': '\\u03C5',\n    'Uuml': '\\u00DC',\n    'uuml': '\\u00FC',\n    'weierp': '\\u2118',\n    'Xi': '\\u039E',\n    'xi': '\\u03BE',\n    'Yacute': '\\u00DD',\n    'yacute': '\\u00FD',\n    'yen': '\\u00A5',\n    'yuml': '\\u00FF',\n    'Yuml': '\\u0178',\n    'Zeta': '\\u0396',\n    'zeta': '\\u03B6',\n    'zwj': '\\u200D',\n    'zwnj': '\\u200C',\n};\n// The &ngsp; pseudo-entity is denoting a space. see:\n// https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart\nvar NGSP_UNICODE = '\\uE500';\nNAMED_ENTITIES['ngsp'] = NGSP_UNICODE;\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar HtmlTagDefinition = /** @class */ (function () {\n    function HtmlTagDefinition(_a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, closedByChildren = _b.closedByChildren, implicitNamespacePrefix = _b.implicitNamespacePrefix, _c = _b.contentType, contentType = _c === void 0 ? TagContentType.PARSABLE_DATA : _c, _d = _b.closedByParent, closedByParent = _d === void 0 ? false : _d, _e = _b.isVoid, isVoid = _e === void 0 ? false : _e, _f = _b.ignoreFirstLf, ignoreFirstLf = _f === void 0 ? false : _f;\n        this.closedByChildren = {};\n        this.closedByParent = false;\n        this.canSelfClose = false;\n        if (closedByChildren && closedByChildren.length > 0) {\n            closedByChildren.forEach(function (tagName) { return _this.closedByChildren[tagName] = true; });\n        }\n        this.isVoid = isVoid;\n        this.closedByParent = closedByParent || isVoid;\n        this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n        this.contentType = contentType;\n        this.ignoreFirstLf = ignoreFirstLf;\n    }\n    HtmlTagDefinition.prototype.isClosedByChild = function (name) {\n        return this.isVoid || name.toLowerCase() in this.closedByChildren;\n    };\n    return HtmlTagDefinition;\n}());\nvar _DEFAULT_TAG_DEFINITION;\n// see http://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nvar TAG_DEFINITIONS;\nfunction getHtmlTagDefinition(tagName) {\n    if (!TAG_DEFINITIONS) {\n        _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n        TAG_DEFINITIONS = {\n            'base': new HtmlTagDefinition({ isVoid: true }),\n            'meta': new HtmlTagDefinition({ isVoid: true }),\n            'area': new HtmlTagDefinition({ isVoid: true }),\n            'embed': new HtmlTagDefinition({ isVoid: true }),\n            'link': new HtmlTagDefinition({ isVoid: true }),\n            'img': new HtmlTagDefinition({ isVoid: true }),\n            'input': new HtmlTagDefinition({ isVoid: true }),\n            'param': new HtmlTagDefinition({ isVoid: true }),\n            'hr': new HtmlTagDefinition({ isVoid: true }),\n            'br': new HtmlTagDefinition({ isVoid: true }),\n            'source': new HtmlTagDefinition({ isVoid: true }),\n            'track': new HtmlTagDefinition({ isVoid: true }),\n            'wbr': new HtmlTagDefinition({ isVoid: true }),\n            'p': new HtmlTagDefinition({\n                closedByChildren: [\n                    'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset',\n                    'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5',\n                    'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol',\n                    'p', 'pre', 'section', 'table', 'ul'\n                ],\n                closedByParent: true\n            }),\n            'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),\n            'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),\n            'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),\n            'tr': new HtmlTagDefinition({ closedByChildren: ['tr'], closedByParent: true }),\n            'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n            'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n            'col': new HtmlTagDefinition({ isVoid: true }),\n            'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),\n            'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),\n            'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),\n            'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),\n            'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),\n            'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n            'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n            'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),\n            'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n            'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),\n            'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),\n            'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),\n            'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),\n            'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n            'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n            'title': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT }),\n            'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),\n        };\n    }\n    return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' + //\":not(\"\n    '([-\\\\w]+)|' + // \"tag\"\n    '(?:\\\\.([-\\\\w]+))|' + // \".class\"\n    // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n    '(?:\\\\[([-.\\\\w*]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' + // \"[name]\", \"[name=value]\",\n    // \"[name=\"value\"]\",\n    // \"[name='value']\"\n    '(\\\\))|' + // \")\"\n    '(\\\\s*,\\\\s*)', // \",\"\n'g');\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nvar CssSelector = /** @class */ (function () {\n    function CssSelector() {\n        this.element = null;\n        this.classNames = [];\n        /**\n         * The selectors are encoded in pairs where:\n         * - even locations are attribute names\n         * - odd locations are attribute values.\n         *\n         * Example:\n         * Selector: `[key1=value1][key2]` would parse to:\n         * ```\n         * ['key1', 'value1', 'key2', '']\n         * ```\n         */\n        this.attrs = [];\n        this.notSelectors = [];\n    }\n    CssSelector.parse = function (selector) {\n        var results = [];\n        var _addResult = function (res, cssSel) {\n            if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n                cssSel.attrs.length == 0) {\n                cssSel.element = '*';\n            }\n            res.push(cssSel);\n        };\n        var cssSelector = new CssSelector();\n        var match;\n        var current = cssSelector;\n        var inNot = false;\n        _SELECTOR_REGEXP.lastIndex = 0;\n        while (match = _SELECTOR_REGEXP.exec(selector)) {\n            if (match[1]) {\n                if (inNot) {\n                    throw new Error('Nesting :not is not allowed in a selector');\n                }\n                inNot = true;\n                current = new CssSelector();\n                cssSelector.notSelectors.push(current);\n            }\n            if (match[2]) {\n                current.setElement(match[2]);\n            }\n            if (match[3]) {\n                current.addClassName(match[3]);\n            }\n            if (match[4]) {\n                current.addAttribute(match[4], match[6]);\n            }\n            if (match[7]) {\n                inNot = false;\n                current = cssSelector;\n            }\n            if (match[8]) {\n                if (inNot) {\n                    throw new Error('Multiple selectors in :not are not supported');\n                }\n                _addResult(results, cssSelector);\n                cssSelector = current = new CssSelector();\n            }\n        }\n        _addResult(results, cssSelector);\n        return results;\n    };\n    CssSelector.prototype.isElementSelector = function () {\n        return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n            this.notSelectors.length === 0;\n    };\n    CssSelector.prototype.hasElementSelector = function () { return !!this.element; };\n    CssSelector.prototype.setElement = function (element) {\n        if (element === void 0) { element = null; }\n        this.element = element;\n    };\n    /** Gets a template string for an element that matches the selector. */\n    CssSelector.prototype.getMatchingElementTemplate = function () {\n        var tagName = this.element || 'div';\n        var classAttr = this.classNames.length > 0 ? \" class=\\\"\" + this.classNames.join(' ') + \"\\\"\" : '';\n        var attrs = '';\n        for (var i = 0; i < this.attrs.length; i += 2) {\n            var attrName = this.attrs[i];\n            var attrValue = this.attrs[i + 1] !== '' ? \"=\\\"\" + this.attrs[i + 1] + \"\\\"\" : '';\n            attrs += \" \" + attrName + attrValue;\n        }\n        return getHtmlTagDefinition(tagName).isVoid ? \"<\" + tagName + classAttr + attrs + \"/>\" :\n            \"<\" + tagName + classAttr + attrs + \"></\" + tagName + \">\";\n    };\n    CssSelector.prototype.getAttrs = function () {\n        var result = [];\n        if (this.classNames.length > 0) {\n            result.push('class', this.classNames.join(' '));\n        }\n        return result.concat(this.attrs);\n    };\n    CssSelector.prototype.addAttribute = function (name, value) {\n        if (value === void 0) { value = ''; }\n        this.attrs.push(name, value && value.toLowerCase() || '');\n    };\n    CssSelector.prototype.addClassName = function (name) { this.classNames.push(name.toLowerCase()); };\n    CssSelector.prototype.toString = function () {\n        var res = this.element || '';\n        if (this.classNames) {\n            this.classNames.forEach(function (klass) { return res += \".\" + klass; });\n        }\n        if (this.attrs) {\n            for (var i = 0; i < this.attrs.length; i += 2) {\n                var name_1 = this.attrs[i];\n                var value = this.attrs[i + 1];\n                res += \"[\" + name_1 + (value ? '=' + value : '') + \"]\";\n            }\n        }\n        this.notSelectors.forEach(function (notSelector) { return res += \":not(\" + notSelector + \")\"; });\n        return res;\n    };\n    return CssSelector;\n}());\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nvar SelectorMatcher = /** @class */ (function () {\n    function SelectorMatcher() {\n        this._elementMap = new Map();\n        this._elementPartialMap = new Map();\n        this._classMap = new Map();\n        this._classPartialMap = new Map();\n        this._attrValueMap = new Map();\n        this._attrValuePartialMap = new Map();\n        this._listContexts = [];\n    }\n    SelectorMatcher.createNotMatcher = function (notSelectors) {\n        var notMatcher = new SelectorMatcher();\n        notMatcher.addSelectables(notSelectors, null);\n        return notMatcher;\n    };\n    SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {\n        var listContext = null;\n        if (cssSelectors.length > 1) {\n            listContext = new SelectorListContext(cssSelectors);\n            this._listContexts.push(listContext);\n        }\n        for (var i = 0; i < cssSelectors.length; i++) {\n            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n        }\n    };\n    /**\n     * Add an object that can be found later on by calling `match`.\n     * @param cssSelector A css selector\n     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\n     */\n    SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {\n        var matcher = this;\n        var element = cssSelector.element;\n        var classNames = cssSelector.classNames;\n        var attrs = cssSelector.attrs;\n        var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n        if (element) {\n            var isTerminal = attrs.length === 0 && classNames.length === 0;\n            if (isTerminal) {\n                this._addTerminal(matcher._elementMap, element, selectable);\n            }\n            else {\n                matcher = this._addPartial(matcher._elementPartialMap, element);\n            }\n        }\n        if (classNames) {\n            for (var i = 0; i < classNames.length; i++) {\n                var isTerminal = attrs.length === 0 && i === classNames.length - 1;\n                var className = classNames[i];\n                if (isTerminal) {\n                    this._addTerminal(matcher._classMap, className, selectable);\n                }\n                else {\n                    matcher = this._addPartial(matcher._classPartialMap, className);\n                }\n            }\n        }\n        if (attrs) {\n            for (var i = 0; i < attrs.length; i += 2) {\n                var isTerminal = i === attrs.length - 2;\n                var name_2 = attrs[i];\n                var value = attrs[i + 1];\n                if (isTerminal) {\n                    var terminalMap = matcher._attrValueMap;\n                    var terminalValuesMap = terminalMap.get(name_2);\n                    if (!terminalValuesMap) {\n                        terminalValuesMap = new Map();\n                        terminalMap.set(name_2, terminalValuesMap);\n                    }\n                    this._addTerminal(terminalValuesMap, value, selectable);\n                }\n                else {\n                    var partialMap = matcher._attrValuePartialMap;\n                    var partialValuesMap = partialMap.get(name_2);\n                    if (!partialValuesMap) {\n                        partialValuesMap = new Map();\n                        partialMap.set(name_2, partialValuesMap);\n                    }\n                    matcher = this._addPartial(partialValuesMap, value);\n                }\n            }\n        }\n    };\n    SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {\n        var terminalList = map.get(name);\n        if (!terminalList) {\n            terminalList = [];\n            map.set(name, terminalList);\n        }\n        terminalList.push(selectable);\n    };\n    SelectorMatcher.prototype._addPartial = function (map, name) {\n        var matcher = map.get(name);\n        if (!matcher) {\n            matcher = new SelectorMatcher();\n            map.set(name, matcher);\n        }\n        return matcher;\n    };\n    /**\n     * Find the objects that have been added via `addSelectable`\n     * whose css selector is contained in the given css selector.\n     * @param cssSelector A css selector\n     * @param matchedCallback This callback will be called with the object handed into `addSelectable`\n     * @return boolean true if a match was found\n    */\n    SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {\n        var result = false;\n        var element = cssSelector.element;\n        var classNames = cssSelector.classNames;\n        var attrs = cssSelector.attrs;\n        for (var i = 0; i < this._listContexts.length; i++) {\n            this._listContexts[i].alreadyMatched = false;\n        }\n        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n            result;\n        if (classNames) {\n            for (var i = 0; i < classNames.length; i++) {\n                var className = classNames[i];\n                result =\n                    this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n                result =\n                    this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n                        result;\n            }\n        }\n        if (attrs) {\n            for (var i = 0; i < attrs.length; i += 2) {\n                var name_3 = attrs[i];\n                var value = attrs[i + 1];\n                var terminalValuesMap = this._attrValueMap.get(name_3);\n                if (value) {\n                    result =\n                        this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n                var partialValuesMap = this._attrValuePartialMap.get(name_3);\n                if (value) {\n                    result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n            }\n        }\n        return result;\n    };\n    /** @internal */\n    SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        var selectables = map.get(name) || [];\n        var starSelectables = map.get('*');\n        if (starSelectables) {\n            selectables = selectables.concat(starSelectables);\n        }\n        if (selectables.length === 0) {\n            return false;\n        }\n        var selectable;\n        var result = false;\n        for (var i = 0; i < selectables.length; i++) {\n            selectable = selectables[i];\n            result = selectable.finalize(cssSelector, matchedCallback) || result;\n        }\n        return result;\n    };\n    /** @internal */\n    SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        var nestedSelector = map.get(name);\n        if (!nestedSelector) {\n            return false;\n        }\n        // TODO(perf): get rid of recursion and measure again\n        // TODO(perf): don't pass the whole selector into the recursion,\n        // but only the not processed parts\n        return nestedSelector.match(cssSelector, matchedCallback);\n    };\n    return SelectorMatcher;\n}());\nvar SelectorListContext = /** @class */ (function () {\n    function SelectorListContext(selectors) {\n        this.selectors = selectors;\n        this.alreadyMatched = false;\n    }\n    return SelectorListContext;\n}());\n// Store context to pass back selector and context when a selector is matched\nvar SelectorContext = /** @class */ (function () {\n    function SelectorContext(selector, cbContext, listContext) {\n        this.selector = selector;\n        this.cbContext = cbContext;\n        this.listContext = listContext;\n        this.notSelectors = selector.notSelectors;\n    }\n    SelectorContext.prototype.finalize = function (cssSelector, callback) {\n        var result = true;\n        if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n            var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n            result = !notMatcher.match(cssSelector, null);\n        }\n        if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n            if (this.listContext) {\n                this.listContext.alreadyMatched = true;\n            }\n            callback(this.selector, this.cbContext);\n        }\n        return result;\n    };\n    return SelectorContext;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar createInject = makeMetadataFactory('Inject', function (token) { return ({ token: token }); });\nvar createInjectionToken = makeMetadataFactory('InjectionToken', function (desc) { return ({ _desc: desc, ngInjectableDef: undefined }); });\nvar createAttribute = makeMetadataFactory('Attribute', function (attributeName) { return ({ attributeName: attributeName }); });\nvar createContentChildren = makeMetadataFactory('ContentChildren', function (selector, data) {\n    if (data === void 0) { data = {}; }\n    return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ selector: selector, first: false, isViewQuery: false, descendants: false }, data));\n});\nvar createContentChild = makeMetadataFactory('ContentChild', function (selector, data) {\n    if (data === void 0) { data = {}; }\n    return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ selector: selector, first: true, isViewQuery: false, descendants: true }, data));\n});\nvar createViewChildren = makeMetadataFactory('ViewChildren', function (selector, data) {\n    if (data === void 0) { data = {}; }\n    return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ selector: selector, first: false, isViewQuery: true, descendants: true }, data));\n});\nvar createViewChild = makeMetadataFactory('ViewChild', function (selector, data) {\n    return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ selector: selector, first: true, isViewQuery: true, descendants: true }, data));\n});\nvar createDirective = makeMetadataFactory('Directive', function (dir) {\n    if (dir === void 0) { dir = {}; }\n    return dir;\n});\nvar ViewEncapsulation;\n(function (ViewEncapsulation) {\n    ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n    ViewEncapsulation[ViewEncapsulation[\"Native\"] = 1] = \"Native\";\n    ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n    ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\nvar ChangeDetectionStrategy;\n(function (ChangeDetectionStrategy) {\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\nvar createComponent = makeMetadataFactory('Component', function (c) {\n    if (c === void 0) { c = {}; }\n    return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ changeDetection: ChangeDetectionStrategy.Default }, c));\n});\nvar createPipe = makeMetadataFactory('Pipe', function (p) { return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ pure: true }, p)); });\nvar createInput = makeMetadataFactory('Input', function (bindingPropertyName) { return ({ bindingPropertyName: bindingPropertyName }); });\nvar createOutput = makeMetadataFactory('Output', function (bindingPropertyName) { return ({ bindingPropertyName: bindingPropertyName }); });\nvar createHostBinding = makeMetadataFactory('HostBinding', function (hostPropertyName) { return ({ hostPropertyName: hostPropertyName }); });\nvar createHostListener = makeMetadataFactory('HostListener', function (eventName, args) { return ({ eventName: eventName, args: args }); });\nvar createNgModule = makeMetadataFactory('NgModule', function (ngModule) { return ngModule; });\nvar createInjectable = makeMetadataFactory('Injectable', function (injectable) {\n    if (injectable === void 0) { injectable = {}; }\n    return injectable;\n});\nvar CUSTOM_ELEMENTS_SCHEMA = {\n    name: 'custom-elements'\n};\nvar NO_ERRORS_SCHEMA = {\n    name: 'no-errors-schema'\n};\nvar createOptional = makeMetadataFactory('Optional');\nvar createSelf = makeMetadataFactory('Self');\nvar createSkipSelf = makeMetadataFactory('SkipSelf');\nvar createHost = makeMetadataFactory('Host');\nvar Type = Function;\nvar SecurityContext;\n(function (SecurityContext) {\n    SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n    SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n    SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n    SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n    SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n    SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n})(SecurityContext || (SecurityContext = {}));\nvar MissingTranslationStrategy;\n(function (MissingTranslationStrategy) {\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Error\"] = 0] = \"Error\";\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Warning\"] = 1] = \"Warning\";\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Ignore\"] = 2] = \"Ignore\";\n})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));\nfunction makeMetadataFactory(name, props) {\n    // This must be declared as a function, not a fat arrow, so that ES2015 devmode produces code\n    // that works with the static_reflector.ts in the ViewEngine compiler.\n    // In particular, `_registerDecoratorOrConstructor` assumes that the value returned here can be\n    // new'ed.\n    function factory() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var values = props ? props.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(args)) : {};\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ ngMetadataName: name }, values);\n    }\n    factory.isTypeOf = function (obj) { return obj && obj.ngMetadataName === name; };\n    factory.ngMetadataName = name;\n    return factory;\n}\nfunction parserSelectorToSimpleSelector(selector) {\n    var classes = selector.classNames && selector.classNames.length ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([8 /* CLASS */], selector.classNames) :\n        [];\n    var elementName = selector.element && selector.element !== '*' ? selector.element : '';\n    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([elementName], selector.attrs, classes);\n}\nfunction parserSelectorToNegativeSelector(selector) {\n    var classes = selector.classNames && selector.classNames.length ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([8 /* CLASS */], selector.classNames) :\n        [];\n    if (selector.element) {\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([\n            1 /* NOT */ | 4 /* ELEMENT */, selector.element\n        ], selector.attrs, classes);\n    }\n    else if (selector.attrs.length) {\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([1 /* NOT */ | 2 /* ATTRIBUTE */], selector.attrs, classes);\n    }\n    else {\n        return selector.classNames && selector.classNames.length ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([1 /* NOT */ | 8 /* CLASS */], selector.classNames) :\n            [];\n    }\n}\nfunction parserSelectorToR3Selector(selector) {\n    var positive = parserSelectorToSimpleSelector(selector);\n    var negative = selector.notSelectors && selector.notSelectors.length ?\n        selector.notSelectors.map(function (notSelector) { return parserSelectorToNegativeSelector(notSelector); }) :\n        [];\n    return positive.concat.apply(positive, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(negative));\n}\nfunction parseSelectorToR3Selector(selector) {\n    return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\n\nvar core = /*#__PURE__*/Object.freeze({\n    createInject: createInject,\n    createInjectionToken: createInjectionToken,\n    createAttribute: createAttribute,\n    createContentChildren: createContentChildren,\n    createContentChild: createContentChild,\n    createViewChildren: createViewChildren,\n    createViewChild: createViewChild,\n    createDirective: createDirective,\n    get ViewEncapsulation () { return ViewEncapsulation; },\n    get ChangeDetectionStrategy () { return ChangeDetectionStrategy; },\n    createComponent: createComponent,\n    createPipe: createPipe,\n    createInput: createInput,\n    createOutput: createOutput,\n    createHostBinding: createHostBinding,\n    createHostListener: createHostListener,\n    createNgModule: createNgModule,\n    createInjectable: createInjectable,\n    CUSTOM_ELEMENTS_SCHEMA: CUSTOM_ELEMENTS_SCHEMA,\n    NO_ERRORS_SCHEMA: NO_ERRORS_SCHEMA,\n    createOptional: createOptional,\n    createSelf: createSelf,\n    createSkipSelf: createSkipSelf,\n    createHost: createHost,\n    Type: Type,\n    get SecurityContext () { return SecurityContext; },\n    get MissingTranslationStrategy () { return MissingTranslationStrategy; },\n    parseSelectorToR3Selector: parseSelectorToR3Selector\n});\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n//// Types\nvar TypeModifier;\n(function (TypeModifier) {\n    TypeModifier[TypeModifier[\"Const\"] = 0] = \"Const\";\n})(TypeModifier || (TypeModifier = {}));\nvar Type$1 = /** @class */ (function () {\n    function Type(modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        this.modifiers = modifiers;\n        if (!modifiers) {\n            this.modifiers = [];\n        }\n    }\n    Type.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };\n    return Type;\n}());\nvar BuiltinTypeName;\n(function (BuiltinTypeName) {\n    BuiltinTypeName[BuiltinTypeName[\"Dynamic\"] = 0] = \"Dynamic\";\n    BuiltinTypeName[BuiltinTypeName[\"Bool\"] = 1] = \"Bool\";\n    BuiltinTypeName[BuiltinTypeName[\"String\"] = 2] = \"String\";\n    BuiltinTypeName[BuiltinTypeName[\"Int\"] = 3] = \"Int\";\n    BuiltinTypeName[BuiltinTypeName[\"Number\"] = 4] = \"Number\";\n    BuiltinTypeName[BuiltinTypeName[\"Function\"] = 5] = \"Function\";\n    BuiltinTypeName[BuiltinTypeName[\"Inferred\"] = 6] = \"Inferred\";\n    BuiltinTypeName[BuiltinTypeName[\"None\"] = 7] = \"None\";\n})(BuiltinTypeName || (BuiltinTypeName = {}));\nvar BuiltinType = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(BuiltinType, _super);\n    function BuiltinType(name, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.name = name;\n        return _this;\n    }\n    BuiltinType.prototype.visitType = function (visitor, context) {\n        return visitor.visitBuiltinType(this, context);\n    };\n    return BuiltinType;\n}(Type$1));\nvar ExpressionType = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ExpressionType, _super);\n    function ExpressionType(value, modifiers, typeParams) {\n        if (modifiers === void 0) { modifiers = null; }\n        if (typeParams === void 0) { typeParams = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.value = value;\n        _this.typeParams = typeParams;\n        return _this;\n    }\n    ExpressionType.prototype.visitType = function (visitor, context) {\n        return visitor.visitExpressionType(this, context);\n    };\n    return ExpressionType;\n}(Type$1));\nvar ArrayType = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ArrayType, _super);\n    function ArrayType(of, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.of = of;\n        return _this;\n    }\n    ArrayType.prototype.visitType = function (visitor, context) {\n        return visitor.visitArrayType(this, context);\n    };\n    return ArrayType;\n}(Type$1));\nvar MapType = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(MapType, _super);\n    function MapType(valueType, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.valueType = valueType || null;\n        return _this;\n    }\n    MapType.prototype.visitType = function (visitor, context) { return visitor.visitMapType(this, context); };\n    return MapType;\n}(Type$1));\nvar DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nvar INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nvar BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nvar INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nvar NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nvar STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nvar FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nvar NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\n///// Expressions\nvar BinaryOperator;\n(function (BinaryOperator) {\n    BinaryOperator[BinaryOperator[\"Equals\"] = 0] = \"Equals\";\n    BinaryOperator[BinaryOperator[\"NotEquals\"] = 1] = \"NotEquals\";\n    BinaryOperator[BinaryOperator[\"Identical\"] = 2] = \"Identical\";\n    BinaryOperator[BinaryOperator[\"NotIdentical\"] = 3] = \"NotIdentical\";\n    BinaryOperator[BinaryOperator[\"Minus\"] = 4] = \"Minus\";\n    BinaryOperator[BinaryOperator[\"Plus\"] = 5] = \"Plus\";\n    BinaryOperator[BinaryOperator[\"Divide\"] = 6] = \"Divide\";\n    BinaryOperator[BinaryOperator[\"Multiply\"] = 7] = \"Multiply\";\n    BinaryOperator[BinaryOperator[\"Modulo\"] = 8] = \"Modulo\";\n    BinaryOperator[BinaryOperator[\"And\"] = 9] = \"And\";\n    BinaryOperator[BinaryOperator[\"Or\"] = 10] = \"Or\";\n    BinaryOperator[BinaryOperator[\"BitwiseAnd\"] = 11] = \"BitwiseAnd\";\n    BinaryOperator[BinaryOperator[\"Lower\"] = 12] = \"Lower\";\n    BinaryOperator[BinaryOperator[\"LowerEquals\"] = 13] = \"LowerEquals\";\n    BinaryOperator[BinaryOperator[\"Bigger\"] = 14] = \"Bigger\";\n    BinaryOperator[BinaryOperator[\"BiggerEquals\"] = 15] = \"BiggerEquals\";\n})(BinaryOperator || (BinaryOperator = {}));\nfunction nullSafeIsEquivalent(base, other) {\n    if (base == null || other == null) {\n        return base == other;\n    }\n    return base.isEquivalent(other);\n}\nfunction areAllEquivalent(base, other) {\n    var len = base.length;\n    if (len !== other.length) {\n        return false;\n    }\n    for (var i = 0; i < len; i++) {\n        if (!base[i].isEquivalent(other[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nvar Expression = /** @class */ (function () {\n    function Expression(type, sourceSpan) {\n        this.type = type || null;\n        this.sourceSpan = sourceSpan || null;\n    }\n    Expression.prototype.prop = function (name, sourceSpan) {\n        return new ReadPropExpr(this, name, null, sourceSpan);\n    };\n    Expression.prototype.key = function (index, type, sourceSpan) {\n        return new ReadKeyExpr(this, index, type, sourceSpan);\n    };\n    Expression.prototype.callMethod = function (name, params, sourceSpan) {\n        return new InvokeMethodExpr(this, name, params, null, sourceSpan);\n    };\n    Expression.prototype.callFn = function (params, sourceSpan) {\n        return new InvokeFunctionExpr(this, params, null, sourceSpan);\n    };\n    Expression.prototype.instantiate = function (params, type, sourceSpan) {\n        return new InstantiateExpr(this, params, type, sourceSpan);\n    };\n    Expression.prototype.conditional = function (trueCase, falseCase, sourceSpan) {\n        if (falseCase === void 0) { falseCase = null; }\n        return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n    };\n    Expression.prototype.equals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.notEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.identical = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.notIdentical = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.minus = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.plus = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.divide = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.multiply = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.modulo = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.and = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.bitwiseAnd = function (rhs, sourceSpan, parens) {\n        if (parens === void 0) { parens = true; }\n        return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);\n    };\n    Expression.prototype.or = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.lower = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.lowerEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.bigger = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.biggerEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.isBlank = function (sourceSpan) {\n        // Note: We use equals by purpose here to compare to null and undefined in JS.\n        // We use the typed null to allow strictNullChecks to narrow types.\n        return this.equals(TYPED_NULL_EXPR, sourceSpan);\n    };\n    Expression.prototype.cast = function (type, sourceSpan) {\n        return new CastExpr(this, type, sourceSpan);\n    };\n    Expression.prototype.toStmt = function () { return new ExpressionStatement(this, null); };\n    return Expression;\n}());\nvar BuiltinVar;\n(function (BuiltinVar) {\n    BuiltinVar[BuiltinVar[\"This\"] = 0] = \"This\";\n    BuiltinVar[BuiltinVar[\"Super\"] = 1] = \"Super\";\n    BuiltinVar[BuiltinVar[\"CatchError\"] = 2] = \"CatchError\";\n    BuiltinVar[BuiltinVar[\"CatchStack\"] = 3] = \"CatchStack\";\n})(BuiltinVar || (BuiltinVar = {}));\nvar ReadVarExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ReadVarExpr, _super);\n    function ReadVarExpr(name, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        if (typeof name === 'string') {\n            _this.name = name;\n            _this.builtin = null;\n        }\n        else {\n            _this.name = null;\n            _this.builtin = name;\n        }\n        return _this;\n    }\n    ReadVarExpr.prototype.isEquivalent = function (e) {\n        return e instanceof ReadVarExpr && this.name === e.name && this.builtin === e.builtin;\n    };\n    ReadVarExpr.prototype.isConstant = function () { return false; };\n    ReadVarExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadVarExpr(this, context);\n    };\n    ReadVarExpr.prototype.set = function (value) {\n        if (!this.name) {\n            throw new Error(\"Built in variable \" + this.builtin + \" can not be assigned to.\");\n        }\n        return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n    };\n    return ReadVarExpr;\n}(Expression));\nvar TypeofExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(TypeofExpr, _super);\n    function TypeofExpr(expr, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.expr = expr;\n        return _this;\n    }\n    TypeofExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitTypeofExpr(this, context);\n    };\n    TypeofExpr.prototype.isEquivalent = function (e) {\n        return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n    };\n    TypeofExpr.prototype.isConstant = function () { return this.expr.isConstant(); };\n    return TypeofExpr;\n}(Expression));\nvar WrappedNodeExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(WrappedNodeExpr, _super);\n    function WrappedNodeExpr(node, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.node = node;\n        return _this;\n    }\n    WrappedNodeExpr.prototype.isEquivalent = function (e) {\n        return e instanceof WrappedNodeExpr && this.node === e.node;\n    };\n    WrappedNodeExpr.prototype.isConstant = function () { return false; };\n    WrappedNodeExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWrappedNodeExpr(this, context);\n    };\n    return WrappedNodeExpr;\n}(Expression));\nvar WriteVarExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(WriteVarExpr, _super);\n    function WriteVarExpr(name, value, type, sourceSpan) {\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    WriteVarExpr.prototype.isEquivalent = function (e) {\n        return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\n    };\n    WriteVarExpr.prototype.isConstant = function () { return false; };\n    WriteVarExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWriteVarExpr(this, context);\n    };\n    WriteVarExpr.prototype.toDeclStmt = function (type, modifiers) {\n        return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n    };\n    WriteVarExpr.prototype.toConstDecl = function () { return this.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]); };\n    return WriteVarExpr;\n}(Expression));\nvar WriteKeyExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(WriteKeyExpr, _super);\n    function WriteKeyExpr(receiver, index, value, type, sourceSpan) {\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.index = index;\n        _this.value = value;\n        return _this;\n    }\n    WriteKeyExpr.prototype.isEquivalent = function (e) {\n        return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);\n    };\n    WriteKeyExpr.prototype.isConstant = function () { return false; };\n    WriteKeyExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWriteKeyExpr(this, context);\n    };\n    return WriteKeyExpr;\n}(Expression));\nvar WritePropExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(WritePropExpr, _super);\n    function WritePropExpr(receiver, name, value, type, sourceSpan) {\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    WritePropExpr.prototype.isEquivalent = function (e) {\n        return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.name === e.name && this.value.isEquivalent(e.value);\n    };\n    WritePropExpr.prototype.isConstant = function () { return false; };\n    WritePropExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWritePropExpr(this, context);\n    };\n    return WritePropExpr;\n}(Expression));\nvar BuiltinMethod;\n(function (BuiltinMethod) {\n    BuiltinMethod[BuiltinMethod[\"ConcatArray\"] = 0] = \"ConcatArray\";\n    BuiltinMethod[BuiltinMethod[\"SubscribeObservable\"] = 1] = \"SubscribeObservable\";\n    BuiltinMethod[BuiltinMethod[\"Bind\"] = 2] = \"Bind\";\n})(BuiltinMethod || (BuiltinMethod = {}));\nvar InvokeMethodExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(InvokeMethodExpr, _super);\n    function InvokeMethodExpr(receiver, method, args, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.args = args;\n        if (typeof method === 'string') {\n            _this.name = method;\n            _this.builtin = null;\n        }\n        else {\n            _this.name = null;\n            _this.builtin = method;\n        }\n        return _this;\n    }\n    InvokeMethodExpr.prototype.isEquivalent = function (e) {\n        return e instanceof InvokeMethodExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.name === e.name && this.builtin === e.builtin && areAllEquivalent(this.args, e.args);\n    };\n    InvokeMethodExpr.prototype.isConstant = function () { return false; };\n    InvokeMethodExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInvokeMethodExpr(this, context);\n    };\n    return InvokeMethodExpr;\n}(Expression));\nvar InvokeFunctionExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(InvokeFunctionExpr, _super);\n    function InvokeFunctionExpr(fn, args, type, sourceSpan, pure) {\n        if (pure === void 0) { pure = false; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.fn = fn;\n        _this.args = args;\n        _this.pure = pure;\n        return _this;\n    }\n    InvokeFunctionExpr.prototype.isEquivalent = function (e) {\n        return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&\n            areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n    };\n    InvokeFunctionExpr.prototype.isConstant = function () { return false; };\n    InvokeFunctionExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInvokeFunctionExpr(this, context);\n    };\n    return InvokeFunctionExpr;\n}(Expression));\nvar InstantiateExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(InstantiateExpr, _super);\n    function InstantiateExpr(classExpr, args, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.classExpr = classExpr;\n        _this.args = args;\n        return _this;\n    }\n    InstantiateExpr.prototype.isEquivalent = function (e) {\n        return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&\n            areAllEquivalent(this.args, e.args);\n    };\n    InstantiateExpr.prototype.isConstant = function () { return false; };\n    InstantiateExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInstantiateExpr(this, context);\n    };\n    return InstantiateExpr;\n}(Expression));\nvar LiteralExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(LiteralExpr, _super);\n    function LiteralExpr(value, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    LiteralExpr.prototype.isEquivalent = function (e) {\n        return e instanceof LiteralExpr && this.value === e.value;\n    };\n    LiteralExpr.prototype.isConstant = function () { return true; };\n    LiteralExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralExpr(this, context);\n    };\n    return LiteralExpr;\n}(Expression));\nvar ExternalExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ExternalExpr, _super);\n    function ExternalExpr(value, type, typeParams, sourceSpan) {\n        if (typeParams === void 0) { typeParams = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        _this.typeParams = typeParams;\n        return _this;\n    }\n    ExternalExpr.prototype.isEquivalent = function (e) {\n        return e instanceof ExternalExpr && this.value.name === e.value.name &&\n            this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;\n    };\n    ExternalExpr.prototype.isConstant = function () { return false; };\n    ExternalExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitExternalExpr(this, context);\n    };\n    return ExternalExpr;\n}(Expression));\nvar ExternalReference = /** @class */ (function () {\n    function ExternalReference(moduleName, name, runtime) {\n        this.moduleName = moduleName;\n        this.name = name;\n        this.runtime = runtime;\n    }\n    return ExternalReference;\n}());\nvar ConditionalExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ConditionalExpr, _super);\n    function ConditionalExpr(condition, trueCase, falseCase, type, sourceSpan) {\n        if (falseCase === void 0) { falseCase = null; }\n        var _this = _super.call(this, type || trueCase.type, sourceSpan) || this;\n        _this.condition = condition;\n        _this.falseCase = falseCase;\n        _this.trueCase = trueCase;\n        return _this;\n    }\n    ConditionalExpr.prototype.isEquivalent = function (e) {\n        return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&\n            this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n    };\n    ConditionalExpr.prototype.isConstant = function () { return false; };\n    ConditionalExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitConditionalExpr(this, context);\n    };\n    return ConditionalExpr;\n}(Expression));\nvar NotExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(NotExpr, _super);\n    function NotExpr(condition, sourceSpan) {\n        var _this = _super.call(this, BOOL_TYPE, sourceSpan) || this;\n        _this.condition = condition;\n        return _this;\n    }\n    NotExpr.prototype.isEquivalent = function (e) {\n        return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n    };\n    NotExpr.prototype.isConstant = function () { return false; };\n    NotExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitNotExpr(this, context);\n    };\n    return NotExpr;\n}(Expression));\nvar AssertNotNull = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(AssertNotNull, _super);\n    function AssertNotNull(condition, sourceSpan) {\n        var _this = _super.call(this, condition.type, sourceSpan) || this;\n        _this.condition = condition;\n        return _this;\n    }\n    AssertNotNull.prototype.isEquivalent = function (e) {\n        return e instanceof AssertNotNull && this.condition.isEquivalent(e.condition);\n    };\n    AssertNotNull.prototype.isConstant = function () { return false; };\n    AssertNotNull.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitAssertNotNullExpr(this, context);\n    };\n    return AssertNotNull;\n}(Expression));\nvar CastExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(CastExpr, _super);\n    function CastExpr(value, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    CastExpr.prototype.isEquivalent = function (e) {\n        return e instanceof CastExpr && this.value.isEquivalent(e.value);\n    };\n    CastExpr.prototype.isConstant = function () { return false; };\n    CastExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitCastExpr(this, context);\n    };\n    return CastExpr;\n}(Expression));\nvar FnParam = /** @class */ (function () {\n    function FnParam(name, type) {\n        if (type === void 0) { type = null; }\n        this.name = name;\n        this.type = type;\n    }\n    FnParam.prototype.isEquivalent = function (param) { return this.name === param.name; };\n    return FnParam;\n}());\nvar FunctionExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(FunctionExpr, _super);\n    function FunctionExpr(params, statements, type, sourceSpan, name) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.params = params;\n        _this.statements = statements;\n        _this.name = name;\n        return _this;\n    }\n    FunctionExpr.prototype.isEquivalent = function (e) {\n        return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&\n            areAllEquivalent(this.statements, e.statements);\n    };\n    FunctionExpr.prototype.isConstant = function () { return false; };\n    FunctionExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitFunctionExpr(this, context);\n    };\n    FunctionExpr.prototype.toDeclStmt = function (name, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n    };\n    return FunctionExpr;\n}(Expression));\nvar BinaryOperatorExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(BinaryOperatorExpr, _super);\n    function BinaryOperatorExpr(operator, lhs, rhs, type, sourceSpan, parens) {\n        if (parens === void 0) { parens = true; }\n        var _this = _super.call(this, type || lhs.type, sourceSpan) || this;\n        _this.operator = operator;\n        _this.rhs = rhs;\n        _this.parens = parens;\n        _this.lhs = lhs;\n        return _this;\n    }\n    BinaryOperatorExpr.prototype.isEquivalent = function (e) {\n        return e instanceof BinaryOperatorExpr && this.operator === e.operator &&\n            this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n    };\n    BinaryOperatorExpr.prototype.isConstant = function () { return false; };\n    BinaryOperatorExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitBinaryOperatorExpr(this, context);\n    };\n    return BinaryOperatorExpr;\n}(Expression));\nvar ReadPropExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ReadPropExpr, _super);\n    function ReadPropExpr(receiver, name, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    ReadPropExpr.prototype.isEquivalent = function (e) {\n        return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.name === e.name;\n    };\n    ReadPropExpr.prototype.isConstant = function () { return false; };\n    ReadPropExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadPropExpr(this, context);\n    };\n    ReadPropExpr.prototype.set = function (value) {\n        return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n    };\n    return ReadPropExpr;\n}(Expression));\nvar ReadKeyExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ReadKeyExpr, _super);\n    function ReadKeyExpr(receiver, index, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.index = index;\n        return _this;\n    }\n    ReadKeyExpr.prototype.isEquivalent = function (e) {\n        return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.index.isEquivalent(e.index);\n    };\n    ReadKeyExpr.prototype.isConstant = function () { return false; };\n    ReadKeyExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadKeyExpr(this, context);\n    };\n    ReadKeyExpr.prototype.set = function (value) {\n        return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n    };\n    return ReadKeyExpr;\n}(Expression));\nvar LiteralArrayExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(LiteralArrayExpr, _super);\n    function LiteralArrayExpr(entries, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.entries = entries;\n        return _this;\n    }\n    LiteralArrayExpr.prototype.isConstant = function () { return this.entries.every(function (e) { return e.isConstant(); }); };\n    LiteralArrayExpr.prototype.isEquivalent = function (e) {\n        return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n    };\n    LiteralArrayExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralArrayExpr(this, context);\n    };\n    return LiteralArrayExpr;\n}(Expression));\nvar LiteralMapEntry = /** @class */ (function () {\n    function LiteralMapEntry(key, value, quoted) {\n        this.key = key;\n        this.value = value;\n        this.quoted = quoted;\n    }\n    LiteralMapEntry.prototype.isEquivalent = function (e) {\n        return this.key === e.key && this.value.isEquivalent(e.value);\n    };\n    return LiteralMapEntry;\n}());\nvar LiteralMapExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(LiteralMapExpr, _super);\n    function LiteralMapExpr(entries, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.entries = entries;\n        _this.valueType = null;\n        if (type) {\n            _this.valueType = type.valueType;\n        }\n        return _this;\n    }\n    LiteralMapExpr.prototype.isEquivalent = function (e) {\n        return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n    };\n    LiteralMapExpr.prototype.isConstant = function () { return this.entries.every(function (e) { return e.value.isConstant(); }); };\n    LiteralMapExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralMapExpr(this, context);\n    };\n    return LiteralMapExpr;\n}(Expression));\nvar CommaExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(CommaExpr, _super);\n    function CommaExpr(parts, sourceSpan) {\n        var _this = _super.call(this, parts[parts.length - 1].type, sourceSpan) || this;\n        _this.parts = parts;\n        return _this;\n    }\n    CommaExpr.prototype.isEquivalent = function (e) {\n        return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n    };\n    CommaExpr.prototype.isConstant = function () { return false; };\n    CommaExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitCommaExpr(this, context);\n    };\n    return CommaExpr;\n}(Expression));\nvar THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);\nvar SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);\nvar CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);\nvar CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);\nvar NULL_EXPR = new LiteralExpr(null, null, null);\nvar TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\n//// Statements\nvar StmtModifier;\n(function (StmtModifier) {\n    StmtModifier[StmtModifier[\"Final\"] = 0] = \"Final\";\n    StmtModifier[StmtModifier[\"Private\"] = 1] = \"Private\";\n    StmtModifier[StmtModifier[\"Exported\"] = 2] = \"Exported\";\n    StmtModifier[StmtModifier[\"Static\"] = 3] = \"Static\";\n})(StmtModifier || (StmtModifier = {}));\nvar Statement = /** @class */ (function () {\n    function Statement(modifiers, sourceSpan) {\n        this.modifiers = modifiers || [];\n        this.sourceSpan = sourceSpan || null;\n    }\n    Statement.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };\n    return Statement;\n}());\nvar DeclareVarStmt = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(DeclareVarStmt, _super);\n    function DeclareVarStmt(name, value, type, modifiers, sourceSpan) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.value = value;\n        _this.type = type || (value && value.type) || null;\n        return _this;\n    }\n    DeclareVarStmt.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof DeclareVarStmt && this.name === stmt.name &&\n            (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n    };\n    DeclareVarStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareVarStmt(this, context);\n    };\n    return DeclareVarStmt;\n}(Statement));\nvar DeclareFunctionStmt = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(DeclareFunctionStmt, _super);\n    function DeclareFunctionStmt(name, params, statements, type, modifiers, sourceSpan) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.params = params;\n        _this.statements = statements;\n        _this.type = type || null;\n        return _this;\n    }\n    DeclareFunctionStmt.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&\n            areAllEquivalent(this.statements, stmt.statements);\n    };\n    DeclareFunctionStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareFunctionStmt(this, context);\n    };\n    return DeclareFunctionStmt;\n}(Statement));\nvar ExpressionStatement = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ExpressionStatement, _super);\n    function ExpressionStatement(expr, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.expr = expr;\n        return _this;\n    }\n    ExpressionStatement.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n    };\n    ExpressionStatement.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitExpressionStmt(this, context);\n    };\n    return ExpressionStatement;\n}(Statement));\nvar ReturnStatement = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ReturnStatement, _super);\n    function ReturnStatement(value, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    ReturnStatement.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n    };\n    ReturnStatement.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitReturnStmt(this, context);\n    };\n    return ReturnStatement;\n}(Statement));\nvar AbstractClassPart = /** @class */ (function () {\n    function AbstractClassPart(type, modifiers) {\n        this.modifiers = modifiers;\n        if (!modifiers) {\n            this.modifiers = [];\n        }\n        this.type = type || null;\n    }\n    AbstractClassPart.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };\n    return AbstractClassPart;\n}());\nvar ClassField = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ClassField, _super);\n    function ClassField(name, type, modifiers, initializer) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        _this.initializer = initializer;\n        return _this;\n    }\n    ClassField.prototype.isEquivalent = function (f) { return this.name === f.name; };\n    return ClassField;\n}(AbstractClassPart));\nvar ClassMethod = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ClassMethod, _super);\n    function ClassMethod(name, params, body, type, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        _this.params = params;\n        _this.body = body;\n        return _this;\n    }\n    ClassMethod.prototype.isEquivalent = function (m) {\n        return this.name === m.name && areAllEquivalent(this.body, m.body);\n    };\n    return ClassMethod;\n}(AbstractClassPart));\nvar ClassGetter = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ClassGetter, _super);\n    function ClassGetter(name, body, type, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        _this.body = body;\n        return _this;\n    }\n    ClassGetter.prototype.isEquivalent = function (m) {\n        return this.name === m.name && areAllEquivalent(this.body, m.body);\n    };\n    return ClassGetter;\n}(AbstractClassPart));\nvar ClassStmt = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ClassStmt, _super);\n    function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers, sourceSpan) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.parent = parent;\n        _this.fields = fields;\n        _this.getters = getters;\n        _this.constructorMethod = constructorMethod;\n        _this.methods = methods;\n        return _this;\n    }\n    ClassStmt.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof ClassStmt && this.name === stmt.name &&\n            nullSafeIsEquivalent(this.parent, stmt.parent) &&\n            areAllEquivalent(this.fields, stmt.fields) &&\n            areAllEquivalent(this.getters, stmt.getters) &&\n            this.constructorMethod.isEquivalent(stmt.constructorMethod) &&\n            areAllEquivalent(this.methods, stmt.methods);\n    };\n    ClassStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareClassStmt(this, context);\n    };\n    return ClassStmt;\n}(Statement));\nvar IfStmt = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(IfStmt, _super);\n    function IfStmt(condition, trueCase, falseCase, sourceSpan) {\n        if (falseCase === void 0) { falseCase = []; }\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.condition = condition;\n        _this.trueCase = trueCase;\n        _this.falseCase = falseCase;\n        return _this;\n    }\n    IfStmt.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&\n            areAllEquivalent(this.trueCase, stmt.trueCase) &&\n            areAllEquivalent(this.falseCase, stmt.falseCase);\n    };\n    IfStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitIfStmt(this, context);\n    };\n    return IfStmt;\n}(Statement));\nvar CommentStmt = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(CommentStmt, _super);\n    function CommentStmt(comment, multiline, sourceSpan) {\n        if (multiline === void 0) { multiline = false; }\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.comment = comment;\n        _this.multiline = multiline;\n        return _this;\n    }\n    CommentStmt.prototype.isEquivalent = function (stmt) { return stmt instanceof CommentStmt; };\n    CommentStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitCommentStmt(this, context);\n    };\n    return CommentStmt;\n}(Statement));\nvar JSDocCommentStmt = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(JSDocCommentStmt, _super);\n    function JSDocCommentStmt(tags, sourceSpan) {\n        if (tags === void 0) { tags = []; }\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.tags = tags;\n        return _this;\n    }\n    JSDocCommentStmt.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof JSDocCommentStmt && this.toString() === stmt.toString();\n    };\n    JSDocCommentStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitJSDocCommentStmt(this, context);\n    };\n    JSDocCommentStmt.prototype.toString = function () { return serializeTags(this.tags); };\n    return JSDocCommentStmt;\n}(Statement));\nvar TryCatchStmt = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(TryCatchStmt, _super);\n    function TryCatchStmt(bodyStmts, catchStmts, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.bodyStmts = bodyStmts;\n        _this.catchStmts = catchStmts;\n        return _this;\n    }\n    TryCatchStmt.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof TryCatchStmt && areAllEquivalent(this.bodyStmts, stmt.bodyStmts) &&\n            areAllEquivalent(this.catchStmts, stmt.catchStmts);\n    };\n    TryCatchStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitTryCatchStmt(this, context);\n    };\n    return TryCatchStmt;\n}(Statement));\nvar ThrowStmt = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ThrowStmt, _super);\n    function ThrowStmt(error, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.error = error;\n        return _this;\n    }\n    ThrowStmt.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof TryCatchStmt && this.error.isEquivalent(stmt.error);\n    };\n    ThrowStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitThrowStmt(this, context);\n    };\n    return ThrowStmt;\n}(Statement));\nvar AstTransformer = /** @class */ (function () {\n    function AstTransformer() {\n    }\n    AstTransformer.prototype.transformExpr = function (expr, context) { return expr; };\n    AstTransformer.prototype.transformStmt = function (stmt, context) { return stmt; };\n    AstTransformer.prototype.visitReadVarExpr = function (ast, context) { return this.transformExpr(ast, context); };\n    AstTransformer.prototype.visitWrappedNodeExpr = function (ast, context) {\n        return this.transformExpr(ast, context);\n    };\n    AstTransformer.prototype.visitTypeofExpr = function (expr, context) {\n        return this.transformExpr(new TypeofExpr(expr.expr.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitWriteVarExpr = function (expr, context) {\n        return this.transformExpr(new WriteVarExpr(expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitWriteKeyExpr = function (expr, context) {\n        return this.transformExpr(new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitWritePropExpr = function (expr, context) {\n        return this.transformExpr(new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitInvokeMethodExpr = function (ast, context) {\n        var method = ast.builtin || ast.name;\n        return this.transformExpr(new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitInvokeFunctionExpr = function (ast, context) {\n        return this.transformExpr(new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitInstantiateExpr = function (ast, context) {\n        return this.transformExpr(new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitLiteralExpr = function (ast, context) { return this.transformExpr(ast, context); };\n    AstTransformer.prototype.visitExternalExpr = function (ast, context) {\n        return this.transformExpr(ast, context);\n    };\n    AstTransformer.prototype.visitConditionalExpr = function (ast, context) {\n        return this.transformExpr(new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitNotExpr = function (ast, context) {\n        return this.transformExpr(new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitAssertNotNullExpr = function (ast, context) {\n        return this.transformExpr(new AssertNotNull(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitCastExpr = function (ast, context) {\n        return this.transformExpr(new CastExpr(ast.value.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitFunctionExpr = function (ast, context) {\n        return this.transformExpr(new FunctionExpr(ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitBinaryOperatorExpr = function (ast, context) {\n        return this.transformExpr(new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitReadPropExpr = function (ast, context) {\n        return this.transformExpr(new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitReadKeyExpr = function (ast, context) {\n        return this.transformExpr(new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitLiteralArrayExpr = function (ast, context) {\n        return this.transformExpr(new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitLiteralMapExpr = function (ast, context) {\n        var _this = this;\n        var entries = ast.entries.map(function (entry) { return new LiteralMapEntry(entry.key, entry.value.visitExpression(_this, context), entry.quoted); });\n        var mapType = new MapType(ast.valueType, null);\n        return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitCommaExpr = function (ast, context) {\n        return this.transformExpr(new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitAllExpressions = function (exprs, context) {\n        var _this = this;\n        return exprs.map(function (expr) { return expr.visitExpression(_this, context); });\n    };\n    AstTransformer.prototype.visitDeclareVarStmt = function (stmt, context) {\n        var value = stmt.value && stmt.value.visitExpression(this, context);\n        return this.transformStmt(new DeclareVarStmt(stmt.name, value, stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        return this.transformStmt(new DeclareFunctionStmt(stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitExpressionStmt = function (stmt, context) {\n        return this.transformStmt(new ExpressionStatement(stmt.expr.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitReturnStmt = function (stmt, context) {\n        return this.transformStmt(new ReturnStatement(stmt.value.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitDeclareClassStmt = function (stmt, context) {\n        var _this = this;\n        var parent = stmt.parent.visitExpression(this, context);\n        var getters = stmt.getters.map(function (getter) { return new ClassGetter(getter.name, _this.visitAllStatements(getter.body, context), getter.type, getter.modifiers); });\n        var ctorMethod = stmt.constructorMethod &&\n            new ClassMethod(stmt.constructorMethod.name, stmt.constructorMethod.params, this.visitAllStatements(stmt.constructorMethod.body, context), stmt.constructorMethod.type, stmt.constructorMethod.modifiers);\n        var methods = stmt.methods.map(function (method) { return new ClassMethod(method.name, method.params, _this.visitAllStatements(method.body, context), method.type, method.modifiers); });\n        return this.transformStmt(new ClassStmt(stmt.name, parent, stmt.fields, getters, ctorMethod, methods, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitIfStmt = function (stmt, context) {\n        return this.transformStmt(new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitTryCatchStmt = function (stmt, context) {\n        return this.transformStmt(new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitThrowStmt = function (stmt, context) {\n        return this.transformStmt(new ThrowStmt(stmt.error.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitCommentStmt = function (stmt, context) {\n        return this.transformStmt(stmt, context);\n    };\n    AstTransformer.prototype.visitJSDocCommentStmt = function (stmt, context) {\n        return this.transformStmt(stmt, context);\n    };\n    AstTransformer.prototype.visitAllStatements = function (stmts, context) {\n        var _this = this;\n        return stmts.map(function (stmt) { return stmt.visitStatement(_this, context); });\n    };\n    return AstTransformer;\n}());\nvar RecursiveAstVisitor = /** @class */ (function () {\n    function RecursiveAstVisitor() {\n    }\n    RecursiveAstVisitor.prototype.visitType = function (ast, context) { return ast; };\n    RecursiveAstVisitor.prototype.visitExpression = function (ast, context) {\n        if (ast.type) {\n            ast.type.visitType(this, context);\n        }\n        return ast;\n    };\n    RecursiveAstVisitor.prototype.visitBuiltinType = function (type, context) { return this.visitType(type, context); };\n    RecursiveAstVisitor.prototype.visitExpressionType = function (type, context) {\n        var _this = this;\n        type.value.visitExpression(this, context);\n        if (type.typeParams !== null) {\n            type.typeParams.forEach(function (param) { return _this.visitType(param, context); });\n        }\n        return this.visitType(type, context);\n    };\n    RecursiveAstVisitor.prototype.visitArrayType = function (type, context) { return this.visitType(type, context); };\n    RecursiveAstVisitor.prototype.visitMapType = function (type, context) { return this.visitType(type, context); };\n    RecursiveAstVisitor.prototype.visitWrappedNodeExpr = function (ast, context) { return ast; };\n    RecursiveAstVisitor.prototype.visitTypeofExpr = function (ast, context) { return this.visitExpression(ast, context); };\n    RecursiveAstVisitor.prototype.visitReadVarExpr = function (ast, context) {\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitWriteVarExpr = function (ast, context) {\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitWriteKeyExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.index.visitExpression(this, context);\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitWritePropExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitInvokeMethodExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitInvokeFunctionExpr = function (ast, context) {\n        ast.fn.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitInstantiateExpr = function (ast, context) {\n        ast.classExpr.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitLiteralExpr = function (ast, context) {\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitExternalExpr = function (ast, context) {\n        var _this = this;\n        if (ast.typeParams) {\n            ast.typeParams.forEach(function (type) { return type.visitType(_this, context); });\n        }\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitConditionalExpr = function (ast, context) {\n        ast.condition.visitExpression(this, context);\n        ast.trueCase.visitExpression(this, context);\n        ast.falseCase.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitNotExpr = function (ast, context) {\n        ast.condition.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitAssertNotNullExpr = function (ast, context) {\n        ast.condition.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitCastExpr = function (ast, context) {\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitFunctionExpr = function (ast, context) {\n        this.visitAllStatements(ast.statements, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitBinaryOperatorExpr = function (ast, context) {\n        ast.lhs.visitExpression(this, context);\n        ast.rhs.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitReadPropExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitReadKeyExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.index.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitLiteralArrayExpr = function (ast, context) {\n        this.visitAllExpressions(ast.entries, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitLiteralMapExpr = function (ast, context) {\n        var _this = this;\n        ast.entries.forEach(function (entry) { return entry.value.visitExpression(_this, context); });\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitCommaExpr = function (ast, context) {\n        this.visitAllExpressions(ast.parts, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitAllExpressions = function (exprs, context) {\n        var _this = this;\n        exprs.forEach(function (expr) { return expr.visitExpression(_this, context); });\n    };\n    RecursiveAstVisitor.prototype.visitDeclareVarStmt = function (stmt, context) {\n        if (stmt.value) {\n            stmt.value.visitExpression(this, context);\n        }\n        if (stmt.type) {\n            stmt.type.visitType(this, context);\n        }\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        this.visitAllStatements(stmt.statements, context);\n        if (stmt.type) {\n            stmt.type.visitType(this, context);\n        }\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitExpressionStmt = function (stmt, context) {\n        stmt.expr.visitExpression(this, context);\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitReturnStmt = function (stmt, context) {\n        stmt.value.visitExpression(this, context);\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitDeclareClassStmt = function (stmt, context) {\n        var _this = this;\n        stmt.parent.visitExpression(this, context);\n        stmt.getters.forEach(function (getter) { return _this.visitAllStatements(getter.body, context); });\n        if (stmt.constructorMethod) {\n            this.visitAllStatements(stmt.constructorMethod.body, context);\n        }\n        stmt.methods.forEach(function (method) { return _this.visitAllStatements(method.body, context); });\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitIfStmt = function (stmt, context) {\n        stmt.condition.visitExpression(this, context);\n        this.visitAllStatements(stmt.trueCase, context);\n        this.visitAllStatements(stmt.falseCase, context);\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitTryCatchStmt = function (stmt, context) {\n        this.visitAllStatements(stmt.bodyStmts, context);\n        this.visitAllStatements(stmt.catchStmts, context);\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitThrowStmt = function (stmt, context) {\n        stmt.error.visitExpression(this, context);\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitCommentStmt = function (stmt, context) { return stmt; };\n    RecursiveAstVisitor.prototype.visitJSDocCommentStmt = function (stmt, context) { return stmt; };\n    RecursiveAstVisitor.prototype.visitAllStatements = function (stmts, context) {\n        var _this = this;\n        stmts.forEach(function (stmt) { return stmt.visitStatement(_this, context); });\n    };\n    return RecursiveAstVisitor;\n}());\nfunction findReadVarNames(stmts) {\n    var visitor = new _ReadVarVisitor();\n    visitor.visitAllStatements(stmts, null);\n    return visitor.varNames;\n}\nvar _ReadVarVisitor = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(_ReadVarVisitor, _super);\n    function _ReadVarVisitor() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.varNames = new Set();\n        return _this;\n    }\n    _ReadVarVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        // Don't descend into nested functions\n        return stmt;\n    };\n    _ReadVarVisitor.prototype.visitDeclareClassStmt = function (stmt, context) {\n        // Don't descend into nested classes\n        return stmt;\n    };\n    _ReadVarVisitor.prototype.visitReadVarExpr = function (ast, context) {\n        if (ast.name) {\n            this.varNames.add(ast.name);\n        }\n        return null;\n    };\n    return _ReadVarVisitor;\n}(RecursiveAstVisitor));\nfunction collectExternalReferences(stmts) {\n    var visitor = new _FindExternalReferencesVisitor();\n    visitor.visitAllStatements(stmts, null);\n    return visitor.externalReferences;\n}\nvar _FindExternalReferencesVisitor = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(_FindExternalReferencesVisitor, _super);\n    function _FindExternalReferencesVisitor() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.externalReferences = [];\n        return _this;\n    }\n    _FindExternalReferencesVisitor.prototype.visitExternalExpr = function (e, context) {\n        this.externalReferences.push(e.value);\n        return _super.prototype.visitExternalExpr.call(this, e, context);\n    };\n    return _FindExternalReferencesVisitor;\n}(RecursiveAstVisitor));\nfunction applySourceSpanToStatementIfNeeded(stmt, sourceSpan) {\n    if (!sourceSpan) {\n        return stmt;\n    }\n    var transformer = new _ApplySourceSpanTransformer(sourceSpan);\n    return stmt.visitStatement(transformer, null);\n}\nfunction applySourceSpanToExpressionIfNeeded(expr, sourceSpan) {\n    if (!sourceSpan) {\n        return expr;\n    }\n    var transformer = new _ApplySourceSpanTransformer(sourceSpan);\n    return expr.visitExpression(transformer, null);\n}\nvar _ApplySourceSpanTransformer = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(_ApplySourceSpanTransformer, _super);\n    function _ApplySourceSpanTransformer(sourceSpan) {\n        var _this = _super.call(this) || this;\n        _this.sourceSpan = sourceSpan;\n        return _this;\n    }\n    _ApplySourceSpanTransformer.prototype._clone = function (obj) {\n        var e_1, _a;\n        var clone = Object.create(obj.constructor.prototype);\n        try {\n            for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var prop = _c.value;\n                clone[prop] = obj[prop];\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return clone;\n    };\n    _ApplySourceSpanTransformer.prototype.transformExpr = function (expr, context) {\n        if (!expr.sourceSpan) {\n            expr = this._clone(expr);\n            expr.sourceSpan = this.sourceSpan;\n        }\n        return expr;\n    };\n    _ApplySourceSpanTransformer.prototype.transformStmt = function (stmt, context) {\n        if (!stmt.sourceSpan) {\n            stmt = this._clone(stmt);\n            stmt.sourceSpan = this.sourceSpan;\n        }\n        return stmt;\n    };\n    return _ApplySourceSpanTransformer;\n}(AstTransformer));\nfunction variable(name, type, sourceSpan) {\n    return new ReadVarExpr(name, type, sourceSpan);\n}\nfunction importExpr(id, typeParams, sourceSpan) {\n    if (typeParams === void 0) { typeParams = null; }\n    return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\nfunction importType(id, typeParams, typeModifiers) {\n    if (typeParams === void 0) { typeParams = null; }\n    if (typeModifiers === void 0) { typeModifiers = null; }\n    return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\nfunction expressionType(expr, typeModifiers, typeParams) {\n    if (typeModifiers === void 0) { typeModifiers = null; }\n    if (typeParams === void 0) { typeParams = null; }\n    return new ExpressionType(expr, typeModifiers, typeParams);\n}\nfunction typeofExpr(expr) {\n    return new TypeofExpr(expr);\n}\nfunction literalArr(values, type, sourceSpan) {\n    return new LiteralArrayExpr(values, type, sourceSpan);\n}\nfunction literalMap(values, type) {\n    if (type === void 0) { type = null; }\n    return new LiteralMapExpr(values.map(function (e) { return new LiteralMapEntry(e.key, e.value, e.quoted); }), type, null);\n}\nfunction not(expr, sourceSpan) {\n    return new NotExpr(expr, sourceSpan);\n}\nfunction assertNotNull(expr, sourceSpan) {\n    return new AssertNotNull(expr, sourceSpan);\n}\nfunction fn(params, body, type, sourceSpan, name) {\n    return new FunctionExpr(params, body, type, sourceSpan, name);\n}\nfunction ifStmt(condition, thenClause, elseClause) {\n    return new IfStmt(condition, thenClause, elseClause);\n}\nfunction literal(value, type, sourceSpan) {\n    return new LiteralExpr(value, type, sourceSpan);\n}\nfunction isNull(exp) {\n    return exp instanceof LiteralExpr && exp.value === null;\n}\n/*\n * Serializes a `Tag` into a string.\n * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\n */\nfunction tagToString(tag) {\n    var out = '';\n    if (tag.tagName) {\n        out += \" @\" + tag.tagName;\n    }\n    if (tag.text) {\n        if (tag.text.match(/\\/\\*|\\*\\//)) {\n            throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n        }\n        out += ' ' + tag.text.replace(/@/g, '\\\\@');\n    }\n    return out;\n}\nfunction serializeTags(tags) {\n    var e_2, _a;\n    if (tags.length === 0)\n        return '';\n    var out = '*\\n';\n    try {\n        for (var tags_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(tags), tags_1_1 = tags_1.next(); !tags_1_1.done; tags_1_1 = tags_1.next()) {\n            var tag = tags_1_1.value;\n            out += ' *';\n            // If the tagToString is multi-line, insert \" * \" prefixes on subsequent lines.\n            out += tagToString(tag).replace(/\\n/g, '\\n * ');\n            out += '\\n';\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (tags_1_1 && !tags_1_1.done && (_a = tags_1.return)) _a.call(tags_1);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    out += ' ';\n    return out;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar DASH_CASE_REGEXP = /-+([a-z0-9])/g;\nfunction dashCaseToCamelCase(input) {\n    return input.replace(DASH_CASE_REGEXP, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        return m[1].toUpperCase();\n    });\n}\nfunction splitAtColon(input, defaultValues) {\n    return _splitAt(input, ':', defaultValues);\n}\nfunction splitAtPeriod(input, defaultValues) {\n    return _splitAt(input, '.', defaultValues);\n}\nfunction _splitAt(input, character, defaultValues) {\n    var characterIndex = input.indexOf(character);\n    if (characterIndex == -1)\n        return defaultValues;\n    return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\nfunction visitValue(value, visitor, context) {\n    if (Array.isArray(value)) {\n        return visitor.visitArray(value, context);\n    }\n    if (isStrictStringMap(value)) {\n        return visitor.visitStringMap(value, context);\n    }\n    if (value == null || typeof value == 'string' || typeof value == 'number' ||\n        typeof value == 'boolean') {\n        return visitor.visitPrimitive(value, context);\n    }\n    return visitor.visitOther(value, context);\n}\nfunction isDefined(val) {\n    return val !== null && val !== undefined;\n}\nfunction noUndefined(val) {\n    return val === undefined ? null : val;\n}\nvar ValueTransformer = /** @class */ (function () {\n    function ValueTransformer() {\n    }\n    ValueTransformer.prototype.visitArray = function (arr, context) {\n        var _this = this;\n        return arr.map(function (value) { return visitValue(value, _this, context); });\n    };\n    ValueTransformer.prototype.visitStringMap = function (map, context) {\n        var _this = this;\n        var result = {};\n        Object.keys(map).forEach(function (key) { result[key] = visitValue(map[key], _this, context); });\n        return result;\n    };\n    ValueTransformer.prototype.visitPrimitive = function (value, context) { return value; };\n    ValueTransformer.prototype.visitOther = function (value, context) { return value; };\n    return ValueTransformer;\n}());\nvar SyncAsync = {\n    assertSync: function (value) {\n        if (isPromise(value)) {\n            throw new Error(\"Illegal state: value cannot be a promise\");\n        }\n        return value;\n    },\n    then: function (value, cb) { return isPromise(value) ? value.then(cb) : cb(value); },\n    all: function (syncAsyncValues) {\n        return syncAsyncValues.some(isPromise) ? Promise.all(syncAsyncValues) : syncAsyncValues;\n    }\n};\nfunction error(msg) {\n    throw new Error(\"Internal Error: \" + msg);\n}\nfunction syntaxError(msg, parseErrors) {\n    var error = Error(msg);\n    error[ERROR_SYNTAX_ERROR] = true;\n    if (parseErrors)\n        error[ERROR_PARSE_ERRORS] = parseErrors;\n    return error;\n}\nvar ERROR_SYNTAX_ERROR = 'ngSyntaxError';\nvar ERROR_PARSE_ERRORS = 'ngParseErrors';\nfunction isSyntaxError(error) {\n    return error[ERROR_SYNTAX_ERROR];\n}\nfunction getParseErrors(error) {\n    return error[ERROR_PARSE_ERRORS] || [];\n}\n// Escape characters that have a special meaning in Regular Expressions\nfunction escapeRegExp(s) {\n    return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\nvar STRING_MAP_PROTO = Object.getPrototypeOf({});\nfunction isStrictStringMap(obj) {\n    return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n}\nfunction utf8Encode(str) {\n    var encoded = '';\n    for (var index = 0; index < str.length; index++) {\n        var codePoint = str.charCodeAt(index);\n        // decode surrogate\n        // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n            var low = str.charCodeAt(index + 1);\n            if (low >= 0xdc00 && low <= 0xdfff) {\n                index++;\n                codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n            }\n        }\n        if (codePoint <= 0x7f) {\n            encoded += String.fromCharCode(codePoint);\n        }\n        else if (codePoint <= 0x7ff) {\n            encoded += String.fromCharCode(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0xffff) {\n            encoded += String.fromCharCode((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0x1fffff) {\n            encoded += String.fromCharCode(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n    }\n    return encoded;\n}\nfunction stringify(token) {\n    if (typeof token === 'string') {\n        return token;\n    }\n    if (token instanceof Array) {\n        return '[' + token.map(stringify).join(', ') + ']';\n    }\n    if (token == null) {\n        return '' + token;\n    }\n    if (token.overriddenName) {\n        return \"\" + token.overriddenName;\n    }\n    if (token.name) {\n        return \"\" + token.name;\n    }\n    if (!token.toString) {\n        return 'object';\n    }\n    // WARNING: do not try to `JSON.stringify(token)` here\n    // see https://github.com/angular/angular/issues/23440\n    var res = token.toString();\n    if (res == null) {\n        return '' + res;\n    }\n    var newLineIndex = res.indexOf('\\n');\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n/**\n * Lazily retrieves the reference value from a forwardRef.\n */\nfunction resolveForwardRef(type) {\n    if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__')) {\n        return type();\n    }\n    else {\n        return type;\n    }\n}\n/**\n * Determine if the argument is shaped like a Promise\n */\nfunction isPromise(obj) {\n    // allow any Promise/A+ compliant thenable.\n    // It's up to the caller to ensure that obj.then conforms to the spec\n    return !!obj && typeof obj.then === 'function';\n}\nvar Version = /** @class */ (function () {\n    function Version(full) {\n        this.full = full;\n        var splits = full.split('.');\n        this.major = splits[0];\n        this.minor = splits[1];\n        this.patch = splits.slice(2).join('.');\n    }\n    return Version;\n}());\nvar __window = typeof window !== 'undefined' && window;\nvar __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nvar __global = typeof global !== 'undefined' && global;\n// Check __global first, because in Node tests both __global and __window may be defined and _global\n// should be __global in that case.\nvar _global = __global || __window || __self;\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CONSTANT_PREFIX = '_c';\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nvar KEY_CONTEXT = {};\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nvar FixupExpression = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(FixupExpression, _super);\n    function FixupExpression(resolved) {\n        var _this = _super.call(this, resolved.type) || this;\n        _this.resolved = resolved;\n        _this.original = resolved;\n        return _this;\n    }\n    FixupExpression.prototype.visitExpression = function (visitor, context) {\n        if (context === KEY_CONTEXT) {\n            // When producing a key we want to traverse the constant not the\n            // variable used to refer to it.\n            return this.original.visitExpression(visitor, context);\n        }\n        else {\n            return this.resolved.visitExpression(visitor, context);\n        }\n    };\n    FixupExpression.prototype.isEquivalent = function (e) {\n        return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n    };\n    FixupExpression.prototype.isConstant = function () { return true; };\n    FixupExpression.prototype.fixup = function (expression) {\n        this.resolved = expression;\n        this.shared = true;\n    };\n    return FixupExpression;\n}(Expression));\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nvar ConstantPool = /** @class */ (function () {\n    function ConstantPool() {\n        this.statements = [];\n        this.literals = new Map();\n        this.literalFactories = new Map();\n        this.injectorDefinitions = new Map();\n        this.directiveDefinitions = new Map();\n        this.componentDefinitions = new Map();\n        this.pipeDefinitions = new Map();\n        this.nextNameIndex = 0;\n    }\n    ConstantPool.prototype.getConstLiteral = function (literal, forceShared) {\n        if (literal instanceof LiteralExpr || literal instanceof FixupExpression) {\n            // Do no put simple literals into the constant pool or try to produce a constant for a\n            // reference to a constant.\n            return literal;\n        }\n        var key = this.keyOf(literal);\n        var fixup = this.literals.get(key);\n        var newValue = false;\n        if (!fixup) {\n            fixup = new FixupExpression(literal);\n            this.literals.set(key, fixup);\n            newValue = true;\n        }\n        if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n            // Replace the expression with a variable\n            var name_1 = this.freshName();\n            this.statements.push(variable(name_1).set(literal).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));\n            fixup.fixup(variable(name_1));\n        }\n        return fixup;\n    };\n    ConstantPool.prototype.getDefinition = function (type, kind, ctx, forceShared) {\n        if (forceShared === void 0) { forceShared = false; }\n        var definitions = this.definitionsOf(kind);\n        var fixup = definitions.get(type);\n        var newValue = false;\n        if (!fixup) {\n            var property = this.propertyNameOf(kind);\n            fixup = new FixupExpression(ctx.importExpr(type).prop(property));\n            definitions.set(type, fixup);\n            newValue = true;\n        }\n        if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n            var name_2 = this.freshName();\n            this.statements.push(variable(name_2).set(fixup.resolved).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));\n            fixup.fixup(variable(name_2));\n        }\n        return fixup;\n    };\n    ConstantPool.prototype.getLiteralFactory = function (literal$1) {\n        // Create a pure function that builds an array of a mix of constant  and variable expressions\n        if (literal$1 instanceof LiteralArrayExpr) {\n            var argumentsForKey = literal$1.entries.map(function (e) { return e.isConstant() ? e : literal(null); });\n            var key = this.keyOf(literalArr(argumentsForKey));\n            return this._getLiteralFactory(key, literal$1.entries, function (entries) { return literalArr(entries); });\n        }\n        else {\n            var expressionForKey = literalMap(literal$1.entries.map(function (e) { return ({\n                key: e.key,\n                value: e.value.isConstant() ? e.value : literal(null),\n                quoted: e.quoted\n            }); }));\n            var key = this.keyOf(expressionForKey);\n            return this._getLiteralFactory(key, literal$1.entries.map(function (e) { return e.value; }), function (entries) { return literalMap(entries.map(function (value, index) { return ({\n                key: literal$1.entries[index].key,\n                value: value,\n                quoted: literal$1.entries[index].quoted\n            }); })); });\n        }\n    };\n    ConstantPool.prototype._getLiteralFactory = function (key, values, resultMap) {\n        var _this = this;\n        var literalFactory = this.literalFactories.get(key);\n        var literalFactoryArguments = values.filter((function (e) { return !e.isConstant(); }));\n        if (!literalFactory) {\n            var resultExpressions = values.map(function (e, index) { return e.isConstant() ? _this.getConstLiteral(e, true) : variable(\"a\" + index); });\n            var parameters = resultExpressions.filter(isVariable).map(function (e) { return new FnParam(e.name, DYNAMIC_TYPE); });\n            var pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);\n            var name_3 = this.freshName();\n            this.statements.push(variable(name_3).set(pureFunctionDeclaration).toDeclStmt(INFERRED_TYPE, [\n                StmtModifier.Final\n            ]));\n            literalFactory = variable(name_3);\n            this.literalFactories.set(key, literalFactory);\n        }\n        return { literalFactory: literalFactory, literalFactoryArguments: literalFactoryArguments };\n    };\n    /**\n     * Produce a unique name.\n     *\n     * The name might be unique among different prefixes if any of the prefixes end in\n     * a digit so the prefix should be a constant string (not based on user input) and\n     * must not end in a digit.\n     */\n    ConstantPool.prototype.uniqueName = function (prefix) { return \"\" + prefix + this.nextNameIndex++; };\n    ConstantPool.prototype.definitionsOf = function (kind) {\n        switch (kind) {\n            case 2 /* Component */:\n                return this.componentDefinitions;\n            case 1 /* Directive */:\n                return this.directiveDefinitions;\n            case 0 /* Injector */:\n                return this.injectorDefinitions;\n            case 3 /* Pipe */:\n                return this.pipeDefinitions;\n        }\n        error(\"Unknown definition kind \" + kind);\n        return this.componentDefinitions;\n    };\n    ConstantPool.prototype.propertyNameOf = function (kind) {\n        switch (kind) {\n            case 2 /* Component */:\n                return 'ngComponentDef';\n            case 1 /* Directive */:\n                return 'ngDirectiveDef';\n            case 0 /* Injector */:\n                return 'ngInjectorDef';\n            case 3 /* Pipe */:\n                return 'ngPipeDef';\n        }\n        error(\"Unknown definition kind \" + kind);\n        return '<unknown>';\n    };\n    ConstantPool.prototype.freshName = function () { return this.uniqueName(CONSTANT_PREFIX); };\n    ConstantPool.prototype.keyOf = function (expression) {\n        return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n    };\n    return ConstantPool;\n}());\n/**\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n * `ConstantPool`.\n *\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n */\nvar KeyVisitor = /** @class */ (function () {\n    function KeyVisitor() {\n        this.visitWrappedNodeExpr = invalid;\n        this.visitWriteVarExpr = invalid;\n        this.visitWriteKeyExpr = invalid;\n        this.visitWritePropExpr = invalid;\n        this.visitInvokeMethodExpr = invalid;\n        this.visitInvokeFunctionExpr = invalid;\n        this.visitInstantiateExpr = invalid;\n        this.visitConditionalExpr = invalid;\n        this.visitNotExpr = invalid;\n        this.visitAssertNotNullExpr = invalid;\n        this.visitCastExpr = invalid;\n        this.visitFunctionExpr = invalid;\n        this.visitBinaryOperatorExpr = invalid;\n        this.visitReadPropExpr = invalid;\n        this.visitReadKeyExpr = invalid;\n        this.visitCommaExpr = invalid;\n    }\n    KeyVisitor.prototype.visitLiteralExpr = function (ast) {\n        return \"\" + (typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value);\n    };\n    KeyVisitor.prototype.visitLiteralArrayExpr = function (ast, context) {\n        var _this = this;\n        return \"[\" + ast.entries.map(function (entry) { return entry.visitExpression(_this, context); }).join(',') + \"]\";\n    };\n    KeyVisitor.prototype.visitLiteralMapExpr = function (ast, context) {\n        var _this = this;\n        var mapKey = function (entry) {\n            var quote = entry.quoted ? '\"' : '';\n            return \"\" + quote + entry.key + quote;\n        };\n        var mapEntry = function (entry) {\n            return mapKey(entry) + \":\" + entry.value.visitExpression(_this, context);\n        };\n        return \"{\" + ast.entries.map(mapEntry).join(',');\n    };\n    KeyVisitor.prototype.visitExternalExpr = function (ast) {\n        return ast.value.moduleName ? \"EX:\" + ast.value.moduleName + \":\" + ast.value.name :\n            \"EX:\" + ast.value.runtime.name;\n    };\n    KeyVisitor.prototype.visitReadVarExpr = function (node) { return \"VAR:\" + node.name; };\n    KeyVisitor.prototype.visitTypeofExpr = function (node, context) {\n        return \"TYPEOF:\" + node.expr.visitExpression(this, context);\n    };\n    return KeyVisitor;\n}());\nfunction invalid(arg) {\n    throw new Error(\"Invalid state: Visitor \" + this.constructor.name + \" doesn't handle \" + arg.constructor.name);\n}\nfunction isVariable(e) {\n    return e instanceof ReadVarExpr;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CORE = '@angular/core';\nvar Identifiers = /** @class */ (function () {\n    function Identifiers() {\n    }\n    Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {\n        name: 'ANALYZE_FOR_ENTRY_COMPONENTS',\n        moduleName: CORE,\n    };\n    Identifiers.ElementRef = { name: 'ElementRef', moduleName: CORE };\n    Identifiers.NgModuleRef = { name: 'NgModuleRef', moduleName: CORE };\n    Identifiers.ViewContainerRef = { name: 'ViewContainerRef', moduleName: CORE };\n    Identifiers.ChangeDetectorRef = {\n        name: 'ChangeDetectorRef',\n        moduleName: CORE,\n    };\n    Identifiers.QueryList = { name: 'QueryList', moduleName: CORE };\n    Identifiers.TemplateRef = { name: 'TemplateRef', moduleName: CORE };\n    Identifiers.Renderer2 = { name: 'Renderer2', moduleName: CORE };\n    Identifiers.CodegenComponentFactoryResolver = {\n        name: 'ɵCodegenComponentFactoryResolver',\n        moduleName: CORE,\n    };\n    Identifiers.ComponentFactoryResolver = {\n        name: 'ComponentFactoryResolver',\n        moduleName: CORE,\n    };\n    Identifiers.ComponentFactory = { name: 'ComponentFactory', moduleName: CORE };\n    Identifiers.ComponentRef = { name: 'ComponentRef', moduleName: CORE };\n    Identifiers.NgModuleFactory = { name: 'NgModuleFactory', moduleName: CORE };\n    Identifiers.createModuleFactory = {\n        name: 'ɵcmf',\n        moduleName: CORE,\n    };\n    Identifiers.moduleDef = {\n        name: 'ɵmod',\n        moduleName: CORE,\n    };\n    Identifiers.moduleProviderDef = {\n        name: 'ɵmpd',\n        moduleName: CORE,\n    };\n    Identifiers.RegisterModuleFactoryFn = {\n        name: 'ɵregisterModuleFactory',\n        moduleName: CORE,\n    };\n    Identifiers.inject = { name: 'ɵɵinject', moduleName: CORE };\n    Identifiers.INJECTOR = { name: 'INJECTOR', moduleName: CORE };\n    Identifiers.Injector = { name: 'Injector', moduleName: CORE };\n    Identifiers.ɵɵdefineInjectable = { name: 'ɵɵdefineInjectable', moduleName: CORE };\n    Identifiers.InjectableDef = { name: 'ɵɵInjectableDef', moduleName: CORE };\n    Identifiers.ViewEncapsulation = {\n        name: 'ViewEncapsulation',\n        moduleName: CORE,\n    };\n    Identifiers.ChangeDetectionStrategy = {\n        name: 'ChangeDetectionStrategy',\n        moduleName: CORE,\n    };\n    Identifiers.SecurityContext = {\n        name: 'SecurityContext',\n        moduleName: CORE,\n    };\n    Identifiers.LOCALE_ID = { name: 'LOCALE_ID', moduleName: CORE };\n    Identifiers.TRANSLATIONS_FORMAT = {\n        name: 'TRANSLATIONS_FORMAT',\n        moduleName: CORE,\n    };\n    Identifiers.inlineInterpolate = {\n        name: 'ɵinlineInterpolate',\n        moduleName: CORE,\n    };\n    Identifiers.interpolate = { name: 'ɵinterpolate', moduleName: CORE };\n    Identifiers.EMPTY_ARRAY = { name: 'ɵEMPTY_ARRAY', moduleName: CORE };\n    Identifiers.EMPTY_MAP = { name: 'ɵEMPTY_MAP', moduleName: CORE };\n    Identifiers.Renderer = { name: 'Renderer', moduleName: CORE };\n    Identifiers.viewDef = { name: 'ɵvid', moduleName: CORE };\n    Identifiers.elementDef = { name: 'ɵeld', moduleName: CORE };\n    Identifiers.anchorDef = { name: 'ɵand', moduleName: CORE };\n    Identifiers.textDef = { name: 'ɵted', moduleName: CORE };\n    Identifiers.directiveDef = { name: 'ɵdid', moduleName: CORE };\n    Identifiers.providerDef = { name: 'ɵprd', moduleName: CORE };\n    Identifiers.queryDef = { name: 'ɵqud', moduleName: CORE };\n    Identifiers.pureArrayDef = { name: 'ɵpad', moduleName: CORE };\n    Identifiers.pureObjectDef = { name: 'ɵpod', moduleName: CORE };\n    Identifiers.purePipeDef = { name: 'ɵppd', moduleName: CORE };\n    Identifiers.pipeDef = { name: 'ɵpid', moduleName: CORE };\n    Identifiers.nodeValue = { name: 'ɵnov', moduleName: CORE };\n    Identifiers.ngContentDef = { name: 'ɵncd', moduleName: CORE };\n    Identifiers.unwrapValue = { name: 'ɵunv', moduleName: CORE };\n    Identifiers.createRendererType2 = { name: 'ɵcrt', moduleName: CORE };\n    // type only\n    Identifiers.RendererType2 = {\n        name: 'RendererType2',\n        moduleName: CORE,\n    };\n    // type only\n    Identifiers.ViewDefinition = {\n        name: 'ɵViewDefinition',\n        moduleName: CORE,\n    };\n    Identifiers.createComponentFactory = { name: 'ɵccf', moduleName: CORE };\n    Identifiers.setClassMetadata = { name: 'ɵsetClassMetadata', moduleName: CORE };\n    return Identifiers;\n}());\nfunction createTokenForReference(reference) {\n    return { identifier: { reference: reference } };\n}\nfunction createTokenForExternalReference(reflector, reference) {\n    return createTokenForReference(reflector.resolveExternalReference(reference));\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A token representing the a reference to a static type.\n *\n * This token is unique for a filePath and name and can be used as a hash table key.\n */\nvar StaticSymbol = /** @class */ (function () {\n    function StaticSymbol(filePath, name, members) {\n        this.filePath = filePath;\n        this.name = name;\n        this.members = members;\n    }\n    StaticSymbol.prototype.assertNoMembers = function () {\n        if (this.members.length) {\n            throw new Error(\"Illegal state: symbol without members expected, but got \" + JSON.stringify(this) + \".\");\n        }\n    };\n    return StaticSymbol;\n}());\n/**\n * A cache of static symbol used by the StaticReflector to return the same symbol for the\n * same symbol values.\n */\nvar StaticSymbolCache = /** @class */ (function () {\n    function StaticSymbolCache() {\n        this.cache = new Map();\n    }\n    StaticSymbolCache.prototype.get = function (declarationFile, name, members) {\n        members = members || [];\n        var memberSuffix = members.length ? \".\" + members.join('.') : '';\n        var key = \"\\\"\" + declarationFile + \"\\\".\" + name + memberSuffix;\n        var result = this.cache.get(key);\n        if (!result) {\n            result = new StaticSymbol(declarationFile, name, members);\n            this.cache.set(key, result);\n        }\n        return result;\n    };\n    return StaticSymbolCache;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// group 0: \"[prop] or (event) or @trigger\"\n// group 1: \"prop\" from \"[prop]\"\n// group 2: \"event\" from \"(event)\"\n// group 3: \"@trigger\" from \"@trigger\"\nvar HOST_REG_EXP = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\nfunction sanitizeIdentifier(name) {\n    return name.replace(/\\W/g, '_');\n}\nvar _anonymousTypeIndex = 0;\nfunction identifierName(compileIdentifier) {\n    if (!compileIdentifier || !compileIdentifier.reference) {\n        return null;\n    }\n    var ref = compileIdentifier.reference;\n    if (ref instanceof StaticSymbol) {\n        return ref.name;\n    }\n    if (ref['__anonymousType']) {\n        return ref['__anonymousType'];\n    }\n    var identifier = stringify(ref);\n    if (identifier.indexOf('(') >= 0) {\n        // case: anonymous functions!\n        identifier = \"anonymous_\" + _anonymousTypeIndex++;\n        ref['__anonymousType'] = identifier;\n    }\n    else {\n        identifier = sanitizeIdentifier(identifier);\n    }\n    return identifier;\n}\nfunction identifierModuleUrl(compileIdentifier) {\n    var ref = compileIdentifier.reference;\n    if (ref instanceof StaticSymbol) {\n        return ref.filePath;\n    }\n    // Runtime type\n    return \"./\" + stringify(ref);\n}\nfunction viewClassName(compType, embeddedTemplateIndex) {\n    return \"View_\" + identifierName({ reference: compType }) + \"_\" + embeddedTemplateIndex;\n}\nfunction rendererTypeName(compType) {\n    return \"RenderType_\" + identifierName({ reference: compType });\n}\nfunction hostViewClassName(compType) {\n    return \"HostView_\" + identifierName({ reference: compType });\n}\nfunction componentFactoryName(compType) {\n    return identifierName({ reference: compType }) + \"NgFactory\";\n}\nvar CompileSummaryKind;\n(function (CompileSummaryKind) {\n    CompileSummaryKind[CompileSummaryKind[\"Pipe\"] = 0] = \"Pipe\";\n    CompileSummaryKind[CompileSummaryKind[\"Directive\"] = 1] = \"Directive\";\n    CompileSummaryKind[CompileSummaryKind[\"NgModule\"] = 2] = \"NgModule\";\n    CompileSummaryKind[CompileSummaryKind[\"Injectable\"] = 3] = \"Injectable\";\n})(CompileSummaryKind || (CompileSummaryKind = {}));\nfunction tokenName(token) {\n    return token.value != null ? sanitizeIdentifier(token.value) : identifierName(token.identifier);\n}\nfunction tokenReference(token) {\n    if (token.identifier != null) {\n        return token.identifier.reference;\n    }\n    else {\n        return token.value;\n    }\n}\n/**\n * Metadata about a stylesheet\n */\nvar CompileStylesheetMetadata = /** @class */ (function () {\n    function CompileStylesheetMetadata(_a) {\n        var _b = _a === void 0 ? {} : _a, moduleUrl = _b.moduleUrl, styles = _b.styles, styleUrls = _b.styleUrls;\n        this.moduleUrl = moduleUrl || null;\n        this.styles = _normalizeArray(styles);\n        this.styleUrls = _normalizeArray(styleUrls);\n    }\n    return CompileStylesheetMetadata;\n}());\n/**\n * Metadata regarding compilation of a template.\n */\nvar CompileTemplateMetadata = /** @class */ (function () {\n    function CompileTemplateMetadata(_a) {\n        var encapsulation = _a.encapsulation, template = _a.template, templateUrl = _a.templateUrl, htmlAst = _a.htmlAst, styles = _a.styles, styleUrls = _a.styleUrls, externalStylesheets = _a.externalStylesheets, animations = _a.animations, ngContentSelectors = _a.ngContentSelectors, interpolation = _a.interpolation, isInline = _a.isInline, preserveWhitespaces = _a.preserveWhitespaces;\n        this.encapsulation = encapsulation;\n        this.template = template;\n        this.templateUrl = templateUrl;\n        this.htmlAst = htmlAst;\n        this.styles = _normalizeArray(styles);\n        this.styleUrls = _normalizeArray(styleUrls);\n        this.externalStylesheets = _normalizeArray(externalStylesheets);\n        this.animations = animations ? flatten(animations) : [];\n        this.ngContentSelectors = ngContentSelectors || [];\n        if (interpolation && interpolation.length != 2) {\n            throw new Error(\"'interpolation' should have a start and an end symbol.\");\n        }\n        this.interpolation = interpolation;\n        this.isInline = isInline;\n        this.preserveWhitespaces = preserveWhitespaces;\n    }\n    CompileTemplateMetadata.prototype.toSummary = function () {\n        return {\n            ngContentSelectors: this.ngContentSelectors,\n            encapsulation: this.encapsulation,\n            styles: this.styles,\n            animations: this.animations\n        };\n    };\n    return CompileTemplateMetadata;\n}());\n/**\n * Metadata regarding compilation of a directive.\n */\nvar CompileDirectiveMetadata = /** @class */ (function () {\n    function CompileDirectiveMetadata(_a) {\n        var isHost = _a.isHost, type = _a.type, isComponent = _a.isComponent, selector = _a.selector, exportAs = _a.exportAs, changeDetection = _a.changeDetection, inputs = _a.inputs, outputs = _a.outputs, hostListeners = _a.hostListeners, hostProperties = _a.hostProperties, hostAttributes = _a.hostAttributes, providers = _a.providers, viewProviders = _a.viewProviders, queries = _a.queries, guards = _a.guards, viewQueries = _a.viewQueries, entryComponents = _a.entryComponents, template = _a.template, componentViewType = _a.componentViewType, rendererType = _a.rendererType, componentFactory = _a.componentFactory;\n        this.isHost = !!isHost;\n        this.type = type;\n        this.isComponent = isComponent;\n        this.selector = selector;\n        this.exportAs = exportAs;\n        this.changeDetection = changeDetection;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.hostListeners = hostListeners;\n        this.hostProperties = hostProperties;\n        this.hostAttributes = hostAttributes;\n        this.providers = _normalizeArray(providers);\n        this.viewProviders = _normalizeArray(viewProviders);\n        this.queries = _normalizeArray(queries);\n        this.guards = guards;\n        this.viewQueries = _normalizeArray(viewQueries);\n        this.entryComponents = _normalizeArray(entryComponents);\n        this.template = template;\n        this.componentViewType = componentViewType;\n        this.rendererType = rendererType;\n        this.componentFactory = componentFactory;\n    }\n    CompileDirectiveMetadata.create = function (_a) {\n        var isHost = _a.isHost, type = _a.type, isComponent = _a.isComponent, selector = _a.selector, exportAs = _a.exportAs, changeDetection = _a.changeDetection, inputs = _a.inputs, outputs = _a.outputs, host = _a.host, providers = _a.providers, viewProviders = _a.viewProviders, queries = _a.queries, guards = _a.guards, viewQueries = _a.viewQueries, entryComponents = _a.entryComponents, template = _a.template, componentViewType = _a.componentViewType, rendererType = _a.rendererType, componentFactory = _a.componentFactory;\n        var hostListeners = {};\n        var hostProperties = {};\n        var hostAttributes = {};\n        if (host != null) {\n            Object.keys(host).forEach(function (key) {\n                var value = host[key];\n                var matches = key.match(HOST_REG_EXP);\n                if (matches === null) {\n                    hostAttributes[key] = value;\n                }\n                else if (matches[1] != null) {\n                    hostProperties[matches[1]] = value;\n                }\n                else if (matches[2] != null) {\n                    hostListeners[matches[2]] = value;\n                }\n            });\n        }\n        var inputsMap = {};\n        if (inputs != null) {\n            inputs.forEach(function (bindConfig) {\n                // canonical syntax: `dirProp: elProp`\n                // if there is no `:`, use dirProp = elProp\n                var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n                inputsMap[parts[0]] = parts[1];\n            });\n        }\n        var outputsMap = {};\n        if (outputs != null) {\n            outputs.forEach(function (bindConfig) {\n                // canonical syntax: `dirProp: elProp`\n                // if there is no `:`, use dirProp = elProp\n                var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n                outputsMap[parts[0]] = parts[1];\n            });\n        }\n        return new CompileDirectiveMetadata({\n            isHost: isHost,\n            type: type,\n            isComponent: !!isComponent, selector: selector, exportAs: exportAs, changeDetection: changeDetection,\n            inputs: inputsMap,\n            outputs: outputsMap,\n            hostListeners: hostListeners,\n            hostProperties: hostProperties,\n            hostAttributes: hostAttributes,\n            providers: providers,\n            viewProviders: viewProviders,\n            queries: queries,\n            guards: guards,\n            viewQueries: viewQueries,\n            entryComponents: entryComponents,\n            template: template,\n            componentViewType: componentViewType,\n            rendererType: rendererType,\n            componentFactory: componentFactory,\n        });\n    };\n    CompileDirectiveMetadata.prototype.toSummary = function () {\n        return {\n            summaryKind: CompileSummaryKind.Directive,\n            type: this.type,\n            isComponent: this.isComponent,\n            selector: this.selector,\n            exportAs: this.exportAs,\n            inputs: this.inputs,\n            outputs: this.outputs,\n            hostListeners: this.hostListeners,\n            hostProperties: this.hostProperties,\n            hostAttributes: this.hostAttributes,\n            providers: this.providers,\n            viewProviders: this.viewProviders,\n            queries: this.queries,\n            guards: this.guards,\n            viewQueries: this.viewQueries,\n            entryComponents: this.entryComponents,\n            changeDetection: this.changeDetection,\n            template: this.template && this.template.toSummary(),\n            componentViewType: this.componentViewType,\n            rendererType: this.rendererType,\n            componentFactory: this.componentFactory\n        };\n    };\n    return CompileDirectiveMetadata;\n}());\nvar CompilePipeMetadata = /** @class */ (function () {\n    function CompilePipeMetadata(_a) {\n        var type = _a.type, name = _a.name, pure = _a.pure;\n        this.type = type;\n        this.name = name;\n        this.pure = !!pure;\n    }\n    CompilePipeMetadata.prototype.toSummary = function () {\n        return {\n            summaryKind: CompileSummaryKind.Pipe,\n            type: this.type,\n            name: this.name,\n            pure: this.pure\n        };\n    };\n    return CompilePipeMetadata;\n}());\nvar CompileShallowModuleMetadata = /** @class */ (function () {\n    function CompileShallowModuleMetadata() {\n    }\n    return CompileShallowModuleMetadata;\n}());\n/**\n * Metadata regarding compilation of a module.\n */\nvar CompileNgModuleMetadata = /** @class */ (function () {\n    function CompileNgModuleMetadata(_a) {\n        var type = _a.type, providers = _a.providers, declaredDirectives = _a.declaredDirectives, exportedDirectives = _a.exportedDirectives, declaredPipes = _a.declaredPipes, exportedPipes = _a.exportedPipes, entryComponents = _a.entryComponents, bootstrapComponents = _a.bootstrapComponents, importedModules = _a.importedModules, exportedModules = _a.exportedModules, schemas = _a.schemas, transitiveModule = _a.transitiveModule, id = _a.id;\n        this.type = type || null;\n        this.declaredDirectives = _normalizeArray(declaredDirectives);\n        this.exportedDirectives = _normalizeArray(exportedDirectives);\n        this.declaredPipes = _normalizeArray(declaredPipes);\n        this.exportedPipes = _normalizeArray(exportedPipes);\n        this.providers = _normalizeArray(providers);\n        this.entryComponents = _normalizeArray(entryComponents);\n        this.bootstrapComponents = _normalizeArray(bootstrapComponents);\n        this.importedModules = _normalizeArray(importedModules);\n        this.exportedModules = _normalizeArray(exportedModules);\n        this.schemas = _normalizeArray(schemas);\n        this.id = id || null;\n        this.transitiveModule = transitiveModule || null;\n    }\n    CompileNgModuleMetadata.prototype.toSummary = function () {\n        var module = this.transitiveModule;\n        return {\n            summaryKind: CompileSummaryKind.NgModule,\n            type: this.type,\n            entryComponents: module.entryComponents,\n            providers: module.providers,\n            modules: module.modules,\n            exportedDirectives: module.exportedDirectives,\n            exportedPipes: module.exportedPipes\n        };\n    };\n    return CompileNgModuleMetadata;\n}());\nvar TransitiveCompileNgModuleMetadata = /** @class */ (function () {\n    function TransitiveCompileNgModuleMetadata() {\n        this.directivesSet = new Set();\n        this.directives = [];\n        this.exportedDirectivesSet = new Set();\n        this.exportedDirectives = [];\n        this.pipesSet = new Set();\n        this.pipes = [];\n        this.exportedPipesSet = new Set();\n        this.exportedPipes = [];\n        this.modulesSet = new Set();\n        this.modules = [];\n        this.entryComponentsSet = new Set();\n        this.entryComponents = [];\n        this.providers = [];\n    }\n    TransitiveCompileNgModuleMetadata.prototype.addProvider = function (provider, module) {\n        this.providers.push({ provider: provider, module: module });\n    };\n    TransitiveCompileNgModuleMetadata.prototype.addDirective = function (id) {\n        if (!this.directivesSet.has(id.reference)) {\n            this.directivesSet.add(id.reference);\n            this.directives.push(id);\n        }\n    };\n    TransitiveCompileNgModuleMetadata.prototype.addExportedDirective = function (id) {\n        if (!this.exportedDirectivesSet.has(id.reference)) {\n            this.exportedDirectivesSet.add(id.reference);\n            this.exportedDirectives.push(id);\n        }\n    };\n    TransitiveCompileNgModuleMetadata.prototype.addPipe = function (id) {\n        if (!this.pipesSet.has(id.reference)) {\n            this.pipesSet.add(id.reference);\n            this.pipes.push(id);\n        }\n    };\n    TransitiveCompileNgModuleMetadata.prototype.addExportedPipe = function (id) {\n        if (!this.exportedPipesSet.has(id.reference)) {\n            this.exportedPipesSet.add(id.reference);\n            this.exportedPipes.push(id);\n        }\n    };\n    TransitiveCompileNgModuleMetadata.prototype.addModule = function (id) {\n        if (!this.modulesSet.has(id.reference)) {\n            this.modulesSet.add(id.reference);\n            this.modules.push(id);\n        }\n    };\n    TransitiveCompileNgModuleMetadata.prototype.addEntryComponent = function (ec) {\n        if (!this.entryComponentsSet.has(ec.componentType)) {\n            this.entryComponentsSet.add(ec.componentType);\n            this.entryComponents.push(ec);\n        }\n    };\n    return TransitiveCompileNgModuleMetadata;\n}());\nfunction _normalizeArray(obj) {\n    return obj || [];\n}\nvar ProviderMeta = /** @class */ (function () {\n    function ProviderMeta(token, _a) {\n        var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;\n        this.token = token;\n        this.useClass = useClass || null;\n        this.useValue = useValue;\n        this.useExisting = useExisting;\n        this.useFactory = useFactory || null;\n        this.dependencies = deps || null;\n        this.multi = !!multi;\n    }\n    return ProviderMeta;\n}());\nfunction flatten(list) {\n    return list.reduce(function (flat, item) {\n        var flatItem = Array.isArray(item) ? flatten(item) : item;\n        return flat.concat(flatItem);\n    }, []);\n}\nfunction jitSourceUrl(url) {\n    // Note: We need 3 \"/\" so that ng shows up as a separate domain\n    // in the chrome dev tools.\n    return url.replace(/(\\w+:\\/\\/[\\w:-]+)?(\\/+)?/, 'ng:///');\n}\nfunction templateSourceUrl(ngModuleType, compMeta, templateMeta) {\n    var url;\n    if (templateMeta.isInline) {\n        if (compMeta.type.reference instanceof StaticSymbol) {\n            // Note: a .ts file might contain multiple components with inline templates,\n            // so we need to give them unique urls, as these will be used for sourcemaps.\n            url = compMeta.type.reference.filePath + \".\" + compMeta.type.reference.name + \".html\";\n        }\n        else {\n            url = identifierName(ngModuleType) + \"/\" + identifierName(compMeta.type) + \".html\";\n        }\n    }\n    else {\n        url = templateMeta.templateUrl;\n    }\n    return compMeta.type.reference instanceof StaticSymbol ? url : jitSourceUrl(url);\n}\nfunction sharedStylesheetJitUrl(meta, id) {\n    var pathParts = meta.moduleUrl.split(/\\/\\\\/g);\n    var baseName = pathParts[pathParts.length - 1];\n    return jitSourceUrl(\"css/\" + id + baseName + \".ngstyle.js\");\n}\nfunction ngModuleJitUrl(moduleMeta) {\n    return jitSourceUrl(identifierName(moduleMeta.type) + \"/module.ngfactory.js\");\n}\nfunction templateJitUrl(ngModuleType, compMeta) {\n    return jitSourceUrl(identifierName(ngModuleType) + \"/\" + identifierName(compMeta.type) + \".ngfactory.js\");\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CORE$1 = '@angular/core';\nvar Identifiers$1 = /** @class */ (function () {\n    function Identifiers() {\n    }\n    /* Methods */\n    Identifiers.NEW_METHOD = 'factory';\n    Identifiers.TRANSFORM_METHOD = 'transform';\n    Identifiers.PATCH_DEPS = 'patchedDeps';\n    /* Instructions */\n    Identifiers.namespaceHTML = { name: 'ɵɵnamespaceHTML', moduleName: CORE$1 };\n    Identifiers.namespaceMathML = { name: 'ɵɵnamespaceMathML', moduleName: CORE$1 };\n    Identifiers.namespaceSVG = { name: 'ɵɵnamespaceSVG', moduleName: CORE$1 };\n    Identifiers.element = { name: 'ɵɵelement', moduleName: CORE$1 };\n    Identifiers.elementStart = { name: 'ɵɵelementStart', moduleName: CORE$1 };\n    Identifiers.elementEnd = { name: 'ɵɵelementEnd', moduleName: CORE$1 };\n    Identifiers.select = { name: 'ɵɵselect', moduleName: CORE$1 };\n    Identifiers.updateSyntheticHostBinding = { name: 'ɵɵupdateSyntheticHostBinding', moduleName: CORE$1 };\n    Identifiers.componentHostSyntheticListener = { name: 'ɵɵcomponentHostSyntheticListener', moduleName: CORE$1 };\n    Identifiers.attribute = { name: 'ɵɵattribute', moduleName: CORE$1 };\n    Identifiers.attributeInterpolate1 = { name: 'ɵɵattributeInterpolate1', moduleName: CORE$1 };\n    Identifiers.attributeInterpolate2 = { name: 'ɵɵattributeInterpolate2', moduleName: CORE$1 };\n    Identifiers.attributeInterpolate3 = { name: 'ɵɵattributeInterpolate3', moduleName: CORE$1 };\n    Identifiers.attributeInterpolate4 = { name: 'ɵɵattributeInterpolate4', moduleName: CORE$1 };\n    Identifiers.attributeInterpolate5 = { name: 'ɵɵattributeInterpolate5', moduleName: CORE$1 };\n    Identifiers.attributeInterpolate6 = { name: 'ɵɵattributeInterpolate6', moduleName: CORE$1 };\n    Identifiers.attributeInterpolate7 = { name: 'ɵɵattributeInterpolate7', moduleName: CORE$1 };\n    Identifiers.attributeInterpolate8 = { name: 'ɵɵattributeInterpolate8', moduleName: CORE$1 };\n    Identifiers.attributeInterpolateV = { name: 'ɵɵattributeInterpolateV', moduleName: CORE$1 };\n    Identifiers.classProp = { name: 'ɵɵclassProp', moduleName: CORE$1 };\n    Identifiers.elementContainerStart = { name: 'ɵɵelementContainerStart', moduleName: CORE$1 };\n    Identifiers.elementContainerEnd = { name: 'ɵɵelementContainerEnd', moduleName: CORE$1 };\n    Identifiers.elementContainer = { name: 'ɵɵelementContainer', moduleName: CORE$1 };\n    Identifiers.styling = { name: 'ɵɵstyling', moduleName: CORE$1 };\n    Identifiers.styleMap = { name: 'ɵɵstyleMap', moduleName: CORE$1 };\n    Identifiers.classMap = { name: 'ɵɵclassMap', moduleName: CORE$1 };\n    Identifiers.classMapInterpolate1 = { name: 'ɵɵclassMapInterpolate1', moduleName: CORE$1 };\n    Identifiers.classMapInterpolate2 = { name: 'ɵɵclassMapInterpolate2', moduleName: CORE$1 };\n    Identifiers.classMapInterpolate3 = { name: 'ɵɵclassMapInterpolate3', moduleName: CORE$1 };\n    Identifiers.classMapInterpolate4 = { name: 'ɵɵclassMapInterpolate4', moduleName: CORE$1 };\n    Identifiers.classMapInterpolate5 = { name: 'ɵɵclassMapInterpolate5', moduleName: CORE$1 };\n    Identifiers.classMapInterpolate6 = { name: 'ɵɵclassMapInterpolate6', moduleName: CORE$1 };\n    Identifiers.classMapInterpolate7 = { name: 'ɵɵclassMapInterpolate7', moduleName: CORE$1 };\n    Identifiers.classMapInterpolate8 = { name: 'ɵɵclassMapInterpolate8', moduleName: CORE$1 };\n    Identifiers.classMapInterpolateV = { name: 'ɵɵclassMapInterpolateV', moduleName: CORE$1 };\n    Identifiers.styleProp = { name: 'ɵɵstyleProp', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolate1 = { name: 'ɵɵstylePropInterpolate1', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolate2 = { name: 'ɵɵstylePropInterpolate2', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolate3 = { name: 'ɵɵstylePropInterpolate3', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolate4 = { name: 'ɵɵstylePropInterpolate4', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolate5 = { name: 'ɵɵstylePropInterpolate5', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolate6 = { name: 'ɵɵstylePropInterpolate6', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolate7 = { name: 'ɵɵstylePropInterpolate7', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolate8 = { name: 'ɵɵstylePropInterpolate8', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolateV = { name: 'ɵɵstylePropInterpolateV', moduleName: CORE$1 };\n    Identifiers.stylingApply = { name: 'ɵɵstylingApply', moduleName: CORE$1 };\n    Identifiers.styleSanitizer = { name: 'ɵɵstyleSanitizer', moduleName: CORE$1 };\n    Identifiers.elementHostAttrs = { name: 'ɵɵelementHostAttrs', moduleName: CORE$1 };\n    Identifiers.containerCreate = { name: 'ɵɵcontainer', moduleName: CORE$1 };\n    Identifiers.nextContext = { name: 'ɵɵnextContext', moduleName: CORE$1 };\n    Identifiers.templateCreate = { name: 'ɵɵtemplate', moduleName: CORE$1 };\n    Identifiers.text = { name: 'ɵɵtext', moduleName: CORE$1 };\n    Identifiers.textBinding = { name: 'ɵɵtextBinding', moduleName: CORE$1 };\n    Identifiers.enableBindings = { name: 'ɵɵenableBindings', moduleName: CORE$1 };\n    Identifiers.disableBindings = { name: 'ɵɵdisableBindings', moduleName: CORE$1 };\n    Identifiers.allocHostVars = { name: 'ɵɵallocHostVars', moduleName: CORE$1 };\n    Identifiers.getCurrentView = { name: 'ɵɵgetCurrentView', moduleName: CORE$1 };\n    Identifiers.textInterpolate = { name: 'ɵɵtextInterpolate', moduleName: CORE$1 };\n    Identifiers.textInterpolate1 = { name: 'ɵɵtextInterpolate1', moduleName: CORE$1 };\n    Identifiers.textInterpolate2 = { name: 'ɵɵtextInterpolate2', moduleName: CORE$1 };\n    Identifiers.textInterpolate3 = { name: 'ɵɵtextInterpolate3', moduleName: CORE$1 };\n    Identifiers.textInterpolate4 = { name: 'ɵɵtextInterpolate4', moduleName: CORE$1 };\n    Identifiers.textInterpolate5 = { name: 'ɵɵtextInterpolate5', moduleName: CORE$1 };\n    Identifiers.textInterpolate6 = { name: 'ɵɵtextInterpolate6', moduleName: CORE$1 };\n    Identifiers.textInterpolate7 = { name: 'ɵɵtextInterpolate7', moduleName: CORE$1 };\n    Identifiers.textInterpolate8 = { name: 'ɵɵtextInterpolate8', moduleName: CORE$1 };\n    Identifiers.textInterpolateV = { name: 'ɵɵtextInterpolateV', moduleName: CORE$1 };\n    Identifiers.restoreView = { name: 'ɵɵrestoreView', moduleName: CORE$1 };\n    Identifiers.pureFunction0 = { name: 'ɵɵpureFunction0', moduleName: CORE$1 };\n    Identifiers.pureFunction1 = { name: 'ɵɵpureFunction1', moduleName: CORE$1 };\n    Identifiers.pureFunction2 = { name: 'ɵɵpureFunction2', moduleName: CORE$1 };\n    Identifiers.pureFunction3 = { name: 'ɵɵpureFunction3', moduleName: CORE$1 };\n    Identifiers.pureFunction4 = { name: 'ɵɵpureFunction4', moduleName: CORE$1 };\n    Identifiers.pureFunction5 = { name: 'ɵɵpureFunction5', moduleName: CORE$1 };\n    Identifiers.pureFunction6 = { name: 'ɵɵpureFunction6', moduleName: CORE$1 };\n    Identifiers.pureFunction7 = { name: 'ɵɵpureFunction7', moduleName: CORE$1 };\n    Identifiers.pureFunction8 = { name: 'ɵɵpureFunction8', moduleName: CORE$1 };\n    Identifiers.pureFunctionV = { name: 'ɵɵpureFunctionV', moduleName: CORE$1 };\n    Identifiers.pipeBind1 = { name: 'ɵɵpipeBind1', moduleName: CORE$1 };\n    Identifiers.pipeBind2 = { name: 'ɵɵpipeBind2', moduleName: CORE$1 };\n    Identifiers.pipeBind3 = { name: 'ɵɵpipeBind3', moduleName: CORE$1 };\n    Identifiers.pipeBind4 = { name: 'ɵɵpipeBind4', moduleName: CORE$1 };\n    Identifiers.pipeBindV = { name: 'ɵɵpipeBindV', moduleName: CORE$1 };\n    Identifiers.hostProperty = { name: 'ɵɵhostProperty', moduleName: CORE$1 };\n    Identifiers.property = { name: 'ɵɵproperty', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate = { name: 'ɵɵpropertyInterpolate', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate1 = { name: 'ɵɵpropertyInterpolate1', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate2 = { name: 'ɵɵpropertyInterpolate2', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate3 = { name: 'ɵɵpropertyInterpolate3', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate4 = { name: 'ɵɵpropertyInterpolate4', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate5 = { name: 'ɵɵpropertyInterpolate5', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate6 = { name: 'ɵɵpropertyInterpolate6', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate7 = { name: 'ɵɵpropertyInterpolate7', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate8 = { name: 'ɵɵpropertyInterpolate8', moduleName: CORE$1 };\n    Identifiers.propertyInterpolateV = { name: 'ɵɵpropertyInterpolateV', moduleName: CORE$1 };\n    Identifiers.i18n = { name: 'ɵɵi18n', moduleName: CORE$1 };\n    Identifiers.i18nAttributes = { name: 'ɵɵi18nAttributes', moduleName: CORE$1 };\n    Identifiers.i18nExp = { name: 'ɵɵi18nExp', moduleName: CORE$1 };\n    Identifiers.i18nStart = { name: 'ɵɵi18nStart', moduleName: CORE$1 };\n    Identifiers.i18nEnd = { name: 'ɵɵi18nEnd', moduleName: CORE$1 };\n    Identifiers.i18nApply = { name: 'ɵɵi18nApply', moduleName: CORE$1 };\n    Identifiers.i18nPostprocess = { name: 'ɵɵi18nPostprocess', moduleName: CORE$1 };\n    Identifiers.i18nLocalize = { name: 'ɵɵi18nLocalize', moduleName: CORE$1 };\n    Identifiers.load = { name: 'ɵɵload', moduleName: CORE$1 };\n    Identifiers.pipe = { name: 'ɵɵpipe', moduleName: CORE$1 };\n    Identifiers.projection = { name: 'ɵɵprojection', moduleName: CORE$1 };\n    Identifiers.projectionDef = { name: 'ɵɵprojectionDef', moduleName: CORE$1 };\n    Identifiers.reference = { name: 'ɵɵreference', moduleName: CORE$1 };\n    Identifiers.inject = { name: 'ɵɵinject', moduleName: CORE$1 };\n    Identifiers.injectAttribute = { name: 'ɵɵinjectAttribute', moduleName: CORE$1 };\n    Identifiers.injectPipeChangeDetectorRef = { name: 'ɵɵinjectPipeChangeDetectorRef', moduleName: CORE$1 };\n    Identifiers.directiveInject = { name: 'ɵɵdirectiveInject', moduleName: CORE$1 };\n    Identifiers.templateRefExtractor = { name: 'ɵɵtemplateRefExtractor', moduleName: CORE$1 };\n    Identifiers.resolveWindow = { name: 'ɵɵresolveWindow', moduleName: CORE$1 };\n    Identifiers.resolveDocument = { name: 'ɵɵresolveDocument', moduleName: CORE$1 };\n    Identifiers.resolveBody = { name: 'ɵɵresolveBody', moduleName: CORE$1 };\n    Identifiers.defineBase = { name: 'ɵɵdefineBase', moduleName: CORE$1 };\n    Identifiers.BaseDef = {\n        name: 'ɵɵBaseDef',\n        moduleName: CORE$1,\n    };\n    Identifiers.defineComponent = { name: 'ɵɵdefineComponent', moduleName: CORE$1 };\n    Identifiers.setComponentScope = { name: 'ɵɵsetComponentScope', moduleName: CORE$1 };\n    Identifiers.ComponentDefWithMeta = {\n        name: 'ɵɵComponentDefWithMeta',\n        moduleName: CORE$1,\n    };\n    Identifiers.defineDirective = {\n        name: 'ɵɵdefineDirective',\n        moduleName: CORE$1,\n    };\n    Identifiers.DirectiveDefWithMeta = {\n        name: 'ɵɵDirectiveDefWithMeta',\n        moduleName: CORE$1,\n    };\n    Identifiers.InjectorDef = {\n        name: 'ɵɵInjectorDef',\n        moduleName: CORE$1,\n    };\n    Identifiers.defineInjector = {\n        name: 'ɵɵdefineInjector',\n        moduleName: CORE$1,\n    };\n    Identifiers.NgModuleDefWithMeta = {\n        name: 'ɵɵNgModuleDefWithMeta',\n        moduleName: CORE$1,\n    };\n    Identifiers.defineNgModule = { name: 'ɵɵdefineNgModule', moduleName: CORE$1 };\n    Identifiers.setNgModuleScope = { name: 'ɵɵsetNgModuleScope', moduleName: CORE$1 };\n    Identifiers.PipeDefWithMeta = { name: 'ɵɵPipeDefWithMeta', moduleName: CORE$1 };\n    Identifiers.definePipe = { name: 'ɵɵdefinePipe', moduleName: CORE$1 };\n    Identifiers.queryRefresh = { name: 'ɵɵqueryRefresh', moduleName: CORE$1 };\n    Identifiers.viewQuery = { name: 'ɵɵviewQuery', moduleName: CORE$1 };\n    Identifiers.staticViewQuery = { name: 'ɵɵstaticViewQuery', moduleName: CORE$1 };\n    Identifiers.staticContentQuery = { name: 'ɵɵstaticContentQuery', moduleName: CORE$1 };\n    Identifiers.loadViewQuery = { name: 'ɵɵloadViewQuery', moduleName: CORE$1 };\n    Identifiers.contentQuery = { name: 'ɵɵcontentQuery', moduleName: CORE$1 };\n    Identifiers.loadContentQuery = { name: 'ɵɵloadContentQuery', moduleName: CORE$1 };\n    Identifiers.NgOnChangesFeature = { name: 'ɵɵNgOnChangesFeature', moduleName: CORE$1 };\n    Identifiers.InheritDefinitionFeature = { name: 'ɵɵInheritDefinitionFeature', moduleName: CORE$1 };\n    Identifiers.ProvidersFeature = { name: 'ɵɵProvidersFeature', moduleName: CORE$1 };\n    Identifiers.listener = { name: 'ɵɵlistener', moduleName: CORE$1 };\n    Identifiers.getFactoryOf = {\n        name: 'ɵɵgetFactoryOf',\n        moduleName: CORE$1,\n    };\n    Identifiers.getInheritedFactory = {\n        name: 'ɵɵgetInheritedFactory',\n        moduleName: CORE$1,\n    };\n    // sanitization-related functions\n    Identifiers.sanitizeHtml = { name: 'ɵɵsanitizeHtml', moduleName: CORE$1 };\n    Identifiers.sanitizeStyle = { name: 'ɵɵsanitizeStyle', moduleName: CORE$1 };\n    Identifiers.defaultStyleSanitizer = { name: 'ɵɵdefaultStyleSanitizer', moduleName: CORE$1 };\n    Identifiers.sanitizeResourceUrl = { name: 'ɵɵsanitizeResourceUrl', moduleName: CORE$1 };\n    Identifiers.sanitizeScript = { name: 'ɵɵsanitizeScript', moduleName: CORE$1 };\n    Identifiers.sanitizeUrl = { name: 'ɵɵsanitizeUrl', moduleName: CORE$1 };\n    Identifiers.sanitizeUrlOrResourceUrl = { name: 'ɵɵsanitizeUrlOrResourceUrl', moduleName: CORE$1 };\n    return Identifiers;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar $EOF = 0;\nvar $BSPACE = 8;\nvar $TAB = 9;\nvar $LF = 10;\nvar $VTAB = 11;\nvar $FF = 12;\nvar $CR = 13;\nvar $SPACE = 32;\nvar $BANG = 33;\nvar $DQ = 34;\nvar $HASH = 35;\nvar $$ = 36;\nvar $PERCENT = 37;\nvar $AMPERSAND = 38;\nvar $SQ = 39;\nvar $LPAREN = 40;\nvar $RPAREN = 41;\nvar $STAR = 42;\nvar $PLUS = 43;\nvar $COMMA = 44;\nvar $MINUS = 45;\nvar $PERIOD = 46;\nvar $SLASH = 47;\nvar $COLON = 58;\nvar $SEMICOLON = 59;\nvar $LT = 60;\nvar $EQ = 61;\nvar $GT = 62;\nvar $QUESTION = 63;\nvar $0 = 48;\nvar $7 = 55;\nvar $9 = 57;\nvar $A = 65;\nvar $E = 69;\nvar $F = 70;\nvar $X = 88;\nvar $Z = 90;\nvar $LBRACKET = 91;\nvar $BACKSLASH = 92;\nvar $RBRACKET = 93;\nvar $CARET = 94;\nvar $_ = 95;\nvar $a = 97;\nvar $b = 98;\nvar $e = 101;\nvar $f = 102;\nvar $n = 110;\nvar $r = 114;\nvar $t = 116;\nvar $u = 117;\nvar $v = 118;\nvar $x = 120;\nvar $z = 122;\nvar $LBRACE = 123;\nvar $BAR = 124;\nvar $RBRACE = 125;\nvar $NBSP = 160;\nvar $PIPE = 124;\nvar $TILDA = 126;\nvar $AT = 64;\nvar $BT = 96;\nfunction isWhitespace(code) {\n    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\nfunction isDigit(code) {\n    return $0 <= code && code <= $9;\n}\nfunction isAsciiLetter(code) {\n    return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\nfunction isAsciiHexDigit(code) {\n    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\nfunction isNewLine(code) {\n    return code === $LF || code === $CR;\n}\nfunction isOctalDigit(code) {\n    return $0 <= code && code <= $7;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ParseLocation = /** @class */ (function () {\n    function ParseLocation(file, offset, line, col) {\n        this.file = file;\n        this.offset = offset;\n        this.line = line;\n        this.col = col;\n    }\n    ParseLocation.prototype.toString = function () {\n        return this.offset != null ? this.file.url + \"@\" + this.line + \":\" + this.col : this.file.url;\n    };\n    ParseLocation.prototype.moveBy = function (delta) {\n        var source = this.file.content;\n        var len = source.length;\n        var offset = this.offset;\n        var line = this.line;\n        var col = this.col;\n        while (offset > 0 && delta < 0) {\n            offset--;\n            delta++;\n            var ch = source.charCodeAt(offset);\n            if (ch == $LF) {\n                line--;\n                var priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));\n                col = priorLine > 0 ? offset - priorLine : offset;\n            }\n            else {\n                col--;\n            }\n        }\n        while (offset < len && delta > 0) {\n            var ch = source.charCodeAt(offset);\n            offset++;\n            delta--;\n            if (ch == $LF) {\n                line++;\n                col = 0;\n            }\n            else {\n                col++;\n            }\n        }\n        return new ParseLocation(this.file, offset, line, col);\n    };\n    // Return the source around the location\n    // Up to `maxChars` or `maxLines` on each side of the location\n    ParseLocation.prototype.getContext = function (maxChars, maxLines) {\n        var content = this.file.content;\n        var startOffset = this.offset;\n        if (startOffset != null) {\n            if (startOffset > content.length - 1) {\n                startOffset = content.length - 1;\n            }\n            var endOffset = startOffset;\n            var ctxChars = 0;\n            var ctxLines = 0;\n            while (ctxChars < maxChars && startOffset > 0) {\n                startOffset--;\n                ctxChars++;\n                if (content[startOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            ctxChars = 0;\n            ctxLines = 0;\n            while (ctxChars < maxChars && endOffset < content.length - 1) {\n                endOffset++;\n                ctxChars++;\n                if (content[endOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            return {\n                before: content.substring(startOffset, this.offset),\n                after: content.substring(this.offset, endOffset + 1),\n            };\n        }\n        return null;\n    };\n    return ParseLocation;\n}());\nvar ParseSourceFile = /** @class */ (function () {\n    function ParseSourceFile(content, url) {\n        this.content = content;\n        this.url = url;\n    }\n    return ParseSourceFile;\n}());\nvar ParseSourceSpan = /** @class */ (function () {\n    function ParseSourceSpan(start, end, details) {\n        if (details === void 0) { details = null; }\n        this.start = start;\n        this.end = end;\n        this.details = details;\n    }\n    ParseSourceSpan.prototype.toString = function () {\n        return this.start.file.content.substring(this.start.offset, this.end.offset);\n    };\n    return ParseSourceSpan;\n}());\nvar EMPTY_PARSE_LOCATION = new ParseLocation(new ParseSourceFile('', ''), 0, 0, 0);\nvar EMPTY_SOURCE_SPAN = new ParseSourceSpan(EMPTY_PARSE_LOCATION, EMPTY_PARSE_LOCATION);\nvar ParseErrorLevel;\n(function (ParseErrorLevel) {\n    ParseErrorLevel[ParseErrorLevel[\"WARNING\"] = 0] = \"WARNING\";\n    ParseErrorLevel[ParseErrorLevel[\"ERROR\"] = 1] = \"ERROR\";\n})(ParseErrorLevel || (ParseErrorLevel = {}));\nvar ParseError = /** @class */ (function () {\n    function ParseError(span, msg, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this.span = span;\n        this.msg = msg;\n        this.level = level;\n    }\n    ParseError.prototype.contextualMessage = function () {\n        var ctx = this.span.start.getContext(100, 3);\n        return ctx ? this.msg + \" (\\\"\" + ctx.before + \"[\" + ParseErrorLevel[this.level] + \" ->]\" + ctx.after + \"\\\")\" :\n            this.msg;\n    };\n    ParseError.prototype.toString = function () {\n        var details = this.span.details ? \", \" + this.span.details : '';\n        return this.contextualMessage() + \": \" + this.span.start + details;\n    };\n    return ParseError;\n}());\nfunction typeSourceSpan(kind, type) {\n    var moduleUrl = identifierModuleUrl(type);\n    var sourceFileName = moduleUrl != null ? \"in \" + kind + \" \" + identifierName(type) + \" in \" + moduleUrl :\n        \"in \" + kind + \" \" + identifierName(type);\n    var sourceFile = new ParseSourceFile('', sourceFileName);\n    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n/**\n * Generates Source Span object for a given R3 Type for JIT mode.\n *\n * @param kind Component or Directive.\n * @param typeName name of the Component or Directive.\n * @param sourceUrl reference to Component or Directive source.\n * @returns instance of ParseSourceSpan that represent a given Component or Directive.\n */\nfunction r3JitTypeSourceSpan(kind, typeName, sourceUrl) {\n    var sourceFileName = \"in \" + kind + \" \" + typeName + \" in \" + sourceUrl;\n    var sourceFile = new ParseSourceFile('', sourceFileName);\n    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Text = /** @class */ (function () {\n    function Text(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    Text.prototype.visit = function (visitor) { return visitor.visitText(this); };\n    return Text;\n}());\nvar BoundText = /** @class */ (function () {\n    function BoundText(value, sourceSpan, i18n) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n    BoundText.prototype.visit = function (visitor) { return visitor.visitBoundText(this); };\n    return BoundText;\n}());\nvar TextAttribute = /** @class */ (function () {\n    function TextAttribute(name, value, sourceSpan, valueSpan, i18n) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n        this.i18n = i18n;\n    }\n    TextAttribute.prototype.visit = function (visitor) { return visitor.visitTextAttribute(this); };\n    return TextAttribute;\n}());\nvar BoundAttribute = /** @class */ (function () {\n    function BoundAttribute(name, type, securityContext, value, unit, sourceSpan, valueSpan, i18n) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n        this.i18n = i18n;\n    }\n    BoundAttribute.fromBoundElementProperty = function (prop, i18n) {\n        return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.valueSpan, i18n);\n    };\n    BoundAttribute.prototype.visit = function (visitor) { return visitor.visitBoundAttribute(this); };\n    return BoundAttribute;\n}());\nvar BoundEvent = /** @class */ (function () {\n    function BoundEvent(name, type, handler, target, phase, sourceSpan, handlerSpan) {\n        this.name = name;\n        this.type = type;\n        this.handler = handler;\n        this.target = target;\n        this.phase = phase;\n        this.sourceSpan = sourceSpan;\n        this.handlerSpan = handlerSpan;\n    }\n    BoundEvent.fromParsedEvent = function (event) {\n        var target = event.type === 0 /* Regular */ ? event.targetOrPhase : null;\n        var phase = event.type === 1 /* Animation */ ? event.targetOrPhase : null;\n        return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan);\n    };\n    BoundEvent.prototype.visit = function (visitor) { return visitor.visitBoundEvent(this); };\n    return BoundEvent;\n}());\nvar Element = /** @class */ (function () {\n    function Element(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n        this.name = name;\n        this.attributes = attributes;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.children = children;\n        this.references = references;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n        this.i18n = i18n;\n        // If the element is empty then the source span should include any closing tag\n        if (children.length === 0 && startSourceSpan && endSourceSpan) {\n            this.sourceSpan = new ParseSourceSpan(sourceSpan.start, endSourceSpan.end);\n        }\n    }\n    Element.prototype.visit = function (visitor) { return visitor.visitElement(this); };\n    return Element;\n}());\nvar Template = /** @class */ (function () {\n    function Template(tagName, attributes, inputs, outputs, templateAttrs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n        this.tagName = tagName;\n        this.attributes = attributes;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.templateAttrs = templateAttrs;\n        this.children = children;\n        this.references = references;\n        this.variables = variables;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n        this.i18n = i18n;\n    }\n    Template.prototype.visit = function (visitor) { return visitor.visitTemplate(this); };\n    return Template;\n}());\nvar Content = /** @class */ (function () {\n    function Content(selector, attributes, sourceSpan, i18n) {\n        this.selector = selector;\n        this.attributes = attributes;\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n    Content.prototype.visit = function (visitor) { return visitor.visitContent(this); };\n    return Content;\n}());\nvar Variable = /** @class */ (function () {\n    function Variable(name, value, sourceSpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n    }\n    Variable.prototype.visit = function (visitor) { return visitor.visitVariable(this); };\n    return Variable;\n}());\nvar Reference = /** @class */ (function () {\n    function Reference(name, value, sourceSpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n    }\n    Reference.prototype.visit = function (visitor) { return visitor.visitReference(this); };\n    return Reference;\n}());\nvar Icu = /** @class */ (function () {\n    function Icu(vars, placeholders, sourceSpan, i18n) {\n        this.vars = vars;\n        this.placeholders = placeholders;\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n    Icu.prototype.visit = function (visitor) { return visitor.visitIcu(this); };\n    return Icu;\n}());\nvar NullVisitor = /** @class */ (function () {\n    function NullVisitor() {\n    }\n    NullVisitor.prototype.visitElement = function (element) { };\n    NullVisitor.prototype.visitTemplate = function (template) { };\n    NullVisitor.prototype.visitContent = function (content) { };\n    NullVisitor.prototype.visitVariable = function (variable) { };\n    NullVisitor.prototype.visitReference = function (reference) { };\n    NullVisitor.prototype.visitTextAttribute = function (attribute) { };\n    NullVisitor.prototype.visitBoundAttribute = function (attribute) { };\n    NullVisitor.prototype.visitBoundEvent = function (attribute) { };\n    NullVisitor.prototype.visitText = function (text) { };\n    NullVisitor.prototype.visitBoundText = function (text) { };\n    NullVisitor.prototype.visitIcu = function (icu) { };\n    return NullVisitor;\n}());\nvar RecursiveVisitor = /** @class */ (function () {\n    function RecursiveVisitor() {\n    }\n    RecursiveVisitor.prototype.visitElement = function (element) {\n        visitAll(this, element.attributes);\n        visitAll(this, element.children);\n        visitAll(this, element.references);\n    };\n    RecursiveVisitor.prototype.visitTemplate = function (template) {\n        visitAll(this, template.attributes);\n        visitAll(this, template.children);\n        visitAll(this, template.references);\n        visitAll(this, template.variables);\n    };\n    RecursiveVisitor.prototype.visitContent = function (content) { };\n    RecursiveVisitor.prototype.visitVariable = function (variable) { };\n    RecursiveVisitor.prototype.visitReference = function (reference) { };\n    RecursiveVisitor.prototype.visitTextAttribute = function (attribute) { };\n    RecursiveVisitor.prototype.visitBoundAttribute = function (attribute) { };\n    RecursiveVisitor.prototype.visitBoundEvent = function (attribute) { };\n    RecursiveVisitor.prototype.visitText = function (text) { };\n    RecursiveVisitor.prototype.visitBoundText = function (text) { };\n    RecursiveVisitor.prototype.visitIcu = function (icu) { };\n    return RecursiveVisitor;\n}());\nvar TransformVisitor = /** @class */ (function () {\n    function TransformVisitor() {\n    }\n    TransformVisitor.prototype.visitElement = function (element) {\n        var newAttributes = transformAll(this, element.attributes);\n        var newInputs = transformAll(this, element.inputs);\n        var newOutputs = transformAll(this, element.outputs);\n        var newChildren = transformAll(this, element.children);\n        var newReferences = transformAll(this, element.references);\n        if (newAttributes != element.attributes || newInputs != element.inputs ||\n            newOutputs != element.outputs || newChildren != element.children ||\n            newReferences != element.references) {\n            return new Element(element.name, newAttributes, newInputs, newOutputs, newChildren, newReferences, element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n        }\n        return element;\n    };\n    TransformVisitor.prototype.visitTemplate = function (template) {\n        var newAttributes = transformAll(this, template.attributes);\n        var newInputs = transformAll(this, template.inputs);\n        var newOutputs = transformAll(this, template.outputs);\n        var newTemplateAttrs = transformAll(this, template.templateAttrs);\n        var newChildren = transformAll(this, template.children);\n        var newReferences = transformAll(this, template.references);\n        var newVariables = transformAll(this, template.variables);\n        if (newAttributes != template.attributes || newInputs != template.inputs ||\n            newOutputs != template.outputs || newTemplateAttrs != template.templateAttrs ||\n            newChildren != template.children || newReferences != template.references ||\n            newVariables != template.variables) {\n            return new Template(template.tagName, newAttributes, newInputs, newOutputs, newTemplateAttrs, newChildren, newReferences, newVariables, template.sourceSpan, template.startSourceSpan, template.endSourceSpan);\n        }\n        return template;\n    };\n    TransformVisitor.prototype.visitContent = function (content) { return content; };\n    TransformVisitor.prototype.visitVariable = function (variable) { return variable; };\n    TransformVisitor.prototype.visitReference = function (reference) { return reference; };\n    TransformVisitor.prototype.visitTextAttribute = function (attribute) { return attribute; };\n    TransformVisitor.prototype.visitBoundAttribute = function (attribute) { return attribute; };\n    TransformVisitor.prototype.visitBoundEvent = function (attribute) { return attribute; };\n    TransformVisitor.prototype.visitText = function (text) { return text; };\n    TransformVisitor.prototype.visitBoundText = function (text) { return text; };\n    TransformVisitor.prototype.visitIcu = function (icu) { return icu; };\n    return TransformVisitor;\n}());\nfunction visitAll(visitor, nodes) {\n    var e_1, _a, e_2, _b;\n    var result = [];\n    if (visitor.visit) {\n        try {\n            for (var nodes_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\n                var node = nodes_1_1.value;\n                var newNode = visitor.visit(node) || node.visit(visitor);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    else {\n        try {\n            for (var nodes_2 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(nodes), nodes_2_1 = nodes_2.next(); !nodes_2_1.done; nodes_2_1 = nodes_2.next()) {\n                var node = nodes_2_1.value;\n                var newNode = node.visit(visitor);\n                if (newNode) {\n                    result.push(newNode);\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (nodes_2_1 && !nodes_2_1.done && (_b = nodes_2.return)) _b.call(nodes_2);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    }\n    return result;\n}\nfunction transformAll(visitor, nodes) {\n    var e_3, _a;\n    var result = [];\n    var changed = false;\n    try {\n        for (var nodes_3 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(nodes), nodes_3_1 = nodes_3.next(); !nodes_3_1.done; nodes_3_1 = nodes_3.next()) {\n            var node = nodes_3_1.value;\n            var newNode = node.visit(visitor);\n            if (newNode) {\n                result.push(newNode);\n            }\n            changed = changed || newNode != node;\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (nodes_3_1 && !nodes_3_1.done && (_a = nodes_3.return)) _a.call(nodes_3);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    return changed ? result : nodes;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Message = /** @class */ (function () {\n    /**\n     * @param nodes message AST\n     * @param placeholders maps placeholder names to static content\n     * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n     * @param meaning\n     * @param description\n     * @param id\n     */\n    function Message(nodes, placeholders, placeholderToMessage, meaning, description, id) {\n        this.nodes = nodes;\n        this.placeholders = placeholders;\n        this.placeholderToMessage = placeholderToMessage;\n        this.meaning = meaning;\n        this.description = description;\n        this.id = id;\n        if (nodes.length) {\n            this.sources = [{\n                    filePath: nodes[0].sourceSpan.start.file.url,\n                    startLine: nodes[0].sourceSpan.start.line + 1,\n                    startCol: nodes[0].sourceSpan.start.col + 1,\n                    endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n                    endCol: nodes[0].sourceSpan.start.col + 1\n                }];\n        }\n        else {\n            this.sources = [];\n        }\n    }\n    return Message;\n}());\nvar Text$1 = /** @class */ (function () {\n    function Text(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    Text.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n    return Text;\n}());\n// TODO(vicb): do we really need this node (vs an array) ?\nvar Container = /** @class */ (function () {\n    function Container(children, sourceSpan) {\n        this.children = children;\n        this.sourceSpan = sourceSpan;\n    }\n    Container.prototype.visit = function (visitor, context) { return visitor.visitContainer(this, context); };\n    return Container;\n}());\nvar Icu$1 = /** @class */ (function () {\n    function Icu(expression, type, cases, sourceSpan) {\n        this.expression = expression;\n        this.type = type;\n        this.cases = cases;\n        this.sourceSpan = sourceSpan;\n    }\n    Icu.prototype.visit = function (visitor, context) { return visitor.visitIcu(this, context); };\n    return Icu;\n}());\nvar TagPlaceholder = /** @class */ (function () {\n    function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {\n        this.tag = tag;\n        this.attrs = attrs;\n        this.startName = startName;\n        this.closeName = closeName;\n        this.children = children;\n        this.isVoid = isVoid;\n        this.sourceSpan = sourceSpan;\n    }\n    TagPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitTagPlaceholder(this, context); };\n    return TagPlaceholder;\n}());\nvar Placeholder = /** @class */ (function () {\n    function Placeholder(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    Placeholder.prototype.visit = function (visitor, context) { return visitor.visitPlaceholder(this, context); };\n    return Placeholder;\n}());\nvar IcuPlaceholder = /** @class */ (function () {\n    function IcuPlaceholder(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    IcuPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitIcuPlaceholder(this, context); };\n    return IcuPlaceholder;\n}());\n// Clone the AST\nvar CloneVisitor = /** @class */ (function () {\n    function CloneVisitor() {\n    }\n    CloneVisitor.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };\n    CloneVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var children = container.children.map(function (n) { return n.visit(_this, context); });\n        return new Container(children, container.sourceSpan);\n    };\n    CloneVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var cases = {};\n        Object.keys(icu.cases).forEach(function (key) { return cases[key] = icu.cases[key].visit(_this, context); });\n        var msg = new Icu$1(icu.expression, icu.type, cases, icu.sourceSpan);\n        msg.expressionPlaceholder = icu.expressionPlaceholder;\n        return msg;\n    };\n    CloneVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var children = ph.children.map(function (n) { return n.visit(_this, context); });\n        return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan);\n    };\n    CloneVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n    };\n    CloneVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n    };\n    return CloneVisitor;\n}());\n// Visit all the nodes recursively\nvar RecurseVisitor = /** @class */ (function () {\n    function RecurseVisitor() {\n    }\n    RecurseVisitor.prototype.visitText = function (text, context) { };\n    RecurseVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        container.children.forEach(function (child) { return child.visit(_this); });\n    };\n    RecurseVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        Object.keys(icu.cases).forEach(function (k) { icu.cases[k].visit(_this); });\n    };\n    RecurseVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        ph.children.forEach(function (child) { return child.visit(_this); });\n    };\n    RecurseVisitor.prototype.visitPlaceholder = function (ph, context) { };\n    RecurseVisitor.prototype.visitIcuPlaceholder = function (ph, context) { };\n    return RecurseVisitor;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction digest(message) {\n    return message.id || sha1(serializeNodes(message.nodes).join('') + (\"[\" + message.meaning + \"]\"));\n}\nfunction decimalDigest(message) {\n    if (message.id) {\n        return message.id;\n    }\n    var visitor = new _SerializerIgnoreIcuExpVisitor();\n    var parts = message.nodes.map(function (a) { return a.visit(visitor, null); });\n    return computeMsgId(parts.join(''), message.meaning);\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\nvar _SerializerVisitor = /** @class */ (function () {\n    function _SerializerVisitor() {\n    }\n    _SerializerVisitor.prototype.visitText = function (text, context) { return text.value; };\n    _SerializerVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        return \"[\" + container.children.map(function (child) { return child.visit(_this); }).join(', ') + \"]\";\n    };\n    _SerializerVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var strCases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        return \"{\" + icu.expression + \", \" + icu.type + \", \" + strCases.join(', ') + \"}\";\n    };\n    _SerializerVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        return ph.isVoid ?\n            \"<ph tag name=\\\"\" + ph.startName + \"\\\"/>\" :\n            \"<ph tag name=\\\"\" + ph.startName + \"\\\">\" + ph.children.map(function (child) { return child.visit(_this); }).join(', ') + \"</ph name=\\\"\" + ph.closeName + \"\\\">\";\n    };\n    _SerializerVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return ph.value ? \"<ph name=\\\"\" + ph.name + \"\\\">\" + ph.value + \"</ph>\" : \"<ph name=\\\"\" + ph.name + \"\\\"/>\";\n    };\n    _SerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return \"<ph icu name=\\\"\" + ph.name + \"\\\">\" + ph.value.visit(this) + \"</ph>\";\n    };\n    return _SerializerVisitor;\n}());\nvar serializerVisitor = new _SerializerVisitor();\nfunction serializeNodes(nodes) {\n    return nodes.map(function (a) { return a.visit(serializerVisitor, null); });\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\nvar _SerializerIgnoreIcuExpVisitor = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(_SerializerIgnoreIcuExpVisitor, _super);\n    function _SerializerIgnoreIcuExpVisitor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    _SerializerIgnoreIcuExpVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var strCases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        // Do not take the expression into account\n        return \"{\" + icu.type + \", \" + strCases.join(', ') + \"}\";\n    };\n    return _SerializerIgnoreIcuExpVisitor;\n}(_SerializerVisitor));\n/**\n * Compute the SHA1 of the given string\n *\n * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\nfunction sha1(str) {\n    var _a, _b;\n    var utf8 = utf8Encode(str);\n    var words32 = stringToWords32(utf8, Endian.Big);\n    var len = utf8.length * 8;\n    var w = new Array(80);\n    var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0], 5), a = _c[0], b = _c[1], c = _c[2], d = _c[3], e = _c[4];\n    words32[len >> 5] |= 0x80 << (24 - len % 32);\n    words32[((len + 64 >> 9) << 4) + 15] = len;\n    for (var i = 0; i < words32.length; i += 16) {\n        var _d = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])([a, b, c, d, e], 5), h0 = _d[0], h1 = _d[1], h2 = _d[2], h3 = _d[3], h4 = _d[4];\n        for (var j = 0; j < 80; j++) {\n            if (j < 16) {\n                w[j] = words32[i + j];\n            }\n            else {\n                w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n            }\n            var _e = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(fk(j, b, c, d), 2), f = _e[0], k = _e[1];\n            var temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n            _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])([d, c, rol32(b, 30), a, temp], 5), e = _a[0], d = _a[1], c = _a[2], b = _a[3], a = _a[4];\n        }\n        _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])([add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)], 5), a = _b[0], b = _b[1], c = _b[2], d = _b[3], e = _b[4];\n    }\n    return byteStringToHexString(words32ToByteString([a, b, c, d, e]));\n}\nfunction fk(index, b, c, d) {\n    if (index < 20) {\n        return [(b & c) | (~b & d), 0x5a827999];\n    }\n    if (index < 40) {\n        return [b ^ c ^ d, 0x6ed9eba1];\n    }\n    if (index < 60) {\n        return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n    }\n    return [b ^ c ^ d, 0xca62c1d6];\n}\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\nfunction fingerprint(str) {\n    var utf8 = utf8Encode(str);\n    var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])([hash32(utf8, 0), hash32(utf8, 102072)], 2), hi = _a[0], lo = _a[1];\n    if (hi == 0 && (lo == 0 || lo == 1)) {\n        hi = hi ^ 0x130f9bef;\n        lo = lo ^ -0x6b5f56d8;\n    }\n    return [hi, lo];\n}\nfunction computeMsgId(msg, meaning) {\n    var _a;\n    var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(fingerprint(msg), 2), hi = _b[0], lo = _b[1];\n    if (meaning) {\n        var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(fingerprint(meaning), 2), him = _c[0], lom = _c[1];\n        _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(add64(rol64([hi, lo], 1), [him, lom]), 2), hi = _a[0], lo = _a[1];\n    }\n    return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));\n}\nfunction hash32(str, c) {\n    var _a;\n    var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])([0x9e3779b9, 0x9e3779b9], 2), a = _b[0], b = _b[1];\n    var i;\n    var len = str.length;\n    for (i = 0; i + 12 <= len; i += 12) {\n        a = add32(a, wordAt(str, i, Endian.Little));\n        b = add32(b, wordAt(str, i + 4, Endian.Little));\n        c = add32(c, wordAt(str, i + 8, Endian.Little));\n        _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(mix([a, b, c]), 3), a = _a[0], b = _a[1], c = _a[2];\n    }\n    a = add32(a, wordAt(str, i, Endian.Little));\n    b = add32(b, wordAt(str, i + 4, Endian.Little));\n    // the first byte of c is reserved for the length\n    c = add32(c, len);\n    c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);\n    return mix([a, b, c])[2];\n}\n// clang-format off\nfunction mix(_a) {\n    var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(_a, 3), a = _b[0], b = _b[1], c = _b[2];\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 13;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 8;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 13;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 12;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 16;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 5;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 3;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 10;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 15;\n    return [a, b, c];\n}\n// clang-format on\n// Utils\nvar Endian;\n(function (Endian) {\n    Endian[Endian[\"Little\"] = 0] = \"Little\";\n    Endian[Endian[\"Big\"] = 1] = \"Big\";\n})(Endian || (Endian = {}));\nfunction add32(a, b) {\n    return add32to64(a, b)[1];\n}\nfunction add32to64(a, b) {\n    var low = (a & 0xffff) + (b & 0xffff);\n    var high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n    return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\nfunction add64(_a, _b) {\n    var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(_a, 2), ah = _c[0], al = _c[1];\n    var _d = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(_b, 2), bh = _d[0], bl = _d[1];\n    var _e = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(add32to64(al, bl), 2), carry = _e[0], l = _e[1];\n    var h = add32(add32(ah, bh), carry);\n    return [h, l];\n}\nfunction sub32(a, b) {\n    var low = (a & 0xffff) - (b & 0xffff);\n    var high = (a >> 16) - (b >> 16) + (low >> 16);\n    return (high << 16) | (low & 0xffff);\n}\n// Rotate a 32b number left `count` position\nfunction rol32(a, count) {\n    return (a << count) | (a >>> (32 - count));\n}\n// Rotate a 64b number left `count` position\nfunction rol64(_a, count) {\n    var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(_a, 2), hi = _b[0], lo = _b[1];\n    var h = (hi << count) | (lo >>> (32 - count));\n    var l = (lo << count) | (hi >>> (32 - count));\n    return [h, l];\n}\nfunction stringToWords32(str, endian) {\n    var words32 = Array((str.length + 3) >>> 2);\n    for (var i = 0; i < words32.length; i++) {\n        words32[i] = wordAt(str, i * 4, endian);\n    }\n    return words32;\n}\nfunction byteAt(str, index) {\n    return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;\n}\nfunction wordAt(str, index, endian) {\n    var word = 0;\n    if (endian === Endian.Big) {\n        for (var i = 0; i < 4; i++) {\n            word += byteAt(str, index + i) << (24 - 8 * i);\n        }\n    }\n    else {\n        for (var i = 0; i < 4; i++) {\n            word += byteAt(str, index + i) << 8 * i;\n        }\n    }\n    return word;\n}\nfunction words32ToByteString(words32) {\n    return words32.reduce(function (str, word) { return str + word32ToByteString(word); }, '');\n}\nfunction word32ToByteString(word) {\n    var str = '';\n    for (var i = 0; i < 4; i++) {\n        str += String.fromCharCode((word >>> 8 * (3 - i)) & 0xff);\n    }\n    return str;\n}\nfunction byteStringToHexString(str) {\n    var hex = '';\n    for (var i = 0; i < str.length; i++) {\n        var b = byteAt(str, i);\n        hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n    }\n    return hex.toLowerCase();\n}\n// based on http://www.danvk.org/hex2dec.html (JS can not handle more than 56b)\nfunction byteStringToDecString(str) {\n    var decimal = '';\n    var toThePower = '1';\n    for (var i = str.length - 1; i >= 0; i--) {\n        decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));\n        toThePower = numberTimesBigInt(256, toThePower);\n    }\n    return decimal.split('').reverse().join('');\n}\n// x and y decimal, lowest significant digit first\nfunction addBigInt(x, y) {\n    var sum = '';\n    var len = Math.max(x.length, y.length);\n    for (var i = 0, carry = 0; i < len || carry; i++) {\n        var tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);\n        if (tmpSum >= 10) {\n            carry = 1;\n            sum += tmpSum - 10;\n        }\n        else {\n            carry = 0;\n            sum += tmpSum;\n        }\n    }\n    return sum;\n}\nfunction numberTimesBigInt(num, b) {\n    var product = '';\n    var bToThePower = b;\n    for (; num !== 0; num = num >>> 1) {\n        if (num & 1)\n            product = addBigInt(product, bToThePower);\n        bToThePower = addBigInt(bToThePower, bToThePower);\n    }\n    return product;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Serializer = /** @class */ (function () {\n    function Serializer() {\n    }\n    // Creates a name mapper, see `PlaceholderMapper`\n    // Returning `null` means that no name mapping is used.\n    Serializer.prototype.createNameMapper = function (message) { return null; };\n    return Serializer;\n}());\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nvar SimplePlaceholderMapper = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(SimplePlaceholderMapper, _super);\n    // create a mapping from the message\n    function SimplePlaceholderMapper(message, mapName) {\n        var _this = _super.call(this) || this;\n        _this.mapName = mapName;\n        _this.internalToPublic = {};\n        _this.publicToNextId = {};\n        _this.publicToInternal = {};\n        message.nodes.forEach(function (node) { return node.visit(_this); });\n        return _this;\n    }\n    SimplePlaceholderMapper.prototype.toPublicName = function (internalName) {\n        return this.internalToPublic.hasOwnProperty(internalName) ?\n            this.internalToPublic[internalName] :\n            null;\n    };\n    SimplePlaceholderMapper.prototype.toInternalName = function (publicName) {\n        return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\n            null;\n    };\n    SimplePlaceholderMapper.prototype.visitText = function (text, context) { return null; };\n    SimplePlaceholderMapper.prototype.visitTagPlaceholder = function (ph, context) {\n        this.visitPlaceholderName(ph.startName);\n        _super.prototype.visitTagPlaceholder.call(this, ph, context);\n        this.visitPlaceholderName(ph.closeName);\n    };\n    SimplePlaceholderMapper.prototype.visitPlaceholder = function (ph, context) { this.visitPlaceholderName(ph.name); };\n    SimplePlaceholderMapper.prototype.visitIcuPlaceholder = function (ph, context) {\n        this.visitPlaceholderName(ph.name);\n    };\n    // XMB placeholders could only contains A-Z, 0-9 and _\n    SimplePlaceholderMapper.prototype.visitPlaceholderName = function (internalName) {\n        if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n            return;\n        }\n        var publicName = this.mapName(internalName);\n        if (this.publicToInternal.hasOwnProperty(publicName)) {\n            // Create a new XMB when it has already been used\n            var nextId = this.publicToNextId[publicName];\n            this.publicToNextId[publicName] = nextId + 1;\n            publicName = publicName + \"_\" + nextId;\n        }\n        else {\n            this.publicToNextId[publicName] = 1;\n        }\n        this.internalToPublic[internalName] = publicName;\n        this.publicToInternal[publicName] = internalName;\n    };\n    return SimplePlaceholderMapper;\n}(RecurseVisitor));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _Visitor = /** @class */ (function () {\n    function _Visitor() {\n    }\n    _Visitor.prototype.visitTag = function (tag) {\n        var _this = this;\n        var strAttrs = this._serializeAttributes(tag.attrs);\n        if (tag.children.length == 0) {\n            return \"<\" + tag.name + strAttrs + \"/>\";\n        }\n        var strChildren = tag.children.map(function (node) { return node.visit(_this); });\n        return \"<\" + tag.name + strAttrs + \">\" + strChildren.join('') + \"</\" + tag.name + \">\";\n    };\n    _Visitor.prototype.visitText = function (text) { return text.value; };\n    _Visitor.prototype.visitDeclaration = function (decl) {\n        return \"<?xml\" + this._serializeAttributes(decl.attrs) + \" ?>\";\n    };\n    _Visitor.prototype._serializeAttributes = function (attrs) {\n        var strAttrs = Object.keys(attrs).map(function (name) { return name + \"=\\\"\" + attrs[name] + \"\\\"\"; }).join(' ');\n        return strAttrs.length > 0 ? ' ' + strAttrs : '';\n    };\n    _Visitor.prototype.visitDoctype = function (doctype) {\n        return \"<!DOCTYPE \" + doctype.rootTag + \" [\\n\" + doctype.dtd + \"\\n]>\";\n    };\n    return _Visitor;\n}());\nvar _visitor = new _Visitor();\nfunction serialize(nodes) {\n    return nodes.map(function (node) { return node.visit(_visitor); }).join('');\n}\nvar Declaration = /** @class */ (function () {\n    function Declaration(unescapedAttrs) {\n        var _this = this;\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach(function (k) {\n            _this.attrs[k] = escapeXml(unescapedAttrs[k]);\n        });\n    }\n    Declaration.prototype.visit = function (visitor) { return visitor.visitDeclaration(this); };\n    return Declaration;\n}());\nvar Doctype = /** @class */ (function () {\n    function Doctype(rootTag, dtd) {\n        this.rootTag = rootTag;\n        this.dtd = dtd;\n    }\n    Doctype.prototype.visit = function (visitor) { return visitor.visitDoctype(this); };\n    return Doctype;\n}());\nvar Tag = /** @class */ (function () {\n    function Tag(name, unescapedAttrs, children) {\n        var _this = this;\n        if (unescapedAttrs === void 0) { unescapedAttrs = {}; }\n        if (children === void 0) { children = []; }\n        this.name = name;\n        this.children = children;\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach(function (k) {\n            _this.attrs[k] = escapeXml(unescapedAttrs[k]);\n        });\n    }\n    Tag.prototype.visit = function (visitor) { return visitor.visitTag(this); };\n    return Tag;\n}());\nvar Text$2 = /** @class */ (function () {\n    function Text(unescapedValue) {\n        this.value = escapeXml(unescapedValue);\n    }\n    Text.prototype.visit = function (visitor) { return visitor.visitText(this); };\n    return Text;\n}());\nvar CR = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(CR, _super);\n    function CR(ws) {\n        if (ws === void 0) { ws = 0; }\n        return _super.call(this, \"\\n\" + new Array(ws + 1).join(' ')) || this;\n    }\n    return CR;\n}(Text$2));\nvar _ESCAPED_CHARS = [\n    [/&/g, '&amp;'],\n    [/\"/g, '&quot;'],\n    [/'/g, '&apos;'],\n    [/</g, '&lt;'],\n    [/>/g, '&gt;'],\n];\n// Escape `_ESCAPED_CHARS` characters in the given text with encoded entities\nfunction escapeXml(text) {\n    return _ESCAPED_CHARS.reduce(function (text, entry) { return text.replace(entry[0], entry[1]); }, text);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _MESSAGES_TAG = 'messagebundle';\nvar _MESSAGE_TAG = 'msg';\nvar _PLACEHOLDER_TAG = 'ph';\nvar _EXAMPLE_TAG = 'ex';\nvar _SOURCE_TAG = 'source';\nvar _DOCTYPE = \"<!ELEMENT messagebundle (msg)*>\\n<!ATTLIST messagebundle class CDATA #IMPLIED>\\n\\n<!ELEMENT msg (#PCDATA|ph|source)*>\\n<!ATTLIST msg id CDATA #IMPLIED>\\n<!ATTLIST msg seq CDATA #IMPLIED>\\n<!ATTLIST msg name CDATA #IMPLIED>\\n<!ATTLIST msg desc CDATA #IMPLIED>\\n<!ATTLIST msg meaning CDATA #IMPLIED>\\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\\n<!ATTLIST msg xml:space (default|preserve) \\\"default\\\">\\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\\n\\n<!ELEMENT source (#PCDATA)>\\n\\n<!ELEMENT ph (#PCDATA|ex)*>\\n<!ATTLIST ph name CDATA #REQUIRED>\\n\\n<!ELEMENT ex (#PCDATA)>\";\nvar Xmb = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Xmb, _super);\n    function Xmb() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Xmb.prototype.write = function (messages, locale) {\n        var exampleVisitor = new ExampleVisitor();\n        var visitor = new _Visitor$1();\n        var rootNode = new Tag(_MESSAGES_TAG);\n        messages.forEach(function (message) {\n            var attrs = { id: message.id };\n            if (message.description) {\n                attrs['desc'] = message.description;\n            }\n            if (message.meaning) {\n                attrs['meaning'] = message.meaning;\n            }\n            var sourceTags = [];\n            message.sources.forEach(function (source) {\n                sourceTags.push(new Tag(_SOURCE_TAG, {}, [\n                    new Text$2(source.filePath + \":\" + source.startLine + (source.endLine !== source.startLine ? ',' + source.endLine : ''))\n                ]));\n            });\n            rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(sourceTags, visitor.serialize(message.nodes))));\n        });\n        rootNode.children.push(new CR());\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }),\n            new CR(),\n            new Doctype(_MESSAGES_TAG, _DOCTYPE),\n            new CR(),\n            exampleVisitor.addDefaultExamples(rootNode),\n            new CR(),\n        ]);\n    };\n    Xmb.prototype.load = function (content, url) {\n        throw new Error('Unsupported');\n    };\n    Xmb.prototype.digest = function (message) { return digest$1(message); };\n    Xmb.prototype.createNameMapper = function (message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    };\n    return Xmb;\n}(Serializer));\nvar _Visitor$1 = /** @class */ (function () {\n    function _Visitor() {\n    }\n    _Visitor.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };\n    _Visitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(node.visit(_this))); });\n        return nodes;\n    };\n    _Visitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var nodes = [new Text$2(\"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \")];\n        Object.keys(icu.cases).forEach(function (c) {\n            nodes.push.apply(nodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([new Text$2(c + \" {\")], icu.cases[c].visit(_this), [new Text$2(\"} \")]));\n        });\n        nodes.push(new Text$2(\"}\"));\n        return nodes;\n    };\n    _Visitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var startTagAsText = new Text$2(\"<\" + ph.tag + \">\");\n        var startEx = new Tag(_EXAMPLE_TAG, {}, [startTagAsText]);\n        // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n        var startTagPh = new Tag(_PLACEHOLDER_TAG, { name: ph.startName }, [startEx, startTagAsText]);\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [startTagPh];\n        }\n        var closeTagAsText = new Text$2(\"</\" + ph.tag + \">\");\n        var closeEx = new Tag(_EXAMPLE_TAG, {}, [closeTagAsText]);\n        // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n        var closeTagPh = new Tag(_PLACEHOLDER_TAG, { name: ph.closeName }, [closeEx, closeTagAsText]);\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([startTagPh], this.serialize(ph.children), [closeTagPh]);\n    };\n    _Visitor.prototype.visitPlaceholder = function (ph, context) {\n        var interpolationAsText = new Text$2(\"{{\" + ph.value + \"}}\");\n        // Example tag needs to be not-empty for TC.\n        var exTag = new Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\n        return [\n            // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n            new Tag(_PLACEHOLDER_TAG, { name: ph.name }, [exTag, interpolationAsText])\n        ];\n    };\n    _Visitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        var icuExpression = ph.value.expression;\n        var icuType = ph.value.type;\n        var icuCases = Object.keys(ph.value.cases).map(function (value) { return value + ' {...}'; }).join(' ');\n        var icuAsText = new Text$2(\"{\" + icuExpression + \", \" + icuType + \", \" + icuCases + \"}\");\n        var exTag = new Tag(_EXAMPLE_TAG, {}, [icuAsText]);\n        return [\n            // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n            new Tag(_PLACEHOLDER_TAG, { name: ph.name }, [exTag, icuAsText])\n        ];\n    };\n    _Visitor.prototype.serialize = function (nodes) {\n        var _this = this;\n        return [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(nodes.map(function (node) { return node.visit(_this); })));\n    };\n    return _Visitor;\n}());\nfunction digest$1(message) {\n    return decimalDigest(message);\n}\n// TC requires at least one non-empty example on placeholders\nvar ExampleVisitor = /** @class */ (function () {\n    function ExampleVisitor() {\n    }\n    ExampleVisitor.prototype.addDefaultExamples = function (node) {\n        node.visit(this);\n        return node;\n    };\n    ExampleVisitor.prototype.visitTag = function (tag) {\n        var _this = this;\n        if (tag.name === _PLACEHOLDER_TAG) {\n            if (!tag.children || tag.children.length == 0) {\n                var exText = new Text$2(tag.attrs['name'] || '...');\n                tag.children = [new Tag(_EXAMPLE_TAG, {}, [exText])];\n            }\n        }\n        else if (tag.children) {\n            tag.children.forEach(function (node) { return node.visit(_this); });\n        }\n    };\n    ExampleVisitor.prototype.visitText = function (text) { };\n    ExampleVisitor.prototype.visitDeclaration = function (decl) { };\n    ExampleVisitor.prototype.visitDoctype = function (doctype) { };\n    return ExampleVisitor;\n}());\n// XMB/XTB placeholders can only contain A-Z, 0-9 and _\nfunction toPublicName(internalName) {\n    return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction mapEntry(key, value) {\n    return { key: key, value: value, quoted: false };\n}\nfunction mapLiteral(obj, quoted) {\n    if (quoted === void 0) { quoted = false; }\n    return literalMap(Object.keys(obj).map(function (key) { return ({\n        key: key,\n        quoted: quoted,\n        value: obj[key],\n    }); }));\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\nvar CLOSURE_TRANSLATION_PREFIX = 'MSG_';\n/* Prefix for non-`goog.getMsg` i18n-related vars */\nvar TRANSLATION_PREFIX = 'I18N_';\n/** Closure uses `goog.getMsg(message)` to lookup translations */\nvar GOOG_GET_MSG = 'goog.getMsg';\n/** Name of the global variable that is used to determine if we use Closure translations or not */\nvar NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';\n/** I18n separators for metadata **/\nvar I18N_MEANING_SEPARATOR = '|';\nvar I18N_ID_SEPARATOR = '@@';\n/** Name of the i18n attributes **/\nvar I18N_ATTR = 'i18n';\nvar I18N_ATTR_PREFIX = 'i18n-';\n/** Prefix of var expressions used in ICUs */\nvar I18N_ICU_VAR_PREFIX = 'VAR_';\n/** Prefix of ICU expressions for post processing */\nvar I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n/** Placeholder wrapper for i18n expressions **/\nvar I18N_PLACEHOLDER_SYMBOL = '�';\nfunction i18nTranslationToDeclStmt(variable$1, closureVar, message, meta, params) {\n    var statements = [];\n    // var I18N_X;\n    statements.push(new DeclareVarStmt(variable$1.name, undefined, INFERRED_TYPE, null, variable$1.sourceSpan));\n    var args = [literal(message)];\n    if (params && Object.keys(params).length) {\n        args.push(mapLiteral(params, true));\n    }\n    // Closure JSDoc comments\n    var docStatements = i18nMetaToDocStmt(meta);\n    var thenStatements = docStatements ? [docStatements] : [];\n    var googFnCall = variable(GOOG_GET_MSG).callFn(args);\n    // const MSG_... = goog.getMsg(..);\n    thenStatements.push(closureVar.set(googFnCall).toConstDecl());\n    // I18N_X = MSG_...;\n    thenStatements.push(new ExpressionStatement(variable$1.set(closureVar)));\n    var localizeFnCall = importExpr(Identifiers$1.i18nLocalize).callFn(args);\n    // I18N_X = i18nLocalize(...);\n    var elseStatements = [new ExpressionStatement(variable$1.set(localizeFnCall))];\n    // if(ngI18nClosureMode) { ... } else { ... }\n    statements.push(ifStmt(variable(NG_I18N_CLOSURE_MODE), thenStatements, elseStatements));\n    return statements;\n}\n// Converts i18n meta information for a message (id, description, meaning)\n// to a JsDoc statement formatted as expected by the Closure compiler.\nfunction i18nMetaToDocStmt(meta) {\n    var tags = [];\n    if (meta.description) {\n        tags.push({ tagName: \"desc\" /* Desc */, text: meta.description });\n    }\n    if (meta.meaning) {\n        tags.push({ tagName: \"meaning\" /* Meaning */, text: meta.meaning });\n    }\n    return tags.length == 0 ? null : new JSDocCommentStmt(tags);\n}\nfunction isI18nAttribute(name) {\n    return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\nfunction isI18nRootNode(meta) {\n    return meta instanceof Message;\n}\nfunction isSingleI18nIcu(meta) {\n    return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu$1;\n}\nfunction hasI18nAttrs(element) {\n    return element.attrs.some(function (attr) { return isI18nAttribute(attr.name); });\n}\nfunction metaFromI18nMessage(message, id) {\n    if (id === void 0) { id = null; }\n    return {\n        id: typeof id === 'string' ? id : message.id || '',\n        meaning: message.meaning || '',\n        description: message.description || ''\n    };\n}\nfunction icuFromI18nMessage(message) {\n    return message.nodes[0];\n}\nfunction wrapI18nPlaceholder(content, contextId) {\n    if (contextId === void 0) { contextId = 0; }\n    var blockId = contextId > 0 ? \":\" + contextId : '';\n    return \"\" + I18N_PLACEHOLDER_SYMBOL + content + blockId + I18N_PLACEHOLDER_SYMBOL;\n}\nfunction assembleI18nBoundString(strings, bindingStartIndex, contextId) {\n    if (bindingStartIndex === void 0) { bindingStartIndex = 0; }\n    if (contextId === void 0) { contextId = 0; }\n    if (!strings.length)\n        return '';\n    var acc = '';\n    var lastIdx = strings.length - 1;\n    for (var i = 0; i < lastIdx; i++) {\n        acc += \"\" + strings[i] + wrapI18nPlaceholder(bindingStartIndex + i, contextId);\n    }\n    acc += strings[lastIdx];\n    return acc;\n}\nfunction getSeqNumberGenerator(startsAt) {\n    if (startsAt === void 0) { startsAt = 0; }\n    var current = startsAt;\n    return function () { return current++; };\n}\nfunction placeholdersToParams(placeholders) {\n    var params = {};\n    placeholders.forEach(function (values, key) {\n        params[key] = literal(values.length > 1 ? \"[\" + values.join('|') + \"]\" : values[0]);\n    });\n    return params;\n}\nfunction updatePlaceholderMap(map, name) {\n    var values = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        values[_i - 2] = arguments[_i];\n    }\n    var current = map.get(name) || [];\n    current.push.apply(current, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(values));\n    map.set(name, current);\n}\nfunction assembleBoundTextPlaceholders(meta, bindingStartIndex, contextId) {\n    if (bindingStartIndex === void 0) { bindingStartIndex = 0; }\n    if (contextId === void 0) { contextId = 0; }\n    var startIdx = bindingStartIndex;\n    var placeholders = new Map();\n    var node = meta instanceof Message ? meta.nodes.find(function (node) { return node instanceof Container; }) : meta;\n    if (node) {\n        node\n            .children\n            .filter(function (child) { return child instanceof Placeholder; })\n            .forEach(function (child, idx) {\n            var content = wrapI18nPlaceholder(startIdx + idx, contextId);\n            updatePlaceholderMap(placeholders, child.name, content);\n        });\n    }\n    return placeholders;\n}\nfunction findIndex(items, callback) {\n    for (var i = 0; i < items.length; i++) {\n        if (callback(items[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Parses i18n metas like:\n *  - \"@@id\",\n *  - \"description[@@id]\",\n *  - \"meaning|description[@@id]\"\n * and returns an object with parsed output.\n *\n * @param meta String that represents i18n meta\n * @returns Object with id, meaning and description fields\n */\nfunction parseI18nMeta(meta) {\n    var _a, _b;\n    var id;\n    var meaning;\n    var description;\n    if (meta) {\n        var idIndex = meta.indexOf(I18N_ID_SEPARATOR);\n        var descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);\n        var meaningAndDesc = void 0;\n        _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])((idIndex > -1) ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''], 2), meaningAndDesc = _a[0], id = _a[1];\n        _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])((descIndex > -1) ?\n            [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n            ['', meaningAndDesc], 2), meaning = _b[0], description = _b[1];\n    }\n    return { id: id, meaning: meaning, description: description };\n}\n/**\n * Converts internal placeholder names to public-facing format\n * (for example to use in goog.getMsg call).\n * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.\n *\n * @param name The placeholder name that should be formatted\n * @returns Formatted placeholder name\n */\nfunction formatI18nPlaceholderName(name, useCamelCase) {\n    if (useCamelCase === void 0) { useCamelCase = true; }\n    var publicName = toPublicName(name);\n    if (!useCamelCase) {\n        return publicName;\n    }\n    var chunks = publicName.split('_');\n    if (chunks.length === 1) {\n        // if no \"_\" found - just lowercase the value\n        return name.toLowerCase();\n    }\n    var postfix;\n    // eject last element if it's a number\n    if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n        postfix = chunks.pop();\n    }\n    var raw = chunks.shift().toLowerCase();\n    if (chunks.length) {\n        raw += chunks.map(function (c) { return c.charAt(0).toUpperCase() + c.slice(1).toLowerCase(); }).join('');\n    }\n    return postfix ? raw + \"_\" + postfix : raw;\n}\n/**\n * Generates a prefix for translation const name.\n *\n * @param extra Additional local prefix that should be injected into translation var name\n * @returns Complete translation const prefix\n */\nfunction getTranslationConstPrefix(extra) {\n    return (\"\" + CLOSURE_TRANSLATION_PREFIX + extra).toUpperCase();\n}\n/**\n * Generates translation declaration statements.\n *\n * @param variable Translation value reference\n * @param closureVar Variable for Closure `goog.getMsg` calls\n * @param message Text message to be translated\n * @param meta Object that contains meta information (id, meaning and description)\n * @param params Object with placeholders key-value pairs\n * @param transformFn Optional transformation (post processing) function reference\n * @returns Array of Statements that represent a given translation\n */\nfunction getTranslationDeclStmts(variable, closureVar, message, meta, params, transformFn) {\n    if (params === void 0) { params = {}; }\n    var statements = [];\n    statements.push.apply(statements, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(i18nTranslationToDeclStmt(variable, closureVar, message, meta, params)));\n    if (transformFn) {\n        statements.push(new ExpressionStatement(variable.set(transformFn(variable))));\n    }\n    return statements;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\n * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\n * bot work in some cases when object keys are mangled by minifier.\n *\n * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\n * inputs that contain potentially unsafe chars.\n */\nvar UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\n/** Name of the temporary to use during data binding */\nvar TEMPORARY_NAME = '_t';\n/** Name of the context parameter passed into a template function */\nvar CONTEXT_NAME = 'ctx';\n/** Name of the RenderFlag passed into a template function */\nvar RENDER_FLAGS = 'rf';\n/** The prefix reference variables */\nvar REFERENCE_PREFIX = '_r';\n/** The name of the implicit context reference */\nvar IMPLICIT_REFERENCE = '$implicit';\n/** Non bindable attribute name **/\nvar NON_BINDABLE_ATTR = 'ngNonBindable';\n/**\n * Creates an allocator for a temporary variable.\n *\n * A variable declaration is added to the statements the first time the allocator is invoked.\n */\nfunction temporaryAllocator(statements, name) {\n    var temp = null;\n    return function () {\n        if (!temp) {\n            statements.push(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));\n            temp = variable(name);\n        }\n        return temp;\n    };\n}\nfunction unsupported(feature) {\n    if (this) {\n        throw new Error(\"Builder \" + this.constructor.name + \" doesn't support \" + feature + \" yet\");\n    }\n    throw new Error(\"Feature \" + feature + \" is not supported yet\");\n}\nfunction invalid$1(arg) {\n    throw new Error(\"Invalid state: Visitor \" + this.constructor.name + \" doesn't handle \" + arg.constructor.name);\n}\nfunction asLiteral(value) {\n    if (Array.isArray(value)) {\n        return literalArr(value.map(asLiteral));\n    }\n    return literal(value, INFERRED_TYPE);\n}\nfunction conditionallyCreateMapObjectLiteral(keys, keepDeclared) {\n    if (Object.getOwnPropertyNames(keys).length > 0) {\n        return mapToExpression(keys, keepDeclared);\n    }\n    return null;\n}\nfunction mapToExpression(map, keepDeclared) {\n    return literalMap(Object.getOwnPropertyNames(map).map(function (key) {\n        var _a, _b;\n        // canonical syntax: `dirProp: publicProp`\n        // if there is no `:`, use dirProp = elProp\n        var value = map[key];\n        var declaredName;\n        var publicName;\n        var minifiedName;\n        if (Array.isArray(value)) {\n            _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(value, 2), publicName = _a[0], declaredName = _a[1];\n        }\n        else {\n            _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(splitAtColon(key, [key, value]), 2), declaredName = _b[0], publicName = _b[1];\n        }\n        minifiedName = declaredName;\n        return {\n            key: minifiedName,\n            // put quotes around keys that contain potentially unsafe characters\n            quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n            value: (keepDeclared && publicName !== declaredName) ?\n                literalArr([asLiteral(publicName), asLiteral(declaredName)]) :\n                asLiteral(publicName)\n        };\n    }));\n}\n/**\n *  Remove trailing null nodes as they are implied.\n */\nfunction trimTrailingNulls(parameters) {\n    while (isNull(parameters[parameters.length - 1])) {\n        parameters.pop();\n    }\n    return parameters;\n}\nfunction getQueryPredicate(query, constantPool) {\n    if (Array.isArray(query.predicate)) {\n        var predicate_1 = [];\n        query.predicate.forEach(function (selector) {\n            // Each item in predicates array may contain strings with comma-separated refs\n            // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\n            // as separate array entities\n            var selectors = selector.split(',').map(function (token) { return literal(token.trim()); });\n            predicate_1.push.apply(predicate_1, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(selectors));\n        });\n        return constantPool.getConstLiteral(literalArr(predicate_1), true);\n    }\n    else {\n        return query.predicate;\n    }\n}\nfunction noop() { }\nvar DefinitionMap = /** @class */ (function () {\n    function DefinitionMap() {\n        this.values = [];\n    }\n    DefinitionMap.prototype.set = function (key, value) {\n        if (value) {\n            this.values.push({ key: key, value: value, quoted: false });\n        }\n    };\n    DefinitionMap.prototype.toLiteralMap = function () { return literalMap(this.values); };\n    return DefinitionMap;\n}());\n/**\n * Extract a map of properties to values for a given element or template node, which can be used\n * by the directive matching machinery.\n *\n * @param elOrTpl the element or template in question\n * @return an object set up for directive matching. For attributes on the element/template, this\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\n * property name to an empty string.\n */\nfunction getAttrsForDirectiveMatching(elOrTpl) {\n    var attributesMap = {};\n    if (elOrTpl instanceof Template && elOrTpl.tagName !== 'ng-template') {\n        elOrTpl.templateAttrs.forEach(function (a) { return attributesMap[a.name] = ''; });\n    }\n    else {\n        elOrTpl.attributes.forEach(function (a) {\n            if (!isI18nAttribute(a.name)) {\n                attributesMap[a.name] = a.value;\n            }\n        });\n        elOrTpl.inputs.forEach(function (i) { attributesMap[i.name] = ''; });\n        elOrTpl.outputs.forEach(function (o) { attributesMap[o.name] = ''; });\n    }\n    return attributesMap;\n}\n/** Returns a call expression to a chained instruction, e.g. `property(params[0])(params[1])`. */\nfunction chainedInstruction(reference, calls, span) {\n    var expression = importExpr(reference, null, span);\n    if (calls.length > 0) {\n        for (var i = 0; i < calls.length; i++) {\n            expression = expression.callFn(calls[i], span);\n        }\n    }\n    else {\n        // Add a blank invocation, in case the `calls` array is empty.\n        expression = expression.callFn([], span);\n    }\n    return expression;\n}\n/**\n * Gets the number of arguments expected to be passed to a generated instruction in the case of\n * interpolation instructions.\n * @param interpolation An interpolation ast\n */\nfunction getInterpolationArgsLength(interpolation) {\n    var expressions = interpolation.expressions, strings = interpolation.strings;\n    if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {\n        // If the interpolation has one interpolated value, but the prefix and suffix are both empty\n        // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or\n        // `textInterpolate`.\n        return 1;\n    }\n    else {\n        return expressions.length + strings.length;\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar R3FactoryDelegateType;\n(function (R3FactoryDelegateType) {\n    R3FactoryDelegateType[R3FactoryDelegateType[\"Class\"] = 0] = \"Class\";\n    R3FactoryDelegateType[R3FactoryDelegateType[\"Function\"] = 1] = \"Function\";\n    R3FactoryDelegateType[R3FactoryDelegateType[\"Factory\"] = 2] = \"Factory\";\n})(R3FactoryDelegateType || (R3FactoryDelegateType = {}));\n/**\n * Resolved type of a dependency.\n *\n * Occasionally, dependencies will have special significance which is known statically. In that\n * case the `R3ResolvedDependencyType` informs the factory generator that a particular dependency\n * should be generated specially (usually by calling a special injection function instead of the\n * standard one).\n */\nvar R3ResolvedDependencyType;\n(function (R3ResolvedDependencyType) {\n    /**\n     * A normal token dependency.\n     */\n    R3ResolvedDependencyType[R3ResolvedDependencyType[\"Token\"] = 0] = \"Token\";\n    /**\n     * The dependency is for an attribute.\n     *\n     * The token expression is a string representing the attribute name.\n     */\n    R3ResolvedDependencyType[R3ResolvedDependencyType[\"Attribute\"] = 1] = \"Attribute\";\n    /**\n     * Injecting the `ChangeDetectorRef` token. Needs special handling when injected into a pipe.\n     */\n    R3ResolvedDependencyType[R3ResolvedDependencyType[\"ChangeDetectorRef\"] = 2] = \"ChangeDetectorRef\";\n})(R3ResolvedDependencyType || (R3ResolvedDependencyType = {}));\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nfunction compileFactoryFunction(meta, isPipe) {\n    if (isPipe === void 0) { isPipe = false; }\n    var t = variable('t');\n    var statements = [];\n    // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n    // this type is always created by constructor invocation, then this is the type-to-create\n    // parameter provided by the user (t) if specified, or the current type if not. If there is a\n    // delegated factory (which is used to create the current type) then this is only the type-to-\n    // create parameter (t).\n    var typeForCtor = !isDelegatedMetadata(meta) ? new BinaryOperatorExpr(BinaryOperator.Or, t, meta.type) : t;\n    var ctorExpr = null;\n    if (meta.deps !== null) {\n        // There is a constructor (either explicitly or implicitly defined).\n        if (meta.deps !== 'invalid') {\n            ctorExpr =\n                new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.injectFn, isPipe));\n        }\n    }\n    else {\n        var baseFactory = variable(\"\\u0275\" + meta.name + \"_BaseFactory\");\n        var getInheritedFactory = importExpr(Identifiers$1.getInheritedFactory);\n        var baseFactoryStmt = baseFactory.set(getInheritedFactory.callFn([meta.type])).toDeclStmt(INFERRED_TYPE, [\n            StmtModifier.Exported, StmtModifier.Final\n        ]);\n        statements.push(baseFactoryStmt);\n        // There is no constructor, use the base class' factory to construct typeForCtor.\n        ctorExpr = baseFactory.callFn([typeForCtor]);\n    }\n    var ctorExprFinal = ctorExpr;\n    var body = [];\n    var retExpr = null;\n    function makeConditionalFactory(nonCtorExpr) {\n        var r = variable('r');\n        body.push(r.set(NULL_EXPR).toDeclStmt());\n        var ctorStmt = null;\n        if (ctorExprFinal !== null) {\n            ctorStmt = r.set(ctorExprFinal).toStmt();\n        }\n        else {\n            ctorStmt = makeErrorStmt(meta.name);\n        }\n        body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n        return r;\n    }\n    if (isDelegatedMetadata(meta) && meta.delegateType === R3FactoryDelegateType.Factory) {\n        var delegateFactory = variable(\"\\u0275\" + meta.name + \"_BaseFactory\");\n        var getFactoryOf = importExpr(Identifiers$1.getFactoryOf);\n        if (meta.delegate.isEquivalent(meta.type)) {\n            throw new Error(\"Illegal state: compiling factory that delegates to itself\");\n        }\n        var delegateFactoryStmt = delegateFactory.set(getFactoryOf.callFn([meta.delegate])).toDeclStmt(INFERRED_TYPE, [\n            StmtModifier.Exported, StmtModifier.Final\n        ]);\n        statements.push(delegateFactoryStmt);\n        retExpr = makeConditionalFactory(delegateFactory.callFn([]));\n    }\n    else if (isDelegatedMetadata(meta)) {\n        // This type is created with a delegated factory. If a type parameter is not specified, call\n        // the factory instead.\n        var delegateArgs = injectDependencies(meta.delegateDeps, meta.injectFn, isPipe);\n        // Either call `new delegate(...)` or `delegate(...)` depending on meta.useNewForDelegate.\n        var factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ?\n            InstantiateExpr :\n            InvokeFunctionExpr)(meta.delegate, delegateArgs);\n        retExpr = makeConditionalFactory(factoryExpr);\n    }\n    else if (isExpressionFactoryMetadata(meta)) {\n        // TODO(alxhub): decide whether to lower the value here or in the caller\n        retExpr = makeConditionalFactory(meta.expression);\n    }\n    else {\n        retExpr = ctorExpr;\n    }\n    if (retExpr !== null) {\n        body.push(new ReturnStatement(retExpr));\n    }\n    else {\n        body.push(makeErrorStmt(meta.name));\n    }\n    return {\n        factory: fn([new FnParam('t', DYNAMIC_TYPE)], body, INFERRED_TYPE, undefined, meta.name + \"_Factory\"),\n        statements: statements,\n    };\n}\nfunction injectDependencies(deps, injectFn, isPipe) {\n    return deps.map(function (dep) { return compileInjectDependency(dep, injectFn, isPipe); });\n}\nfunction compileInjectDependency(dep, injectFn, isPipe) {\n    // Interpret the dependency according to its resolved type.\n    switch (dep.resolved) {\n        case R3ResolvedDependencyType.Token:\n        case R3ResolvedDependencyType.ChangeDetectorRef:\n            // Build up the injection flags according to the metadata.\n            var flags = 0 /* Default */ | (dep.self ? 2 /* Self */ : 0) |\n                (dep.skipSelf ? 4 /* SkipSelf */ : 0) | (dep.host ? 1 /* Host */ : 0) |\n                (dep.optional ? 8 /* Optional */ : 0);\n            // If this dependency is optional or otherwise has non-default flags, then additional\n            // parameters describing how to inject the dependency must be passed to the inject function\n            // that's being used.\n            var flagsParam = (flags !== 0 /* Default */ || dep.optional) ? literal(flags) : null;\n            // We have a separate instruction for injecting ChangeDetectorRef into a pipe.\n            if (isPipe && dep.resolved === R3ResolvedDependencyType.ChangeDetectorRef) {\n                return importExpr(Identifiers$1.injectPipeChangeDetectorRef).callFn(flagsParam ? [flagsParam] : []);\n            }\n            // Build up the arguments to the injectFn call.\n            var injectArgs = [dep.token];\n            if (flagsParam) {\n                injectArgs.push(flagsParam);\n            }\n            return importExpr(injectFn).callFn(injectArgs);\n        case R3ResolvedDependencyType.Attribute:\n            // In the case of attributes, the attribute name in question is given as the token.\n            return importExpr(Identifiers$1.injectAttribute).callFn([dep.token]);\n        default:\n            return unsupported(\"Unknown R3ResolvedDependencyType: \" + R3ResolvedDependencyType[dep.resolved]);\n    }\n}\n/**\n * A helper function useful for extracting `R3DependencyMetadata` from a Render2\n * `CompileTypeMetadata` instance.\n */\nfunction dependenciesFromGlobalMetadata(type, outputCtx, reflector) {\n    var e_1, _a;\n    // Use the `CompileReflector` to look up references to some well-known Angular types. These will\n    // be compared with the token to statically determine whether the token has significance to\n    // Angular, and set the correct `R3ResolvedDependencyType` as a result.\n    var injectorRef = reflector.resolveExternalReference(Identifiers.Injector);\n    // Iterate through the type's DI dependencies and produce `R3DependencyMetadata` for each of them.\n    var deps = [];\n    try {\n        for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(type.diDeps), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var dependency = _c.value;\n            if (dependency.token) {\n                var tokenRef = tokenReference(dependency.token);\n                var resolved = dependency.isAttribute ?\n                    R3ResolvedDependencyType.Attribute :\n                    R3ResolvedDependencyType.Token;\n                // In the case of most dependencies, the token will be a reference to a type. Sometimes,\n                // however, it can be a string, in the case of older Angular code or @Attribute injection.\n                var token = tokenRef instanceof StaticSymbol ? outputCtx.importExpr(tokenRef) : literal(tokenRef);\n                // Construct the dependency.\n                deps.push({\n                    token: token,\n                    resolved: resolved,\n                    host: !!dependency.isHost,\n                    optional: !!dependency.isOptional,\n                    self: !!dependency.isSelf,\n                    skipSelf: !!dependency.isSkipSelf,\n                });\n            }\n            else {\n                unsupported('dependency without a token');\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return deps;\n}\nfunction makeErrorStmt(name) {\n    return new ThrowStmt(new InstantiateExpr(new ReadVarExpr('Error'), [\n        literal(name + \" has a constructor which is not compatible with Dependency Injection. It should probably not be @Injectable().\")\n    ]));\n}\nfunction isDelegatedMetadata(meta) {\n    return meta.delegateType !== undefined;\n}\nfunction isExpressionFactoryMetadata(meta) {\n    return meta.expression !== undefined;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Convert an object map with `Expression` values into a `LiteralMapExpr`.\n */\nfunction mapToMapExpression(map) {\n    var result = Object.keys(map).map(function (key) { return ({ key: key, value: map[key], quoted: false }); });\n    return literalMap(result);\n}\n/**\n * Convert metadata into an `Expression` in the given `OutputContext`.\n *\n * This operation will handle arrays, references to symbols, or literal `null` or `undefined`.\n */\nfunction convertMetaToOutput(meta, ctx) {\n    if (Array.isArray(meta)) {\n        return literalArr(meta.map(function (entry) { return convertMetaToOutput(entry, ctx); }));\n    }\n    if (meta instanceof StaticSymbol) {\n        return ctx.importExpr(meta);\n    }\n    if (meta == null) {\n        return literal(meta);\n    }\n    throw new Error(\"Internal error: Unsupported or unknown metadata: \" + meta);\n}\nfunction typeWithParameters(type, numParams) {\n    var params = null;\n    if (numParams > 0) {\n        params = [];\n        for (var i = 0; i < numParams; i++) {\n            params.push(DYNAMIC_TYPE);\n        }\n    }\n    return expressionType(type, null, params);\n}\nvar ANIMATE_SYMBOL_PREFIX = '@';\nfunction prepareSyntheticPropertyName(name) {\n    return \"\" + ANIMATE_SYMBOL_PREFIX + name;\n}\nfunction prepareSyntheticListenerName(name, phase) {\n    return \"\" + ANIMATE_SYMBOL_PREFIX + name + \".\" + phase;\n}\nfunction isSyntheticPropertyOrListener(name) {\n    return name.charAt(0) == ANIMATE_SYMBOL_PREFIX;\n}\nfunction getSyntheticPropertyName(name) {\n    // this will strip out listener phase values...\n    // @foo.start => @foo\n    var i = name.indexOf('.');\n    name = i > 0 ? name.substring(0, i) : name;\n    if (name.charAt(0) !== ANIMATE_SYMBOL_PREFIX) {\n        name = ANIMATE_SYMBOL_PREFIX + name;\n    }\n    return name;\n}\nfunction prepareSyntheticListenerFunctionName(name, phase) {\n    return \"animation_\" + name + \"_\" + phase;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction compileInjectable(meta) {\n    var result = null;\n    var factoryMeta = {\n        name: meta.name,\n        type: meta.type,\n        deps: meta.ctorDeps,\n        injectFn: Identifiers.inject,\n    };\n    if (meta.useClass !== undefined) {\n        // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\n        // used to instantiate the class with dependencies injected, or deps are not specified and\n        // the factory of the class is used to instantiate it.\n        //\n        // A special case exists for useClass: Type where Type is the injectable type itself and no\n        // deps are specified, in which case 'useClass' is effectively ignored.\n        var useClassOnSelf = meta.useClass.isEquivalent(meta.type);\n        var deps = undefined;\n        if (meta.userDeps !== undefined) {\n            deps = meta.userDeps;\n        }\n        if (deps !== undefined) {\n            // factory: () => new meta.useClass(...deps)\n            result = compileFactoryFunction(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, factoryMeta, { delegate: meta.useClass, delegateDeps: deps, delegateType: R3FactoryDelegateType.Class }));\n        }\n        else if (useClassOnSelf) {\n            result = compileFactoryFunction(factoryMeta);\n        }\n        else {\n            result = compileFactoryFunction(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, factoryMeta, { delegate: meta.useClass, delegateType: R3FactoryDelegateType.Factory }));\n        }\n    }\n    else if (meta.useFactory !== undefined) {\n        result = compileFactoryFunction(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, factoryMeta, { delegate: meta.useFactory, delegateDeps: meta.userDeps || [], delegateType: R3FactoryDelegateType.Function }));\n    }\n    else if (meta.useValue !== undefined) {\n        // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n        // client code because meta.useValue is an Expression which will be defined even if the actual\n        // value is undefined.\n        result = compileFactoryFunction(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, factoryMeta, { expression: meta.useValue }));\n    }\n    else if (meta.useExisting !== undefined) {\n        // useExisting is an `inject` call on the existing token.\n        result = compileFactoryFunction(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, factoryMeta, { expression: importExpr(Identifiers.inject).callFn([meta.useExisting]) }));\n    }\n    else {\n        result = compileFactoryFunction(factoryMeta);\n    }\n    var token = meta.type;\n    var providedIn = meta.providedIn;\n    var expression = importExpr(Identifiers.ɵɵdefineInjectable).callFn([mapToMapExpression({ token: token, factory: result.factory, providedIn: providedIn })]);\n    var type = new ExpressionType(importExpr(Identifiers.InjectableDef, [typeWithParameters(meta.type, meta.typeArgumentCount)]));\n    return {\n        expression: expression,\n        type: type,\n        statements: result.statements,\n    };\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction assertArrayOfStrings(identifier, value) {\n    if (value == null) {\n        return;\n    }\n    if (!Array.isArray(value)) {\n        throw new Error(\"Expected '\" + identifier + \"' to be an array of strings.\");\n    }\n    for (var i = 0; i < value.length; i += 1) {\n        if (typeof value[i] !== 'string') {\n            throw new Error(\"Expected '\" + identifier + \"' to be an array of strings.\");\n        }\n    }\n}\nvar UNUSABLE_INTERPOLATION_REGEXPS = [\n    /^\\s*$/,\n    /[<>]/,\n    /^[{}]$/,\n    /&(#|[a-z])/i,\n    /^\\/\\//,\n];\nfunction assertInterpolationSymbols(identifier, value) {\n    if (value != null && !(Array.isArray(value) && value.length == 2)) {\n        throw new Error(\"Expected '\" + identifier + \"' to be an array, [start, end].\");\n    }\n    else if (value != null) {\n        var start_1 = value[0];\n        var end_1 = value[1];\n        // Check for unusable interpolation symbols\n        UNUSABLE_INTERPOLATION_REGEXPS.forEach(function (regexp) {\n            if (regexp.test(start_1) || regexp.test(end_1)) {\n                throw new Error(\"['\" + start_1 + \"', '\" + end_1 + \"'] contains unusable interpolation symbol.\");\n            }\n        });\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar InterpolationConfig = /** @class */ (function () {\n    function InterpolationConfig(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    InterpolationConfig.fromArray = function (markers) {\n        if (!markers) {\n            return DEFAULT_INTERPOLATION_CONFIG;\n        }\n        assertInterpolationSymbols('interpolation', markers);\n        return new InterpolationConfig(markers[0], markers[1]);\n    };\n    return InterpolationConfig;\n}());\nvar DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nvar VERSION = 3;\nvar JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\nvar SourceMapGenerator = /** @class */ (function () {\n    function SourceMapGenerator(file) {\n        if (file === void 0) { file = null; }\n        this.file = file;\n        this.sourcesContent = new Map();\n        this.lines = [];\n        this.lastCol0 = 0;\n        this.hasMappings = false;\n    }\n    // The content is `null` when the content is expected to be loaded using the URL\n    SourceMapGenerator.prototype.addSource = function (url, content) {\n        if (content === void 0) { content = null; }\n        if (!this.sourcesContent.has(url)) {\n            this.sourcesContent.set(url, content);\n        }\n        return this;\n    };\n    SourceMapGenerator.prototype.addLine = function () {\n        this.lines.push([]);\n        this.lastCol0 = 0;\n        return this;\n    };\n    SourceMapGenerator.prototype.addMapping = function (col0, sourceUrl, sourceLine0, sourceCol0) {\n        if (!this.currentLine) {\n            throw new Error(\"A line must be added before mappings can be added\");\n        }\n        if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n            throw new Error(\"Unknown source file \\\"\" + sourceUrl + \"\\\"\");\n        }\n        if (col0 == null) {\n            throw new Error(\"The column in the generated code must be provided\");\n        }\n        if (col0 < this.lastCol0) {\n            throw new Error(\"Mapping should be added in output order\");\n        }\n        if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n            throw new Error(\"The source location must be provided when a source url is provided\");\n        }\n        this.hasMappings = true;\n        this.lastCol0 = col0;\n        this.currentLine.push({ col0: col0, sourceUrl: sourceUrl, sourceLine0: sourceLine0, sourceCol0: sourceCol0 });\n        return this;\n    };\n    Object.defineProperty(SourceMapGenerator.prototype, \"currentLine\", {\n        get: function () { return this.lines.slice(-1)[0]; },\n        enumerable: true,\n        configurable: true\n    });\n    SourceMapGenerator.prototype.toJSON = function () {\n        var _this = this;\n        if (!this.hasMappings) {\n            return null;\n        }\n        var sourcesIndex = new Map();\n        var sources = [];\n        var sourcesContent = [];\n        Array.from(this.sourcesContent.keys()).forEach(function (url, i) {\n            sourcesIndex.set(url, i);\n            sources.push(url);\n            sourcesContent.push(_this.sourcesContent.get(url) || null);\n        });\n        var mappings = '';\n        var lastCol0 = 0;\n        var lastSourceIndex = 0;\n        var lastSourceLine0 = 0;\n        var lastSourceCol0 = 0;\n        this.lines.forEach(function (segments) {\n            lastCol0 = 0;\n            mappings += segments\n                .map(function (segment) {\n                // zero-based starting column of the line in the generated code\n                var segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                lastCol0 = segment.col0;\n                if (segment.sourceUrl != null) {\n                    // zero-based index into the “sources” list\n                    segAsStr +=\n                        toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);\n                    lastSourceIndex = sourcesIndex.get(segment.sourceUrl);\n                    // the zero-based starting line in the original source\n                    segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);\n                    lastSourceLine0 = segment.sourceLine0;\n                    // the zero-based starting column in the original source\n                    segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);\n                    lastSourceCol0 = segment.sourceCol0;\n                }\n                return segAsStr;\n            })\n                .join(',');\n            mappings += ';';\n        });\n        mappings = mappings.slice(0, -1);\n        return {\n            'file': this.file || '',\n            'version': VERSION,\n            'sourceRoot': '',\n            'sources': sources,\n            'sourcesContent': sourcesContent,\n            'mappings': mappings,\n        };\n    };\n    SourceMapGenerator.prototype.toJsComment = function () {\n        return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n            '';\n    };\n    return SourceMapGenerator;\n}());\nfunction toBase64String(value) {\n    var b64 = '';\n    value = utf8Encode(value);\n    for (var i = 0; i < value.length;) {\n        var i1 = value.charCodeAt(i++);\n        var i2 = value.charCodeAt(i++);\n        var i3 = value.charCodeAt(i++);\n        b64 += toBase64Digit(i1 >> 2);\n        b64 += toBase64Digit(((i1 & 3) << 4) | (isNaN(i2) ? 0 : i2 >> 4));\n        b64 += isNaN(i2) ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 >> 6));\n        b64 += isNaN(i2) || isNaN(i3) ? '=' : toBase64Digit(i3 & 63);\n    }\n    return b64;\n}\nfunction toBase64VLQ(value) {\n    value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n    var out = '';\n    do {\n        var digit = value & 31;\n        value = value >> 5;\n        if (value > 0) {\n            digit = digit | 32;\n        }\n        out += toBase64Digit(digit);\n    } while (value > 0);\n    return out;\n}\nvar B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfunction toBase64Digit(value) {\n    if (value < 0 || value >= 64) {\n        throw new Error(\"Can only encode value in the range [0, 63]\");\n    }\n    return B64_DIGITS[value];\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nvar _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nvar _INDENT_WITH = '  ';\nvar CATCH_ERROR_VAR$1 = variable('error', null, null);\nvar CATCH_STACK_VAR$1 = variable('stack', null, null);\nvar _EmittedLine = /** @class */ (function () {\n    function _EmittedLine(indent) {\n        this.indent = indent;\n        this.partsLength = 0;\n        this.parts = [];\n        this.srcSpans = [];\n    }\n    return _EmittedLine;\n}());\nvar EmitterVisitorContext = /** @class */ (function () {\n    function EmitterVisitorContext(_indent) {\n        this._indent = _indent;\n        this._classes = [];\n        this._preambleLineCount = 0;\n        this._lines = [new _EmittedLine(_indent)];\n    }\n    EmitterVisitorContext.createRoot = function () { return new EmitterVisitorContext(0); };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"_currentLine\", {\n        get: function () { return this._lines[this._lines.length - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    EmitterVisitorContext.prototype.println = function (from, lastPart) {\n        if (lastPart === void 0) { lastPart = ''; }\n        this.print(from || null, lastPart, true);\n    };\n    EmitterVisitorContext.prototype.lineIsEmpty = function () { return this._currentLine.parts.length === 0; };\n    EmitterVisitorContext.prototype.lineLength = function () {\n        return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n    };\n    EmitterVisitorContext.prototype.print = function (from, part, newLine) {\n        if (newLine === void 0) { newLine = false; }\n        if (part.length > 0) {\n            this._currentLine.parts.push(part);\n            this._currentLine.partsLength += part.length;\n            this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n        }\n        if (newLine) {\n            this._lines.push(new _EmittedLine(this._indent));\n        }\n    };\n    EmitterVisitorContext.prototype.removeEmptyLastLine = function () {\n        if (this.lineIsEmpty()) {\n            this._lines.pop();\n        }\n    };\n    EmitterVisitorContext.prototype.incIndent = function () {\n        this._indent++;\n        if (this.lineIsEmpty()) {\n            this._currentLine.indent = this._indent;\n        }\n    };\n    EmitterVisitorContext.prototype.decIndent = function () {\n        this._indent--;\n        if (this.lineIsEmpty()) {\n            this._currentLine.indent = this._indent;\n        }\n    };\n    EmitterVisitorContext.prototype.pushClass = function (clazz) { this._classes.push(clazz); };\n    EmitterVisitorContext.prototype.popClass = function () { return this._classes.pop(); };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"currentClass\", {\n        get: function () {\n            return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    EmitterVisitorContext.prototype.toSource = function () {\n        return this.sourceLines\n            .map(function (l) { return l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : ''; })\n            .join('\\n');\n    };\n    EmitterVisitorContext.prototype.toSourceMapGenerator = function (genFilePath, startsAtLine) {\n        if (startsAtLine === void 0) { startsAtLine = 0; }\n        var map = new SourceMapGenerator(genFilePath);\n        var firstOffsetMapped = false;\n        var mapFirstOffsetIfNeeded = function () {\n            if (!firstOffsetMapped) {\n                // Add a single space so that tools won't try to load the file from disk.\n                // Note: We are using virtual urls like `ng:///`, so we have to\n                // provide a content here.\n                map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n                firstOffsetMapped = true;\n            }\n        };\n        for (var i = 0; i < startsAtLine; i++) {\n            map.addLine();\n            mapFirstOffsetIfNeeded();\n        }\n        this.sourceLines.forEach(function (line, lineIdx) {\n            map.addLine();\n            var spans = line.srcSpans;\n            var parts = line.parts;\n            var col0 = line.indent * _INDENT_WITH.length;\n            var spanIdx = 0;\n            // skip leading parts without source spans\n            while (spanIdx < spans.length && !spans[spanIdx]) {\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n            }\n            if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n                firstOffsetMapped = true;\n            }\n            else {\n                mapFirstOffsetIfNeeded();\n            }\n            while (spanIdx < spans.length) {\n                var span = spans[spanIdx];\n                var source = span.start.file;\n                var sourceLine = span.start.line;\n                var sourceCol = span.start.col;\n                map.addSource(source.url, source.content)\n                    .addMapping(col0, source.url, sourceLine, sourceCol);\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n                // assign parts without span or the same span to the previous segment\n                while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n                    col0 += parts[spanIdx].length;\n                    spanIdx++;\n                }\n            }\n        });\n        return map;\n    };\n    EmitterVisitorContext.prototype.setPreambleLineCount = function (count) { return this._preambleLineCount = count; };\n    EmitterVisitorContext.prototype.spanOf = function (line, column) {\n        var emittedLine = this._lines[line - this._preambleLineCount];\n        if (emittedLine) {\n            var columnsLeft = column - _createIndent(emittedLine.indent).length;\n            for (var partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n                var part = emittedLine.parts[partIndex];\n                if (part.length > columnsLeft) {\n                    return emittedLine.srcSpans[partIndex];\n                }\n                columnsLeft -= part.length;\n            }\n        }\n        return null;\n    };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"sourceLines\", {\n        get: function () {\n            if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n                return this._lines.slice(0, -1);\n            }\n            return this._lines;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return EmitterVisitorContext;\n}());\nvar AbstractEmitterVisitor = /** @class */ (function () {\n    function AbstractEmitterVisitor(_escapeDollarInStrings) {\n        this._escapeDollarInStrings = _escapeDollarInStrings;\n    }\n    AbstractEmitterVisitor.prototype.visitExpressionStmt = function (stmt, ctx) {\n        stmt.expr.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitReturnStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"return \");\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitIfStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"if (\");\n        stmt.condition.visitExpression(this, ctx);\n        ctx.print(stmt, \") {\");\n        var hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n        if (stmt.trueCase.length <= 1 && !hasElseCase) {\n            ctx.print(stmt, \" \");\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.removeEmptyLastLine();\n            ctx.print(stmt, \" \");\n        }\n        else {\n            ctx.println();\n            ctx.incIndent();\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.decIndent();\n            if (hasElseCase) {\n                ctx.println(stmt, \"} else {\");\n                ctx.incIndent();\n                this.visitAllStatements(stmt.falseCase, ctx);\n                ctx.decIndent();\n            }\n        }\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitThrowStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"throw \");\n        stmt.error.visitExpression(this, ctx);\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitCommentStmt = function (stmt, ctx) {\n        if (stmt.multiline) {\n            ctx.println(stmt, \"/* \" + stmt.comment + \" */\");\n        }\n        else {\n            stmt.comment.split('\\n').forEach(function (line) { ctx.println(stmt, \"// \" + line); });\n        }\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitJSDocCommentStmt = function (stmt, ctx) {\n        ctx.println(stmt, \"/*\" + stmt.toString() + \"*/\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitWriteVarExpr = function (expr, ctx) {\n        var lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        ctx.print(expr, expr.name + \" = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitWriteKeyExpr = function (expr, ctx) {\n        var lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, \"[\");\n        expr.index.visitExpression(this, ctx);\n        ctx.print(expr, \"] = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitWritePropExpr = function (expr, ctx) {\n        var lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, \".\" + expr.name + \" = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitInvokeMethodExpr = function (expr, ctx) {\n        expr.receiver.visitExpression(this, ctx);\n        var name = expr.name;\n        if (expr.builtin != null) {\n            name = this.getBuiltinMethodName(expr.builtin);\n            if (name == null) {\n                // some builtins just mean to skip the call.\n                return null;\n            }\n        }\n        ctx.print(expr, \".\" + name + \"(\");\n        this.visitAllExpressions(expr.args, ctx, \",\");\n        ctx.print(expr, \")\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {\n        expr.fn.visitExpression(this, ctx);\n        ctx.print(expr, \"(\");\n        this.visitAllExpressions(expr.args, ctx, ',');\n        ctx.print(expr, \")\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitWrappedNodeExpr = function (ast, ctx) {\n        throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n    };\n    AbstractEmitterVisitor.prototype.visitTypeofExpr = function (expr, ctx) {\n        ctx.print(expr, 'typeof ');\n        expr.expr.visitExpression(this, ctx);\n    };\n    AbstractEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {\n        var varName = ast.name;\n        if (ast.builtin != null) {\n            switch (ast.builtin) {\n                case BuiltinVar.Super:\n                    varName = 'super';\n                    break;\n                case BuiltinVar.This:\n                    varName = 'this';\n                    break;\n                case BuiltinVar.CatchError:\n                    varName = CATCH_ERROR_VAR$1.name;\n                    break;\n                case BuiltinVar.CatchStack:\n                    varName = CATCH_STACK_VAR$1.name;\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin variable \" + ast.builtin);\n            }\n        }\n        ctx.print(ast, varName);\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {\n        ctx.print(ast, \"new \");\n        ast.classExpr.visitExpression(this, ctx);\n        ctx.print(ast, \"(\");\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, \")\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {\n        var value = ast.value;\n        if (typeof value === 'string') {\n            ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n        }\n        else {\n            ctx.print(ast, \"\" + value);\n        }\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitConditionalExpr = function (ast, ctx) {\n        ctx.print(ast, \"(\");\n        ast.condition.visitExpression(this, ctx);\n        ctx.print(ast, '? ');\n        ast.trueCase.visitExpression(this, ctx);\n        ctx.print(ast, ': ');\n        ast.falseCase.visitExpression(this, ctx);\n        ctx.print(ast, \")\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitNotExpr = function (ast, ctx) {\n        ctx.print(ast, '!');\n        ast.condition.visitExpression(this, ctx);\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitAssertNotNullExpr = function (ast, ctx) {\n        ast.condition.visitExpression(this, ctx);\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitBinaryOperatorExpr = function (ast, ctx) {\n        var opStr;\n        switch (ast.operator) {\n            case BinaryOperator.Equals:\n                opStr = '==';\n                break;\n            case BinaryOperator.Identical:\n                opStr = '===';\n                break;\n            case BinaryOperator.NotEquals:\n                opStr = '!=';\n                break;\n            case BinaryOperator.NotIdentical:\n                opStr = '!==';\n                break;\n            case BinaryOperator.And:\n                opStr = '&&';\n                break;\n            case BinaryOperator.BitwiseAnd:\n                opStr = '&';\n                break;\n            case BinaryOperator.Or:\n                opStr = '||';\n                break;\n            case BinaryOperator.Plus:\n                opStr = '+';\n                break;\n            case BinaryOperator.Minus:\n                opStr = '-';\n                break;\n            case BinaryOperator.Divide:\n                opStr = '/';\n                break;\n            case BinaryOperator.Multiply:\n                opStr = '*';\n                break;\n            case BinaryOperator.Modulo:\n                opStr = '%';\n                break;\n            case BinaryOperator.Lower:\n                opStr = '<';\n                break;\n            case BinaryOperator.LowerEquals:\n                opStr = '<=';\n                break;\n            case BinaryOperator.Bigger:\n                opStr = '>';\n                break;\n            case BinaryOperator.BiggerEquals:\n                opStr = '>=';\n                break;\n            default:\n                throw new Error(\"Unknown operator \" + ast.operator);\n        }\n        if (ast.parens)\n            ctx.print(ast, \"(\");\n        ast.lhs.visitExpression(this, ctx);\n        ctx.print(ast, \" \" + opStr + \" \");\n        ast.rhs.visitExpression(this, ctx);\n        if (ast.parens)\n            ctx.print(ast, \")\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitReadPropExpr = function (ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, \".\");\n        ctx.print(ast, ast.name);\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitReadKeyExpr = function (ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, \"[\");\n        ast.index.visitExpression(this, ctx);\n        ctx.print(ast, \"]\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        ctx.print(ast, \"[\");\n        this.visitAllExpressions(ast.entries, ctx, ',');\n        ctx.print(ast, \"]\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitLiteralMapExpr = function (ast, ctx) {\n        var _this = this;\n        ctx.print(ast, \"{\");\n        this.visitAllObjects(function (entry) {\n            ctx.print(ast, escapeIdentifier(entry.key, _this._escapeDollarInStrings, entry.quoted) + \":\");\n            entry.value.visitExpression(_this, ctx);\n        }, ast.entries, ctx, ',');\n        ctx.print(ast, \"}\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitCommaExpr = function (ast, ctx) {\n        ctx.print(ast, '(');\n        this.visitAllExpressions(ast.parts, ctx, ',');\n        ctx.print(ast, ')');\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitAllExpressions = function (expressions, ctx, separator) {\n        var _this = this;\n        this.visitAllObjects(function (expr) { return expr.visitExpression(_this, ctx); }, expressions, ctx, separator);\n    };\n    AbstractEmitterVisitor.prototype.visitAllObjects = function (handler, expressions, ctx, separator) {\n        var incrementedIndent = false;\n        for (var i = 0; i < expressions.length; i++) {\n            if (i > 0) {\n                if (ctx.lineLength() > 80) {\n                    ctx.print(null, separator, true);\n                    if (!incrementedIndent) {\n                        // continuation are marked with double indent.\n                        ctx.incIndent();\n                        ctx.incIndent();\n                        incrementedIndent = true;\n                    }\n                }\n                else {\n                    ctx.print(null, separator, false);\n                }\n            }\n            handler(expressions[i]);\n        }\n        if (incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.decIndent();\n            ctx.decIndent();\n        }\n    };\n    AbstractEmitterVisitor.prototype.visitAllStatements = function (statements, ctx) {\n        var _this = this;\n        statements.forEach(function (stmt) { return stmt.visitStatement(_this, ctx); });\n    };\n    return AbstractEmitterVisitor;\n}());\nfunction escapeIdentifier(input, escapeDollar, alwaysQuote) {\n    if (alwaysQuote === void 0) { alwaysQuote = true; }\n    if (input == null) {\n        return null;\n    }\n    var body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, function () {\n        var match = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            match[_i] = arguments[_i];\n        }\n        if (match[0] == '$') {\n            return escapeDollar ? '\\\\$' : '$';\n        }\n        else if (match[0] == '\\n') {\n            return '\\\\n';\n        }\n        else if (match[0] == '\\r') {\n            return '\\\\r';\n        }\n        else {\n            return \"\\\\\" + match[0];\n        }\n    });\n    var requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n    return requiresQuotes ? \"'\" + body + \"'\" : body;\n}\nfunction _createIndent(count) {\n    var res = '';\n    for (var i = 0; i < count; i++) {\n        res += _INDENT_WITH;\n    }\n    return res;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar AbstractJsEmitterVisitor = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(AbstractJsEmitterVisitor, _super);\n    function AbstractJsEmitterVisitor() {\n        return _super.call(this, false) || this;\n    }\n    AbstractJsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var _this = this;\n        ctx.pushClass(stmt);\n        this._visitClassConstructor(stmt, ctx);\n        if (stmt.parent != null) {\n            ctx.print(stmt, stmt.name + \".prototype = Object.create(\");\n            stmt.parent.visitExpression(this, ctx);\n            ctx.println(stmt, \".prototype);\");\n        }\n        stmt.getters.forEach(function (getter) { return _this._visitClassGetter(stmt, getter, ctx); });\n        stmt.methods.forEach(function (method) { return _this._visitClassMethod(stmt, method, ctx); });\n        ctx.popClass();\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        if (stmt.constructorMethod != null) {\n            this._visitParams(stmt.constructorMethod.params, ctx);\n        }\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        if (stmt.constructorMethod != null) {\n            if (stmt.constructorMethod.body.length > 0) {\n                ctx.println(stmt, \"var self = this;\");\n                this.visitAllStatements(stmt.constructorMethod.body, ctx);\n            }\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n    };\n    AbstractJsEmitterVisitor.prototype._visitClassGetter = function (stmt, getter, ctx) {\n        ctx.println(stmt, \"Object.defineProperty(\" + stmt.name + \".prototype, '\" + getter.name + \"', { get: function() {\");\n        ctx.incIndent();\n        if (getter.body.length > 0) {\n            ctx.println(stmt, \"var self = this;\");\n            this.visitAllStatements(getter.body, ctx);\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"}});\");\n    };\n    AbstractJsEmitterVisitor.prototype._visitClassMethod = function (stmt, method, ctx) {\n        ctx.print(stmt, stmt.name + \".prototype.\" + method.name + \" = function(\");\n        this._visitParams(method.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        if (method.body.length > 0) {\n            ctx.println(stmt, \"var self = this;\");\n            this.visitAllStatements(method.body, ctx);\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"};\");\n    };\n    AbstractJsEmitterVisitor.prototype.visitWrappedNodeExpr = function (ast, ctx) {\n        throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\n    };\n    AbstractJsEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {\n        if (ast.builtin === BuiltinVar.This) {\n            ctx.print(ast, 'self');\n        }\n        else if (ast.builtin === BuiltinVar.Super) {\n            throw new Error(\"'super' needs to be handled at a parent ast node, not at the variable level!\");\n        }\n        else {\n            _super.prototype.visitReadVarExpr.call(this, ast, ctx);\n        }\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"var \" + stmt.name);\n        if (stmt.value) {\n            ctx.print(stmt, ' = ');\n            stmt.value.visitExpression(this, ctx);\n        }\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {\n        ast.value.visitExpression(this, ctx);\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {\n        var fnExpr = expr.fn;\n        if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n            ctx.currentClass.parent.visitExpression(this, ctx);\n            ctx.print(expr, \".call(this\");\n            if (expr.args.length > 0) {\n                ctx.print(expr, \", \");\n                this.visitAllExpressions(expr.args, ctx, ',');\n            }\n            ctx.print(expr, \")\");\n        }\n        else {\n            _super.prototype.visitInvokeFunctionExpr.call(this, expr, ctx);\n        }\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {\n        ctx.print(ast, \"function\" + (ast.name ? ' ' + ast.name : '') + \"(\");\n        this._visitParams(ast.params, ctx);\n        ctx.println(ast, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, \"}\");\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        this._visitParams(stmt.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        ctx.println(stmt, \"try {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.bodyStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"} catch (\" + CATCH_ERROR_VAR$1.name + \") {\");\n        ctx.incIndent();\n        var catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [\n                StmtModifier.Final\n            ])].concat(stmt.catchStmts);\n        this.visitAllStatements(catchStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype._visitParams = function (params, ctx) {\n        this.visitAllObjects(function (param) { return ctx.print(null, param.name); }, params, ctx, ',');\n    };\n    AbstractJsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {\n        var name;\n        switch (method) {\n            case BuiltinMethod.ConcatArray:\n                name = 'concat';\n                break;\n            case BuiltinMethod.SubscribeObservable:\n                name = 'subscribe';\n                break;\n            case BuiltinMethod.Bind:\n                name = 'bind';\n                break;\n            default:\n                throw new Error(\"Unknown builtin method: \" + method);\n        }\n        return name;\n    };\n    return AbstractJsEmitterVisitor;\n}(AbstractEmitterVisitor));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A helper class to manage the evaluation of JIT generated code.\n */\nvar JitEvaluator = /** @class */ (function () {\n    function JitEvaluator() {\n    }\n    /**\n     *\n     * @param sourceUrl The URL of the generated code.\n     * @param statements An array of Angular statement AST nodes to be evaluated.\n     * @param reflector A helper used when converting the statements to executable code.\n     * @param createSourceMaps If true then create a source-map for the generated code and include it\n     * inline as a source-map comment.\n     * @returns A map of all the variables in the generated code.\n     */\n    JitEvaluator.prototype.evaluateStatements = function (sourceUrl, statements, reflector, createSourceMaps) {\n        var converter = new JitEmitterVisitor(reflector);\n        var ctx = EmitterVisitorContext.createRoot();\n        // Ensure generated code is in strict mode\n        if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n            statements = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([\n                literal('use strict').toStmt()\n            ], statements);\n        }\n        converter.visitAllStatements(statements, ctx);\n        converter.createReturnStmt(ctx);\n        return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n    };\n    /**\n     * Evaluate a piece of JIT generated code.\n     * @param sourceUrl The URL of this generated code.\n     * @param ctx A context object that contains an AST of the code to be evaluated.\n     * @param vars A map containing the names and values of variables that the evaluated code might\n     * reference.\n     * @param createSourceMap If true then create a source-map for the generated code and include it\n     * inline as a source-map comment.\n     * @returns The result of evaluating the code.\n     */\n    JitEvaluator.prototype.evaluateCode = function (sourceUrl, ctx, vars, createSourceMap) {\n        var fnBody = \"\\\"use strict\\\";\" + ctx.toSource() + \"\\n//# sourceURL=\" + sourceUrl;\n        var fnArgNames = [];\n        var fnArgValues = [];\n        for (var argName in vars) {\n            fnArgValues.push(vars[argName]);\n            fnArgNames.push(argName);\n        }\n        if (createSourceMap) {\n            // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n            // E.g. ```\n            // function anonymous(a,b,c\n            // /**/) { ... }```\n            // We don't want to hard code this fact, so we auto detect it via an empty function first.\n            var emptyFn = new (Function.bind.apply(Function, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([void 0], fnArgNames.concat('return null;'))))().toString();\n            var headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n            fnBody += \"\\n\" + ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment();\n        }\n        var fn = new (Function.bind.apply(Function, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([void 0], fnArgNames.concat(fnBody))))();\n        return this.executeFunction(fn, fnArgValues);\n    };\n    /**\n     * Execute a JIT generated function by calling it.\n     *\n     * This method can be overridden in tests to capture the functions that are generated\n     * by this `JitEvaluator` class.\n     *\n     * @param fn A function to execute.\n     * @param args The arguments to pass to the function being executed.\n     * @returns The return value of the executed function.\n     */\n    JitEvaluator.prototype.executeFunction = function (fn, args) { return fn.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(args)); };\n    return JitEvaluator;\n}());\n/**\n * An Angular AST visitor that converts AST nodes into executable JavaScript code.\n */\nvar JitEmitterVisitor = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(JitEmitterVisitor, _super);\n    function JitEmitterVisitor(reflector) {\n        var _this = _super.call(this) || this;\n        _this.reflector = reflector;\n        _this._evalArgNames = [];\n        _this._evalArgValues = [];\n        _this._evalExportedVars = [];\n        return _this;\n    }\n    JitEmitterVisitor.prototype.createReturnStmt = function (ctx) {\n        var stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(function (resultVar) { return new LiteralMapEntry(resultVar, variable(resultVar), false); })));\n        stmt.visitStatement(this, ctx);\n    };\n    JitEmitterVisitor.prototype.getArgs = function () {\n        var result = {};\n        for (var i = 0; i < this._evalArgNames.length; i++) {\n            result[this._evalArgNames[i]] = this._evalArgValues[i];\n        }\n        return result;\n    };\n    JitEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {\n        this._emitReferenceToExternal(ast, this.reflector.resolveExternalReference(ast.value), ctx);\n        return null;\n    };\n    JitEmitterVisitor.prototype.visitWrappedNodeExpr = function (ast, ctx) {\n        this._emitReferenceToExternal(ast, ast.node, ctx);\n        return null;\n    };\n    JitEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return _super.prototype.visitDeclareVarStmt.call(this, stmt, ctx);\n    };\n    JitEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return _super.prototype.visitDeclareFunctionStmt.call(this, stmt, ctx);\n    };\n    JitEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return _super.prototype.visitDeclareClassStmt.call(this, stmt, ctx);\n    };\n    JitEmitterVisitor.prototype._emitReferenceToExternal = function (ast, value, ctx) {\n        var id = this._evalArgValues.indexOf(value);\n        if (id === -1) {\n            id = this._evalArgValues.length;\n            this._evalArgValues.push(value);\n            var name_1 = identifierName({ reference: value }) || 'val';\n            this._evalArgNames.push(\"jit_\" + name_1 + \"_\" + id);\n        }\n        ctx.print(ast, this._evalArgNames[id]);\n    };\n    return JitEmitterVisitor;\n}(AbstractJsEmitterVisitor));\nfunction isUseStrictStatement(statement) {\n    return statement.isEquivalent(literal('use strict').toStmt());\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Implementation of `CompileReflector` which resolves references to @angular/core\n * symbols at runtime, according to a consumer-provided mapping.\n *\n * Only supports `resolveExternalReference`, all other methods throw.\n */\nvar R3JitReflector = /** @class */ (function () {\n    function R3JitReflector(context) {\n        this.context = context;\n    }\n    R3JitReflector.prototype.resolveExternalReference = function (ref) {\n        // This reflector only handles @angular/core imports.\n        if (ref.moduleName !== '@angular/core') {\n            throw new Error(\"Cannot resolve external reference to \" + ref.moduleName + \", only references to @angular/core are supported.\");\n        }\n        if (!this.context.hasOwnProperty(ref.name)) {\n            throw new Error(\"No value provided for @angular/core symbol '\" + ref.name + \"'.\");\n        }\n        return this.context[ref.name];\n    };\n    R3JitReflector.prototype.parameters = function (typeOrFunc) { throw new Error('Not implemented.'); };\n    R3JitReflector.prototype.annotations = function (typeOrFunc) { throw new Error('Not implemented.'); };\n    R3JitReflector.prototype.shallowAnnotations = function (typeOrFunc) { throw new Error('Not implemented.'); };\n    R3JitReflector.prototype.tryAnnotations = function (typeOrFunc) { throw new Error('Not implemented.'); };\n    R3JitReflector.prototype.propMetadata = function (typeOrFunc) { throw new Error('Not implemented.'); };\n    R3JitReflector.prototype.hasLifecycleHook = function (type, lcProperty) { throw new Error('Not implemented.'); };\n    R3JitReflector.prototype.guards = function (typeOrFunc) { throw new Error('Not implemented.'); };\n    R3JitReflector.prototype.componentModuleUrl = function (type, cmpMetadata) { throw new Error('Not implemented.'); };\n    return R3JitReflector;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\nfunction compileNgModule(meta) {\n    var moduleType = meta.type, bootstrap = meta.bootstrap, declarations = meta.declarations, imports = meta.imports, exports = meta.exports, schemas = meta.schemas, containsForwardDecls = meta.containsForwardDecls, emitInline = meta.emitInline, id = meta.id;\n    var additionalStatements = [];\n    var definitionMap = {\n        type: moduleType\n    };\n    // Only generate the keys in the metadata if the arrays have values.\n    if (bootstrap.length) {\n        definitionMap.bootstrap = refsToArray(bootstrap, containsForwardDecls);\n    }\n    // If requested to emit scope information inline, pass the declarations, imports and exports to\n    // the `ɵɵdefineNgModule` call. The JIT compilation uses this.\n    if (emitInline) {\n        if (declarations.length) {\n            definitionMap.declarations = refsToArray(declarations, containsForwardDecls);\n        }\n        if (imports.length) {\n            definitionMap.imports = refsToArray(imports, containsForwardDecls);\n        }\n        if (exports.length) {\n            definitionMap.exports = refsToArray(exports, containsForwardDecls);\n        }\n    }\n    // If not emitting inline, the scope information is not passed into `ɵɵdefineNgModule` as it would\n    // prevent tree-shaking of the declarations, imports and exports references.\n    else {\n        var setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n        if (setNgModuleScopeCall !== null) {\n            additionalStatements.push(setNgModuleScopeCall);\n        }\n    }\n    if (schemas && schemas.length) {\n        definitionMap.schemas = literalArr(schemas.map(function (ref) { return ref.value; }));\n    }\n    if (id) {\n        definitionMap.id = id;\n    }\n    var expression = importExpr(Identifiers$1.defineNgModule).callFn([mapToMapExpression(definitionMap)]);\n    var type = new ExpressionType(importExpr(Identifiers$1.NgModuleDefWithMeta, [\n        new ExpressionType(moduleType), tupleTypeOf(declarations), tupleTypeOf(imports),\n        tupleTypeOf(exports)\n    ]));\n    return { expression: expression, type: type, additionalStatements: additionalStatements };\n}\n/**\n * Generates a function call to `ɵɵsetNgModuleScope` with all necessary information so that the\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\n * such that the references to declarations, imports and exports may be elided causing these\n * symbols to become tree-shakeable.\n */\nfunction generateSetNgModuleScopeCall(meta) {\n    var moduleType = meta.type, declarations = meta.declarations, imports = meta.imports, exports = meta.exports, containsForwardDecls = meta.containsForwardDecls;\n    var scopeMap = {};\n    if (declarations.length) {\n        scopeMap.declarations = refsToArray(declarations, containsForwardDecls);\n    }\n    if (imports.length) {\n        scopeMap.imports = refsToArray(imports, containsForwardDecls);\n    }\n    if (exports.length) {\n        scopeMap.exports = refsToArray(exports, containsForwardDecls);\n    }\n    if (Object.keys(scopeMap).length === 0) {\n        return null;\n    }\n    var fnCall = new InvokeFunctionExpr(\n    /* fn */ importExpr(Identifiers$1.setNgModuleScope), \n    /* args */ [moduleType, mapToMapExpression(scopeMap)], \n    /* type */ undefined, \n    /* sourceSpan */ undefined, \n    /* pure */ true);\n    return fnCall.toStmt();\n}\nfunction compileInjector(meta) {\n    var result = compileFactoryFunction({\n        name: meta.name,\n        type: meta.type,\n        deps: meta.deps,\n        injectFn: Identifiers$1.inject,\n    });\n    var definitionMap = {\n        factory: result.factory,\n    };\n    if (meta.providers !== null) {\n        definitionMap.providers = meta.providers;\n    }\n    if (meta.imports.length > 0) {\n        definitionMap.imports = literalArr(meta.imports);\n    }\n    var expression = importExpr(Identifiers$1.defineInjector).callFn([mapToMapExpression(definitionMap)]);\n    var type = new ExpressionType(importExpr(Identifiers$1.InjectorDef, [new ExpressionType(meta.type)]));\n    return { expression: expression, type: type, statements: result.statements };\n}\n// TODO(alxhub): integrate this with `compileNgModule`. Currently the two are separate operations.\nfunction compileNgModuleFromRender2(ctx, ngModule, injectableCompiler) {\n    var className = identifierName(ngModule.type);\n    var rawImports = ngModule.rawImports ? [ngModule.rawImports] : [];\n    var rawExports = ngModule.rawExports ? [ngModule.rawExports] : [];\n    var injectorDefArg = mapLiteral({\n        'factory': injectableCompiler.factoryFor({ type: ngModule.type, symbol: ngModule.type.reference }, ctx),\n        'providers': convertMetaToOutput(ngModule.rawProviders, ctx),\n        'imports': convertMetaToOutput(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(rawImports, rawExports), ctx),\n    });\n    var injectorDef = importExpr(Identifiers$1.defineInjector).callFn([injectorDefArg]);\n    ctx.statements.push(new ClassStmt(\n    /* name */ className, \n    /* parent */ null, \n    /* fields */ [new ClassField(\n        /* name */ 'ngInjectorDef', \n        /* type */ INFERRED_TYPE, \n        /* modifiers */ [StmtModifier.Static], \n        /* initializer */ injectorDef)], \n    /* getters */ [], \n    /* constructorMethod */ new ClassMethod(null, [], []), \n    /* methods */ []));\n}\nfunction accessExportScope(module) {\n    var selectorScope = new ReadPropExpr(module, 'ngModuleDef');\n    return new ReadPropExpr(selectorScope, 'exported');\n}\nfunction tupleTypeOf(exp) {\n    var types = exp.map(function (ref) { return typeofExpr(ref.type); });\n    return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;\n}\nfunction refsToArray(refs, shouldForwardDeclare) {\n    var values = literalArr(refs.map(function (ref) { return ref.value; }));\n    return shouldForwardDeclare ? fn([], [new ReturnStatement(values)]) : values;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction compilePipeFromMetadata(metadata) {\n    var definitionMapValues = [];\n    // e.g. `name: 'myPipe'`\n    definitionMapValues.push({ key: 'name', value: literal(metadata.pipeName), quoted: false });\n    // e.g. `type: MyPipe`\n    definitionMapValues.push({ key: 'type', value: metadata.type, quoted: false });\n    var templateFactory = compileFactoryFunction({\n        name: metadata.name,\n        type: metadata.type,\n        deps: metadata.deps,\n        injectFn: Identifiers$1.directiveInject,\n    }, true);\n    definitionMapValues.push({ key: 'factory', value: templateFactory.factory, quoted: false });\n    // e.g. `pure: true`\n    definitionMapValues.push({ key: 'pure', value: literal(metadata.pure), quoted: false });\n    var expression = importExpr(Identifiers$1.definePipe).callFn([literalMap(definitionMapValues)]);\n    var type = new ExpressionType(importExpr(Identifiers$1.PipeDefWithMeta, [\n        typeWithParameters(metadata.type, metadata.typeArgumentCount),\n        new ExpressionType(new LiteralExpr(metadata.pipeName)),\n    ]));\n    return { expression: expression, type: type, statements: templateFactory.statements };\n}\n/**\n * Write a pipe definition to the output context.\n */\nfunction compilePipeFromRender2(outputCtx, pipe, reflector) {\n    var definitionMapValues = [];\n    var name = identifierName(pipe.type);\n    if (!name) {\n        return error(\"Cannot resolve the name of \" + pipe.type);\n    }\n    var metadata = {\n        name: name,\n        pipeName: pipe.name,\n        type: outputCtx.importExpr(pipe.type.reference),\n        typeArgumentCount: 0,\n        deps: dependenciesFromGlobalMetadata(pipe.type, outputCtx, reflector),\n        pure: pipe.pure,\n    };\n    var res = compilePipeFromMetadata(metadata);\n    var definitionField = outputCtx.constantPool.propertyNameOf(3 /* Pipe */);\n    outputCtx.statements.push(new ClassStmt(\n    /* name */ name, \n    /* parent */ null, \n    /* fields */ [new ClassField(\n        /* name */ definitionField, \n        /* type */ INFERRED_TYPE, \n        /* modifiers */ [StmtModifier.Static], \n        /* initializer */ res.expression)], \n    /* getters */ [], \n    /* constructorMethod */ new ClassMethod(null, [], []), \n    /* methods */ []));\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ParserError = /** @class */ (function () {\n    function ParserError(message, input, errLocation, ctxLocation) {\n        this.input = input;\n        this.errLocation = errLocation;\n        this.ctxLocation = ctxLocation;\n        this.message = \"Parser Error: \" + message + \" \" + errLocation + \" [\" + input + \"] in \" + ctxLocation;\n    }\n    return ParserError;\n}());\nvar ParseSpan = /** @class */ (function () {\n    function ParseSpan(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    return ParseSpan;\n}());\nvar AST = /** @class */ (function () {\n    function AST(span) {\n        this.span = span;\n    }\n    AST.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return null;\n    };\n    AST.prototype.toString = function () { return 'AST'; };\n    return AST;\n}());\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nvar Quote = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Quote, _super);\n    function Quote(span, prefix, uninterpretedExpression, location) {\n        var _this = _super.call(this, span) || this;\n        _this.prefix = prefix;\n        _this.uninterpretedExpression = uninterpretedExpression;\n        _this.location = location;\n        return _this;\n    }\n    Quote.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitQuote(this, context);\n    };\n    Quote.prototype.toString = function () { return 'Quote'; };\n    return Quote;\n}(AST));\nvar EmptyExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(EmptyExpr, _super);\n    function EmptyExpr() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    EmptyExpr.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        // do nothing\n    };\n    return EmptyExpr;\n}(AST));\nvar ImplicitReceiver = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ImplicitReceiver, _super);\n    function ImplicitReceiver() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ImplicitReceiver.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitImplicitReceiver(this, context);\n    };\n    return ImplicitReceiver;\n}(AST));\n/**\n * Multiple expressions separated by a semicolon.\n */\nvar Chain = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Chain, _super);\n    function Chain(span, expressions) {\n        var _this = _super.call(this, span) || this;\n        _this.expressions = expressions;\n        return _this;\n    }\n    Chain.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitChain(this, context);\n    };\n    return Chain;\n}(AST));\nvar Conditional = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Conditional, _super);\n    function Conditional(span, condition, trueExp, falseExp) {\n        var _this = _super.call(this, span) || this;\n        _this.condition = condition;\n        _this.trueExp = trueExp;\n        _this.falseExp = falseExp;\n        return _this;\n    }\n    Conditional.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitConditional(this, context);\n    };\n    return Conditional;\n}(AST));\nvar PropertyRead = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(PropertyRead, _super);\n    function PropertyRead(span, receiver, name) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    PropertyRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPropertyRead(this, context);\n    };\n    return PropertyRead;\n}(AST));\nvar PropertyWrite = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(PropertyWrite, _super);\n    function PropertyWrite(span, receiver, name, value) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    PropertyWrite.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPropertyWrite(this, context);\n    };\n    return PropertyWrite;\n}(AST));\nvar SafePropertyRead = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(SafePropertyRead, _super);\n    function SafePropertyRead(span, receiver, name) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    SafePropertyRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitSafePropertyRead(this, context);\n    };\n    return SafePropertyRead;\n}(AST));\nvar KeyedRead = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(KeyedRead, _super);\n    function KeyedRead(span, obj, key) {\n        var _this = _super.call(this, span) || this;\n        _this.obj = obj;\n        _this.key = key;\n        return _this;\n    }\n    KeyedRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitKeyedRead(this, context);\n    };\n    return KeyedRead;\n}(AST));\nvar KeyedWrite = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(KeyedWrite, _super);\n    function KeyedWrite(span, obj, key, value) {\n        var _this = _super.call(this, span) || this;\n        _this.obj = obj;\n        _this.key = key;\n        _this.value = value;\n        return _this;\n    }\n    KeyedWrite.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitKeyedWrite(this, context);\n    };\n    return KeyedWrite;\n}(AST));\nvar BindingPipe = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(BindingPipe, _super);\n    function BindingPipe(span, exp, name, args) {\n        var _this = _super.call(this, span) || this;\n        _this.exp = exp;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    BindingPipe.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPipe(this, context);\n    };\n    return BindingPipe;\n}(AST));\nvar LiteralPrimitive = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(LiteralPrimitive, _super);\n    function LiteralPrimitive(span, value) {\n        var _this = _super.call(this, span) || this;\n        _this.value = value;\n        return _this;\n    }\n    LiteralPrimitive.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralPrimitive(this, context);\n    };\n    return LiteralPrimitive;\n}(AST));\nvar LiteralArray = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(LiteralArray, _super);\n    function LiteralArray(span, expressions) {\n        var _this = _super.call(this, span) || this;\n        _this.expressions = expressions;\n        return _this;\n    }\n    LiteralArray.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralArray(this, context);\n    };\n    return LiteralArray;\n}(AST));\nvar LiteralMap = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(LiteralMap, _super);\n    function LiteralMap(span, keys, values) {\n        var _this = _super.call(this, span) || this;\n        _this.keys = keys;\n        _this.values = values;\n        return _this;\n    }\n    LiteralMap.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralMap(this, context);\n    };\n    return LiteralMap;\n}(AST));\nvar Interpolation = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Interpolation, _super);\n    function Interpolation(span, strings, expressions) {\n        var _this = _super.call(this, span) || this;\n        _this.strings = strings;\n        _this.expressions = expressions;\n        return _this;\n    }\n    Interpolation.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitInterpolation(this, context);\n    };\n    return Interpolation;\n}(AST));\nvar Binary = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Binary, _super);\n    function Binary(span, operation, left, right) {\n        var _this = _super.call(this, span) || this;\n        _this.operation = operation;\n        _this.left = left;\n        _this.right = right;\n        return _this;\n    }\n    Binary.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitBinary(this, context);\n    };\n    return Binary;\n}(AST));\nvar PrefixNot = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(PrefixNot, _super);\n    function PrefixNot(span, expression) {\n        var _this = _super.call(this, span) || this;\n        _this.expression = expression;\n        return _this;\n    }\n    PrefixNot.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPrefixNot(this, context);\n    };\n    return PrefixNot;\n}(AST));\nvar NonNullAssert = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(NonNullAssert, _super);\n    function NonNullAssert(span, expression) {\n        var _this = _super.call(this, span) || this;\n        _this.expression = expression;\n        return _this;\n    }\n    NonNullAssert.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitNonNullAssert(this, context);\n    };\n    return NonNullAssert;\n}(AST));\nvar MethodCall = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(MethodCall, _super);\n    function MethodCall(span, receiver, name, args) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    MethodCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitMethodCall(this, context);\n    };\n    return MethodCall;\n}(AST));\nvar SafeMethodCall = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(SafeMethodCall, _super);\n    function SafeMethodCall(span, receiver, name, args) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    SafeMethodCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitSafeMethodCall(this, context);\n    };\n    return SafeMethodCall;\n}(AST));\nvar FunctionCall = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(FunctionCall, _super);\n    function FunctionCall(span, target, args) {\n        var _this = _super.call(this, span) || this;\n        _this.target = target;\n        _this.args = args;\n        return _this;\n    }\n    FunctionCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitFunctionCall(this, context);\n    };\n    return FunctionCall;\n}(AST));\n/**\n * Records the absolute position of a text span in a source file, where `start` and `end` are the\n * starting and ending byte offsets, respectively, of the text span in a source file.\n */\nvar AbsoluteSourceSpan = /** @class */ (function () {\n    function AbsoluteSourceSpan(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    return AbsoluteSourceSpan;\n}());\nvar ASTWithSource = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ASTWithSource, _super);\n    function ASTWithSource(ast, source, location, absoluteOffset, errors) {\n        var _this = _super.call(this, new ParseSpan(0, source == null ? 0 : source.length)) || this;\n        _this.ast = ast;\n        _this.source = source;\n        _this.location = location;\n        _this.errors = errors;\n        _this.sourceSpan = new AbsoluteSourceSpan(absoluteOffset, absoluteOffset + _this.span.end);\n        return _this;\n    }\n    ASTWithSource.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        if (visitor.visitASTWithSource) {\n            return visitor.visitASTWithSource(this, context);\n        }\n        return this.ast.visit(visitor, context);\n    };\n    ASTWithSource.prototype.toString = function () { return this.source + \" in \" + this.location; };\n    return ASTWithSource;\n}(AST));\nvar TemplateBinding = /** @class */ (function () {\n    function TemplateBinding(span, key, keyIsVar, name, expression) {\n        this.span = span;\n        this.key = key;\n        this.keyIsVar = keyIsVar;\n        this.name = name;\n        this.expression = expression;\n    }\n    return TemplateBinding;\n}());\nvar NullAstVisitor = /** @class */ (function () {\n    function NullAstVisitor() {\n    }\n    NullAstVisitor.prototype.visitBinary = function (ast, context) { };\n    NullAstVisitor.prototype.visitChain = function (ast, context) { };\n    NullAstVisitor.prototype.visitConditional = function (ast, context) { };\n    NullAstVisitor.prototype.visitFunctionCall = function (ast, context) { };\n    NullAstVisitor.prototype.visitImplicitReceiver = function (ast, context) { };\n    NullAstVisitor.prototype.visitInterpolation = function (ast, context) { };\n    NullAstVisitor.prototype.visitKeyedRead = function (ast, context) { };\n    NullAstVisitor.prototype.visitKeyedWrite = function (ast, context) { };\n    NullAstVisitor.prototype.visitLiteralArray = function (ast, context) { };\n    NullAstVisitor.prototype.visitLiteralMap = function (ast, context) { };\n    NullAstVisitor.prototype.visitLiteralPrimitive = function (ast, context) { };\n    NullAstVisitor.prototype.visitMethodCall = function (ast, context) { };\n    NullAstVisitor.prototype.visitPipe = function (ast, context) { };\n    NullAstVisitor.prototype.visitPrefixNot = function (ast, context) { };\n    NullAstVisitor.prototype.visitNonNullAssert = function (ast, context) { };\n    NullAstVisitor.prototype.visitPropertyRead = function (ast, context) { };\n    NullAstVisitor.prototype.visitPropertyWrite = function (ast, context) { };\n    NullAstVisitor.prototype.visitQuote = function (ast, context) { };\n    NullAstVisitor.prototype.visitSafeMethodCall = function (ast, context) { };\n    NullAstVisitor.prototype.visitSafePropertyRead = function (ast, context) { };\n    return NullAstVisitor;\n}());\nvar RecursiveAstVisitor$1 = /** @class */ (function () {\n    function RecursiveAstVisitor() {\n    }\n    RecursiveAstVisitor.prototype.visitBinary = function (ast, context) {\n        ast.left.visit(this, context);\n        ast.right.visit(this, context);\n        return null;\n    };\n    RecursiveAstVisitor.prototype.visitChain = function (ast, context) { return this.visitAll(ast.expressions, context); };\n    RecursiveAstVisitor.prototype.visitConditional = function (ast, context) {\n        ast.condition.visit(this, context);\n        ast.trueExp.visit(this, context);\n        ast.falseExp.visit(this, context);\n        return null;\n    };\n    RecursiveAstVisitor.prototype.visitPipe = function (ast, context) {\n        ast.exp.visit(this, context);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    RecursiveAstVisitor.prototype.visitFunctionCall = function (ast, context) {\n        ast.target.visit(this, context);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast, context) { return null; };\n    RecursiveAstVisitor.prototype.visitInterpolation = function (ast, context) {\n        return this.visitAll(ast.expressions, context);\n    };\n    RecursiveAstVisitor.prototype.visitKeyedRead = function (ast, context) {\n        ast.obj.visit(this, context);\n        ast.key.visit(this, context);\n        return null;\n    };\n    RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast, context) {\n        ast.obj.visit(this, context);\n        ast.key.visit(this, context);\n        ast.value.visit(this, context);\n        return null;\n    };\n    RecursiveAstVisitor.prototype.visitLiteralArray = function (ast, context) {\n        return this.visitAll(ast.expressions, context);\n    };\n    RecursiveAstVisitor.prototype.visitLiteralMap = function (ast, context) { return this.visitAll(ast.values, context); };\n    RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast, context) { return null; };\n    RecursiveAstVisitor.prototype.visitMethodCall = function (ast, context) {\n        ast.receiver.visit(this, context);\n        return this.visitAll(ast.args, context);\n    };\n    RecursiveAstVisitor.prototype.visitPrefixNot = function (ast, context) {\n        ast.expression.visit(this, context);\n        return null;\n    };\n    RecursiveAstVisitor.prototype.visitNonNullAssert = function (ast, context) {\n        ast.expression.visit(this, context);\n        return null;\n    };\n    RecursiveAstVisitor.prototype.visitPropertyRead = function (ast, context) {\n        ast.receiver.visit(this, context);\n        return null;\n    };\n    RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast, context) {\n        ast.receiver.visit(this, context);\n        ast.value.visit(this, context);\n        return null;\n    };\n    RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast, context) {\n        ast.receiver.visit(this, context);\n        return null;\n    };\n    RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast, context) {\n        ast.receiver.visit(this, context);\n        return this.visitAll(ast.args, context);\n    };\n    RecursiveAstVisitor.prototype.visitAll = function (asts, context) {\n        var _this = this;\n        asts.forEach(function (ast) { return ast.visit(_this, context); });\n        return null;\n    };\n    RecursiveAstVisitor.prototype.visitQuote = function (ast, context) { return null; };\n    return RecursiveAstVisitor;\n}());\nvar AstTransformer$1 = /** @class */ (function () {\n    function AstTransformer() {\n    }\n    AstTransformer.prototype.visitImplicitReceiver = function (ast, context) { return ast; };\n    AstTransformer.prototype.visitInterpolation = function (ast, context) {\n        return new Interpolation(ast.span, ast.strings, this.visitAll(ast.expressions));\n    };\n    AstTransformer.prototype.visitLiteralPrimitive = function (ast, context) {\n        return new LiteralPrimitive(ast.span, ast.value);\n    };\n    AstTransformer.prototype.visitPropertyRead = function (ast, context) {\n        return new PropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    };\n    AstTransformer.prototype.visitPropertyWrite = function (ast, context) {\n        return new PropertyWrite(ast.span, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n    };\n    AstTransformer.prototype.visitSafePropertyRead = function (ast, context) {\n        return new SafePropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    };\n    AstTransformer.prototype.visitMethodCall = function (ast, context) {\n        return new MethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    AstTransformer.prototype.visitSafeMethodCall = function (ast, context) {\n        return new SafeMethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    AstTransformer.prototype.visitFunctionCall = function (ast, context) {\n        return new FunctionCall(ast.span, ast.target.visit(this), this.visitAll(ast.args));\n    };\n    AstTransformer.prototype.visitLiteralArray = function (ast, context) {\n        return new LiteralArray(ast.span, this.visitAll(ast.expressions));\n    };\n    AstTransformer.prototype.visitLiteralMap = function (ast, context) {\n        return new LiteralMap(ast.span, ast.keys, this.visitAll(ast.values));\n    };\n    AstTransformer.prototype.visitBinary = function (ast, context) {\n        return new Binary(ast.span, ast.operation, ast.left.visit(this), ast.right.visit(this));\n    };\n    AstTransformer.prototype.visitPrefixNot = function (ast, context) {\n        return new PrefixNot(ast.span, ast.expression.visit(this));\n    };\n    AstTransformer.prototype.visitNonNullAssert = function (ast, context) {\n        return new NonNullAssert(ast.span, ast.expression.visit(this));\n    };\n    AstTransformer.prototype.visitConditional = function (ast, context) {\n        return new Conditional(ast.span, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n    };\n    AstTransformer.prototype.visitPipe = function (ast, context) {\n        return new BindingPipe(ast.span, ast.exp.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    AstTransformer.prototype.visitKeyedRead = function (ast, context) {\n        return new KeyedRead(ast.span, ast.obj.visit(this), ast.key.visit(this));\n    };\n    AstTransformer.prototype.visitKeyedWrite = function (ast, context) {\n        return new KeyedWrite(ast.span, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n    };\n    AstTransformer.prototype.visitAll = function (asts) {\n        var res = new Array(asts.length);\n        for (var i = 0; i < asts.length; ++i) {\n            res[i] = asts[i].visit(this);\n        }\n        return res;\n    };\n    AstTransformer.prototype.visitChain = function (ast, context) {\n        return new Chain(ast.span, this.visitAll(ast.expressions));\n    };\n    AstTransformer.prototype.visitQuote = function (ast, context) {\n        return new Quote(ast.span, ast.prefix, ast.uninterpretedExpression, ast.location);\n    };\n    return AstTransformer;\n}());\n// A transformer that only creates new nodes if the transformer makes a change or\n// a change is made a child node.\nvar AstMemoryEfficientTransformer = /** @class */ (function () {\n    function AstMemoryEfficientTransformer() {\n    }\n    AstMemoryEfficientTransformer.prototype.visitImplicitReceiver = function (ast, context) { return ast; };\n    AstMemoryEfficientTransformer.prototype.visitInterpolation = function (ast, context) {\n        var expressions = this.visitAll(ast.expressions);\n        if (expressions !== ast.expressions)\n            return new Interpolation(ast.span, ast.strings, expressions);\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitLiteralPrimitive = function (ast, context) { return ast; };\n    AstMemoryEfficientTransformer.prototype.visitPropertyRead = function (ast, context) {\n        var receiver = ast.receiver.visit(this);\n        if (receiver !== ast.receiver) {\n            return new PropertyRead(ast.span, receiver, ast.name);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitPropertyWrite = function (ast, context) {\n        var receiver = ast.receiver.visit(this);\n        var value = ast.value.visit(this);\n        if (receiver !== ast.receiver || value !== ast.value) {\n            return new PropertyWrite(ast.span, receiver, ast.name, value);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitSafePropertyRead = function (ast, context) {\n        var receiver = ast.receiver.visit(this);\n        if (receiver !== ast.receiver) {\n            return new SafePropertyRead(ast.span, receiver, ast.name);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitMethodCall = function (ast, context) {\n        var receiver = ast.receiver.visit(this);\n        var args = this.visitAll(ast.args);\n        if (receiver !== ast.receiver || args !== ast.args) {\n            return new MethodCall(ast.span, receiver, ast.name, args);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitSafeMethodCall = function (ast, context) {\n        var receiver = ast.receiver.visit(this);\n        var args = this.visitAll(ast.args);\n        if (receiver !== ast.receiver || args !== ast.args) {\n            return new SafeMethodCall(ast.span, receiver, ast.name, args);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitFunctionCall = function (ast, context) {\n        var target = ast.target && ast.target.visit(this);\n        var args = this.visitAll(ast.args);\n        if (target !== ast.target || args !== ast.args) {\n            return new FunctionCall(ast.span, target, args);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitLiteralArray = function (ast, context) {\n        var expressions = this.visitAll(ast.expressions);\n        if (expressions !== ast.expressions) {\n            return new LiteralArray(ast.span, expressions);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitLiteralMap = function (ast, context) {\n        var values = this.visitAll(ast.values);\n        if (values !== ast.values) {\n            return new LiteralMap(ast.span, ast.keys, values);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitBinary = function (ast, context) {\n        var left = ast.left.visit(this);\n        var right = ast.right.visit(this);\n        if (left !== ast.left || right !== ast.right) {\n            return new Binary(ast.span, ast.operation, left, right);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitPrefixNot = function (ast, context) {\n        var expression = ast.expression.visit(this);\n        if (expression !== ast.expression) {\n            return new PrefixNot(ast.span, expression);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitNonNullAssert = function (ast, context) {\n        var expression = ast.expression.visit(this);\n        if (expression !== ast.expression) {\n            return new NonNullAssert(ast.span, expression);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitConditional = function (ast, context) {\n        var condition = ast.condition.visit(this);\n        var trueExp = ast.trueExp.visit(this);\n        var falseExp = ast.falseExp.visit(this);\n        if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {\n            return new Conditional(ast.span, condition, trueExp, falseExp);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitPipe = function (ast, context) {\n        var exp = ast.exp.visit(this);\n        var args = this.visitAll(ast.args);\n        if (exp !== ast.exp || args !== ast.args) {\n            return new BindingPipe(ast.span, exp, ast.name, args);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitKeyedRead = function (ast, context) {\n        var obj = ast.obj.visit(this);\n        var key = ast.key.visit(this);\n        if (obj !== ast.obj || key !== ast.key) {\n            return new KeyedRead(ast.span, obj, key);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitKeyedWrite = function (ast, context) {\n        var obj = ast.obj.visit(this);\n        var key = ast.key.visit(this);\n        var value = ast.value.visit(this);\n        if (obj !== ast.obj || key !== ast.key || value !== ast.value) {\n            return new KeyedWrite(ast.span, obj, key, value);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitAll = function (asts) {\n        var res = new Array(asts.length);\n        var modified = false;\n        for (var i = 0; i < asts.length; ++i) {\n            var original = asts[i];\n            var value = original.visit(this);\n            res[i] = value;\n            modified = modified || value !== original;\n        }\n        return modified ? res : asts;\n    };\n    AstMemoryEfficientTransformer.prototype.visitChain = function (ast, context) {\n        var expressions = this.visitAll(ast.expressions);\n        if (expressions !== ast.expressions) {\n            return new Chain(ast.span, expressions);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitQuote = function (ast, context) { return ast; };\n    return AstMemoryEfficientTransformer;\n}());\nfunction visitAstChildren(ast, visitor, context) {\n    function visit(ast) {\n        visitor.visit && visitor.visit(ast, context) || ast.visit(visitor, context);\n    }\n    function visitAll(asts) { asts.forEach(visit); }\n    ast.visit({\n        visitBinary: function (ast) {\n            visit(ast.left);\n            visit(ast.right);\n        },\n        visitChain: function (ast) { visitAll(ast.expressions); },\n        visitConditional: function (ast) {\n            visit(ast.condition);\n            visit(ast.trueExp);\n            visit(ast.falseExp);\n        },\n        visitFunctionCall: function (ast) {\n            if (ast.target) {\n                visit(ast.target);\n            }\n            visitAll(ast.args);\n        },\n        visitImplicitReceiver: function (ast) { },\n        visitInterpolation: function (ast) { visitAll(ast.expressions); },\n        visitKeyedRead: function (ast) {\n            visit(ast.obj);\n            visit(ast.key);\n        },\n        visitKeyedWrite: function (ast) {\n            visit(ast.obj);\n            visit(ast.key);\n            visit(ast.obj);\n        },\n        visitLiteralArray: function (ast) { visitAll(ast.expressions); },\n        visitLiteralMap: function (ast) { },\n        visitLiteralPrimitive: function (ast) { },\n        visitMethodCall: function (ast) {\n            visit(ast.receiver);\n            visitAll(ast.args);\n        },\n        visitPipe: function (ast) {\n            visit(ast.exp);\n            visitAll(ast.args);\n        },\n        visitPrefixNot: function (ast) { visit(ast.expression); },\n        visitNonNullAssert: function (ast) { visit(ast.expression); },\n        visitPropertyRead: function (ast) { visit(ast.receiver); },\n        visitPropertyWrite: function (ast) {\n            visit(ast.receiver);\n            visit(ast.value);\n        },\n        visitQuote: function (ast) { },\n        visitSafeMethodCall: function (ast) {\n            visit(ast.receiver);\n            visitAll(ast.args);\n        },\n        visitSafePropertyRead: function (ast) { visit(ast.receiver); },\n    });\n}\n// Bindings\nvar ParsedProperty = /** @class */ (function () {\n    function ParsedProperty(name, expression, type, sourceSpan, valueSpan) {\n        this.name = name;\n        this.expression = expression;\n        this.type = type;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n        this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n        this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n    }\n    return ParsedProperty;\n}());\nvar ParsedPropertyType;\n(function (ParsedPropertyType) {\n    ParsedPropertyType[ParsedPropertyType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    ParsedPropertyType[ParsedPropertyType[\"LITERAL_ATTR\"] = 1] = \"LITERAL_ATTR\";\n    ParsedPropertyType[ParsedPropertyType[\"ANIMATION\"] = 2] = \"ANIMATION\";\n})(ParsedPropertyType || (ParsedPropertyType = {}));\nvar ParsedEvent = /** @class */ (function () {\n    // Regular events have a target\n    // Animation events have a phase\n    function ParsedEvent(name, targetOrPhase, type, handler, sourceSpan, handlerSpan) {\n        this.name = name;\n        this.targetOrPhase = targetOrPhase;\n        this.type = type;\n        this.handler = handler;\n        this.sourceSpan = sourceSpan;\n        this.handlerSpan = handlerSpan;\n    }\n    return ParsedEvent;\n}());\nvar ParsedVariable = /** @class */ (function () {\n    function ParsedVariable(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    return ParsedVariable;\n}());\nvar BoundElementProperty = /** @class */ (function () {\n    function BoundElementProperty(name, type, securityContext, value, unit, sourceSpan, valueSpan) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n    }\n    return BoundElementProperty;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar EventHandlerVars = /** @class */ (function () {\n    function EventHandlerVars() {\n    }\n    EventHandlerVars.event = variable('$event');\n    return EventHandlerVars;\n}());\nvar ConvertActionBindingResult = /** @class */ (function () {\n    function ConvertActionBindingResult(\n    /**\n     * Render2 compatible statements,\n     */\n    stmts, \n    /**\n     * Variable name used with render2 compatible statements.\n     */\n    allowDefault) {\n        this.stmts = stmts;\n        this.allowDefault = allowDefault;\n        /**\n         * This is bit of a hack. It converts statements which render2 expects to statements which are\n         * expected by render3.\n         *\n         * Example: `<div click=\"doSomething($event)\">` will generate:\n         *\n         * Render3:\n         * ```\n         * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);\n         * return pd_b;\n         * ```\n         *\n         * but render2 expects:\n         * ```\n         * return ctx.doSomething($event);\n         * ```\n         */\n        // TODO(misko): remove this hack once we no longer support ViewEngine.\n        this.render3Stmts = stmts.map(function (statement) {\n            if (statement instanceof DeclareVarStmt && statement.name == allowDefault.name &&\n                statement.value instanceof BinaryOperatorExpr) {\n                var lhs = statement.value.lhs;\n                return new ReturnStatement(lhs.value);\n            }\n            return statement;\n        });\n    }\n    return ConvertActionBindingResult;\n}());\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n */\nfunction convertActionBinding(localResolver, implicitReceiver, action, bindingId, interpolationFunction, baseSourceSpan) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    var actionWithoutBuiltins = convertPropertyBindingBuiltins({\n        createLiteralArrayConverter: function (argCount) {\n            // Note: no caching for literal arrays in actions.\n            return function (args) { return literalArr(args); };\n        },\n        createLiteralMapConverter: function (keys) {\n            // Note: no caching for literal maps in actions.\n            return function (values) {\n                var entries = keys.map(function (k, i) { return ({\n                    key: k.key,\n                    value: values[i],\n                    quoted: k.quoted,\n                }); });\n                return literalMap(entries);\n            };\n        },\n        createPipeConverter: function (name) {\n            throw new Error(\"Illegal State: Actions are not allowed to contain pipes. Pipe: \" + name);\n        }\n    }, action);\n    var visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction, baseSourceSpan);\n    var actionStmts = [];\n    flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n    prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n    if (visitor.usesImplicitReceiver) {\n        localResolver.notifyImplicitReceiverUse();\n    }\n    var lastIndex = actionStmts.length - 1;\n    var preventDefaultVar = null;\n    if (lastIndex >= 0) {\n        var lastStatement = actionStmts[lastIndex];\n        var returnExpr = convertStmtIntoExpression(lastStatement);\n        if (returnExpr) {\n            // Note: We need to cast the result of the method call to dynamic,\n            // as it might be a void method!\n            preventDefaultVar = createPreventDefaultVar(bindingId);\n            actionStmts[lastIndex] =\n                preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false)))\n                    .toDeclStmt(null, [StmtModifier.Final]);\n        }\n    }\n    return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\nfunction convertPropertyBindingBuiltins(converterFactory, ast) {\n    return convertBuiltins(converterFactory, ast);\n}\nvar ConvertPropertyBindingResult = /** @class */ (function () {\n    function ConvertPropertyBindingResult(stmts, currValExpr) {\n        this.stmts = stmts;\n        this.currValExpr = currValExpr;\n    }\n    return ConvertPropertyBindingResult;\n}());\nvar BindingForm;\n(function (BindingForm) {\n    // The general form of binding expression, supports all expressions.\n    BindingForm[BindingForm[\"General\"] = 0] = \"General\";\n    // Try to generate a simple binding (no temporaries or statements)\n    // otherwise generate a general binding\n    BindingForm[BindingForm[\"TrySimple\"] = 1] = \"TrySimple\";\n})(BindingForm || (BindingForm = {}));\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n */\nfunction convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId, form, interpolationFunction) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    var currValExpr = createCurrValueExpr(bindingId);\n    var visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);\n    var outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n    var stmts = getStatementsFromVisitor(visitor, bindingId);\n    if (visitor.usesImplicitReceiver) {\n        localResolver.notifyImplicitReceiverUse();\n    }\n    if (visitor.temporaryCount === 0 && form == BindingForm.TrySimple) {\n        return new ConvertPropertyBindingResult([], outputExpr);\n    }\n    stmts.push(currValExpr.set(outputExpr).toDeclStmt(DYNAMIC_TYPE, [StmtModifier.Final]));\n    return new ConvertPropertyBindingResult(stmts, currValExpr);\n}\n/**\n * Given some expression, such as a binding or interpolation expression, and a context expression to\n * look values up on, visit each facet of the given expression resolving values from the context\n * expression such that a list of arguments can be derived from the found values that can be used as\n * arguments to an external update instruction.\n *\n * @param localResolver The resolver to use to look up expressions by name appropriately\n * @param contextVariableExpression The expression representing the context variable used to create\n * the final argument expressions\n * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to\n * be resolved and what arguments list to build.\n * @param bindingId A name prefix used to create temporary variable names if they're needed for the\n * arguments generated\n * @returns An array of expressions that can be passed as arguments to instruction expressions like\n * `o.importExpr(R3.propertyInterpolate).callFn(result)`\n */\nfunction convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {\n    var visitor = new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, undefined);\n    var outputExpr = expressionWithArgumentsToExtract.visit(visitor, _Mode.Expression);\n    if (visitor.usesImplicitReceiver) {\n        localResolver.notifyImplicitReceiverUse();\n    }\n    var stmts = getStatementsFromVisitor(visitor, bindingId);\n    // Removing the first argument, because it was a length for ViewEngine, not Ivy.\n    var args = outputExpr.args.slice(1);\n    if (expressionWithArgumentsToExtract instanceof Interpolation) {\n        // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the\n        // args returned to just the value, because we're going to pass it to a special instruction.\n        var strings = expressionWithArgumentsToExtract.strings;\n        if (args.length === 3 && strings[0] === '' && strings[1] === '') {\n            // Single argument interpolate instructions.\n            args = [args[1]];\n        }\n        else if (args.length >= 19) {\n            // 19 or more arguments must be passed to the `interpolateV`-style instructions, which accept\n            // an array of arguments\n            args = [literalArr(args)];\n        }\n    }\n    return { stmts: stmts, args: args };\n}\nfunction getStatementsFromVisitor(visitor, bindingId) {\n    var stmts = [];\n    for (var i = 0; i < visitor.temporaryCount; i++) {\n        stmts.push(temporaryDeclaration(bindingId, i));\n    }\n    return stmts;\n}\nfunction convertBuiltins(converterFactory, ast) {\n    var visitor = new _BuiltinAstConverter(converterFactory);\n    return ast.visit(visitor);\n}\nfunction temporaryName(bindingId, temporaryNumber) {\n    return \"tmp_\" + bindingId + \"_\" + temporaryNumber;\n}\nfunction temporaryDeclaration(bindingId, temporaryNumber) {\n    return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber), NULL_EXPR);\n}\nfunction prependTemporaryDecls(temporaryCount, bindingId, statements) {\n    for (var i = temporaryCount - 1; i >= 0; i--) {\n        statements.unshift(temporaryDeclaration(bindingId, i));\n    }\n}\nvar _Mode;\n(function (_Mode) {\n    _Mode[_Mode[\"Statement\"] = 0] = \"Statement\";\n    _Mode[_Mode[\"Expression\"] = 1] = \"Expression\";\n})(_Mode || (_Mode = {}));\nfunction ensureStatementMode(mode, ast) {\n    if (mode !== _Mode.Statement) {\n        throw new Error(\"Expected a statement, but saw \" + ast);\n    }\n}\nfunction ensureExpressionMode(mode, ast) {\n    if (mode !== _Mode.Expression) {\n        throw new Error(\"Expected an expression, but saw \" + ast);\n    }\n}\nfunction convertToStatementIfNeeded(mode, expr) {\n    if (mode === _Mode.Statement) {\n        return expr.toStmt();\n    }\n    else {\n        return expr;\n    }\n}\nvar _BuiltinAstConverter = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(_BuiltinAstConverter, _super);\n    function _BuiltinAstConverter(_converterFactory) {\n        var _this = _super.call(this) || this;\n        _this._converterFactory = _converterFactory;\n        return _this;\n    }\n    _BuiltinAstConverter.prototype.visitPipe = function (ast, context) {\n        var _this = this;\n        var args = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([ast.exp], ast.args).map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n    };\n    _BuiltinAstConverter.prototype.visitLiteralArray = function (ast, context) {\n        var _this = this;\n        var args = ast.expressions.map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n    };\n    _BuiltinAstConverter.prototype.visitLiteralMap = function (ast, context) {\n        var _this = this;\n        var args = ast.values.map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n    };\n    return _BuiltinAstConverter;\n}(AstTransformer$1));\nvar _AstToIrVisitor = /** @class */ (function () {\n    function _AstToIrVisitor(_localResolver, _implicitReceiver, bindingId, interpolationFunction, baseSourceSpan) {\n        this._localResolver = _localResolver;\n        this._implicitReceiver = _implicitReceiver;\n        this.bindingId = bindingId;\n        this.interpolationFunction = interpolationFunction;\n        this.baseSourceSpan = baseSourceSpan;\n        this._nodeMap = new Map();\n        this._resultMap = new Map();\n        this._currentTemporary = 0;\n        this.temporaryCount = 0;\n        this.usesImplicitReceiver = false;\n    }\n    _AstToIrVisitor.prototype.visitBinary = function (ast, mode) {\n        var op;\n        switch (ast.operation) {\n            case '+':\n                op = BinaryOperator.Plus;\n                break;\n            case '-':\n                op = BinaryOperator.Minus;\n                break;\n            case '*':\n                op = BinaryOperator.Multiply;\n                break;\n            case '/':\n                op = BinaryOperator.Divide;\n                break;\n            case '%':\n                op = BinaryOperator.Modulo;\n                break;\n            case '&&':\n                op = BinaryOperator.And;\n                break;\n            case '||':\n                op = BinaryOperator.Or;\n                break;\n            case '==':\n                op = BinaryOperator.Equals;\n                break;\n            case '!=':\n                op = BinaryOperator.NotEquals;\n                break;\n            case '===':\n                op = BinaryOperator.Identical;\n                break;\n            case '!==':\n                op = BinaryOperator.NotIdentical;\n                break;\n            case '<':\n                op = BinaryOperator.Lower;\n                break;\n            case '>':\n                op = BinaryOperator.Bigger;\n                break;\n            case '<=':\n                op = BinaryOperator.LowerEquals;\n                break;\n            case '>=':\n                op = BinaryOperator.BiggerEquals;\n                break;\n            default:\n                throw new Error(\"Unsupported operation \" + ast.operation);\n        }\n        return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));\n    };\n    _AstToIrVisitor.prototype.visitChain = function (ast, mode) {\n        ensureStatementMode(mode, ast);\n        return this.visitAll(ast.expressions, mode);\n    };\n    _AstToIrVisitor.prototype.visitConditional = function (ast, mode) {\n        var value = this._visit(ast.condition, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));\n    };\n    _AstToIrVisitor.prototype.visitPipe = function (ast, mode) {\n        throw new Error(\"Illegal state: Pipes should have been converted into functions. Pipe: \" + ast.name);\n    };\n    _AstToIrVisitor.prototype.visitFunctionCall = function (ast, mode) {\n        var convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n        var fnResult;\n        if (ast instanceof BuiltinFunctionCall) {\n            fnResult = ast.converter(convertedArgs);\n        }\n        else {\n            fnResult = this._visit(ast.target, _Mode.Expression)\n                .callFn(convertedArgs, this.convertSourceSpan(ast.span));\n        }\n        return convertToStatementIfNeeded(mode, fnResult);\n    };\n    _AstToIrVisitor.prototype.visitImplicitReceiver = function (ast, mode) {\n        ensureExpressionMode(mode, ast);\n        this.usesImplicitReceiver = true;\n        return this._implicitReceiver;\n    };\n    _AstToIrVisitor.prototype.visitInterpolation = function (ast, mode) {\n        ensureExpressionMode(mode, ast);\n        var args = [literal(ast.expressions.length)];\n        for (var i = 0; i < ast.strings.length - 1; i++) {\n            args.push(literal(ast.strings[i]));\n            args.push(this._visit(ast.expressions[i], _Mode.Expression));\n        }\n        args.push(literal(ast.strings[ast.strings.length - 1]));\n        if (this.interpolationFunction) {\n            return this.interpolationFunction(args);\n        }\n        return ast.expressions.length <= 9 ?\n            importExpr(Identifiers.inlineInterpolate).callFn(args) :\n            importExpr(Identifiers.interpolate).callFn([\n                args[0], literalArr(args.slice(1), undefined, this.convertSourceSpan(ast.span))\n            ]);\n    };\n    _AstToIrVisitor.prototype.visitKeyedRead = function (ast, mode) {\n        var leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            return convertToStatementIfNeeded(mode, this._visit(ast.obj, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n        }\n    };\n    _AstToIrVisitor.prototype.visitKeyedWrite = function (ast, mode) {\n        var obj = this._visit(ast.obj, _Mode.Expression);\n        var key = this._visit(ast.key, _Mode.Expression);\n        var value = this._visit(ast.value, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n    };\n    _AstToIrVisitor.prototype.visitLiteralArray = function (ast, mode) {\n        throw new Error(\"Illegal State: literal arrays should have been converted into functions\");\n    };\n    _AstToIrVisitor.prototype.visitLiteralMap = function (ast, mode) {\n        throw new Error(\"Illegal State: literal maps should have been converted into functions\");\n    };\n    _AstToIrVisitor.prototype.visitLiteralPrimitive = function (ast, mode) {\n        // For literal values of null, undefined, true, or false allow type interference\n        // to infer the type.\n        var type = ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?\n            INFERRED_TYPE :\n            undefined;\n        return convertToStatementIfNeeded(mode, literal(ast.value, type, this.convertSourceSpan(ast.span)));\n    };\n    _AstToIrVisitor.prototype._getLocal = function (name) { return this._localResolver.getLocal(name); };\n    _AstToIrVisitor.prototype.visitMethodCall = function (ast, mode) {\n        if (ast.receiver instanceof ImplicitReceiver && ast.name == '$any') {\n            var args = this.visitAll(ast.args, _Mode.Expression);\n            if (args.length != 1) {\n                throw new Error(\"Invalid call to $any, expected 1 argument but received \" + (args.length || 'none'));\n            }\n            return args[0].cast(DYNAMIC_TYPE, this.convertSourceSpan(ast.span));\n        }\n        var leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            var args = this.visitAll(ast.args, _Mode.Expression);\n            var prevUsesImplicitReceiver = this.usesImplicitReceiver;\n            var result = null;\n            var receiver = this._visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                var varExpr = this._getLocal(ast.name);\n                if (varExpr) {\n                    // Restore the previous \"usesImplicitReceiver\" state since the implicit\n                    // receiver has been replaced with a resolved local expression.\n                    this.usesImplicitReceiver = prevUsesImplicitReceiver;\n                    result = varExpr.callFn(args);\n                }\n            }\n            if (result == null) {\n                result = receiver.callMethod(ast.name, args, this.convertSourceSpan(ast.span));\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    };\n    _AstToIrVisitor.prototype.visitPrefixNot = function (ast, mode) {\n        return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));\n    };\n    _AstToIrVisitor.prototype.visitNonNullAssert = function (ast, mode) {\n        return convertToStatementIfNeeded(mode, assertNotNull(this._visit(ast.expression, _Mode.Expression)));\n    };\n    _AstToIrVisitor.prototype.visitPropertyRead = function (ast, mode) {\n        var leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            var result = null;\n            var prevUsesImplicitReceiver = this.usesImplicitReceiver;\n            var receiver = this._visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                result = this._getLocal(ast.name);\n                if (result) {\n                    // Restore the previous \"usesImplicitReceiver\" state since the implicit\n                    // receiver has been replaced with a resolved local expression.\n                    this.usesImplicitReceiver = prevUsesImplicitReceiver;\n                }\n            }\n            if (result == null) {\n                result = receiver.prop(ast.name);\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    };\n    _AstToIrVisitor.prototype.visitPropertyWrite = function (ast, mode) {\n        var receiver = this._visit(ast.receiver, _Mode.Expression);\n        var prevUsesImplicitReceiver = this.usesImplicitReceiver;\n        var varExpr = null;\n        if (receiver === this._implicitReceiver) {\n            var localExpr = this._getLocal(ast.name);\n            if (localExpr) {\n                if (localExpr instanceof ReadPropExpr) {\n                    // If the local variable is a property read expression, it's a reference\n                    // to a 'context.property' value and will be used as the target of the\n                    // write expression.\n                    varExpr = localExpr;\n                    // Restore the previous \"usesImplicitReceiver\" state since the implicit\n                    // receiver has been replaced with a resolved local expression.\n                    this.usesImplicitReceiver = prevUsesImplicitReceiver;\n                }\n                else {\n                    // Otherwise it's an error.\n                    throw new Error('Cannot assign to a reference or variable!');\n                }\n            }\n        }\n        // If no local expression could be produced, use the original receiver's\n        // property as the target.\n        if (varExpr === null) {\n            varExpr = receiver.prop(ast.name);\n        }\n        return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n    };\n    _AstToIrVisitor.prototype.visitSafePropertyRead = function (ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    };\n    _AstToIrVisitor.prototype.visitSafeMethodCall = function (ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    };\n    _AstToIrVisitor.prototype.visitAll = function (asts, mode) {\n        var _this = this;\n        return asts.map(function (ast) { return _this._visit(ast, mode); });\n    };\n    _AstToIrVisitor.prototype.visitQuote = function (ast, mode) {\n        throw new Error(\"Quotes are not supported for evaluation!\\n        Statement: \" + ast.uninterpretedExpression + \" located at \" + ast.location);\n    };\n    _AstToIrVisitor.prototype._visit = function (ast, mode) {\n        var result = this._resultMap.get(ast);\n        if (result)\n            return result;\n        return (this._nodeMap.get(ast) || ast).visit(this, mode);\n    };\n    _AstToIrVisitor.prototype.convertSafeAccess = function (ast, leftMostSafe, mode) {\n        // If the expression contains a safe access node on the left it needs to be converted to\n        // an expression that guards the access to the member by checking the receiver for blank. As\n        // execution proceeds from left to right, the left most part of the expression must be guarded\n        // first but, because member access is left associative, the right side of the expression is at\n        // the top of the AST. The desired result requires lifting a copy of the the left part of the\n        // expression up to test it for blank before generating the unguarded version.\n        // Consider, for example the following expression: a?.b.c?.d.e\n        // This results in the ast:\n        //         .\n        //        / \\\n        //       ?.   e\n        //      /  \\\n        //     .    d\n        //    / \\\n        //   ?.  c\n        //  /  \\\n        // a    b\n        // The following tree should be generated:\n        //\n        //        /---- ? ----\\\n        //       /      |      \\\n        //     a   /--- ? ---\\  null\n        //        /     |     \\\n        //       .      .     null\n        //      / \\    / \\\n        //     .  c   .   e\n        //    / \\    / \\\n        //   a   b  .   d\n        //         / \\\n        //        .   c\n        //       / \\\n        //      a   b\n        //\n        // Notice that the first guard condition is the left hand of the left most safe access node\n        // which comes in as leftMostSafe to this routine.\n        var guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n        var temporary = undefined;\n        if (this.needsTemporary(leftMostSafe.receiver)) {\n            // If the expression has method calls or pipes then we need to save the result into a\n            // temporary variable to avoid calling stateful or impure code more than once.\n            temporary = this.allocateTemporary();\n            // Preserve the result in the temporary variable\n            guardedExpression = temporary.set(guardedExpression);\n            // Ensure all further references to the guarded expression refer to the temporary instead.\n            this._resultMap.set(leftMostSafe.receiver, temporary);\n        }\n        var condition = guardedExpression.isBlank();\n        // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n        // leftMostNode with its unguarded version in the call to `this.visit()`.\n        if (leftMostSafe instanceof SafeMethodCall) {\n            this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n        }\n        else {\n            this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));\n        }\n        // Recursively convert the node now without the guarded member access.\n        var access = this._visit(ast, _Mode.Expression);\n        // Remove the mapping. This is not strictly required as the converter only traverses each node\n        // once but is safer if the conversion is changed to traverse the nodes more than once.\n        this._nodeMap.delete(leftMostSafe);\n        // If we allocated a temporary, release it.\n        if (temporary) {\n            this.releaseTemporary(temporary);\n        }\n        // Produce the conditional\n        return convertToStatementIfNeeded(mode, condition.conditional(literal(null), access));\n    };\n    // Given a expression of the form a?.b.c?.d.e the the left most safe node is\n    // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n    // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n    // safe method call as this needs be transform initially to:\n    //   a == null ? null : a.c.b.c?.d.e\n    // then to:\n    //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n    _AstToIrVisitor.prototype.leftMostSafeNode = function (ast) {\n        var _this = this;\n        var visit = function (visitor, ast) {\n            return (_this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        return ast.visit({\n            visitBinary: function (ast) { return null; },\n            visitChain: function (ast) { return null; },\n            visitConditional: function (ast) { return null; },\n            visitFunctionCall: function (ast) { return null; },\n            visitImplicitReceiver: function (ast) { return null; },\n            visitInterpolation: function (ast) { return null; },\n            visitKeyedRead: function (ast) { return visit(this, ast.obj); },\n            visitKeyedWrite: function (ast) { return null; },\n            visitLiteralArray: function (ast) { return null; },\n            visitLiteralMap: function (ast) { return null; },\n            visitLiteralPrimitive: function (ast) { return null; },\n            visitMethodCall: function (ast) { return visit(this, ast.receiver); },\n            visitPipe: function (ast) { return null; },\n            visitPrefixNot: function (ast) { return null; },\n            visitNonNullAssert: function (ast) { return null; },\n            visitPropertyRead: function (ast) { return visit(this, ast.receiver); },\n            visitPropertyWrite: function (ast) { return null; },\n            visitQuote: function (ast) { return null; },\n            visitSafeMethodCall: function (ast) { return visit(this, ast.receiver) || ast; },\n            visitSafePropertyRead: function (ast) {\n                return visit(this, ast.receiver) || ast;\n            }\n        });\n    };\n    // Returns true of the AST includes a method or a pipe indicating that, if the\n    // expression is used as the target of a safe property or method access then\n    // the expression should be stored into a temporary variable.\n    _AstToIrVisitor.prototype.needsTemporary = function (ast) {\n        var _this = this;\n        var visit = function (visitor, ast) {\n            return ast && (_this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        var visitSome = function (visitor, ast) {\n            return ast.some(function (ast) { return visit(visitor, ast); });\n        };\n        return ast.visit({\n            visitBinary: function (ast) { return visit(this, ast.left) || visit(this, ast.right); },\n            visitChain: function (ast) { return false; },\n            visitConditional: function (ast) {\n                return visit(this, ast.condition) || visit(this, ast.trueExp) ||\n                    visit(this, ast.falseExp);\n            },\n            visitFunctionCall: function (ast) { return true; },\n            visitImplicitReceiver: function (ast) { return false; },\n            visitInterpolation: function (ast) { return visitSome(this, ast.expressions); },\n            visitKeyedRead: function (ast) { return false; },\n            visitKeyedWrite: function (ast) { return false; },\n            visitLiteralArray: function (ast) { return true; },\n            visitLiteralMap: function (ast) { return true; },\n            visitLiteralPrimitive: function (ast) { return false; },\n            visitMethodCall: function (ast) { return true; },\n            visitPipe: function (ast) { return true; },\n            visitPrefixNot: function (ast) { return visit(this, ast.expression); },\n            visitNonNullAssert: function (ast) { return visit(this, ast.expression); },\n            visitPropertyRead: function (ast) { return false; },\n            visitPropertyWrite: function (ast) { return false; },\n            visitQuote: function (ast) { return false; },\n            visitSafeMethodCall: function (ast) { return true; },\n            visitSafePropertyRead: function (ast) { return false; }\n        });\n    };\n    _AstToIrVisitor.prototype.allocateTemporary = function () {\n        var tempNumber = this._currentTemporary++;\n        this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n        return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n    };\n    _AstToIrVisitor.prototype.releaseTemporary = function (temporary) {\n        this._currentTemporary--;\n        if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n            throw new Error(\"Temporary \" + temporary.name + \" released out of order\");\n        }\n    };\n    /**\n     * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\n     *\n     * `ParseSpan` objects are relative to the start of the expression.\n     * This method converts these to full `ParseSourceSpan` objects that\n     * show where the span is within the overall source file.\n     *\n     * @param span the relative span to convert.\n     * @returns a `ParseSourceSpan` for the the given span or null if no\n     * `baseSourceSpan` was provided to this class.\n     */\n    _AstToIrVisitor.prototype.convertSourceSpan = function (span) {\n        if (this.baseSourceSpan) {\n            var start = this.baseSourceSpan.start.moveBy(span.start);\n            var end = this.baseSourceSpan.start.moveBy(span.end);\n            return new ParseSourceSpan(start, end);\n        }\n        else {\n            return null;\n        }\n    };\n    return _AstToIrVisitor;\n}());\nfunction flattenStatements(arg, output) {\n    if (Array.isArray(arg)) {\n        arg.forEach(function (entry) { return flattenStatements(entry, output); });\n    }\n    else {\n        output.push(arg);\n    }\n}\nvar DefaultLocalResolver = /** @class */ (function () {\n    function DefaultLocalResolver() {\n    }\n    DefaultLocalResolver.prototype.notifyImplicitReceiverUse = function () { };\n    DefaultLocalResolver.prototype.getLocal = function (name) {\n        if (name === EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        return null;\n    };\n    return DefaultLocalResolver;\n}());\nfunction createCurrValueExpr(bindingId) {\n    return variable(\"currVal_\" + bindingId); // fix syntax highlighting: `\n}\nfunction createPreventDefaultVar(bindingId) {\n    return variable(\"pd_\" + bindingId);\n}\nfunction convertStmtIntoExpression(stmt) {\n    if (stmt instanceof ExpressionStatement) {\n        return stmt.expr;\n    }\n    else if (stmt instanceof ReturnStatement) {\n        return stmt.value;\n    }\n    return null;\n}\nvar BuiltinFunctionCall = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(BuiltinFunctionCall, _super);\n    function BuiltinFunctionCall(span, args, converter) {\n        var _this = _super.call(this, span, null, args) || this;\n        _this.args = args;\n        _this.converter = converter;\n        return _this;\n    }\n    return BuiltinFunctionCall;\n}(FunctionCall));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This file is a port of shadowCSS from webcomponents.js to TypeScript.\n *\n * Please make sure to keep to edits in sync with the source file.\n *\n * Source:\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n *\n * The original file level comment is reproduced below\n */\n/*\n  This is a limited shim for ShadowDOM css styling.\n  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\n\n  The intention here is to support only the styling features which can be\n  relatively simply implemented. The goal is to allow users to avoid the\n  most obvious pitfalls and do so without compromising performance significantly.\n  For ShadowDOM styling that's not covered here, a set of best practices\n  can be provided that should allow users to accomplish more complex styling.\n\n  The following is a list of specific ShadowDOM styling features and a brief\n  discussion of the approach used to shim.\n\n  Shimmed features:\n\n  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\n  element using the :host rule. To shim this feature, the :host styles are\n  reformatted and prefixed with a given scope name and promoted to a\n  document level stylesheet.\n  For example, given a scope name of .foo, a rule like this:\n\n    :host {\n        background: red;\n      }\n    }\n\n  becomes:\n\n    .foo {\n      background: red;\n    }\n\n  * encapsulation: Styles defined within ShadowDOM, apply only to\n  dom inside the ShadowDOM. Polymer uses one of two techniques to implement\n  this feature.\n\n  By default, rules are prefixed with the host element tag name\n  as a descendant selector. This ensures styling does not leak out of the 'top'\n  of the element's ShadowDOM. For example,\n\n  div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n  x-foo div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n\n  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then\n  selectors are scoped by adding an attribute selector suffix to each\n  simple selector that contains the host element tag name. Each element\n  in the element's ShadowDOM template is also given the scope attribute.\n  Thus, these rules match only elements that have the scope attribute.\n  For example, given a scope name of x-foo, a rule like this:\n\n    div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n    div[x-foo] {\n      font-weight: bold;\n    }\n\n  Note that elements that are dynamically added to a scope must have the scope\n  selector added to them manually.\n\n  * upper/lower bound encapsulation: Styles which are defined outside a\n  shadowRoot should not cross the ShadowDOM boundary and should not apply\n  inside a shadowRoot.\n\n  This styling behavior is not emulated. Some possible ways to do this that\n  were rejected due to complexity and/or performance concerns include: (1) reset\n  every possible property for every possible selector for a given scope name;\n  (2) re-implement css in javascript.\n\n  As an alternative, users should make sure to use selectors\n  specific to the scope in which they are working.\n\n  * ::distributed: This behavior is not emulated. It's often not necessary\n  to style the contents of a specific insertion point and instead, descendants\n  of the host element can be styled selectively. Users can also create an\n  extra node around an insertion point and style that node's contents\n  via descendent selectors. For example, with a shadowRoot like this:\n\n    <style>\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <content></content>\n\n  could become:\n\n    <style>\n      / *@polyfill .content-container div * /\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <div class=\"content-container\">\n      <content></content>\n    </div>\n\n  Note the use of @polyfill in the comment above a ShadowDOM specific style\n  declaration. This is a directive to the styling shim to use the selector\n  in comments in lieu of the next selector when running under polyfill.\n*/\nvar ShadowCss = /** @class */ (function () {\n    function ShadowCss() {\n        this.strictStyling = true;\n    }\n    /*\n    * Shim some cssText with the given selector. Returns cssText that can\n    * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).\n    *\n    * When strictStyling is true:\n    * - selector is the attribute added to all elements inside the host,\n    * - hostSelector is the attribute added to the host itself.\n    */\n    ShadowCss.prototype.shimCssText = function (cssText, selector, hostSelector) {\n        if (hostSelector === void 0) { hostSelector = ''; }\n        var commentsWithHash = extractCommentsWithHash(cssText);\n        cssText = stripComments(cssText);\n        cssText = this._insertDirectives(cssText);\n        var scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([scopedCssText], commentsWithHash).join('\\n');\n    };\n    ShadowCss.prototype._insertDirectives = function (cssText) {\n        cssText = this._insertPolyfillDirectivesInCssText(cssText);\n        return this._insertPolyfillRulesInCssText(cssText);\n    };\n    /*\n     * Process styles to convert native ShadowDOM rules that will trip\n     * up the css parser; we rely on decorating the stylesheet with inert rules.\n     *\n     * For example, we convert this rule:\n     *\n     * polyfill-next-selector { content: ':host menu-item'; }\n     * ::content menu-item {\n     *\n     * to this:\n     *\n     * scopeName menu-item {\n     *\n    **/\n    ShadowCss.prototype._insertPolyfillDirectivesInCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentNextSelectorRe, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            return m[2] + '{';\n        });\n    };\n    /*\n     * Process styles to add rules which will only apply under the polyfill\n     *\n     * For example, we convert this rule:\n     *\n     * polyfill-rule {\n     *   content: ':host menu-item';\n     * ...\n     * }\n     *\n     * to this:\n     *\n     * scopeName menu-item {...}\n     *\n    **/\n    ShadowCss.prototype._insertPolyfillRulesInCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentRuleRe, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            var rule = m[0].replace(m[1], '').replace(m[2], '');\n            return m[4] + rule;\n        });\n    };\n    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\n     *\n     *  .foo {... }\n     *\n     *  and converts this to\n     *\n     *  scopeName .foo { ... }\n    */\n    ShadowCss.prototype._scopeCssText = function (cssText, scopeSelector, hostSelector) {\n        var unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n        // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n        cssText = this._insertPolyfillHostInCssText(cssText);\n        cssText = this._convertColonHost(cssText);\n        cssText = this._convertColonHostContext(cssText);\n        cssText = this._convertShadowDOMSelectors(cssText);\n        if (scopeSelector) {\n            cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n        }\n        cssText = cssText + '\\n' + unscopedRules;\n        return cssText.trim();\n    };\n    /*\n     * Process styles to add rules which will only apply under the polyfill\n     * and do not process via CSSOM. (CSSOM is destructive to rules on rare\n     * occasions, e.g. -webkit-calc on Safari.)\n     * For example, we convert this rule:\n     *\n     * @polyfill-unscoped-rule {\n     *   content: 'menu-item';\n     * ... }\n     *\n     * to this:\n     *\n     * menu-item {...}\n     *\n    **/\n    ShadowCss.prototype._extractUnscopedRulesFromCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        var r = '';\n        var m;\n        _cssContentUnscopedRuleRe.lastIndex = 0;\n        while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n            var rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n            r += rule + '\\n\\n';\n        }\n        return r;\n    };\n    /*\n     * convert a rule like :host(.foo) > .bar { }\n     *\n     * to\n     *\n     * .foo<scopeName> > .bar\n    */\n    ShadowCss.prototype._convertColonHost = function (cssText) {\n        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);\n    };\n    /*\n     * convert a rule like :host-context(.foo) > .bar { }\n     *\n     * to\n     *\n     * .foo<scopeName> > .bar, .foo scopeName > .bar { }\n     *\n     * and\n     *\n     * :host-context(.foo:host) .bar { ... }\n     *\n     * to\n     *\n     * .foo<scopeName> .bar { ... }\n    */\n    ShadowCss.prototype._convertColonHostContext = function (cssText) {\n        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);\n    };\n    ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {\n        // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule\n        return cssText.replace(regExp, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            if (m[2]) {\n                var parts = m[2].split(',');\n                var r = [];\n                for (var i = 0; i < parts.length; i++) {\n                    var p = parts[i].trim();\n                    if (!p)\n                        break;\n                    r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n                }\n                return r.join(',');\n            }\n            else {\n                return _polyfillHostNoCombinator + m[3];\n            }\n        });\n    };\n    ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {\n        if (part.indexOf(_polyfillHost) > -1) {\n            return this._colonHostPartReplacer(host, part, suffix);\n        }\n        else {\n            return host + part + suffix + ', ' + part + ' ' + host + suffix;\n        }\n    };\n    ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {\n        return host + part.replace(_polyfillHost, '') + suffix;\n    };\n    /*\n     * Convert combinators like ::shadow and pseudo-elements like ::content\n     * by replacing with space.\n    */\n    ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {\n        return _shadowDOMSelectorsRe.reduce(function (result, pattern) { return result.replace(pattern, ' '); }, cssText);\n    };\n    // change a selector like 'div' to 'name div'\n    ShadowCss.prototype._scopeSelectors = function (cssText, scopeSelector, hostSelector) {\n        var _this = this;\n        return processRules(cssText, function (rule) {\n            var selector = rule.selector;\n            var content = rule.content;\n            if (rule.selector[0] != '@') {\n                selector =\n                    _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);\n            }\n            else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n                rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {\n                content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n            }\n            return new CssRule(selector, content);\n        });\n    };\n    ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, strict) {\n        var _this = this;\n        return selector.split(',')\n            .map(function (part) { return part.trim().split(_shadowDeepSelectors); })\n            .map(function (deepParts) {\n            var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(deepParts), shallowPart = _a[0], otherParts = _a.slice(1);\n            var applyScope = function (shallowPart) {\n                if (_this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n                    return strict ?\n                        _this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :\n                        _this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n                }\n                else {\n                    return shallowPart;\n                }\n            };\n            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([applyScope(shallowPart)], otherParts).join(' ');\n        })\n            .join(', ');\n    };\n    ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {\n        var re = this._makeScopeMatcher(scopeSelector);\n        return !re.test(selector);\n    };\n    ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {\n        var lre = /\\[/g;\n        var rre = /\\]/g;\n        scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n        return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n    };\n    ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {\n        // Difference from webcomponents.js: scopeSelector could not be an array\n        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n    };\n    // scope via name and [is=name]\n    ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {\n        // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n        _polyfillHostRe.lastIndex = 0;\n        if (_polyfillHostRe.test(selector)) {\n            var replaceBy_1 = this.strictStyling ? \"[\" + hostSelector + \"]\" : scopeSelector;\n            return selector\n                .replace(_polyfillHostNoCombinatorRe, function (hnc, selector) {\n                return selector.replace(/([^:]*)(:*)(.*)/, function (_, before, colon, after) {\n                    return before + replaceBy_1 + colon + after;\n                });\n            })\n                .replace(_polyfillHostRe, replaceBy_1 + ' ');\n        }\n        return scopeSelector + ' ' + selector;\n    };\n    // return a selector with [name] suffix on each simple selector\n    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */\n    ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector, hostSelector) {\n        var _this = this;\n        var isRe = /\\[is=([^\\]]*)\\]/g;\n        scopeSelector = scopeSelector.replace(isRe, function (_) {\n            var parts = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                parts[_i - 1] = arguments[_i];\n            }\n            return parts[0];\n        });\n        var attrName = '[' + scopeSelector + ']';\n        var _scopeSelectorPart = function (p) {\n            var scopedP = p.trim();\n            if (!scopedP) {\n                return '';\n            }\n            if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n                scopedP = _this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n            }\n            else {\n                // remove :host since it should be unnecessary\n                var t = p.replace(_polyfillHostRe, '');\n                if (t.length > 0) {\n                    var matches = t.match(/([^:]*)(:*)(.*)/);\n                    if (matches) {\n                        scopedP = matches[1] + attrName + matches[2] + matches[3];\n                    }\n                }\n            }\n            return scopedP;\n        };\n        var safeContent = new SafeSelector(selector);\n        selector = safeContent.content();\n        var scopedSelector = '';\n        var startIndex = 0;\n        var res;\n        var sep = /( |>|\\+|~(?!=))\\s*/g;\n        // If a selector appears before :host it should not be shimmed as it\n        // matches on ancestor elements and not on elements in the host's shadow\n        // `:host-context(div)` is transformed to\n        // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n        // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n        // Historically `component-tag:host` was matching the component so we also want to preserve\n        // this behavior to avoid breaking legacy apps (it should not match).\n        // The behavior should be:\n        // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n        // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n        //   `:host-context(tag)`)\n        var hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\n        // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\n        var shouldScope = !hasHost;\n        while ((res = sep.exec(selector)) !== null) {\n            var separator = res[1];\n            var part_1 = selector.slice(startIndex, res.index).trim();\n            shouldScope = shouldScope || part_1.indexOf(_polyfillHostNoCombinator) > -1;\n            var scopedPart = shouldScope ? _scopeSelectorPart(part_1) : part_1;\n            scopedSelector += scopedPart + \" \" + separator + \" \";\n            startIndex = sep.lastIndex;\n        }\n        var part = selector.substring(startIndex);\n        shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n        scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\n        // replace the placeholders with their original values\n        return safeContent.restore(scopedSelector);\n    };\n    ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {\n        return selector.replace(_colonHostContextRe, _polyfillHostContext)\n            .replace(_colonHostRe, _polyfillHost);\n    };\n    return ShadowCss;\n}());\nvar SafeSelector = /** @class */ (function () {\n    function SafeSelector(selector) {\n        var _this = this;\n        this.placeholders = [];\n        this.index = 0;\n        // Replaces attribute selectors with placeholders.\n        // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n        selector = selector.replace(/(\\[[^\\]]*\\])/g, function (_, keep) {\n            var replaceBy = \"__ph-\" + _this.index + \"__\";\n            _this.placeholders.push(keep);\n            _this.index++;\n            return replaceBy;\n        });\n        // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n        // WS and \"+\" would otherwise be interpreted as selector separators.\n        this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, function (_, pseudo, exp) {\n            var replaceBy = \"__ph-\" + _this.index + \"__\";\n            _this.placeholders.push(exp);\n            _this.index++;\n            return pseudo + replaceBy;\n        });\n    }\n    SafeSelector.prototype.restore = function (content) {\n        var _this = this;\n        return content.replace(/__ph-(\\d+)__/g, function (ph, index) { return _this.placeholders[+index]; });\n    };\n    SafeSelector.prototype.content = function () { return this._content; };\n    return SafeSelector;\n}());\nvar _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nvar _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nvar _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nvar _polyfillHost = '-shadowcsshost';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nvar _polyfillHostContext = '-shadowcsscontext';\nvar _parenSuffix = ')(?:\\\\((' +\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n    ')\\\\))?([^,{]*)';\nvar _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');\nvar _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');\nvar _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nvar _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nvar _shadowDOMSelectorsRe = [\n    /::shadow/g,\n    /::content/g,\n    // Deprecated selectors\n    /\\/shadow-deep\\//g,\n    /\\/shadow\\//g,\n];\n// The deep combinator is deprecated in the CSS spec\n// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.\n// see https://github.com/angular/angular/pull/17677\nvar _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nvar _selectorReSuffix = '([>\\\\s~+\\[.,{:][\\\\s\\\\S]*)?$';\nvar _polyfillHostRe = /-shadowcsshost/gim;\nvar _colonHostRe = /:host/gim;\nvar _colonHostContextRe = /:host-context/gim;\nvar _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\nfunction stripComments(input) {\n    return input.replace(_commentRe, '');\n}\nvar _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\nfunction extractCommentsWithHash(input) {\n    return input.match(_commentWithHashRe) || [];\n}\nvar _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nvar _curlyRe = /([{}])/g;\nvar OPEN_CURLY = '{';\nvar CLOSE_CURLY = '}';\nvar BLOCK_PLACEHOLDER = '%BLOCK%';\nvar CssRule = /** @class */ (function () {\n    function CssRule(selector, content) {\n        this.selector = selector;\n        this.content = content;\n    }\n    return CssRule;\n}());\nfunction processRules(input, ruleCallback) {\n    var inputWithEscapedBlocks = escapeBlocks(input);\n    var nextBlockIndex = 0;\n    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        var selector = m[2];\n        var content = '';\n        var suffix = m[4];\n        var contentPrefix = '';\n        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n            contentPrefix = '{';\n        }\n        var rule = ruleCallback(new CssRule(selector, content));\n        return \"\" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;\n    });\n}\nvar StringWithEscapedBlocks = /** @class */ (function () {\n    function StringWithEscapedBlocks(escapedString, blocks) {\n        this.escapedString = escapedString;\n        this.blocks = blocks;\n    }\n    return StringWithEscapedBlocks;\n}());\nfunction escapeBlocks(input) {\n    var inputParts = input.split(_curlyRe);\n    var resultParts = [];\n    var escapedBlocks = [];\n    var bracketCount = 0;\n    var currentBlockParts = [];\n    for (var partIndex = 0; partIndex < inputParts.length; partIndex++) {\n        var part = inputParts[partIndex];\n        if (part == CLOSE_CURLY) {\n            bracketCount--;\n        }\n        if (bracketCount > 0) {\n            currentBlockParts.push(part);\n        }\n        else {\n            if (currentBlockParts.length > 0) {\n                escapedBlocks.push(currentBlockParts.join(''));\n                resultParts.push(BLOCK_PLACEHOLDER);\n                currentBlockParts = [];\n            }\n            resultParts.push(part);\n        }\n        if (part == OPEN_CURLY) {\n            bracketCount++;\n        }\n    }\n    if (currentBlockParts.length > 0) {\n        escapedBlocks.push(currentBlockParts.join(''));\n        resultParts.push(BLOCK_PLACEHOLDER);\n    }\n    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar COMPONENT_VARIABLE = '%COMP%';\nvar HOST_ATTR = \"_nghost-\" + COMPONENT_VARIABLE;\nvar CONTENT_ATTR = \"_ngcontent-\" + COMPONENT_VARIABLE;\nvar StylesCompileDependency = /** @class */ (function () {\n    function StylesCompileDependency(name, moduleUrl, setValue) {\n        this.name = name;\n        this.moduleUrl = moduleUrl;\n        this.setValue = setValue;\n    }\n    return StylesCompileDependency;\n}());\nvar CompiledStylesheet = /** @class */ (function () {\n    function CompiledStylesheet(outputCtx, stylesVar, dependencies, isShimmed, meta) {\n        this.outputCtx = outputCtx;\n        this.stylesVar = stylesVar;\n        this.dependencies = dependencies;\n        this.isShimmed = isShimmed;\n        this.meta = meta;\n    }\n    return CompiledStylesheet;\n}());\nvar StyleCompiler = /** @class */ (function () {\n    function StyleCompiler(_urlResolver) {\n        this._urlResolver = _urlResolver;\n        this._shadowCss = new ShadowCss();\n    }\n    StyleCompiler.prototype.compileComponent = function (outputCtx, comp) {\n        var template = comp.template;\n        return this._compileStyles(outputCtx, comp, new CompileStylesheetMetadata({\n            styles: template.styles,\n            styleUrls: template.styleUrls,\n            moduleUrl: identifierModuleUrl(comp.type)\n        }), this.needsStyleShim(comp), true);\n    };\n    StyleCompiler.prototype.compileStyles = function (outputCtx, comp, stylesheet, shim) {\n        if (shim === void 0) { shim = this.needsStyleShim(comp); }\n        return this._compileStyles(outputCtx, comp, stylesheet, shim, false);\n    };\n    StyleCompiler.prototype.needsStyleShim = function (comp) {\n        return comp.template.encapsulation === ViewEncapsulation.Emulated;\n    };\n    StyleCompiler.prototype._compileStyles = function (outputCtx, comp, stylesheet, shim, isComponentStylesheet) {\n        var _this = this;\n        var styleExpressions = stylesheet.styles.map(function (plainStyle) { return literal(_this._shimIfNeeded(plainStyle, shim)); });\n        var dependencies = [];\n        stylesheet.styleUrls.forEach(function (styleUrl) {\n            var exprIndex = styleExpressions.length;\n            // Note: This placeholder will be filled later.\n            styleExpressions.push(null);\n            dependencies.push(new StylesCompileDependency(getStylesVarName(null), styleUrl, function (value) { return styleExpressions[exprIndex] = outputCtx.importExpr(value); }));\n        });\n        // styles variable contains plain strings and arrays of other styles arrays (recursive),\n        // so we set its type to dynamic.\n        var stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);\n        var stmt = variable(stylesVar)\n            .set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])))\n            .toDeclStmt(null, isComponentStylesheet ? [StmtModifier.Final] : [\n            StmtModifier.Final, StmtModifier.Exported\n        ]);\n        outputCtx.statements.push(stmt);\n        return new CompiledStylesheet(outputCtx, stylesVar, dependencies, shim, stylesheet);\n    };\n    StyleCompiler.prototype._shimIfNeeded = function (style, shim) {\n        return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;\n    };\n    return StyleCompiler;\n}());\nfunction getStylesVarName(component) {\n    var result = \"styles\";\n    if (component) {\n        result += \"_\" + identifierName(component.type);\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A path is an ordered set of elements. Typically a path is to  a\n * particular offset in a source file. The head of the list is the top\n * most node. The tail is the node that contains the offset directly.\n *\n * For example, the expression `a + b + c` might have an ast that looks\n * like:\n *     +\n *    / \\\n *   a   +\n *      / \\\n *     b   c\n *\n * The path to the node at offset 9 would be `['+' at 1-10, '+' at 7-10,\n * 'c' at 9-10]` and the path the node at offset 1 would be\n * `['+' at 1-10, 'a' at 1-2]`.\n */\nvar AstPath = /** @class */ (function () {\n    function AstPath(path, position) {\n        if (position === void 0) { position = -1; }\n        this.path = path;\n        this.position = position;\n    }\n    Object.defineProperty(AstPath.prototype, \"empty\", {\n        get: function () { return !this.path || !this.path.length; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AstPath.prototype, \"head\", {\n        get: function () { return this.path[0]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AstPath.prototype, \"tail\", {\n        get: function () { return this.path[this.path.length - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    AstPath.prototype.parentOf = function (node) {\n        return node && this.path[this.path.indexOf(node) - 1];\n    };\n    AstPath.prototype.childOf = function (node) { return this.path[this.path.indexOf(node) + 1]; };\n    AstPath.prototype.first = function (ctor) {\n        for (var i = this.path.length - 1; i >= 0; i--) {\n            var item = this.path[i];\n            if (item instanceof ctor)\n                return item;\n        }\n    };\n    AstPath.prototype.push = function (node) { this.path.push(node); };\n    AstPath.prototype.pop = function () { return this.path.pop(); };\n    return AstPath;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Text$3 = /** @class */ (function () {\n    function Text(value, sourceSpan, i18n) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n    Text.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n    return Text;\n}());\nvar Expansion = /** @class */ (function () {\n    function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {\n        this.switchValue = switchValue;\n        this.type = type;\n        this.cases = cases;\n        this.sourceSpan = sourceSpan;\n        this.switchValueSourceSpan = switchValueSourceSpan;\n        this.i18n = i18n;\n    }\n    Expansion.prototype.visit = function (visitor, context) { return visitor.visitExpansion(this, context); };\n    return Expansion;\n}());\nvar ExpansionCase = /** @class */ (function () {\n    function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n        this.value = value;\n        this.expression = expression;\n        this.sourceSpan = sourceSpan;\n        this.valueSourceSpan = valueSourceSpan;\n        this.expSourceSpan = expSourceSpan;\n    }\n    ExpansionCase.prototype.visit = function (visitor, context) { return visitor.visitExpansionCase(this, context); };\n    return ExpansionCase;\n}());\nvar Attribute = /** @class */ (function () {\n    function Attribute(name, value, sourceSpan, valueSpan, i18n) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n        this.i18n = i18n;\n    }\n    Attribute.prototype.visit = function (visitor, context) { return visitor.visitAttribute(this, context); };\n    return Attribute;\n}());\nvar Element$1 = /** @class */ (function () {\n    function Element(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n        if (startSourceSpan === void 0) { startSourceSpan = null; }\n        if (endSourceSpan === void 0) { endSourceSpan = null; }\n        this.name = name;\n        this.attrs = attrs;\n        this.children = children;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n        this.i18n = i18n;\n    }\n    Element.prototype.visit = function (visitor, context) { return visitor.visitElement(this, context); };\n    return Element;\n}());\nvar Comment = /** @class */ (function () {\n    function Comment(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    Comment.prototype.visit = function (visitor, context) { return visitor.visitComment(this, context); };\n    return Comment;\n}());\nfunction visitAll$1(visitor, nodes, context) {\n    if (context === void 0) { context = null; }\n    var result = [];\n    var visit = visitor.visit ?\n        function (ast) { return visitor.visit(ast, context) || ast.visit(visitor, context); } :\n        function (ast) { return ast.visit(visitor, context); };\n    nodes.forEach(function (ast) {\n        var astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\nvar RecursiveVisitor$1 = /** @class */ (function () {\n    function RecursiveVisitor() {\n    }\n    RecursiveVisitor.prototype.visitElement = function (ast, context) {\n        this.visitChildren(context, function (visit) {\n            visit(ast.attrs);\n            visit(ast.children);\n        });\n    };\n    RecursiveVisitor.prototype.visitAttribute = function (ast, context) { };\n    RecursiveVisitor.prototype.visitText = function (ast, context) { };\n    RecursiveVisitor.prototype.visitComment = function (ast, context) { };\n    RecursiveVisitor.prototype.visitExpansion = function (ast, context) {\n        return this.visitChildren(context, function (visit) { visit(ast.cases); });\n    };\n    RecursiveVisitor.prototype.visitExpansionCase = function (ast, context) { };\n    RecursiveVisitor.prototype.visitChildren = function (context, cb) {\n        var results = [];\n        var t = this;\n        function visit(children) {\n            if (children)\n                results.push(visitAll$1(t, children, context));\n        }\n        cb(visit);\n        return Array.prototype.concat.apply([], results);\n    };\n    return RecursiveVisitor;\n}());\nfunction spanOf(ast) {\n    var start = ast.sourceSpan.start.offset;\n    var end = ast.sourceSpan.end.offset;\n    if (ast instanceof Element$1) {\n        if (ast.endSourceSpan) {\n            end = ast.endSourceSpan.end.offset;\n        }\n        else if (ast.children && ast.children.length) {\n            end = spanOf(ast.children[ast.children.length - 1]).end;\n        }\n    }\n    return { start: start, end: end };\n}\nfunction findNode(nodes, position) {\n    var path = [];\n    var visitor = new /** @class */ (function (_super) {\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(class_1, _super);\n        function class_1() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        class_1.prototype.visit = function (ast, context) {\n            var span = spanOf(ast);\n            if (span.start <= position && position < span.end) {\n                path.push(ast);\n            }\n            else {\n                // Returning a value here will result in the children being skipped.\n                return true;\n            }\n        };\n        return class_1;\n    }(RecursiveVisitor$1));\n    visitAll$1(visitor, nodes);\n    return new AstPath(path, position);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TokenType;\n(function (TokenType) {\n    TokenType[TokenType[\"TAG_OPEN_START\"] = 0] = \"TAG_OPEN_START\";\n    TokenType[TokenType[\"TAG_OPEN_END\"] = 1] = \"TAG_OPEN_END\";\n    TokenType[TokenType[\"TAG_OPEN_END_VOID\"] = 2] = \"TAG_OPEN_END_VOID\";\n    TokenType[TokenType[\"TAG_CLOSE\"] = 3] = \"TAG_CLOSE\";\n    TokenType[TokenType[\"TEXT\"] = 4] = \"TEXT\";\n    TokenType[TokenType[\"ESCAPABLE_RAW_TEXT\"] = 5] = \"ESCAPABLE_RAW_TEXT\";\n    TokenType[TokenType[\"RAW_TEXT\"] = 6] = \"RAW_TEXT\";\n    TokenType[TokenType[\"COMMENT_START\"] = 7] = \"COMMENT_START\";\n    TokenType[TokenType[\"COMMENT_END\"] = 8] = \"COMMENT_END\";\n    TokenType[TokenType[\"CDATA_START\"] = 9] = \"CDATA_START\";\n    TokenType[TokenType[\"CDATA_END\"] = 10] = \"CDATA_END\";\n    TokenType[TokenType[\"ATTR_NAME\"] = 11] = \"ATTR_NAME\";\n    TokenType[TokenType[\"ATTR_QUOTE\"] = 12] = \"ATTR_QUOTE\";\n    TokenType[TokenType[\"ATTR_VALUE\"] = 13] = \"ATTR_VALUE\";\n    TokenType[TokenType[\"DOC_TYPE\"] = 14] = \"DOC_TYPE\";\n    TokenType[TokenType[\"EXPANSION_FORM_START\"] = 15] = \"EXPANSION_FORM_START\";\n    TokenType[TokenType[\"EXPANSION_CASE_VALUE\"] = 16] = \"EXPANSION_CASE_VALUE\";\n    TokenType[TokenType[\"EXPANSION_CASE_EXP_START\"] = 17] = \"EXPANSION_CASE_EXP_START\";\n    TokenType[TokenType[\"EXPANSION_CASE_EXP_END\"] = 18] = \"EXPANSION_CASE_EXP_END\";\n    TokenType[TokenType[\"EXPANSION_FORM_END\"] = 19] = \"EXPANSION_FORM_END\";\n    TokenType[TokenType[\"EOF\"] = 20] = \"EOF\";\n})(TokenType || (TokenType = {}));\nvar Token = /** @class */ (function () {\n    function Token(type, parts, sourceSpan) {\n        this.type = type;\n        this.parts = parts;\n        this.sourceSpan = sourceSpan;\n    }\n    return Token;\n}());\nvar TokenError = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(TokenError, _super);\n    function TokenError(errorMsg, tokenType, span) {\n        var _this = _super.call(this, span, errorMsg) || this;\n        _this.tokenType = tokenType;\n        return _this;\n    }\n    return TokenError;\n}(ParseError));\nvar TokenizeResult = /** @class */ (function () {\n    function TokenizeResult(tokens, errors) {\n        this.tokens = tokens;\n        this.errors = errors;\n    }\n    return TokenizeResult;\n}());\nfunction tokenize(source, url, getTagDefinition, options) {\n    if (options === void 0) { options = {}; }\n    return new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options).tokenize();\n}\nvar _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\nfunction _unexpectedCharacterErrorMsg(charCode) {\n    var char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);\n    return \"Unexpected character \\\"\" + char + \"\\\"\";\n}\nfunction _unknownEntityErrorMsg(entitySrc) {\n    return \"Unknown entity \\\"\" + entitySrc + \"\\\" - use the \\\"&#<decimal>;\\\" or  \\\"&#x<hex>;\\\" syntax\";\n}\nvar _ControlFlowError = /** @class */ (function () {\n    function _ControlFlowError(error) {\n        this.error = error;\n    }\n    return _ControlFlowError;\n}());\n// See http://www.w3.org/TR/html51/syntax.html#writing\nvar _Tokenizer = /** @class */ (function () {\n    /**\n     * @param _file The html source file being tokenized.\n     * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.\n     * @param options Configuration of the tokenization.\n     */\n    function _Tokenizer(_file, _getTagDefinition, options) {\n        this._getTagDefinition = _getTagDefinition;\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        this._expansionCaseStack = [];\n        this._inInterpolation = false;\n        this.tokens = [];\n        this.errors = [];\n        this._tokenizeIcu = options.tokenizeExpansionForms || false;\n        this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n        this._leadingTriviaCodePoints =\n            options.leadingTriviaChars && options.leadingTriviaChars.map(function (c) { return c.codePointAt(0) || 0; });\n        var range = options.range || { endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0 };\n        this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) :\n            new PlainCharacterCursor(_file, range);\n        try {\n            this._cursor.init();\n        }\n        catch (e) {\n            this.handleError(e);\n        }\n    }\n    _Tokenizer.prototype._processCarriageReturns = function (content) {\n        // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\n        // In order to keep the original position in the source, we can not\n        // pre-process it.\n        // Instead CRs are processed right before instantiating the tokens.\n        return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n    };\n    _Tokenizer.prototype.tokenize = function () {\n        while (this._cursor.peek() !== $EOF) {\n            var start = this._cursor.clone();\n            try {\n                if (this._attemptCharCode($LT)) {\n                    if (this._attemptCharCode($BANG)) {\n                        if (this._attemptCharCode($LBRACKET)) {\n                            this._consumeCdata(start);\n                        }\n                        else if (this._attemptCharCode($MINUS)) {\n                            this._consumeComment(start);\n                        }\n                        else {\n                            this._consumeDocType(start);\n                        }\n                    }\n                    else if (this._attemptCharCode($SLASH)) {\n                        this._consumeTagClose(start);\n                    }\n                    else {\n                        this._consumeTagOpen(start);\n                    }\n                }\n                else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n                    this._consumeText();\n                }\n            }\n            catch (e) {\n                this.handleError(e);\n            }\n        }\n        this._beginToken(TokenType.EOF);\n        this._endToken([]);\n        return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);\n    };\n    /**\n     * @returns whether an ICU token has been created\n     * @internal\n     */\n    _Tokenizer.prototype._tokenizeExpansionForm = function () {\n        if (this.isExpansionFormStart()) {\n            this._consumeExpansionFormStart();\n            return true;\n        }\n        if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n            this._consumeExpansionCaseStart();\n            return true;\n        }\n        if (this._cursor.peek() === $RBRACE) {\n            if (this._isInExpansionCase()) {\n                this._consumeExpansionCaseEnd();\n                return true;\n            }\n            if (this._isInExpansionForm()) {\n                this._consumeExpansionFormEnd();\n                return true;\n            }\n        }\n        return false;\n    };\n    _Tokenizer.prototype._beginToken = function (type, start) {\n        if (start === void 0) { start = this._cursor.clone(); }\n        this._currentTokenStart = start;\n        this._currentTokenType = type;\n    };\n    _Tokenizer.prototype._endToken = function (parts, end) {\n        if (end === void 0) { end = this._cursor.clone(); }\n        if (this._currentTokenStart === null) {\n            throw new TokenError('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(end));\n        }\n        if (this._currentTokenType === null) {\n            throw new TokenError('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));\n        }\n        var token = new Token(this._currentTokenType, parts, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));\n        this.tokens.push(token);\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        return token;\n    };\n    _Tokenizer.prototype._createError = function (msg, span) {\n        if (this._isInExpansionForm()) {\n            msg += \" (Do you have an unescaped \\\"{\\\" in your template? Use \\\"{{ '{' }}\\\") to escape it.)\";\n        }\n        var error = new TokenError(msg, this._currentTokenType, span);\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        return new _ControlFlowError(error);\n    };\n    _Tokenizer.prototype.handleError = function (e) {\n        if (e instanceof CursorError) {\n            e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n        }\n        if (e instanceof _ControlFlowError) {\n            this.errors.push(e.error);\n        }\n        else {\n            throw e;\n        }\n    };\n    _Tokenizer.prototype._attemptCharCode = function (charCode) {\n        if (this._cursor.peek() === charCode) {\n            this._cursor.advance();\n            return true;\n        }\n        return false;\n    };\n    _Tokenizer.prototype._attemptCharCodeCaseInsensitive = function (charCode) {\n        if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n            this._cursor.advance();\n            return true;\n        }\n        return false;\n    };\n    _Tokenizer.prototype._requireCharCode = function (charCode) {\n        var location = this._cursor.clone();\n        if (!this._attemptCharCode(charCode)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n        }\n    };\n    _Tokenizer.prototype._attemptStr = function (chars) {\n        var len = chars.length;\n        if (this._cursor.charsLeft() < len) {\n            return false;\n        }\n        var initialPosition = this._cursor.clone();\n        for (var i = 0; i < len; i++) {\n            if (!this._attemptCharCode(chars.charCodeAt(i))) {\n                // If attempting to parse the string fails, we want to reset the parser\n                // to where it was before the attempt\n                this._cursor = initialPosition;\n                return false;\n            }\n        }\n        return true;\n    };\n    _Tokenizer.prototype._attemptStrCaseInsensitive = function (chars) {\n        for (var i = 0; i < chars.length; i++) {\n            if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    };\n    _Tokenizer.prototype._requireStr = function (chars) {\n        var location = this._cursor.clone();\n        if (!this._attemptStr(chars)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n        }\n    };\n    _Tokenizer.prototype._attemptCharCodeUntilFn = function (predicate) {\n        while (!predicate(this._cursor.peek())) {\n            this._cursor.advance();\n        }\n    };\n    _Tokenizer.prototype._requireCharCodeUntilFn = function (predicate, len) {\n        var start = this._cursor.clone();\n        this._attemptCharCodeUntilFn(predicate);\n        var end = this._cursor.clone();\n        if (end.diff(start) < len) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n        }\n    };\n    _Tokenizer.prototype._attemptUntilChar = function (char) {\n        while (this._cursor.peek() !== char) {\n            this._cursor.advance();\n        }\n    };\n    _Tokenizer.prototype._readChar = function (decodeEntities) {\n        if (decodeEntities && this._cursor.peek() === $AMPERSAND) {\n            return this._decodeEntity();\n        }\n        else {\n            // Don't rely upon reading directly from `_input` as the actual char value\n            // may have been generated from an escape sequence.\n            var char = String.fromCodePoint(this._cursor.peek());\n            this._cursor.advance();\n            return char;\n        }\n    };\n    _Tokenizer.prototype._decodeEntity = function () {\n        var start = this._cursor.clone();\n        this._cursor.advance();\n        if (this._attemptCharCode($HASH)) {\n            var isHex = this._attemptCharCode($x) || this._attemptCharCode($X);\n            var codeStart = this._cursor.clone();\n            this._attemptCharCodeUntilFn(isDigitEntityEnd);\n            if (this._cursor.peek() != $SEMICOLON) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan());\n            }\n            var strNum = this._cursor.getChars(codeStart);\n            this._cursor.advance();\n            try {\n                var charCode = parseInt(strNum, isHex ? 16 : 10);\n                return String.fromCharCode(charCode);\n            }\n            catch (_a) {\n                throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\n            }\n        }\n        else {\n            var nameStart = this._cursor.clone();\n            this._attemptCharCodeUntilFn(isNamedEntityEnd);\n            if (this._cursor.peek() != $SEMICOLON) {\n                this._cursor = nameStart;\n                return '&';\n            }\n            var name_1 = this._cursor.getChars(nameStart);\n            this._cursor.advance();\n            var char = NAMED_ENTITIES[name_1];\n            if (!char) {\n                throw this._createError(_unknownEntityErrorMsg(name_1), this._cursor.getSpan(start));\n            }\n            return char;\n        }\n    };\n    _Tokenizer.prototype._consumeRawText = function (decodeEntities, endMarkerPredicate) {\n        this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT);\n        var parts = [];\n        while (true) {\n            var tagCloseStart = this._cursor.clone();\n            var foundEndMarker = endMarkerPredicate();\n            this._cursor = tagCloseStart;\n            if (foundEndMarker) {\n                break;\n            }\n            parts.push(this._readChar(decodeEntities));\n        }\n        return this._endToken([this._processCarriageReturns(parts.join(''))]);\n    };\n    _Tokenizer.prototype._consumeComment = function (start) {\n        var _this = this;\n        this._beginToken(TokenType.COMMENT_START, start);\n        this._requireCharCode($MINUS);\n        this._endToken([]);\n        this._consumeRawText(false, function () { return _this._attemptStr('-->'); });\n        this._beginToken(TokenType.COMMENT_END);\n        this._requireStr('-->');\n        this._endToken([]);\n    };\n    _Tokenizer.prototype._consumeCdata = function (start) {\n        var _this = this;\n        this._beginToken(TokenType.CDATA_START, start);\n        this._requireStr('CDATA[');\n        this._endToken([]);\n        this._consumeRawText(false, function () { return _this._attemptStr(']]>'); });\n        this._beginToken(TokenType.CDATA_END);\n        this._requireStr(']]>');\n        this._endToken([]);\n    };\n    _Tokenizer.prototype._consumeDocType = function (start) {\n        this._beginToken(TokenType.DOC_TYPE, start);\n        var contentStart = this._cursor.clone();\n        this._attemptUntilChar($GT);\n        var content = this._cursor.getChars(contentStart);\n        this._cursor.advance();\n        this._endToken([content]);\n    };\n    _Tokenizer.prototype._consumePrefixAndName = function () {\n        var nameOrPrefixStart = this._cursor.clone();\n        var prefix = '';\n        while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {\n            this._cursor.advance();\n        }\n        var nameStart;\n        if (this._cursor.peek() === $COLON) {\n            prefix = this._cursor.getChars(nameOrPrefixStart);\n            this._cursor.advance();\n            nameStart = this._cursor.clone();\n        }\n        else {\n            nameStart = nameOrPrefixStart;\n        }\n        this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);\n        var name = this._cursor.getChars(nameStart);\n        return [prefix, name];\n    };\n    _Tokenizer.prototype._consumeTagOpen = function (start) {\n        var tagName;\n        var prefix;\n        var openTagToken;\n        var tokensBeforeTagOpen = this.tokens.length;\n        var innerStart = this._cursor.clone();\n        try {\n            if (!isAsciiLetter(this._cursor.peek())) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n            }\n            openTagToken = this._consumeTagOpenStart(start);\n            prefix = openTagToken.parts[0];\n            tagName = openTagToken.parts[1];\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            while (this._cursor.peek() !== $SLASH && this._cursor.peek() !== $GT) {\n                this._consumeAttributeName();\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n                if (this._attemptCharCode($EQ)) {\n                    this._attemptCharCodeUntilFn(isNotWhitespace);\n                    this._consumeAttributeValue();\n                }\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n            }\n            this._consumeTagOpenEnd();\n        }\n        catch (e) {\n            if (e instanceof _ControlFlowError) {\n                // When the start tag is invalid (including invalid \"attributes\"), assume we want a \"<\"\n                this._cursor = innerStart;\n                if (openTagToken) {\n                    this.tokens.length = tokensBeforeTagOpen;\n                }\n                // Back to back text tokens are merged at the end\n                this._beginToken(TokenType.TEXT, start);\n                this._endToken(['<']);\n                return;\n            }\n            throw e;\n        }\n        var contentTokenType = this._getTagDefinition(tagName).contentType;\n        if (contentTokenType === TagContentType.RAW_TEXT) {\n            this._consumeRawTextWithTagClose(prefix, tagName, false);\n        }\n        else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n            this._consumeRawTextWithTagClose(prefix, tagName, true);\n        }\n    };\n    _Tokenizer.prototype._consumeRawTextWithTagClose = function (prefix, tagName, decodeEntities) {\n        var _this = this;\n        var textToken = this._consumeRawText(decodeEntities, function () {\n            if (!_this._attemptCharCode($LT))\n                return false;\n            if (!_this._attemptCharCode($SLASH))\n                return false;\n            _this._attemptCharCodeUntilFn(isNotWhitespace);\n            if (!_this._attemptStrCaseInsensitive(tagName))\n                return false;\n            _this._attemptCharCodeUntilFn(isNotWhitespace);\n            return _this._attemptCharCode($GT);\n        });\n        this._beginToken(TokenType.TAG_CLOSE);\n        this._requireCharCodeUntilFn(function (code) { return code === $GT; }, 3);\n        this._cursor.advance(); // Consume the `>`\n        this._endToken([prefix, tagName]);\n    };\n    _Tokenizer.prototype._consumeTagOpenStart = function (start) {\n        this._beginToken(TokenType.TAG_OPEN_START, start);\n        var parts = this._consumePrefixAndName();\n        return this._endToken(parts);\n    };\n    _Tokenizer.prototype._consumeAttributeName = function () {\n        var attrNameStart = this._cursor.peek();\n        if (attrNameStart === $SQ || attrNameStart === $DQ) {\n            throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n        }\n        this._beginToken(TokenType.ATTR_NAME);\n        var prefixAndName = this._consumePrefixAndName();\n        this._endToken(prefixAndName);\n    };\n    _Tokenizer.prototype._consumeAttributeValue = function () {\n        var value;\n        if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {\n            this._beginToken(TokenType.ATTR_QUOTE);\n            var quoteChar = this._cursor.peek();\n            this._cursor.advance();\n            this._endToken([String.fromCodePoint(quoteChar)]);\n            this._beginToken(TokenType.ATTR_VALUE);\n            var parts = [];\n            while (this._cursor.peek() !== quoteChar) {\n                parts.push(this._readChar(true));\n            }\n            value = parts.join('');\n            this._endToken([this._processCarriageReturns(value)]);\n            this._beginToken(TokenType.ATTR_QUOTE);\n            this._cursor.advance();\n            this._endToken([String.fromCodePoint(quoteChar)]);\n        }\n        else {\n            this._beginToken(TokenType.ATTR_VALUE);\n            var valueStart = this._cursor.clone();\n            this._requireCharCodeUntilFn(isNameEnd, 1);\n            value = this._cursor.getChars(valueStart);\n            this._endToken([this._processCarriageReturns(value)]);\n        }\n    };\n    _Tokenizer.prototype._consumeTagOpenEnd = function () {\n        var tokenType = this._attemptCharCode($SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;\n        this._beginToken(tokenType);\n        this._requireCharCode($GT);\n        this._endToken([]);\n    };\n    _Tokenizer.prototype._consumeTagClose = function (start) {\n        this._beginToken(TokenType.TAG_CLOSE, start);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        var prefixAndName = this._consumePrefixAndName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._requireCharCode($GT);\n        this._endToken(prefixAndName);\n    };\n    _Tokenizer.prototype._consumeExpansionFormStart = function () {\n        this._beginToken(TokenType.EXPANSION_FORM_START);\n        this._requireCharCode($LBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n        this._beginToken(TokenType.RAW_TEXT);\n        var condition = this._readUntil($COMMA);\n        this._endToken([condition]);\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(TokenType.RAW_TEXT);\n        var type = this._readUntil($COMMA);\n        this._endToken([type]);\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n    };\n    _Tokenizer.prototype._consumeExpansionCaseStart = function () {\n        this._beginToken(TokenType.EXPANSION_CASE_VALUE);\n        var value = this._readUntil($LBRACE).trim();\n        this._endToken([value]);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(TokenType.EXPANSION_CASE_EXP_START);\n        this._requireCharCode($LBRACE);\n        this._endToken([]);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n    };\n    _Tokenizer.prototype._consumeExpansionCaseEnd = function () {\n        this._beginToken(TokenType.EXPANSION_CASE_EXP_END);\n        this._requireCharCode($RBRACE);\n        this._endToken([]);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.pop();\n    };\n    _Tokenizer.prototype._consumeExpansionFormEnd = function () {\n        this._beginToken(TokenType.EXPANSION_FORM_END);\n        this._requireCharCode($RBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.pop();\n    };\n    _Tokenizer.prototype._consumeText = function () {\n        var start = this._cursor.clone();\n        this._beginToken(TokenType.TEXT, start);\n        var parts = [];\n        do {\n            if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n                parts.push(this._interpolationConfig.start);\n                this._inInterpolation = true;\n            }\n            else if (this._interpolationConfig && this._inInterpolation &&\n                this._attemptStr(this._interpolationConfig.end)) {\n                parts.push(this._interpolationConfig.end);\n                this._inInterpolation = false;\n            }\n            else {\n                parts.push(this._readChar(true));\n            }\n        } while (!this._isTextEnd());\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n    };\n    _Tokenizer.prototype._isTextEnd = function () {\n        if (this._cursor.peek() === $LT || this._cursor.peek() === $EOF) {\n            return true;\n        }\n        if (this._tokenizeIcu && !this._inInterpolation) {\n            if (this.isExpansionFormStart()) {\n                // start of an expansion form\n                return true;\n            }\n            if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {\n                // end of and expansion case\n                return true;\n            }\n        }\n        return false;\n    };\n    _Tokenizer.prototype._readUntil = function (char) {\n        var start = this._cursor.clone();\n        this._attemptUntilChar(char);\n        return this._cursor.getChars(start);\n    };\n    _Tokenizer.prototype._isInExpansionCase = function () {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                TokenType.EXPANSION_CASE_EXP_START;\n    };\n    _Tokenizer.prototype._isInExpansionForm = function () {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                TokenType.EXPANSION_FORM_START;\n    };\n    _Tokenizer.prototype.isExpansionFormStart = function () {\n        if (this._cursor.peek() !== $LBRACE) {\n            return false;\n        }\n        if (this._interpolationConfig) {\n            var start = this._cursor.clone();\n            var isInterpolation = this._attemptStr(this._interpolationConfig.start);\n            this._cursor = start;\n            return !isInterpolation;\n        }\n        return true;\n    };\n    return _Tokenizer;\n}());\nfunction isNotWhitespace(code) {\n    return !isWhitespace(code) || code === $EOF;\n}\nfunction isNameEnd(code) {\n    return isWhitespace(code) || code === $GT || code === $SLASH ||\n        code === $SQ || code === $DQ || code === $EQ;\n}\nfunction isPrefixEnd(code) {\n    return (code < $a || $z < code) && (code < $A || $Z < code) &&\n        (code < $0 || code > $9);\n}\nfunction isDigitEntityEnd(code) {\n    return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);\n}\nfunction isNamedEntityEnd(code) {\n    return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);\n}\nfunction isExpansionCaseStart(peek) {\n    return peek === $EQ || isAsciiLetter(peek) || isDigit(peek);\n}\nfunction compareCharCodeCaseInsensitive(code1, code2) {\n    return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);\n}\nfunction toUpperCaseCharCode(code) {\n    return code >= $a && code <= $z ? code - $a + $A : code;\n}\nfunction mergeTextTokens(srcTokens) {\n    var dstTokens = [];\n    var lastDstToken = undefined;\n    for (var i = 0; i < srcTokens.length; i++) {\n        var token = srcTokens[i];\n        if (lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {\n            lastDstToken.parts[0] += token.parts[0];\n            lastDstToken.sourceSpan.end = token.sourceSpan.end;\n        }\n        else {\n            lastDstToken = token;\n            dstTokens.push(lastDstToken);\n        }\n    }\n    return dstTokens;\n}\nvar PlainCharacterCursor = /** @class */ (function () {\n    function PlainCharacterCursor(fileOrCursor, range) {\n        if (fileOrCursor instanceof PlainCharacterCursor) {\n            this.file = fileOrCursor.file;\n            this.input = fileOrCursor.input;\n            this.end = fileOrCursor.end;\n            this.state = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, fileOrCursor.state);\n        }\n        else {\n            if (!range) {\n                throw new Error('Programming error: the range argument must be provided with a file argument.');\n            }\n            this.file = fileOrCursor;\n            this.input = fileOrCursor.content;\n            this.end = range.endPos;\n            this.state = {\n                peek: -1,\n                offset: range.startPos,\n                line: range.startLine,\n                column: range.startCol,\n            };\n        }\n    }\n    PlainCharacterCursor.prototype.clone = function () { return new PlainCharacterCursor(this); };\n    PlainCharacterCursor.prototype.peek = function () { return this.state.peek; };\n    PlainCharacterCursor.prototype.charsLeft = function () { return this.end - this.state.offset; };\n    PlainCharacterCursor.prototype.diff = function (other) { return this.state.offset - other.state.offset; };\n    PlainCharacterCursor.prototype.advance = function () { this.advanceState(this.state); };\n    PlainCharacterCursor.prototype.init = function () { this.updatePeek(this.state); };\n    PlainCharacterCursor.prototype.getSpan = function (start, leadingTriviaCodePoints) {\n        start = start || this;\n        if (leadingTriviaCodePoints) {\n            start = start.clone();\n            while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n                start.advance();\n            }\n        }\n        return new ParseSourceSpan(new ParseLocation(start.file, start.state.offset, start.state.line, start.state.column), new ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));\n    };\n    PlainCharacterCursor.prototype.getChars = function (start) {\n        return this.input.substring(start.state.offset, this.state.offset);\n    };\n    PlainCharacterCursor.prototype.charAt = function (pos) { return this.input.charCodeAt(pos); };\n    PlainCharacterCursor.prototype.advanceState = function (state) {\n        if (state.offset >= this.end) {\n            this.state = state;\n            throw new CursorError('Unexpected character \"EOF\"', this);\n        }\n        var currentChar = this.charAt(state.offset);\n        if (currentChar === $LF) {\n            state.line++;\n            state.column = 0;\n        }\n        else if (!isNewLine(currentChar)) {\n            state.column++;\n        }\n        state.offset++;\n        this.updatePeek(state);\n    };\n    PlainCharacterCursor.prototype.updatePeek = function (state) {\n        state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);\n    };\n    return PlainCharacterCursor;\n}());\nvar EscapedCharacterCursor = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(EscapedCharacterCursor, _super);\n    function EscapedCharacterCursor(fileOrCursor, range) {\n        var _this = this;\n        if (fileOrCursor instanceof EscapedCharacterCursor) {\n            _this = _super.call(this, fileOrCursor) || this;\n            _this.internalState = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, fileOrCursor.internalState);\n        }\n        else {\n            _this = _super.call(this, fileOrCursor, range) || this;\n            _this.internalState = _this.state;\n        }\n        return _this;\n    }\n    EscapedCharacterCursor.prototype.advance = function () {\n        this.state = this.internalState;\n        _super.prototype.advance.call(this);\n        this.processEscapeSequence();\n    };\n    EscapedCharacterCursor.prototype.init = function () {\n        _super.prototype.init.call(this);\n        this.processEscapeSequence();\n    };\n    EscapedCharacterCursor.prototype.clone = function () { return new EscapedCharacterCursor(this); };\n    EscapedCharacterCursor.prototype.getChars = function (start) {\n        var cursor = start.clone();\n        var chars = '';\n        while (cursor.internalState.offset < this.internalState.offset) {\n            chars += String.fromCodePoint(cursor.peek());\n            cursor.advance();\n        }\n        return chars;\n    };\n    /**\n     * Process the escape sequence that starts at the current position in the text.\n     *\n     * This method is called to ensure that `peek` has the unescaped value of escape sequences.\n     */\n    EscapedCharacterCursor.prototype.processEscapeSequence = function () {\n        var _this = this;\n        var peek = function () { return _this.internalState.peek; };\n        if (peek() === $BACKSLASH) {\n            // We have hit an escape sequence so we need the internal state to become independent\n            // of the external state.\n            this.internalState = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, this.state);\n            // Move past the backslash\n            this.advanceState(this.internalState);\n            // First check for standard control char sequences\n            if (peek() === $n) {\n                this.state.peek = $LF;\n            }\n            else if (peek() === $r) {\n                this.state.peek = $CR;\n            }\n            else if (peek() === $v) {\n                this.state.peek = $VTAB;\n            }\n            else if (peek() === $t) {\n                this.state.peek = $TAB;\n            }\n            else if (peek() === $b) {\n                this.state.peek = $BSPACE;\n            }\n            else if (peek() === $f) {\n                this.state.peek = $FF;\n            }\n            // Now consider more complex sequences\n            else if (peek() === $u) {\n                // Unicode code-point sequence\n                this.advanceState(this.internalState); // advance past the `u` char\n                if (peek() === $LBRACE) {\n                    // Variable length Unicode, e.g. `\\x{123}`\n                    this.advanceState(this.internalState); // advance past the `{` char\n                    // Advance past the variable number of hex digits until we hit a `}` char\n                    var digitStart = this.clone();\n                    var length_1 = 0;\n                    while (peek() !== $RBRACE) {\n                        this.advanceState(this.internalState);\n                        length_1++;\n                    }\n                    this.state.peek = this.decodeHexDigits(digitStart, length_1);\n                }\n                else {\n                    // Fixed length Unicode, e.g. `\\u1234`\n                    var digitStart = this.clone();\n                    this.advanceState(this.internalState);\n                    this.advanceState(this.internalState);\n                    this.advanceState(this.internalState);\n                    this.state.peek = this.decodeHexDigits(digitStart, 4);\n                }\n            }\n            else if (peek() === $x) {\n                // Hex char code, e.g. `\\x2F`\n                this.advanceState(this.internalState); // advance past the `x` char\n                var digitStart = this.clone();\n                this.advanceState(this.internalState);\n                this.state.peek = this.decodeHexDigits(digitStart, 2);\n            }\n            else if (isOctalDigit(peek())) {\n                // Octal char code, e.g. `\\012`,\n                var octal = '';\n                var length_2 = 0;\n                var previous = this.clone();\n                while (isOctalDigit(peek()) && length_2 < 3) {\n                    previous = this.clone();\n                    octal += String.fromCodePoint(peek());\n                    this.advanceState(this.internalState);\n                    length_2++;\n                }\n                this.state.peek = parseInt(octal, 8);\n                // Backup one char\n                this.internalState = previous.internalState;\n            }\n            else if (isNewLine(this.internalState.peek)) {\n                // Line continuation `\\` followed by a new line\n                this.advanceState(this.internalState); // advance over the newline\n                this.state = this.internalState;\n            }\n            else {\n                // If none of the `if` blocks were executed then we just have an escaped normal character.\n                // In that case we just, effectively, skip the backslash from the character.\n                this.state.peek = this.internalState.peek;\n            }\n        }\n    };\n    EscapedCharacterCursor.prototype.decodeHexDigits = function (start, length) {\n        var hex = this.input.substr(start.internalState.offset, length);\n        var charCode = parseInt(hex, 16);\n        if (!isNaN(charCode)) {\n            return charCode;\n        }\n        else {\n            start.state = start.internalState;\n            throw new CursorError('Invalid hexadecimal escape sequence', start);\n        }\n    };\n    return EscapedCharacterCursor;\n}(PlainCharacterCursor));\nvar CursorError = /** @class */ (function () {\n    function CursorError(msg, cursor) {\n        this.msg = msg;\n        this.cursor = cursor;\n    }\n    return CursorError;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TreeError = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(TreeError, _super);\n    function TreeError(elementName, span, msg) {\n        var _this = _super.call(this, span, msg) || this;\n        _this.elementName = elementName;\n        return _this;\n    }\n    TreeError.create = function (elementName, span, msg) {\n        return new TreeError(elementName, span, msg);\n    };\n    return TreeError;\n}(ParseError));\nvar ParseTreeResult = /** @class */ (function () {\n    function ParseTreeResult(rootNodes, errors) {\n        this.rootNodes = rootNodes;\n        this.errors = errors;\n    }\n    return ParseTreeResult;\n}());\nvar Parser = /** @class */ (function () {\n    function Parser(getTagDefinition) {\n        this.getTagDefinition = getTagDefinition;\n    }\n    Parser.prototype.parse = function (source, url, options) {\n        var tokensAndErrors = tokenize(source, url, this.getTagDefinition, options);\n        var treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();\n        return new ParseTreeResult(treeAndErrors.rootNodes, tokensAndErrors.errors.concat(treeAndErrors.errors));\n    };\n    return Parser;\n}());\nvar _TreeBuilder = /** @class */ (function () {\n    function _TreeBuilder(tokens, getTagDefinition) {\n        this.tokens = tokens;\n        this.getTagDefinition = getTagDefinition;\n        this._index = -1;\n        this._rootNodes = [];\n        this._errors = [];\n        this._elementStack = [];\n        this._advance();\n    }\n    _TreeBuilder.prototype.build = function () {\n        while (this._peek.type !== TokenType.EOF) {\n            if (this._peek.type === TokenType.TAG_OPEN_START) {\n                this._consumeStartTag(this._advance());\n            }\n            else if (this._peek.type === TokenType.TAG_CLOSE) {\n                this._consumeEndTag(this._advance());\n            }\n            else if (this._peek.type === TokenType.CDATA_START) {\n                this._closeVoidElement();\n                this._consumeCdata(this._advance());\n            }\n            else if (this._peek.type === TokenType.COMMENT_START) {\n                this._closeVoidElement();\n                this._consumeComment(this._advance());\n            }\n            else if (this._peek.type === TokenType.TEXT || this._peek.type === TokenType.RAW_TEXT ||\n                this._peek.type === TokenType.ESCAPABLE_RAW_TEXT) {\n                this._closeVoidElement();\n                this._consumeText(this._advance());\n            }\n            else if (this._peek.type === TokenType.EXPANSION_FORM_START) {\n                this._consumeExpansion(this._advance());\n            }\n            else {\n                // Skip all other tokens...\n                this._advance();\n            }\n        }\n        return new ParseTreeResult(this._rootNodes, this._errors);\n    };\n    _TreeBuilder.prototype._advance = function () {\n        var prev = this._peek;\n        if (this._index < this.tokens.length - 1) {\n            // Note: there is always an EOF token at the end\n            this._index++;\n        }\n        this._peek = this.tokens[this._index];\n        return prev;\n    };\n    _TreeBuilder.prototype._advanceIf = function (type) {\n        if (this._peek.type === type) {\n            return this._advance();\n        }\n        return null;\n    };\n    _TreeBuilder.prototype._consumeCdata = function (startToken) {\n        this._consumeText(this._advance());\n        this._advanceIf(TokenType.CDATA_END);\n    };\n    _TreeBuilder.prototype._consumeComment = function (token) {\n        var text = this._advanceIf(TokenType.RAW_TEXT);\n        this._advanceIf(TokenType.COMMENT_END);\n        var value = text != null ? text.parts[0].trim() : null;\n        this._addToParent(new Comment(value, token.sourceSpan));\n    };\n    _TreeBuilder.prototype._consumeExpansion = function (token) {\n        var switchValue = this._advance();\n        var type = this._advance();\n        var cases = [];\n        // read =\n        while (this._peek.type === TokenType.EXPANSION_CASE_VALUE) {\n            var expCase = this._parseExpansionCase();\n            if (!expCase)\n                return; // error\n            cases.push(expCase);\n        }\n        // read the final }\n        if (this._peek.type !== TokenType.EXPANSION_FORM_END) {\n            this._errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n            return;\n        }\n        var sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);\n        this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n        this._advance();\n    };\n    _TreeBuilder.prototype._parseExpansionCase = function () {\n        var value = this._advance();\n        // read {\n        if (this._peek.type !== TokenType.EXPANSION_CASE_EXP_START) {\n            this._errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '{'.\"));\n            return null;\n        }\n        // read until }\n        var start = this._advance();\n        var exp = this._collectExpansionExpTokens(start);\n        if (!exp)\n            return null;\n        var end = this._advance();\n        exp.push(new Token(TokenType.EOF, [], end.sourceSpan));\n        // parse everything in between { and }\n        var parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();\n        if (parsedExp.errors.length > 0) {\n            this._errors = this._errors.concat(parsedExp.errors);\n            return null;\n        }\n        var sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);\n        var expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);\n        return new ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n    };\n    _TreeBuilder.prototype._collectExpansionExpTokens = function (start) {\n        var exp = [];\n        var expansionFormStack = [TokenType.EXPANSION_CASE_EXP_START];\n        while (true) {\n            if (this._peek.type === TokenType.EXPANSION_FORM_START ||\n                this._peek.type === TokenType.EXPANSION_CASE_EXP_START) {\n                expansionFormStack.push(this._peek.type);\n            }\n            if (this._peek.type === TokenType.EXPANSION_CASE_EXP_END) {\n                if (lastOnStack(expansionFormStack, TokenType.EXPANSION_CASE_EXP_START)) {\n                    expansionFormStack.pop();\n                    if (expansionFormStack.length == 0)\n                        return exp;\n                }\n                else {\n                    this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                    return null;\n                }\n            }\n            if (this._peek.type === TokenType.EXPANSION_FORM_END) {\n                if (lastOnStack(expansionFormStack, TokenType.EXPANSION_FORM_START)) {\n                    expansionFormStack.pop();\n                }\n                else {\n                    this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                    return null;\n                }\n            }\n            if (this._peek.type === TokenType.EOF) {\n                this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                return null;\n            }\n            exp.push(this._advance());\n        }\n    };\n    _TreeBuilder.prototype._consumeText = function (token) {\n        var text = token.parts[0];\n        if (text.length > 0 && text[0] == '\\n') {\n            var parent_1 = this._getParentElement();\n            if (parent_1 != null && parent_1.children.length == 0 &&\n                this.getTagDefinition(parent_1.name).ignoreFirstLf) {\n                text = text.substring(1);\n            }\n        }\n        if (text.length > 0) {\n            this._addToParent(new Text$3(text, token.sourceSpan));\n        }\n    };\n    _TreeBuilder.prototype._closeVoidElement = function () {\n        var el = this._getParentElement();\n        if (el && this.getTagDefinition(el.name).isVoid) {\n            this._elementStack.pop();\n        }\n    };\n    _TreeBuilder.prototype._consumeStartTag = function (startTagToken) {\n        var prefix = startTagToken.parts[0];\n        var name = startTagToken.parts[1];\n        var attrs = [];\n        while (this._peek.type === TokenType.ATTR_NAME) {\n            attrs.push(this._consumeAttr(this._advance()));\n        }\n        var fullName = this._getElementFullName(prefix, name, this._getParentElement());\n        var selfClosing = false;\n        // Note: There could have been a tokenizer error\n        // so that we don't get a token for the end tag...\n        if (this._peek.type === TokenType.TAG_OPEN_END_VOID) {\n            this._advance();\n            selfClosing = true;\n            var tagDef = this.getTagDefinition(fullName);\n            if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n                this._errors.push(TreeError.create(fullName, startTagToken.sourceSpan, \"Only void and foreign elements can be self closed \\\"\" + startTagToken.parts[1] + \"\\\"\"));\n            }\n        }\n        else if (this._peek.type === TokenType.TAG_OPEN_END) {\n            this._advance();\n            selfClosing = false;\n        }\n        var end = this._peek.sourceSpan.start;\n        var span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);\n        var el = new Element$1(fullName, attrs, [], span, span, undefined);\n        this._pushElement(el);\n        if (selfClosing) {\n            this._popElement(fullName);\n            el.endSourceSpan = span;\n        }\n    };\n    _TreeBuilder.prototype._pushElement = function (el) {\n        var parentEl = this._getParentElement();\n        if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n            this._elementStack.pop();\n        }\n        this._addToParent(el);\n        this._elementStack.push(el);\n    };\n    _TreeBuilder.prototype._consumeEndTag = function (endTagToken) {\n        var fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n        if (this._getParentElement()) {\n            this._getParentElement().endSourceSpan = endTagToken.sourceSpan;\n        }\n        if (this.getTagDefinition(fullName).isVoid) {\n            this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, \"Void elements do not have end tags \\\"\" + endTagToken.parts[1] + \"\\\"\"));\n        }\n        else if (!this._popElement(fullName)) {\n            var errMsg = \"Unexpected closing tag \\\"\" + fullName + \"\\\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags\";\n            this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n        }\n    };\n    _TreeBuilder.prototype._popElement = function (fullName) {\n        for (var stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n            var el = this._elementStack[stackIndex];\n            if (el.name == fullName) {\n                this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n                return true;\n            }\n            if (!this.getTagDefinition(el.name).closedByParent) {\n                return false;\n            }\n        }\n        return false;\n    };\n    _TreeBuilder.prototype._consumeAttr = function (attrName) {\n        var fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n        var end = attrName.sourceSpan.end;\n        var value = '';\n        var valueSpan = undefined;\n        if (this._peek.type === TokenType.ATTR_QUOTE) {\n            this._advance();\n        }\n        if (this._peek.type === TokenType.ATTR_VALUE) {\n            var valueToken = this._advance();\n            value = valueToken.parts[0];\n            end = valueToken.sourceSpan.end;\n            valueSpan = valueToken.sourceSpan;\n        }\n        if (this._peek.type === TokenType.ATTR_QUOTE) {\n            var quoteToken = this._advance();\n            end = quoteToken.sourceSpan.end;\n        }\n        return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);\n    };\n    _TreeBuilder.prototype._getParentElement = function () {\n        return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n    };\n    /**\n     * Returns the parent in the DOM and the container.\n     *\n     * `<ng-container>` elements are skipped as they are not rendered as DOM element.\n     */\n    _TreeBuilder.prototype._getParentElementSkippingContainers = function () {\n        var container = null;\n        for (var i = this._elementStack.length - 1; i >= 0; i--) {\n            if (!isNgContainer(this._elementStack[i].name)) {\n                return { parent: this._elementStack[i], container: container };\n            }\n            container = this._elementStack[i];\n        }\n        return { parent: null, container: container };\n    };\n    _TreeBuilder.prototype._addToParent = function (node) {\n        var parent = this._getParentElement();\n        if (parent != null) {\n            parent.children.push(node);\n        }\n        else {\n            this._rootNodes.push(node);\n        }\n    };\n    /**\n     * Insert a node between the parent and the container.\n     * When no container is given, the node is appended as a child of the parent.\n     * Also updates the element stack accordingly.\n     *\n     * @internal\n     */\n    _TreeBuilder.prototype._insertBeforeContainer = function (parent, container, node) {\n        if (!container) {\n            this._addToParent(node);\n            this._elementStack.push(node);\n        }\n        else {\n            if (parent) {\n                // replace the container with the new node in the children\n                var index = parent.children.indexOf(container);\n                parent.children[index] = node;\n            }\n            else {\n                this._rootNodes.push(node);\n            }\n            node.children.push(container);\n            this._elementStack.splice(this._elementStack.indexOf(container), 0, node);\n        }\n    };\n    _TreeBuilder.prototype._getElementFullName = function (prefix, localName, parentElement) {\n        if (prefix === '') {\n            prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';\n            if (prefix === '' && parentElement != null) {\n                prefix = getNsPrefix(parentElement.name);\n            }\n        }\n        return mergeNsAndName(prefix, localName);\n    };\n    return _TreeBuilder;\n}());\nfunction lastOnStack(stack, element) {\n    return stack.length > 0 && stack[stack.length - 1] === element;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar HtmlParser = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(HtmlParser, _super);\n    function HtmlParser() {\n        return _super.call(this, getHtmlTagDefinition) || this;\n    }\n    HtmlParser.prototype.parse = function (source, url, options) {\n        return _super.prototype.parse.call(this, source, url, options);\n    };\n    return HtmlParser;\n}(Parser));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';\nvar SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);\n// Equivalent to \\s with \\u00a0 (non-breaking space) excluded.\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\nvar WS_CHARS = ' \\f\\n\\r\\t\\v\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff';\nvar NO_WS_REGEXP = new RegExp(\"[^\" + WS_CHARS + \"]\");\nvar WS_REPLACE_REGEXP = new RegExp(\"[\" + WS_CHARS + \"]{2,}\", 'g');\nfunction hasPreserveWhitespacesAttr(attrs) {\n    return attrs.some(function (attr) { return attr.name === PRESERVE_WS_ATTR_NAME; });\n}\n/**\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space. We are re-implementing the same idea here.\n */\nfunction replaceNgsp(value) {\n    // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE\n    return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');\n}\n/**\n * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:\n * - consider spaces, tabs and new lines as whitespace characters;\n * - drop text nodes consisting of whitespace characters only;\n * - for all other text nodes replace consecutive whitespace characters with one space;\n * - convert &ngsp; pseudo-entity to a single space;\n *\n * Removal and trimming of whitespaces have positive performance impact (less code to generate\n * while compiling templates, faster view creation). At the same time it can be \"destructive\"\n * in some cases (whitespaces can influence layout). Because of the potential of breaking layout\n * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for\n * whitespace removal. The default option for whitespace removal will be revisited in Angular 6\n * and might be changed to \"on\" by default.\n */\nvar WhitespaceVisitor = /** @class */ (function () {\n    function WhitespaceVisitor() {\n    }\n    WhitespaceVisitor.prototype.visitElement = function (element, context) {\n        if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {\n            // don't descent into elements where we need to preserve whitespaces\n            // but still visit all attributes to eliminate one used as a market to preserve WS\n            return new Element$1(element.name, visitAll$1(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n        }\n        return new Element$1(element.name, element.attrs, visitAll$1(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n    };\n    WhitespaceVisitor.prototype.visitAttribute = function (attribute, context) {\n        return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;\n    };\n    WhitespaceVisitor.prototype.visitText = function (text, context) {\n        var isNotBlank = text.value.match(NO_WS_REGEXP);\n        if (isNotBlank) {\n            return new Text$3(replaceNgsp(text.value).replace(WS_REPLACE_REGEXP, ' '), text.sourceSpan, text.i18n);\n        }\n        return null;\n    };\n    WhitespaceVisitor.prototype.visitComment = function (comment, context) { return comment; };\n    WhitespaceVisitor.prototype.visitExpansion = function (expansion, context) { return expansion; };\n    WhitespaceVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return expansionCase; };\n    return WhitespaceVisitor;\n}());\nfunction removeWhitespaces(htmlAstWithErrors) {\n    return new ParseTreeResult(visitAll$1(new WhitespaceVisitor(), htmlAstWithErrors.rootNodes), htmlAstWithErrors.errors);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// http://cldr.unicode.org/index/cldr-spec/plural-rules\nvar PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];\n/**\n * Expands special forms into elements.\n *\n * For example,\n *\n * ```\n * { messages.length, plural,\n *   =0 {zero}\n *   =1 {one}\n *   other {more than one}\n * }\n * ```\n *\n * will be expanded into\n *\n * ```\n * <ng-container [ngPlural]=\"messages.length\">\n *   <ng-template ngPluralCase=\"=0\">zero</ng-template>\n *   <ng-template ngPluralCase=\"=1\">one</ng-template>\n *   <ng-template ngPluralCase=\"other\">more than one</ng-template>\n * </ng-container>\n * ```\n */\nfunction expandNodes(nodes) {\n    var expander = new _Expander();\n    return new ExpansionResult(visitAll$1(expander, nodes), expander.isExpanded, expander.errors);\n}\nvar ExpansionResult = /** @class */ (function () {\n    function ExpansionResult(nodes, expanded, errors) {\n        this.nodes = nodes;\n        this.expanded = expanded;\n        this.errors = errors;\n    }\n    return ExpansionResult;\n}());\nvar ExpansionError = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ExpansionError, _super);\n    function ExpansionError(span, errorMsg) {\n        return _super.call(this, span, errorMsg) || this;\n    }\n    return ExpansionError;\n}(ParseError));\n/**\n * Expand expansion forms (plural, select) to directives\n *\n * @internal\n */\nvar _Expander = /** @class */ (function () {\n    function _Expander() {\n        this.isExpanded = false;\n        this.errors = [];\n    }\n    _Expander.prototype.visitElement = function (element, context) {\n        return new Element$1(element.name, element.attrs, visitAll$1(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n    };\n    _Expander.prototype.visitAttribute = function (attribute, context) { return attribute; };\n    _Expander.prototype.visitText = function (text, context) { return text; };\n    _Expander.prototype.visitComment = function (comment, context) { return comment; };\n    _Expander.prototype.visitExpansion = function (icu, context) {\n        this.isExpanded = true;\n        return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) :\n            _expandDefaultForm(icu, this.errors);\n    };\n    _Expander.prototype.visitExpansionCase = function (icuCase, context) {\n        throw new Error('Should not be reached');\n    };\n    return _Expander;\n}());\n// Plural forms are expanded to `NgPlural` and `NgPluralCase`s\nfunction _expandPluralForm(ast, errors) {\n    var children = ast.cases.map(function (c) {\n        if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\\d+$/)) {\n            errors.push(new ExpansionError(c.valueSourceSpan, \"Plural cases should be \\\"=<number>\\\" or one of \" + PLURAL_CASES.join(\", \")));\n        }\n        var expansionResult = expandNodes(c.expression);\n        errors.push.apply(errors, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(expansionResult.errors));\n        return new Element$1(\"ng-template\", [new Attribute('ngPluralCase', \"\" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    });\n    var switchAttr = new Attribute('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);\n    return new Element$1('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n// ICU messages (excluding plural form) are expanded to `NgSwitch`  and `NgSwitchCase`s\nfunction _expandDefaultForm(ast, errors) {\n    var children = ast.cases.map(function (c) {\n        var expansionResult = expandNodes(c.expression);\n        errors.push.apply(errors, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(expansionResult.errors));\n        if (c.value === 'other') {\n            // other is the default case when no values match\n            return new Element$1(\"ng-template\", [new Attribute('ngSwitchDefault', '', c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n        }\n        return new Element$1(\"ng-template\", [new Attribute('ngSwitchCase', \"\" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    });\n    var switchAttr = new Attribute('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);\n    return new Element$1('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _a;\n/**\n * A segment of text within the template.\n */\nvar TextAst = /** @class */ (function () {\n    function TextAst(value, ngContentIndex, sourceSpan) {\n        this.value = value;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    TextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n    return TextAst;\n}());\n/**\n * A bound expression within the text of a template.\n */\nvar BoundTextAst = /** @class */ (function () {\n    function BoundTextAst(value, ngContentIndex, sourceSpan) {\n        this.value = value;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    BoundTextAst.prototype.visit = function (visitor, context) {\n        return visitor.visitBoundText(this, context);\n    };\n    return BoundTextAst;\n}());\n/**\n * A plain attribute on an element.\n */\nvar AttrAst = /** @class */ (function () {\n    function AttrAst(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    AttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };\n    return AttrAst;\n}());\nvar BoundPropertyMapping = (_a = {},\n    _a[4 /* Animation */] = 4 /* Animation */,\n    _a[1 /* Attribute */] = 1 /* Attribute */,\n    _a[2 /* Class */] = 2 /* Class */,\n    _a[0 /* Property */] = 0 /* Property */,\n    _a[3 /* Style */] = 3 /* Style */,\n    _a);\n/**\n * A binding for an element property (e.g. `[property]=\"expression\"`) or an animation trigger (e.g.\n * `[@trigger]=\"stateExp\"`)\n */\nvar BoundElementPropertyAst = /** @class */ (function () {\n    function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n        this.isAnimation = this.type === 4 /* Animation */;\n    }\n    BoundElementPropertyAst.fromBoundProperty = function (prop) {\n        var type = BoundPropertyMapping[prop.type];\n        return new BoundElementPropertyAst(prop.name, type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan);\n    };\n    BoundElementPropertyAst.prototype.visit = function (visitor, context) {\n        return visitor.visitElementProperty(this, context);\n    };\n    return BoundElementPropertyAst;\n}());\n/**\n * A binding for an element event (e.g. `(event)=\"handler()\"`) or an animation trigger event (e.g.\n * `(@trigger.phase)=\"callback($event)\"`).\n */\nvar BoundEventAst = /** @class */ (function () {\n    function BoundEventAst(name, target, phase, handler, sourceSpan, handlerSpan) {\n        this.name = name;\n        this.target = target;\n        this.phase = phase;\n        this.handler = handler;\n        this.sourceSpan = sourceSpan;\n        this.handlerSpan = handlerSpan;\n        this.fullName = BoundEventAst.calcFullName(this.name, this.target, this.phase);\n        this.isAnimation = !!this.phase;\n    }\n    BoundEventAst.calcFullName = function (name, target, phase) {\n        if (target) {\n            return target + \":\" + name;\n        }\n        if (phase) {\n            return \"@\" + name + \".\" + phase;\n        }\n        return name;\n    };\n    BoundEventAst.fromParsedEvent = function (event) {\n        var target = event.type === 0 /* Regular */ ? event.targetOrPhase : null;\n        var phase = event.type === 1 /* Animation */ ? event.targetOrPhase : null;\n        return new BoundEventAst(event.name, target, phase, event.handler, event.sourceSpan, event.handlerSpan);\n    };\n    BoundEventAst.prototype.visit = function (visitor, context) {\n        return visitor.visitEvent(this, context);\n    };\n    return BoundEventAst;\n}());\n/**\n * A reference declaration on an element (e.g. `let someName=\"expression\"`).\n */\nvar ReferenceAst = /** @class */ (function () {\n    function ReferenceAst(name, value, originalValue, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.originalValue = originalValue;\n        this.sourceSpan = sourceSpan;\n    }\n    ReferenceAst.prototype.visit = function (visitor, context) {\n        return visitor.visitReference(this, context);\n    };\n    return ReferenceAst;\n}());\n/**\n * A variable declaration on a <ng-template> (e.g. `var-someName=\"someLocalName\"`).\n */\nvar VariableAst = /** @class */ (function () {\n    function VariableAst(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    VariableAst.fromParsedVariable = function (v) {\n        return new VariableAst(v.name, v.value, v.sourceSpan);\n    };\n    VariableAst.prototype.visit = function (visitor, context) {\n        return visitor.visitVariable(this, context);\n    };\n    return VariableAst;\n}());\n/**\n * An element declaration in a template.\n */\nvar ElementAst = /** @class */ (function () {\n    function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan, endSourceSpan) {\n        this.name = name;\n        this.attrs = attrs;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.references = references;\n        this.directives = directives;\n        this.providers = providers;\n        this.hasViewContainer = hasViewContainer;\n        this.queryMatches = queryMatches;\n        this.children = children;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    ElementAst.prototype.visit = function (visitor, context) {\n        return visitor.visitElement(this, context);\n    };\n    return ElementAst;\n}());\n/**\n * A `<ng-template>` element included in an Angular template.\n */\nvar EmbeddedTemplateAst = /** @class */ (function () {\n    function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan) {\n        this.attrs = attrs;\n        this.outputs = outputs;\n        this.references = references;\n        this.variables = variables;\n        this.directives = directives;\n        this.providers = providers;\n        this.hasViewContainer = hasViewContainer;\n        this.queryMatches = queryMatches;\n        this.children = children;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    EmbeddedTemplateAst.prototype.visit = function (visitor, context) {\n        return visitor.visitEmbeddedTemplate(this, context);\n    };\n    return EmbeddedTemplateAst;\n}());\n/**\n * A directive property with a bound value (e.g. `*ngIf=\"condition\").\n */\nvar BoundDirectivePropertyAst = /** @class */ (function () {\n    function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {\n        this.directiveName = directiveName;\n        this.templateName = templateName;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    BoundDirectivePropertyAst.prototype.visit = function (visitor, context) {\n        return visitor.visitDirectiveProperty(this, context);\n    };\n    return BoundDirectivePropertyAst;\n}());\n/**\n * A directive declared on an element.\n */\nvar DirectiveAst = /** @class */ (function () {\n    function DirectiveAst(directive, inputs, hostProperties, hostEvents, contentQueryStartId, sourceSpan) {\n        this.directive = directive;\n        this.inputs = inputs;\n        this.hostProperties = hostProperties;\n        this.hostEvents = hostEvents;\n        this.contentQueryStartId = contentQueryStartId;\n        this.sourceSpan = sourceSpan;\n    }\n    DirectiveAst.prototype.visit = function (visitor, context) {\n        return visitor.visitDirective(this, context);\n    };\n    return DirectiveAst;\n}());\n/**\n * A provider declared on an element\n */\nvar ProviderAst = /** @class */ (function () {\n    function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan, isModule) {\n        this.token = token;\n        this.multiProvider = multiProvider;\n        this.eager = eager;\n        this.providers = providers;\n        this.providerType = providerType;\n        this.lifecycleHooks = lifecycleHooks;\n        this.sourceSpan = sourceSpan;\n        this.isModule = isModule;\n    }\n    ProviderAst.prototype.visit = function (visitor, context) {\n        // No visit method in the visitor for now...\n        return null;\n    };\n    return ProviderAst;\n}());\nvar ProviderAstType;\n(function (ProviderAstType) {\n    ProviderAstType[ProviderAstType[\"PublicService\"] = 0] = \"PublicService\";\n    ProviderAstType[ProviderAstType[\"PrivateService\"] = 1] = \"PrivateService\";\n    ProviderAstType[ProviderAstType[\"Component\"] = 2] = \"Component\";\n    ProviderAstType[ProviderAstType[\"Directive\"] = 3] = \"Directive\";\n    ProviderAstType[ProviderAstType[\"Builtin\"] = 4] = \"Builtin\";\n})(ProviderAstType || (ProviderAstType = {}));\n/**\n * Position where content is to be projected (instance of `<ng-content>` in a template).\n */\nvar NgContentAst = /** @class */ (function () {\n    function NgContentAst(index, ngContentIndex, sourceSpan) {\n        this.index = index;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    NgContentAst.prototype.visit = function (visitor, context) {\n        return visitor.visitNgContent(this, context);\n    };\n    return NgContentAst;\n}());\n/**\n * A visitor that accepts each node but doesn't do anything. It is intended to be used\n * as the base class for a visitor that is only interested in a subset of the node types.\n */\nvar NullTemplateVisitor = /** @class */ (function () {\n    function NullTemplateVisitor() {\n    }\n    NullTemplateVisitor.prototype.visitNgContent = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitEmbeddedTemplate = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitElement = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitReference = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitVariable = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitEvent = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitElementProperty = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitAttr = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitBoundText = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitText = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitDirective = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitDirectiveProperty = function (ast, context) { };\n    return NullTemplateVisitor;\n}());\n/**\n * Base class that can be used to build a visitor that visits each node\n * in an template ast recursively.\n */\nvar RecursiveTemplateAstVisitor = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(RecursiveTemplateAstVisitor, _super);\n    function RecursiveTemplateAstVisitor() {\n        return _super.call(this) || this;\n    }\n    // Nodes with children\n    RecursiveTemplateAstVisitor.prototype.visitEmbeddedTemplate = function (ast, context) {\n        return this.visitChildren(context, function (visit) {\n            visit(ast.attrs);\n            visit(ast.references);\n            visit(ast.variables);\n            visit(ast.directives);\n            visit(ast.providers);\n            visit(ast.children);\n        });\n    };\n    RecursiveTemplateAstVisitor.prototype.visitElement = function (ast, context) {\n        return this.visitChildren(context, function (visit) {\n            visit(ast.attrs);\n            visit(ast.inputs);\n            visit(ast.outputs);\n            visit(ast.references);\n            visit(ast.directives);\n            visit(ast.providers);\n            visit(ast.children);\n        });\n    };\n    RecursiveTemplateAstVisitor.prototype.visitDirective = function (ast, context) {\n        return this.visitChildren(context, function (visit) {\n            visit(ast.inputs);\n            visit(ast.hostProperties);\n            visit(ast.hostEvents);\n        });\n    };\n    RecursiveTemplateAstVisitor.prototype.visitChildren = function (context, cb) {\n        var results = [];\n        var t = this;\n        function visit(children) {\n            if (children && children.length)\n                results.push(templateVisitAll(t, children, context));\n        }\n        cb(visit);\n        return Array.prototype.concat.apply([], results);\n    };\n    return RecursiveTemplateAstVisitor;\n}(NullTemplateVisitor));\n/**\n * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.\n */\nfunction templateVisitAll(visitor, asts, context) {\n    if (context === void 0) { context = null; }\n    var result = [];\n    var visit = visitor.visit ?\n        function (ast) { return visitor.visit(ast, context) || ast.visit(visitor, context); } :\n        function (ast) { return ast.visit(visitor, context); };\n    asts.forEach(function (ast) {\n        var astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ProviderError = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ProviderError, _super);\n    function ProviderError(message, span) {\n        return _super.call(this, span, message) || this;\n    }\n    return ProviderError;\n}(ParseError));\nvar ProviderViewContext = /** @class */ (function () {\n    function ProviderViewContext(reflector, component) {\n        var _this = this;\n        this.reflector = reflector;\n        this.component = component;\n        this.errors = [];\n        this.viewQueries = _getViewQueries(component);\n        this.viewProviders = new Map();\n        component.viewProviders.forEach(function (provider) {\n            if (_this.viewProviders.get(tokenReference(provider.token)) == null) {\n                _this.viewProviders.set(tokenReference(provider.token), true);\n            }\n        });\n    }\n    return ProviderViewContext;\n}());\nvar ProviderElementContext = /** @class */ (function () {\n    function ProviderElementContext(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, isTemplate, contentQueryStartId, _sourceSpan) {\n        var _this = this;\n        this.viewContext = viewContext;\n        this._parent = _parent;\n        this._isViewRoot = _isViewRoot;\n        this._directiveAsts = _directiveAsts;\n        this._sourceSpan = _sourceSpan;\n        this._transformedProviders = new Map();\n        this._seenProviders = new Map();\n        this._queriedTokens = new Map();\n        this.transformedHasViewContainer = false;\n        this._attrs = {};\n        attrs.forEach(function (attrAst) { return _this._attrs[attrAst.name] = attrAst.value; });\n        var directivesMeta = _directiveAsts.map(function (directiveAst) { return directiveAst.directive; });\n        this._allProviders =\n            _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);\n        this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._addQueryReadsTo(provider.token, provider.token, _this._queriedTokens);\n        });\n        if (isTemplate) {\n            var templateRefId = createTokenForExternalReference(this.viewContext.reflector, Identifiers.TemplateRef);\n            this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);\n        }\n        refs.forEach(function (refAst) {\n            var defaultQueryValue = refAst.value ||\n                createTokenForExternalReference(_this.viewContext.reflector, Identifiers.ElementRef);\n            _this._addQueryReadsTo({ value: refAst.name }, defaultQueryValue, _this._queriedTokens);\n        });\n        if (this._queriedTokens.get(this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef))) {\n            this.transformedHasViewContainer = true;\n        }\n        // create the providers that we know are eager first\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            var eager = provider.eager || _this._queriedTokens.get(tokenReference(provider.token));\n            if (eager) {\n                _this._getOrCreateLocalProvider(provider.providerType, provider.token, true);\n            }\n        });\n    }\n    ProviderElementContext.prototype.afterElement = function () {\n        var _this = this;\n        // collect lazy providers\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._getOrCreateLocalProvider(provider.providerType, provider.token, false);\n        });\n    };\n    Object.defineProperty(ProviderElementContext.prototype, \"transformProviders\", {\n        get: function () {\n            // Note: Maps keep their insertion order.\n            var lazyProviders = [];\n            var eagerProviders = [];\n            this._transformedProviders.forEach(function (provider) {\n                if (provider.eager) {\n                    eagerProviders.push(provider);\n                }\n                else {\n                    lazyProviders.push(provider);\n                }\n            });\n            return lazyProviders.concat(eagerProviders);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"transformedDirectiveAsts\", {\n        get: function () {\n            var sortedProviderTypes = this.transformProviders.map(function (provider) { return provider.token.identifier; });\n            var sortedDirectives = this._directiveAsts.slice();\n            sortedDirectives.sort(function (dir1, dir2) { return sortedProviderTypes.indexOf(dir1.directive.type) -\n                sortedProviderTypes.indexOf(dir2.directive.type); });\n            return sortedDirectives;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"queryMatches\", {\n        get: function () {\n            var allMatches = [];\n            this._queriedTokens.forEach(function (matches) { allMatches.push.apply(allMatches, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(matches)); });\n            return allMatches;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ProviderElementContext.prototype._addQueryReadsTo = function (token, defaultValue, queryReadTokens) {\n        this._getQueriesFor(token).forEach(function (query) {\n            var queryValue = query.meta.read || defaultValue;\n            var tokenRef = tokenReference(queryValue);\n            var queryMatches = queryReadTokens.get(tokenRef);\n            if (!queryMatches) {\n                queryMatches = [];\n                queryReadTokens.set(tokenRef, queryMatches);\n            }\n            queryMatches.push({ queryId: query.queryId, value: queryValue });\n        });\n    };\n    ProviderElementContext.prototype._getQueriesFor = function (token) {\n        var result = [];\n        var currentEl = this;\n        var distance = 0;\n        var queries;\n        while (currentEl !== null) {\n            queries = currentEl._contentQueries.get(tokenReference(token));\n            if (queries) {\n                result.push.apply(result, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(queries.filter(function (query) { return query.meta.descendants || distance <= 1; })));\n            }\n            if (currentEl._directiveAsts.length > 0) {\n                distance++;\n            }\n            currentEl = currentEl._parent;\n        }\n        queries = this.viewContext.viewQueries.get(tokenReference(token));\n        if (queries) {\n            result.push.apply(result, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(queries));\n        }\n        return result;\n    };\n    ProviderElementContext.prototype._getOrCreateLocalProvider = function (requestingProviderType, token, eager) {\n        var _this = this;\n        var resolvedProvider = this._allProviders.get(tokenReference(token));\n        if (!resolvedProvider || ((requestingProviderType === ProviderAstType.Directive ||\n            requestingProviderType === ProviderAstType.PublicService) &&\n            resolvedProvider.providerType === ProviderAstType.PrivateService) ||\n            ((requestingProviderType === ProviderAstType.PrivateService ||\n                requestingProviderType === ProviderAstType.PublicService) &&\n                resolvedProvider.providerType === ProviderAstType.Builtin)) {\n            return null;\n        }\n        var transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n        if (transformedProviderAst) {\n            return transformedProviderAst;\n        }\n        if (this._seenProviders.get(tokenReference(token)) != null) {\n            this.viewContext.errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \" + tokenName(token), this._sourceSpan));\n            return null;\n        }\n        this._seenProviders.set(tokenReference(token), true);\n        var transformedProviders = resolvedProvider.providers.map(function (provider) {\n            var transformedUseValue = provider.useValue;\n            var transformedUseExisting = provider.useExisting;\n            var transformedDeps = undefined;\n            if (provider.useExisting != null) {\n                var existingDiDep = _this._getDependency(resolvedProvider.providerType, { token: provider.useExisting }, eager);\n                if (existingDiDep.token != null) {\n                    transformedUseExisting = existingDiDep.token;\n                }\n                else {\n                    transformedUseExisting = null;\n                    transformedUseValue = existingDiDep.value;\n                }\n            }\n            else if (provider.useFactory) {\n                var deps = provider.deps || provider.useFactory.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });\n            }\n            else if (provider.useClass) {\n                var deps = provider.deps || provider.useClass.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });\n            }\n            return _transformProvider(provider, {\n                useExisting: transformedUseExisting,\n                useValue: transformedUseValue,\n                deps: transformedDeps\n            });\n        });\n        transformedProviderAst =\n            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\n        this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n        return transformedProviderAst;\n    };\n    ProviderElementContext.prototype._getLocalDependency = function (requestingProviderType, dep, eager) {\n        if (eager === void 0) { eager = false; }\n        if (dep.isAttribute) {\n            var attrValue = this._attrs[dep.token.value];\n            return { isValue: true, value: attrValue == null ? null : attrValue };\n        }\n        if (dep.token != null) {\n            // access builtints\n            if ((requestingProviderType === ProviderAstType.Directive ||\n                requestingProviderType === ProviderAstType.Component)) {\n                if (tokenReference(dep.token) ===\n                    this.viewContext.reflector.resolveExternalReference(Identifiers.Renderer) ||\n                    tokenReference(dep.token) ===\n                        this.viewContext.reflector.resolveExternalReference(Identifiers.ElementRef) ||\n                    tokenReference(dep.token) ===\n                        this.viewContext.reflector.resolveExternalReference(Identifiers.ChangeDetectorRef) ||\n                    tokenReference(dep.token) ===\n                        this.viewContext.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n                    return dep;\n                }\n                if (tokenReference(dep.token) ===\n                    this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {\n                    this.transformedHasViewContainer = true;\n                }\n            }\n            // access the injector\n            if (tokenReference(dep.token) ===\n                this.viewContext.reflector.resolveExternalReference(Identifiers.Injector)) {\n                return dep;\n            }\n            // access providers\n            if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {\n                return dep;\n            }\n        }\n        return null;\n    };\n    ProviderElementContext.prototype._getDependency = function (requestingProviderType, dep, eager) {\n        if (eager === void 0) { eager = false; }\n        var currElement = this;\n        var currEager = eager;\n        var result = null;\n        if (!dep.isSkipSelf) {\n            result = this._getLocalDependency(requestingProviderType, dep, eager);\n        }\n        if (dep.isSelf) {\n            if (!result && dep.isOptional) {\n                result = { isValue: true, value: null };\n            }\n        }\n        else {\n            // check parent elements\n            while (!result && currElement._parent) {\n                var prevElement = currElement;\n                currElement = currElement._parent;\n                if (prevElement._isViewRoot) {\n                    currEager = false;\n                }\n                result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);\n            }\n            // check @Host restriction\n            if (!result) {\n                if (!dep.isHost || this.viewContext.component.isHost ||\n                    this.viewContext.component.type.reference === tokenReference(dep.token) ||\n                    this.viewContext.viewProviders.get(tokenReference(dep.token)) != null) {\n                    result = dep;\n                }\n                else {\n                    result = dep.isOptional ? { isValue: true, value: null } : null;\n                }\n            }\n        }\n        if (!result) {\n            this.viewContext.errors.push(new ProviderError(\"No provider for \" + tokenName(dep.token), this._sourceSpan));\n        }\n        return result;\n    };\n    return ProviderElementContext;\n}());\nvar NgModuleProviderAnalyzer = /** @class */ (function () {\n    function NgModuleProviderAnalyzer(reflector, ngModule, extraProviders, sourceSpan) {\n        var _this = this;\n        this.reflector = reflector;\n        this._transformedProviders = new Map();\n        this._seenProviders = new Map();\n        this._errors = [];\n        this._allProviders = new Map();\n        ngModule.transitiveModule.modules.forEach(function (ngModuleType) {\n            var ngModuleProvider = { token: { identifier: ngModuleType }, useClass: ngModuleType };\n            _resolveProviders([ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, _this._errors, _this._allProviders, /* isModule */ true);\n        });\n        _resolveProviders(ngModule.transitiveModule.providers.map(function (entry) { return entry.provider; }).concat(extraProviders), ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders, \n        /* isModule */ false);\n    }\n    NgModuleProviderAnalyzer.prototype.parse = function () {\n        var _this = this;\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._getOrCreateLocalProvider(provider.token, provider.eager);\n        });\n        if (this._errors.length > 0) {\n            var errorString = this._errors.join('\\n');\n            throw new Error(\"Provider parse errors:\\n\" + errorString);\n        }\n        // Note: Maps keep their insertion order.\n        var lazyProviders = [];\n        var eagerProviders = [];\n        this._transformedProviders.forEach(function (provider) {\n            if (provider.eager) {\n                eagerProviders.push(provider);\n            }\n            else {\n                lazyProviders.push(provider);\n            }\n        });\n        return lazyProviders.concat(eagerProviders);\n    };\n    NgModuleProviderAnalyzer.prototype._getOrCreateLocalProvider = function (token, eager) {\n        var _this = this;\n        var resolvedProvider = this._allProviders.get(tokenReference(token));\n        if (!resolvedProvider) {\n            return null;\n        }\n        var transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n        if (transformedProviderAst) {\n            return transformedProviderAst;\n        }\n        if (this._seenProviders.get(tokenReference(token)) != null) {\n            this._errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \" + tokenName(token), resolvedProvider.sourceSpan));\n            return null;\n        }\n        this._seenProviders.set(tokenReference(token), true);\n        var transformedProviders = resolvedProvider.providers.map(function (provider) {\n            var transformedUseValue = provider.useValue;\n            var transformedUseExisting = provider.useExisting;\n            var transformedDeps = undefined;\n            if (provider.useExisting != null) {\n                var existingDiDep = _this._getDependency({ token: provider.useExisting }, eager, resolvedProvider.sourceSpan);\n                if (existingDiDep.token != null) {\n                    transformedUseExisting = existingDiDep.token;\n                }\n                else {\n                    transformedUseExisting = null;\n                    transformedUseValue = existingDiDep.value;\n                }\n            }\n            else if (provider.useFactory) {\n                var deps = provider.deps || provider.useFactory.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });\n            }\n            else if (provider.useClass) {\n                var deps = provider.deps || provider.useClass.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });\n            }\n            return _transformProvider(provider, {\n                useExisting: transformedUseExisting,\n                useValue: transformedUseValue,\n                deps: transformedDeps\n            });\n        });\n        transformedProviderAst =\n            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\n        this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n        return transformedProviderAst;\n    };\n    NgModuleProviderAnalyzer.prototype._getDependency = function (dep, eager, requestorSourceSpan) {\n        if (eager === void 0) { eager = false; }\n        var foundLocal = false;\n        if (!dep.isSkipSelf && dep.token != null) {\n            // access the injector\n            if (tokenReference(dep.token) ===\n                this.reflector.resolveExternalReference(Identifiers.Injector) ||\n                tokenReference(dep.token) ===\n                    this.reflector.resolveExternalReference(Identifiers.ComponentFactoryResolver)) {\n                foundLocal = true;\n                // access providers\n            }\n            else if (this._getOrCreateLocalProvider(dep.token, eager) != null) {\n                foundLocal = true;\n            }\n        }\n        return dep;\n    };\n    return NgModuleProviderAnalyzer;\n}());\nfunction _transformProvider(provider, _a) {\n    var useExisting = _a.useExisting, useValue = _a.useValue, deps = _a.deps;\n    return {\n        token: provider.token,\n        useClass: provider.useClass,\n        useExisting: useExisting,\n        useFactory: provider.useFactory,\n        useValue: useValue,\n        deps: deps,\n        multi: provider.multi\n    };\n}\nfunction _transformProviderAst(provider, _a) {\n    var eager = _a.eager, providers = _a.providers;\n    return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan, provider.isModule);\n}\nfunction _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {\n    var providersByToken = new Map();\n    directives.forEach(function (directive) {\n        var dirProvider = { token: { identifier: directive.type }, useClass: directive.type };\n        _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken, /* isModule */ false);\n    });\n    // Note: directives need to be able to overwrite providers of a component!\n    var directivesWithComponentFirst = directives.filter(function (dir) { return dir.isComponent; }).concat(directives.filter(function (dir) { return !dir.isComponent; }));\n    directivesWithComponentFirst.forEach(function (directive) {\n        _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken, /* isModule */ false);\n        _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken, /* isModule */ false);\n    });\n    return providersByToken;\n}\nfunction _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken, isModule) {\n    providers.forEach(function (provider) {\n        var resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));\n        if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {\n            targetErrors.push(new ProviderError(\"Mixing multi and non multi provider is not possible for token \" + tokenName(resolvedProvider.token), sourceSpan));\n        }\n        if (!resolvedProvider) {\n            var lifecycleHooks = provider.token.identifier &&\n                provider.token.identifier.lifecycleHooks ?\n                provider.token.identifier.lifecycleHooks :\n                [];\n            var isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);\n            resolvedProvider = new ProviderAst(provider.token, !!provider.multi, eager || isUseValue, [provider], providerType, lifecycleHooks, sourceSpan, isModule);\n            targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);\n        }\n        else {\n            if (!provider.multi) {\n                resolvedProvider.providers.length = 0;\n            }\n            resolvedProvider.providers.push(provider);\n        }\n    });\n}\nfunction _getViewQueries(component) {\n    // Note: queries start with id 1 so we can use the number in a Bloom filter!\n    var viewQueryId = 1;\n    var viewQueries = new Map();\n    if (component.viewQueries) {\n        component.viewQueries.forEach(function (query) { return _addQueryToTokenMap(viewQueries, { meta: query, queryId: viewQueryId++ }); });\n    }\n    return viewQueries;\n}\nfunction _getContentQueries(contentQueryStartId, directives) {\n    var contentQueryId = contentQueryStartId;\n    var contentQueries = new Map();\n    directives.forEach(function (directive, directiveIndex) {\n        if (directive.queries) {\n            directive.queries.forEach(function (query) { return _addQueryToTokenMap(contentQueries, { meta: query, queryId: contentQueryId++ }); });\n        }\n    });\n    return contentQueries;\n}\nfunction _addQueryToTokenMap(map, query) {\n    query.meta.selectors.forEach(function (token) {\n        var entry = map.get(tokenReference(token));\n        if (!entry) {\n            entry = [];\n            map.set(tokenReference(token), entry);\n        }\n        entry.push(query);\n    });\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar StyleWithImports = /** @class */ (function () {\n    function StyleWithImports(style, styleUrls) {\n        this.style = style;\n        this.styleUrls = styleUrls;\n    }\n    return StyleWithImports;\n}());\nfunction isStyleUrlResolvable(url) {\n    if (url == null || url.length === 0 || url[0] == '/')\n        return false;\n    var schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n    return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\n/**\n * Rewrites stylesheets by resolving and removing the @import urls that\n * are either relative or don't have a `package:` scheme\n */\nfunction extractStyleUrls(resolver, baseUrl, cssText) {\n    var foundUrls = [];\n    var modifiedCssText = cssText.replace(CSS_STRIPPABLE_COMMENT_REGEXP, '')\n        .replace(CSS_IMPORT_REGEXP, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        var url = m[1] || m[2];\n        if (!isStyleUrlResolvable(url)) {\n            // Do not attempt to resolve non-package absolute URLs with URI\n            // scheme\n            return m[0];\n        }\n        foundUrls.push(resolver.resolve(baseUrl, url));\n        return '';\n    });\n    return new StyleWithImports(modifiedCssText, foundUrls);\n}\nvar CSS_IMPORT_REGEXP = /@import\\s+(?:url\\()?\\s*(?:(?:['\"]([^'\"]*))|([^;\\)\\s]*))[^;]*;?/g;\nvar CSS_STRIPPABLE_COMMENT_REGEXP = /\\/\\*(?!#\\s*(?:sourceURL|sourceMappingURL)=)[\\s\\S]+?\\*\\//g;\nvar URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar PROPERTY_PARTS_SEPARATOR = '.';\nvar ATTRIBUTE_PREFIX = 'attr';\nvar CLASS_PREFIX = 'class';\nvar STYLE_PREFIX = 'style';\nvar ANIMATE_PROP_PREFIX = 'animate-';\n/**\n * Parses bindings in templates and in the directive host area.\n */\nvar BindingParser = /** @class */ (function () {\n    function BindingParser(_exprParser, _interpolationConfig, _schemaRegistry, pipes, errors) {\n        this._exprParser = _exprParser;\n        this._interpolationConfig = _interpolationConfig;\n        this._schemaRegistry = _schemaRegistry;\n        this.errors = errors;\n        this.pipesByName = null;\n        this._usedPipes = new Map();\n        // When the `pipes` parameter is `null`, do not check for used pipes\n        // This is used in IVY when we might not know the available pipes at compile time\n        if (pipes) {\n            var pipesByName_1 = new Map();\n            pipes.forEach(function (pipe) { return pipesByName_1.set(pipe.name, pipe); });\n            this.pipesByName = pipesByName_1;\n        }\n    }\n    Object.defineProperty(BindingParser.prototype, \"interpolationConfig\", {\n        get: function () { return this._interpolationConfig; },\n        enumerable: true,\n        configurable: true\n    });\n    BindingParser.prototype.getUsedPipes = function () { return Array.from(this._usedPipes.values()); };\n    BindingParser.prototype.createBoundHostProperties = function (dirMeta, sourceSpan) {\n        var _this = this;\n        if (dirMeta.hostProperties) {\n            var boundProps_1 = [];\n            Object.keys(dirMeta.hostProperties).forEach(function (propName) {\n                var expression = dirMeta.hostProperties[propName];\n                if (typeof expression === 'string') {\n                    _this.parsePropertyBinding(propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [], boundProps_1);\n                }\n                else {\n                    _this._reportError(\"Value of the host property binding \\\"\" + propName + \"\\\" needs to be a string representing an expression but got \\\"\" + expression + \"\\\" (\" + typeof expression + \")\", sourceSpan);\n                }\n            });\n            return boundProps_1;\n        }\n        return null;\n    };\n    BindingParser.prototype.createDirectiveHostPropertyAsts = function (dirMeta, elementSelector, sourceSpan) {\n        var _this = this;\n        var boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);\n        return boundProps &&\n            boundProps.map(function (prop) { return _this.createBoundElementProperty(elementSelector, prop); });\n    };\n    BindingParser.prototype.createDirectiveHostEventAsts = function (dirMeta, sourceSpan) {\n        var _this = this;\n        if (dirMeta.hostListeners) {\n            var targetEvents_1 = [];\n            Object.keys(dirMeta.hostListeners).forEach(function (propName) {\n                var expression = dirMeta.hostListeners[propName];\n                if (typeof expression === 'string') {\n                    // TODO: pass a more accurate handlerSpan for this event.\n                    _this.parseEvent(propName, expression, sourceSpan, sourceSpan, [], targetEvents_1);\n                }\n                else {\n                    _this._reportError(\"Value of the host listener \\\"\" + propName + \"\\\" needs to be a string representing an expression but got \\\"\" + expression + \"\\\" (\" + typeof expression + \")\", sourceSpan);\n                }\n            });\n            return targetEvents_1;\n        }\n        return null;\n    };\n    BindingParser.prototype.parseInterpolation = function (value, sourceSpan) {\n        var sourceInfo = sourceSpan.start.toString();\n        try {\n            var ast = this._exprParser.parseInterpolation(value, sourceInfo, sourceSpan.start.offset, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, sourceSpan.start.offset);\n        }\n    };\n    // Parse an inline template binding. ie `<tag *tplKey=\"<tplValue>\">`\n    BindingParser.prototype.parseInlineTemplateBinding = function (tplKey, tplValue, sourceSpan, absoluteOffset, targetMatchableAttrs, targetProps, targetVars) {\n        var bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan);\n        for (var i = 0; i < bindings.length; i++) {\n            var binding = bindings[i];\n            if (binding.keyIsVar) {\n                targetVars.push(new ParsedVariable(binding.key, binding.name, sourceSpan));\n            }\n            else if (binding.expression) {\n                this._parsePropertyAst(binding.key, binding.expression, sourceSpan, undefined, targetMatchableAttrs, targetProps);\n            }\n            else {\n                targetMatchableAttrs.push([binding.key, '']);\n                this.parseLiteralAttr(binding.key, null, sourceSpan, absoluteOffset, undefined, targetMatchableAttrs, targetProps);\n            }\n        }\n    };\n    BindingParser.prototype._parseTemplateBindings = function (tplKey, tplValue, sourceSpan) {\n        var _this = this;\n        var sourceInfo = sourceSpan.start.toString();\n        try {\n            var bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, sourceSpan.start.offset);\n            this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n            bindingsResult.templateBindings.forEach(function (binding) {\n                if (binding.expression) {\n                    _this._checkPipes(binding.expression, sourceSpan);\n                }\n            });\n            bindingsResult.warnings.forEach(function (warning) { _this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING); });\n            return bindingsResult.templateBindings;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return [];\n        }\n    };\n    BindingParser.prototype.parseLiteralAttr = function (name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps) {\n        if (isAnimationLabel(name)) {\n            name = name.substring(1);\n            if (value) {\n                this._reportError(\"Assigning animation triggers via @prop=\\\"exp\\\" attributes with an expression is invalid.\" +\n                    \" Use property bindings (e.g. [@prop]=\\\"exp\\\") or use an attribute without a value (e.g. @prop) instead.\", sourceSpan, ParseErrorLevel.ERROR);\n            }\n            this._parseAnimation(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, valueSpan));\n        }\n    };\n    BindingParser.prototype.parsePropertyBinding = function (name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps) {\n        var isAnimationProp = false;\n        if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n            isAnimationProp = true;\n            name = name.substring(ANIMATE_PROP_PREFIX.length);\n        }\n        else if (isAnimationLabel(name)) {\n            isAnimationProp = true;\n            name = name.substring(1);\n        }\n        if (isAnimationProp) {\n            this._parseAnimation(name, expression, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, valueSpan, targetMatchableAttrs, targetProps);\n        }\n    };\n    BindingParser.prototype.parsePropertyInterpolation = function (name, value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps) {\n        var expr = this.parseInterpolation(value, valueSpan || sourceSpan);\n        if (expr) {\n            this._parsePropertyAst(name, expr, sourceSpan, valueSpan, targetMatchableAttrs, targetProps);\n            return true;\n        }\n        return false;\n    };\n    BindingParser.prototype._parsePropertyAst = function (name, ast, sourceSpan, valueSpan, targetMatchableAttrs, targetProps) {\n        targetMatchableAttrs.push([name, ast.source]);\n        targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, valueSpan));\n    };\n    BindingParser.prototype._parseAnimation = function (name, expression, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps) {\n        // This will occur when a @trigger is not paired with an expression.\n        // For animations it is valid to not have an expression since */void\n        // states will be applied by angular when the element is attached/detached\n        var ast = this._parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\n        targetMatchableAttrs.push([name, ast.source]);\n        targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, valueSpan));\n    };\n    BindingParser.prototype._parseBinding = function (value, isHostBinding, sourceSpan, absoluteOffset) {\n        var sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\n        try {\n            var ast = isHostBinding ?\n                this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) :\n                this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n    };\n    BindingParser.prototype.createBoundElementProperty = function (elementSelector, boundProp, skipValidation, mapPropertyName) {\n        if (skipValidation === void 0) { skipValidation = false; }\n        if (mapPropertyName === void 0) { mapPropertyName = true; }\n        if (boundProp.isAnimation) {\n            return new BoundElementProperty(boundProp.name, 4 /* Animation */, SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.valueSpan);\n        }\n        var unit = null;\n        var bindingType = undefined;\n        var boundPropertyName = null;\n        var parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n        var securityContexts = undefined;\n        // Check for special cases (prefix style, attr, class)\n        if (parts.length > 1) {\n            if (parts[0] == ATTRIBUTE_PREFIX) {\n                boundPropertyName = parts[1];\n                if (!skipValidation) {\n                    this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n                }\n                securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n                var nsSeparatorIdx = boundPropertyName.indexOf(':');\n                if (nsSeparatorIdx > -1) {\n                    var ns = boundPropertyName.substring(0, nsSeparatorIdx);\n                    var name_1 = boundPropertyName.substring(nsSeparatorIdx + 1);\n                    boundPropertyName = mergeNsAndName(ns, name_1);\n                }\n                bindingType = 1 /* Attribute */;\n            }\n            else if (parts[0] == CLASS_PREFIX) {\n                boundPropertyName = parts[1];\n                bindingType = 2 /* Class */;\n                securityContexts = [SecurityContext.NONE];\n            }\n            else if (parts[0] == STYLE_PREFIX) {\n                unit = parts.length > 2 ? parts[2] : null;\n                boundPropertyName = parts[1];\n                bindingType = 3 /* Style */;\n                securityContexts = [SecurityContext.STYLE];\n            }\n        }\n        // If not a special case, use the full property name\n        if (boundPropertyName === null) {\n            var mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n            boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n            securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);\n            bindingType = 0 /* Property */;\n            if (!skipValidation) {\n                this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n            }\n        }\n        return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.valueSpan);\n    };\n    BindingParser.prototype.parseEvent = function (name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents) {\n        if (isAnimationLabel(name)) {\n            name = name.substr(1);\n            this._parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents);\n        }\n        else {\n            this._parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents);\n        }\n    };\n    BindingParser.prototype.calcPossibleSecurityContexts = function (selector, propName, isAttribute) {\n        var prop = this._schemaRegistry.getMappedPropName(propName);\n        return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n    };\n    BindingParser.prototype._parseAnimationEvent = function (name, expression, sourceSpan, handlerSpan, targetEvents) {\n        var matches = splitAtPeriod(name, [name, '']);\n        var eventName = matches[0];\n        var phase = matches[1].toLowerCase();\n        if (phase) {\n            switch (phase) {\n                case 'start':\n                case 'done':\n                    var ast = this._parseAction(expression, handlerSpan);\n                    targetEvents.push(new ParsedEvent(eventName, phase, 1 /* Animation */, ast, sourceSpan, handlerSpan));\n                    break;\n                default:\n                    this._reportError(\"The provided animation output phase value \\\"\" + phase + \"\\\" for \\\"@\" + eventName + \"\\\" is not supported (use start or done)\", sourceSpan);\n                    break;\n            }\n        }\n        else {\n            this._reportError(\"The animation trigger output event (@\" + eventName + \") is missing its phase value name (start or done are currently supported)\", sourceSpan);\n        }\n    };\n    BindingParser.prototype._parseRegularEvent = function (name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents) {\n        // long format: 'target: eventName'\n        var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(splitAtColon(name, [null, name]), 2), target = _a[0], eventName = _a[1];\n        var ast = this._parseAction(expression, handlerSpan);\n        targetMatchableAttrs.push([name, ast.source]);\n        targetEvents.push(new ParsedEvent(eventName, target, 0 /* Regular */, ast, sourceSpan, handlerSpan));\n        // Don't detect directives for event names for now,\n        // so don't add the event name to the matchableAttrs\n    };\n    BindingParser.prototype._parseAction = function (value, sourceSpan) {\n        var sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\n        var absoluteOffset = (sourceSpan && sourceSpan.start) ? sourceSpan.start.offset : 0;\n        try {\n            var ast = this._exprParser.parseAction(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n            if (ast) {\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            }\n            if (!ast || ast.ast instanceof EmptyExpr) {\n                this._reportError(\"Empty expressions are not allowed\", sourceSpan);\n                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n            }\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n    };\n    BindingParser.prototype._reportError = function (message, sourceSpan, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this.errors.push(new ParseError(sourceSpan, message, level));\n    };\n    BindingParser.prototype._reportExpressionParserErrors = function (errors, sourceSpan) {\n        var e_1, _a;\n        try {\n            for (var errors_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(errors), errors_1_1 = errors_1.next(); !errors_1_1.done; errors_1_1 = errors_1.next()) {\n                var error = errors_1_1.value;\n                this._reportError(error.message, sourceSpan);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (errors_1_1 && !errors_1_1.done && (_a = errors_1.return)) _a.call(errors_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    // Make sure all the used pipes are known in `this.pipesByName`\n    BindingParser.prototype._checkPipes = function (ast, sourceSpan) {\n        var _this = this;\n        if (ast && this.pipesByName) {\n            var collector = new PipeCollector();\n            ast.visit(collector);\n            collector.pipes.forEach(function (ast, pipeName) {\n                var pipeMeta = _this.pipesByName.get(pipeName);\n                if (!pipeMeta) {\n                    _this._reportError(\"The pipe '\" + pipeName + \"' could not be found\", new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n                }\n                else {\n                    _this._usedPipes.set(pipeName, pipeMeta);\n                }\n            });\n        }\n    };\n    /**\n     * @param propName the name of the property / attribute\n     * @param sourceSpan\n     * @param isAttr true when binding to an attribute\n     */\n    BindingParser.prototype._validatePropertyOrAttributeName = function (propName, sourceSpan, isAttr) {\n        var report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n            this._schemaRegistry.validateProperty(propName);\n        if (report.error) {\n            this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);\n        }\n    };\n    return BindingParser;\n}());\nvar PipeCollector = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(PipeCollector, _super);\n    function PipeCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.pipes = new Map();\n        return _this;\n    }\n    PipeCollector.prototype.visitPipe = function (ast, context) {\n        this.pipes.set(ast.name, ast);\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    return PipeCollector;\n}(RecursiveAstVisitor$1));\nfunction isAnimationLabel(name) {\n    return name[0] == '@';\n}\nfunction calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n    var ctxs = [];\n    CssSelector.parse(selector).forEach(function (selector) {\n        var elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n        var notElementNames = new Set(selector.notSelectors.filter(function (selector) { return selector.isElementSelector(); })\n            .map(function (selector) { return selector.element; }));\n        var possibleElementNames = elementNames.filter(function (elementName) { return !notElementNames.has(elementName); });\n        ctxs.push.apply(ctxs, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(possibleElementNames.map(function (elementName) { return registry.securityContext(elementName, propName, isAttribute); })));\n    });\n    return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar NG_CONTENT_SELECT_ATTR = 'select';\nvar LINK_ELEMENT = 'link';\nvar LINK_STYLE_REL_ATTR = 'rel';\nvar LINK_STYLE_HREF_ATTR = 'href';\nvar LINK_STYLE_REL_VALUE = 'stylesheet';\nvar STYLE_ELEMENT = 'style';\nvar SCRIPT_ELEMENT = 'script';\nvar NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nvar NG_PROJECT_AS = 'ngProjectAs';\nfunction preparseElement(ast) {\n    var selectAttr = null;\n    var hrefAttr = null;\n    var relAttr = null;\n    var nonBindable = false;\n    var projectAs = '';\n    ast.attrs.forEach(function (attr) {\n        var lcAttrName = attr.name.toLowerCase();\n        if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n            selectAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n            hrefAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n            relAttr = attr.value;\n        }\n        else if (attr.name == NG_NON_BINDABLE_ATTR) {\n            nonBindable = true;\n        }\n        else if (attr.name == NG_PROJECT_AS) {\n            if (attr.value.length > 0) {\n                projectAs = attr.value;\n            }\n        }\n    });\n    selectAttr = normalizeNgContentSelect(selectAttr);\n    var nodeName = ast.name.toLowerCase();\n    var type = PreparsedElementType.OTHER;\n    if (isNgContent(nodeName)) {\n        type = PreparsedElementType.NG_CONTENT;\n    }\n    else if (nodeName == STYLE_ELEMENT) {\n        type = PreparsedElementType.STYLE;\n    }\n    else if (nodeName == SCRIPT_ELEMENT) {\n        type = PreparsedElementType.SCRIPT;\n    }\n    else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n        type = PreparsedElementType.STYLESHEET;\n    }\n    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\nvar PreparsedElementType;\n(function (PreparsedElementType) {\n    PreparsedElementType[PreparsedElementType[\"NG_CONTENT\"] = 0] = \"NG_CONTENT\";\n    PreparsedElementType[PreparsedElementType[\"STYLE\"] = 1] = \"STYLE\";\n    PreparsedElementType[PreparsedElementType[\"STYLESHEET\"] = 2] = \"STYLESHEET\";\n    PreparsedElementType[PreparsedElementType[\"SCRIPT\"] = 3] = \"SCRIPT\";\n    PreparsedElementType[PreparsedElementType[\"OTHER\"] = 4] = \"OTHER\";\n})(PreparsedElementType || (PreparsedElementType = {}));\nvar PreparsedElement = /** @class */ (function () {\n    function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {\n        this.type = type;\n        this.selectAttr = selectAttr;\n        this.hrefAttr = hrefAttr;\n        this.nonBindable = nonBindable;\n        this.projectAs = projectAs;\n    }\n    return PreparsedElement;\n}());\nfunction normalizeNgContentSelect(selectAttr) {\n    if (selectAttr === null || selectAttr.length === 0) {\n        return '*';\n    }\n    return selectAttr;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n// Group 1 = \"bind-\"\nvar KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nvar KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nvar KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nvar KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nvar KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nvar KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nvar IDENT_KW_IDX = 7;\n// Group 8 = identifier inside [()]\nvar IDENT_BANANA_BOX_IDX = 8;\n// Group 9 = identifier inside []\nvar IDENT_PROPERTY_IDX = 9;\n// Group 10 = identifier inside ()\nvar IDENT_EVENT_IDX = 10;\nvar TEMPLATE_ATTR_PREFIX = '*';\nvar CLASS_ATTR = 'class';\nvar _TEXT_CSS_SELECTOR;\nfunction TEXT_CSS_SELECTOR() {\n    if (!_TEXT_CSS_SELECTOR) {\n        _TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];\n    }\n    return _TEXT_CSS_SELECTOR;\n}\nvar TemplateParseError = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(TemplateParseError, _super);\n    function TemplateParseError(message, span, level) {\n        return _super.call(this, span, message, level) || this;\n    }\n    return TemplateParseError;\n}(ParseError));\nvar TemplateParseResult = /** @class */ (function () {\n    function TemplateParseResult(templateAst, usedPipes, errors) {\n        this.templateAst = templateAst;\n        this.usedPipes = usedPipes;\n        this.errors = errors;\n    }\n    return TemplateParseResult;\n}());\nvar TemplateParser = /** @class */ (function () {\n    function TemplateParser(_config, _reflector, _exprParser, _schemaRegistry, _htmlParser, _console, transforms) {\n        this._config = _config;\n        this._reflector = _reflector;\n        this._exprParser = _exprParser;\n        this._schemaRegistry = _schemaRegistry;\n        this._htmlParser = _htmlParser;\n        this._console = _console;\n        this.transforms = transforms;\n    }\n    Object.defineProperty(TemplateParser.prototype, \"expressionParser\", {\n        get: function () { return this._exprParser; },\n        enumerable: true,\n        configurable: true\n    });\n    TemplateParser.prototype.parse = function (component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {\n        var result = this.tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces);\n        var warnings = result.errors.filter(function (error) { return error.level === ParseErrorLevel.WARNING; });\n        var errors = result.errors.filter(function (error) { return error.level === ParseErrorLevel.ERROR; });\n        if (warnings.length > 0) {\n            this._console.warn(\"Template parse warnings:\\n\" + warnings.join('\\n'));\n        }\n        if (errors.length > 0) {\n            var errorString = errors.join('\\n');\n            throw syntaxError(\"Template parse errors:\\n\" + errorString, errors);\n        }\n        return { template: result.templateAst, pipes: result.usedPipes };\n    };\n    TemplateParser.prototype.tryParse = function (component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {\n        var htmlParseResult = typeof template === 'string' ?\n            this._htmlParser.parse(template, templateUrl, {\n                tokenizeExpansionForms: true,\n                interpolationConfig: this.getInterpolationConfig(component)\n            }) :\n            template;\n        if (!preserveWhitespaces) {\n            htmlParseResult = removeWhitespaces(htmlParseResult);\n        }\n        return this.tryParseHtml(this.expandHtml(htmlParseResult), component, directives, pipes, schemas);\n    };\n    TemplateParser.prototype.tryParseHtml = function (htmlAstWithErrors, component, directives, pipes, schemas) {\n        var result;\n        var errors = htmlAstWithErrors.errors;\n        var usedPipes = [];\n        if (htmlAstWithErrors.rootNodes.length > 0) {\n            var uniqDirectives = removeSummaryDuplicates(directives);\n            var uniqPipes = removeSummaryDuplicates(pipes);\n            var providerViewContext = new ProviderViewContext(this._reflector, component);\n            var interpolationConfig = undefined;\n            if (component.template && component.template.interpolation) {\n                interpolationConfig = {\n                    start: component.template.interpolation[0],\n                    end: component.template.interpolation[1]\n                };\n            }\n            var bindingParser = new BindingParser(this._exprParser, interpolationConfig, this._schemaRegistry, uniqPipes, errors);\n            var parseVisitor = new TemplateParseVisitor(this._reflector, this._config, providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);\n            result = visitAll$1(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);\n            errors.push.apply(errors, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(providerViewContext.errors));\n            usedPipes.push.apply(usedPipes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(bindingParser.getUsedPipes()));\n        }\n        else {\n            result = [];\n        }\n        this._assertNoReferenceDuplicationOnTemplate(result, errors);\n        if (errors.length > 0) {\n            return new TemplateParseResult(result, usedPipes, errors);\n        }\n        if (this.transforms) {\n            this.transforms.forEach(function (transform) { result = templateVisitAll(transform, result); });\n        }\n        return new TemplateParseResult(result, usedPipes, errors);\n    };\n    TemplateParser.prototype.expandHtml = function (htmlAstWithErrors, forced) {\n        if (forced === void 0) { forced = false; }\n        var errors = htmlAstWithErrors.errors;\n        if (errors.length == 0 || forced) {\n            // Transform ICU messages to angular directives\n            var expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);\n            errors.push.apply(errors, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(expandedHtmlAst.errors));\n            htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);\n        }\n        return htmlAstWithErrors;\n    };\n    TemplateParser.prototype.getInterpolationConfig = function (component) {\n        if (component.template) {\n            return InterpolationConfig.fromArray(component.template.interpolation);\n        }\n        return undefined;\n    };\n    /** @internal */\n    TemplateParser.prototype._assertNoReferenceDuplicationOnTemplate = function (result, errors) {\n        var existingReferences = [];\n        result.filter(function (element) { return !!element.references; })\n            .forEach(function (element) { return element.references.forEach(function (reference) {\n            var name = reference.name;\n            if (existingReferences.indexOf(name) < 0) {\n                existingReferences.push(name);\n            }\n            else {\n                var error = new TemplateParseError(\"Reference \\\"#\" + name + \"\\\" is defined several times\", reference.sourceSpan, ParseErrorLevel.ERROR);\n                errors.push(error);\n            }\n        }); });\n    };\n    return TemplateParser;\n}());\nvar TemplateParseVisitor = /** @class */ (function () {\n    function TemplateParseVisitor(reflector, config, providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {\n        var _this = this;\n        this.reflector = reflector;\n        this.config = config;\n        this.providerViewContext = providerViewContext;\n        this._bindingParser = _bindingParser;\n        this._schemaRegistry = _schemaRegistry;\n        this._schemas = _schemas;\n        this._targetErrors = _targetErrors;\n        this.selectorMatcher = new SelectorMatcher();\n        this.directivesIndex = new Map();\n        this.ngContentCount = 0;\n        // Note: queries start with id 1 so we can use the number in a Bloom filter!\n        this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;\n        directives.forEach(function (directive, index) {\n            var selector = CssSelector.parse(directive.selector);\n            _this.selectorMatcher.addSelectables(selector, directive);\n            _this.directivesIndex.set(directive, index);\n        });\n    }\n    TemplateParseVisitor.prototype.visitExpansion = function (expansion, context) { return null; };\n    TemplateParseVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return null; };\n    TemplateParseVisitor.prototype.visitText = function (text, parent) {\n        var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());\n        var valueNoNgsp = replaceNgsp(text.value);\n        var expr = this._bindingParser.parseInterpolation(valueNoNgsp, text.sourceSpan);\n        return expr ? new BoundTextAst(expr, ngContentIndex, text.sourceSpan) :\n            new TextAst(valueNoNgsp, ngContentIndex, text.sourceSpan);\n    };\n    TemplateParseVisitor.prototype.visitAttribute = function (attribute, context) {\n        return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    };\n    TemplateParseVisitor.prototype.visitComment = function (comment, context) { return null; };\n    TemplateParseVisitor.prototype.visitElement = function (element, parent) {\n        var _this = this;\n        var queryStartIndex = this.contentQueryStartId;\n        var elName = element.name;\n        var preparsedElement = preparseElement(element);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE) {\n            // Skipping <script> for security reasons\n            // Skipping <style> as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n            isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n            // Skipping stylesheets with either relative urls or package scheme as we already processed\n            // them in the StyleCompiler\n            return null;\n        }\n        var matchableAttrs = [];\n        var elementOrDirectiveProps = [];\n        var elementOrDirectiveRefs = [];\n        var elementVars = [];\n        var events = [];\n        var templateElementOrDirectiveProps = [];\n        var templateMatchableAttrs = [];\n        var templateElementVars = [];\n        var hasInlineTemplates = false;\n        var attrs = [];\n        var isTemplateElement = isNgTemplate(element.name);\n        element.attrs.forEach(function (attr) {\n            var parsedVariables = [];\n            var hasBinding = _this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);\n            elementVars.push.apply(elementVars, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(parsedVariables.map(function (v) { return VariableAst.fromParsedVariable(v); })));\n            var templateValue;\n            var templateKey;\n            var normalizedName = _this._normalizeAttributeName(attr.name);\n            if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n                templateValue = attr.value;\n                templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n            }\n            var hasTemplateBinding = templateValue != null;\n            if (hasTemplateBinding) {\n                if (hasInlineTemplates) {\n                    _this._reportError(\"Can't have multiple template bindings on one element. Use only one attribute prefixed with *\", attr.sourceSpan);\n                }\n                hasInlineTemplates = true;\n                var parsedVariables_1 = [];\n                _this._bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attr.sourceSpan, attr.sourceSpan.start.offset, templateMatchableAttrs, templateElementOrDirectiveProps, parsedVariables_1);\n                templateElementVars.push.apply(templateElementVars, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(parsedVariables_1.map(function (v) { return VariableAst.fromParsedVariable(v); })));\n            }\n            if (!hasBinding && !hasTemplateBinding) {\n                // don't include the bindings as attributes as well in the AST\n                attrs.push(_this.visitAttribute(attr, null));\n                matchableAttrs.push([attr.name, attr.value]);\n            }\n        });\n        var elementCssSelector = createElementCssSelector(elName, matchableAttrs);\n        var _a = this._parseDirectives(this.selectorMatcher, elementCssSelector), directiveMetas = _a.directives, matchElement = _a.matchElement;\n        var references = [];\n        var boundDirectivePropNames = new Set();\n        var directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references, boundDirectivePropNames);\n        var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, boundDirectivePropNames);\n        var isViewRoot = parent.isTemplateElement || hasInlineTemplates;\n        var providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, isTemplateElement, queryStartIndex, element.sourceSpan);\n        var children = visitAll$1(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));\n        providerContext.afterElement();\n        // Override the actual selector when the `ngProjectAs` attribute is provided\n        var projectionSelector = preparsedElement.projectAs != '' ?\n            CssSelector.parse(preparsedElement.projectAs)[0] :\n            elementCssSelector;\n        var ngContentIndex = parent.findNgContentIndex(projectionSelector);\n        var parsedElement;\n        if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n            // `<ng-content>` element\n            if (element.children && !element.children.every(_isEmptyTextNode)) {\n                this._reportError(\"<ng-content> element cannot have content.\", element.sourceSpan);\n            }\n            parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\n        }\n        else if (isTemplateElement) {\n            // `<ng-template>` element\n            this._assertAllEventsPublishedByDirectives(directiveAsts, events);\n            this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);\n            parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\n        }\n        else {\n            // element other than `<ng-content>` and `<ng-template>`\n            this._assertElementExists(matchElement, element);\n            this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);\n            var ngContentIndex_1 = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);\n            parsedElement = new ElementAst(elName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex_1, element.sourceSpan, element.endSourceSpan || null);\n        }\n        if (hasInlineTemplates) {\n            // The element as a *-attribute\n            var templateQueryStartIndex = this.contentQueryStartId;\n            var templateSelector = createElementCssSelector('ng-template', templateMatchableAttrs);\n            var directives = this._parseDirectives(this.selectorMatcher, templateSelector).directives;\n            var templateBoundDirectivePropNames = new Set();\n            var templateDirectiveAsts = this._createDirectiveAsts(true, elName, directives, templateElementOrDirectiveProps, [], element.sourceSpan, [], templateBoundDirectivePropNames);\n            var templateElementProps = this._createElementPropertyAsts(elName, templateElementOrDirectiveProps, templateBoundDirectivePropNames);\n            this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);\n            var templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], true, templateQueryStartIndex, element.sourceSpan);\n            templateProviderContext.afterElement();\n            parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches, [parsedElement], ngContentIndex, element.sourceSpan);\n        }\n        return parsedElement;\n    };\n    TemplateParseVisitor.prototype._parseAttr = function (isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {\n        var name = this._normalizeAttributeName(attr.name);\n        var value = attr.value;\n        var srcSpan = attr.sourceSpan;\n        var absoluteOffset = attr.valueSpan ? attr.valueSpan.start.offset : srcSpan.start.offset;\n        var boundEvents = [];\n        var bindParts = name.match(BIND_NAME_REGEXP);\n        var hasBinding = false;\n        if (bindParts !== null) {\n            hasBinding = true;\n            if (bindParts[KW_BIND_IDX] != null) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[KW_LET_IDX]) {\n                if (isTemplateElement) {\n                    var identifier = bindParts[IDENT_KW_IDX];\n                    this._parseVariable(identifier, value, srcSpan, targetVars);\n                }\n                else {\n                    this._reportError(\"\\\"let-\\\" is only supported on ng-template elements.\", srcSpan);\n                }\n            }\n            else if (bindParts[KW_REF_IDX]) {\n                var identifier = bindParts[IDENT_KW_IDX];\n                this._parseReference(identifier, value, srcSpan, targetRefs);\n            }\n            else if (bindParts[KW_ON_IDX]) {\n                this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n            }\n            else if (bindParts[KW_BINDON_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n                this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n            }\n            else if (bindParts[KW_AT_IDX]) {\n                this._bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n                this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n            }\n            else if (bindParts[IDENT_PROPERTY_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[IDENT_EVENT_IDX]) {\n                this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n            }\n        }\n        else {\n            hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, attr.valueSpan, targetMatchableAttrs, targetProps);\n        }\n        if (!hasBinding) {\n            this._bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n        }\n        targetEvents.push.apply(targetEvents, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(boundEvents.map(function (e) { return BoundEventAst.fromParsedEvent(e); })));\n        return hasBinding;\n    };\n    TemplateParseVisitor.prototype._normalizeAttributeName = function (attrName) {\n        return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n    };\n    TemplateParseVisitor.prototype._parseVariable = function (identifier, value, sourceSpan, targetVars) {\n        if (identifier.indexOf('-') > -1) {\n            this._reportError(\"\\\"-\\\" is not allowed in variable names\", sourceSpan);\n        }\n        targetVars.push(new VariableAst(identifier, value, sourceSpan));\n    };\n    TemplateParseVisitor.prototype._parseReference = function (identifier, value, sourceSpan, targetRefs) {\n        if (identifier.indexOf('-') > -1) {\n            this._reportError(\"\\\"-\\\" is not allowed in reference names\", sourceSpan);\n        }\n        targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));\n    };\n    TemplateParseVisitor.prototype._parseAssignmentEvent = function (name, expression, sourceSpan, valueSpan, targetMatchableAttrs, targetEvents) {\n        this._bindingParser.parseEvent(name + \"Change\", expression + \"=$event\", sourceSpan, valueSpan, targetMatchableAttrs, targetEvents);\n    };\n    TemplateParseVisitor.prototype._parseDirectives = function (selectorMatcher, elementCssSelector) {\n        var _this = this;\n        // Need to sort the directives so that we get consistent results throughout,\n        // as selectorMatcher uses Maps inside.\n        // Also deduplicate directives as they might match more than one time!\n        var directives = new Array(this.directivesIndex.size);\n        // Whether any directive selector matches on the element name\n        var matchElement = false;\n        selectorMatcher.match(elementCssSelector, function (selector, directive) {\n            directives[_this.directivesIndex.get(directive)] = directive;\n            matchElement = matchElement || selector.hasElementSelector();\n        });\n        return {\n            directives: directives.filter(function (dir) { return !!dir; }),\n            matchElement: matchElement,\n        };\n    };\n    TemplateParseVisitor.prototype._createDirectiveAsts = function (isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences, targetBoundDirectivePropNames) {\n        var _this = this;\n        var matchedReferences = new Set();\n        var component = null;\n        var directiveAsts = directives.map(function (directive) {\n            var sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, \"Directive \" + identifierName(directive.type));\n            if (directive.isComponent) {\n                component = directive;\n            }\n            var directiveProperties = [];\n            var boundProperties = _this._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan);\n            var hostProperties = boundProperties.map(function (prop) { return BoundElementPropertyAst.fromBoundProperty(prop); });\n            // Note: We need to check the host properties here as well,\n            // as we don't know the element name in the DirectiveWrapperCompiler yet.\n            hostProperties = _this._checkPropertiesInSchema(elementName, hostProperties);\n            var parsedEvents = _this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan);\n            _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);\n            elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n                if ((elOrDirRef.value.length === 0 && directive.isComponent) ||\n                    (elOrDirRef.isReferenceToDirective(directive))) {\n                    targetReferences.push(new ReferenceAst(elOrDirRef.name, createTokenForReference(directive.type.reference), elOrDirRef.value, elOrDirRef.sourceSpan));\n                    matchedReferences.add(elOrDirRef.name);\n                }\n            });\n            var hostEvents = parsedEvents.map(function (e) { return BoundEventAst.fromParsedEvent(e); });\n            var contentQueryStartId = _this.contentQueryStartId;\n            _this.contentQueryStartId += directive.queries.length;\n            return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId, sourceSpan);\n        });\n        elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n            if (elOrDirRef.value.length > 0) {\n                if (!matchedReferences.has(elOrDirRef.name)) {\n                    _this._reportError(\"There is no directive with \\\"exportAs\\\" set to \\\"\" + elOrDirRef.value + \"\\\"\", elOrDirRef.sourceSpan);\n                }\n            }\n            else if (!component) {\n                var refToken = null;\n                if (isTemplateElement) {\n                    refToken = createTokenForExternalReference(_this.reflector, Identifiers.TemplateRef);\n                }\n                targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.value, elOrDirRef.sourceSpan));\n            }\n        });\n        return directiveAsts;\n    };\n    TemplateParseVisitor.prototype._createDirectivePropertyAsts = function (directiveProperties, boundProps, targetBoundDirectiveProps, targetBoundDirectivePropNames) {\n        if (directiveProperties) {\n            var boundPropsByName_1 = new Map();\n            boundProps.forEach(function (boundProp) {\n                var prevValue = boundPropsByName_1.get(boundProp.name);\n                if (!prevValue || prevValue.isLiteral) {\n                    // give [a]=\"b\" a higher precedence than a=\"b\" on the same element\n                    boundPropsByName_1.set(boundProp.name, boundProp);\n                }\n            });\n            Object.keys(directiveProperties).forEach(function (dirProp) {\n                var elProp = directiveProperties[dirProp];\n                var boundProp = boundPropsByName_1.get(elProp);\n                // Bindings are optional, so this binding only needs to be set up if an expression is given.\n                if (boundProp) {\n                    targetBoundDirectivePropNames.add(boundProp.name);\n                    if (!isEmptyExpression(boundProp.expression)) {\n                        targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));\n                    }\n                }\n            });\n        }\n    };\n    TemplateParseVisitor.prototype._createElementPropertyAsts = function (elementName, props, boundDirectivePropNames) {\n        var _this = this;\n        var boundElementProps = [];\n        props.forEach(function (prop) {\n            if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {\n                var boundProp = _this._bindingParser.createBoundElementProperty(elementName, prop);\n                boundElementProps.push(BoundElementPropertyAst.fromBoundProperty(boundProp));\n            }\n        });\n        return this._checkPropertiesInSchema(elementName, boundElementProps);\n    };\n    TemplateParseVisitor.prototype._findComponentDirectives = function (directives) {\n        return directives.filter(function (directive) { return directive.directive.isComponent; });\n    };\n    TemplateParseVisitor.prototype._findComponentDirectiveNames = function (directives) {\n        return this._findComponentDirectives(directives)\n            .map(function (directive) { return identifierName(directive.directive.type); });\n    };\n    TemplateParseVisitor.prototype._assertOnlyOneComponent = function (directives, sourceSpan) {\n        var componentTypeNames = this._findComponentDirectiveNames(directives);\n        if (componentTypeNames.length > 1) {\n            this._reportError(\"More than one component matched on this element.\\n\" +\n                \"Make sure that only one component's selector can match a given element.\\n\" +\n                (\"Conflicting components: \" + componentTypeNames.join(',')), sourceSpan);\n        }\n    };\n    /**\n     * Make sure that non-angular tags conform to the schemas.\n     *\n     * Note: An element is considered an angular tag when at least one directive selector matches the\n     * tag name.\n     *\n     * @param matchElement Whether any directive has matched on the tag name\n     * @param element the html element\n     */\n    TemplateParseVisitor.prototype._assertElementExists = function (matchElement, element) {\n        var elName = element.name.replace(/^:xhtml:/, '');\n        if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {\n            var errorMsg = \"'\" + elName + \"' is not a known element:\\n\";\n            errorMsg +=\n                \"1. If '\" + elName + \"' is an Angular component, then verify that it is part of this module.\\n\";\n            if (elName.indexOf('-') > -1) {\n                errorMsg +=\n                    \"2. If '\" + elName + \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\";\n            }\n            else {\n                errorMsg +=\n                    \"2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n            }\n            this._reportError(errorMsg, element.sourceSpan);\n        }\n    };\n    TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function (directives, elementProps, sourceSpan) {\n        var _this = this;\n        var componentTypeNames = this._findComponentDirectiveNames(directives);\n        if (componentTypeNames.length > 0) {\n            this._reportError(\"Components on an embedded template: \" + componentTypeNames.join(','), sourceSpan);\n        }\n        elementProps.forEach(function (prop) {\n            _this._reportError(\"Property binding \" + prop.name + \" not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\", sourceSpan);\n        });\n    };\n    TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function (directives, events) {\n        var _this = this;\n        var allDirectiveEvents = new Set();\n        directives.forEach(function (directive) {\n            Object.keys(directive.directive.outputs).forEach(function (k) {\n                var eventName = directive.directive.outputs[k];\n                allDirectiveEvents.add(eventName);\n            });\n        });\n        events.forEach(function (event) {\n            if (event.target != null || !allDirectiveEvents.has(event.name)) {\n                _this._reportError(\"Event binding \" + event.fullName + \" not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\", event.sourceSpan);\n            }\n        });\n    };\n    TemplateParseVisitor.prototype._checkPropertiesInSchema = function (elementName, boundProps) {\n        var _this = this;\n        // Note: We can't filter out empty expressions before this method,\n        // as we still want to validate them!\n        return boundProps.filter(function (boundProp) {\n            if (boundProp.type === 0 /* Property */ &&\n                !_this._schemaRegistry.hasProperty(elementName, boundProp.name, _this._schemas)) {\n                var errorMsg = \"Can't bind to '\" + boundProp.name + \"' since it isn't a known property of '\" + elementName + \"'.\";\n                if (elementName.startsWith('ng-')) {\n                    errorMsg +=\n                        \"\\n1. If '\" + boundProp.name + \"' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.\" +\n                            \"\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n                }\n                else if (elementName.indexOf('-') > -1) {\n                    errorMsg +=\n                        \"\\n1. If '\" + elementName + \"' is an Angular component and it has '\" + boundProp.name + \"' input, then verify that it is part of this module.\" +\n                            (\"\\n2. If '\" + elementName + \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\") +\n                            \"\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n                }\n                _this._reportError(errorMsg, boundProp.sourceSpan);\n            }\n            return !isEmptyExpression(boundProp.value);\n        });\n    };\n    TemplateParseVisitor.prototype._reportError = function (message, sourceSpan, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this._targetErrors.push(new ParseError(sourceSpan, message, level));\n    };\n    return TemplateParseVisitor;\n}());\nvar NonBindableVisitor = /** @class */ (function () {\n    function NonBindableVisitor() {\n    }\n    NonBindableVisitor.prototype.visitElement = function (ast, parent) {\n        var preparsedElement = preparseElement(ast);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE ||\n            preparsedElement.type === PreparsedElementType.STYLESHEET) {\n            // Skipping <script> for security reasons\n            // Skipping <style> and stylesheets as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        var attrNameAndValues = ast.attrs.map(function (attr) { return [attr.name, attr.value]; });\n        var selector = createElementCssSelector(ast.name, attrNameAndValues);\n        var ngContentIndex = parent.findNgContentIndex(selector);\n        var children = visitAll$1(this, ast.children, EMPTY_ELEMENT_CONTEXT);\n        return new ElementAst(ast.name, visitAll$1(this, ast.attrs), [], [], [], [], [], false, [], children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);\n    };\n    NonBindableVisitor.prototype.visitComment = function (comment, context) { return null; };\n    NonBindableVisitor.prototype.visitAttribute = function (attribute, context) {\n        return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    };\n    NonBindableVisitor.prototype.visitText = function (text, parent) {\n        var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());\n        return new TextAst(text.value, ngContentIndex, text.sourceSpan);\n    };\n    NonBindableVisitor.prototype.visitExpansion = function (expansion, context) { return expansion; };\n    NonBindableVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return expansionCase; };\n    return NonBindableVisitor;\n}());\n/**\n * A reference to an element or directive in a template. E.g., the reference in this template:\n *\n * <div #myMenu=\"coolMenu\">\n *\n * would be {name: 'myMenu', value: 'coolMenu', sourceSpan: ...}\n */\nvar ElementOrDirectiveRef = /** @class */ (function () {\n    function ElementOrDirectiveRef(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /** Gets whether this is a reference to the given directive. */\n    ElementOrDirectiveRef.prototype.isReferenceToDirective = function (directive) {\n        return splitExportAs(directive.exportAs).indexOf(this.value) !== -1;\n    };\n    return ElementOrDirectiveRef;\n}());\n/** Splits a raw, potentially comma-delimited `exportAs` value into an array of names. */\nfunction splitExportAs(exportAs) {\n    return exportAs ? exportAs.split(',').map(function (e) { return e.trim(); }) : [];\n}\nfunction splitClasses(classAttrValue) {\n    return classAttrValue.trim().split(/\\s+/g);\n}\nvar ElementContext = /** @class */ (function () {\n    function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {\n        this.isTemplateElement = isTemplateElement;\n        this._ngContentIndexMatcher = _ngContentIndexMatcher;\n        this._wildcardNgContentIndex = _wildcardNgContentIndex;\n        this.providerContext = providerContext;\n    }\n    ElementContext.create = function (isTemplateElement, directives, providerContext) {\n        var matcher = new SelectorMatcher();\n        var wildcardNgContentIndex = null;\n        var component = directives.find(function (directive) { return directive.directive.isComponent; });\n        if (component) {\n            var ngContentSelectors = component.directive.template.ngContentSelectors;\n            for (var i = 0; i < ngContentSelectors.length; i++) {\n                var selector = ngContentSelectors[i];\n                if (selector === '*') {\n                    wildcardNgContentIndex = i;\n                }\n                else {\n                    matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);\n                }\n            }\n        }\n        return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);\n    };\n    ElementContext.prototype.findNgContentIndex = function (selector) {\n        var ngContentIndices = [];\n        this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) { ngContentIndices.push(ngContentIndex); });\n        ngContentIndices.sort();\n        if (this._wildcardNgContentIndex != null) {\n            ngContentIndices.push(this._wildcardNgContentIndex);\n        }\n        return ngContentIndices.length > 0 ? ngContentIndices[0] : null;\n    };\n    return ElementContext;\n}());\nfunction createElementCssSelector(elementName, attributes) {\n    var cssSelector = new CssSelector();\n    var elNameNoNs = splitNsName(elementName)[1];\n    cssSelector.setElement(elNameNoNs);\n    for (var i = 0; i < attributes.length; i++) {\n        var attrName = attributes[i][0];\n        var attrNameNoNs = splitNsName(attrName)[1];\n        var attrValue = attributes[i][1];\n        cssSelector.addAttribute(attrNameNoNs, attrValue);\n        if (attrName.toLowerCase() == CLASS_ATTR) {\n            var classes = splitClasses(attrValue);\n            classes.forEach(function (className) { return cssSelector.addClassName(className); });\n        }\n    }\n    return cssSelector;\n}\nvar EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);\nvar NON_BINDABLE_VISITOR = new NonBindableVisitor();\nfunction _isEmptyTextNode(node) {\n    return node instanceof Text$3 && node.value.trim().length == 0;\n}\nfunction removeSummaryDuplicates(items) {\n    var map = new Map();\n    items.forEach(function (item) {\n        if (!map.get(item.type.reference)) {\n            map.set(item.type.reference, item);\n        }\n    });\n    return Array.from(map.values());\n}\nfunction isEmptyExpression(ast) {\n    if (ast instanceof ASTWithSource) {\n        ast = ast.ast;\n    }\n    return ast instanceof EmptyExpr;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Parses string representation of a style and converts it into object literal.\n *\n * @param value string representation of style as used in the `style` attribute in HTML.\n *   Example: `color: red; height: auto`.\n * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',\n * 'auto']`\n */\nfunction parse(value) {\n    // we use a string array here instead of a string map\n    // because a string-map is not guaranteed to retain the\n    // order of the entries whereas a string array can be\n    // construted in a [key, value, key, value] format.\n    var styles = [];\n    var i = 0;\n    var parenDepth = 0;\n    var quote = 0 /* QuoteNone */;\n    var valueStart = 0;\n    var propStart = 0;\n    var currentProp = null;\n    var valueHasQuotes = false;\n    while (i < value.length) {\n        var token = value.charCodeAt(i++);\n        switch (token) {\n            case 40 /* OpenParen */:\n                parenDepth++;\n                break;\n            case 41 /* CloseParen */:\n                parenDepth--;\n                break;\n            case 39 /* QuoteSingle */:\n                // valueStart needs to be there since prop values don't\n                // have quotes in CSS\n                valueHasQuotes = valueHasQuotes || valueStart > 0;\n                if (quote === 0 /* QuoteNone */) {\n                    quote = 39 /* QuoteSingle */;\n                }\n                else if (quote === 39 /* QuoteSingle */ && value.charCodeAt(i - 1) !== 92 /* BackSlash */) {\n                    quote = 0 /* QuoteNone */;\n                }\n                break;\n            case 34 /* QuoteDouble */:\n                // same logic as above\n                valueHasQuotes = valueHasQuotes || valueStart > 0;\n                if (quote === 0 /* QuoteNone */) {\n                    quote = 34 /* QuoteDouble */;\n                }\n                else if (quote === 34 /* QuoteDouble */ && value.charCodeAt(i - 1) !== 92 /* BackSlash */) {\n                    quote = 0 /* QuoteNone */;\n                }\n                break;\n            case 58 /* Colon */:\n                if (!currentProp && parenDepth === 0 && quote === 0 /* QuoteNone */) {\n                    currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n                    valueStart = i;\n                }\n                break;\n            case 59 /* Semicolon */:\n                if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0 /* QuoteNone */) {\n                    var styleVal = value.substring(valueStart, i - 1).trim();\n                    styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n                    propStart = i;\n                    valueStart = 0;\n                    currentProp = null;\n                    valueHasQuotes = false;\n                }\n                break;\n        }\n    }\n    if (currentProp && valueStart) {\n        var styleVal = value.substr(valueStart).trim();\n        styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n    }\n    return styles;\n}\nfunction stripUnnecessaryQuotes(value) {\n    var qS = value.charCodeAt(0);\n    var qE = value.charCodeAt(value.length - 1);\n    if (qS == qE && (qS == 39 /* QuoteSingle */ || qS == 34 /* QuoteDouble */)) {\n        var tempValue = value.substring(1, value.length - 1);\n        // special case to avoid using a multi-quoted string that was just chomped\n        // (e.g. `font-family: \"Verdana\", \"sans-serif\"`)\n        if (tempValue.indexOf('\\'') == -1 && tempValue.indexOf('\"') == -1) {\n            value = tempValue;\n        }\n    }\n    return value;\n}\nfunction hyphenate(value) {\n    return value.replace(/[a-z][A-Z]/g, function (v) {\n        return v.charAt(0) + '-' + v.charAt(1);\n    }).toLowerCase();\n}\n\nvar IMPORTANT_FLAG = '!important';\n/**\n * Produces creation/update instructions for all styling bindings (class and style)\n *\n * It also produces the creation instruction to register all initial styling values\n * (which are all the static class=\"...\" and style=\"...\" attribute values that exist\n * on an element within a template).\n *\n * The builder class below handles producing instructions for the following cases:\n *\n * - Static style/class attributes (style=\"...\" and class=\"...\")\n * - Dynamic style/class map bindings ([style]=\"map\" and [class]=\"map|string\")\n * - Dynamic style/class property bindings ([style.prop]=\"exp\" and [class.name]=\"exp\")\n *\n * Due to the complex relationship of all of these cases, the instructions generated\n * for these attributes/properties/bindings must be done so in the correct order. The\n * order which these must be generated is as follows:\n *\n * if (createMode) {\n *   styling(...)\n * }\n * if (updateMode) {\n *   styleMap(...)\n *   classMap(...)\n *   styleProp(...)\n *   classProp(...)\n *   stylingApply(...)\n * }\n *\n * The creation/update methods within the builder class produce these instructions.\n */\nvar StylingBuilder = /** @class */ (function () {\n    function StylingBuilder(_elementIndexExpr, _directiveExpr) {\n        this._elementIndexExpr = _elementIndexExpr;\n        this._directiveExpr = _directiveExpr;\n        /** Whether or not there are any static styling values present */\n        this._hasInitialValues = false;\n        /**\n         *  Whether or not there are any styling bindings present\n         *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)\n         */\n        this.hasBindings = false;\n        /** the input for [class] (if it exists) */\n        this._classMapInput = null;\n        /** the input for [style] (if it exists) */\n        this._styleMapInput = null;\n        /** an array of each [style.prop] input */\n        this._singleStyleInputs = null;\n        /** an array of each [class.name] input */\n        this._singleClassInputs = null;\n        this._lastStylingInput = null;\n        this._firstStylingInput = null;\n        // maps are used instead of hash maps because a Map will\n        // retain the ordering of the keys\n        /**\n         * Represents the location of each style binding in the template\n         * (e.g. `<div [style.width]=\"w\" [style.height]=\"h\">` implies\n         * that `width=0` and `height=1`)\n         */\n        this._stylesIndex = new Map();\n        /**\n         * Represents the location of each class binding in the template\n         * (e.g. `<div [class.big]=\"b\" [class.hidden]=\"h\">` implies\n         * that `big=0` and `hidden=1`)\n         */\n        this._classesIndex = new Map();\n        this._initialStyleValues = [];\n        this._initialClassValues = [];\n        // certain style properties ALWAYS need sanitization\n        // this is checked each time new styles are encountered\n        this._useDefaultSanitizer = false;\n    }\n    /**\n     * Registers a given input to the styling builder to be later used when producing AOT code.\n     *\n     * The code below will only accept the input if it is somehow tied to styling (whether it be\n     * style/class bindings or static style/class attributes).\n     */\n    StylingBuilder.prototype.registerBoundInput = function (input) {\n        // [attr.style] or [attr.class] are skipped in the code below,\n        // they should not be treated as styling-based bindings since\n        // they are intended to be written directly to the attr and\n        // will therefore skip all style/class resolution that is present\n        // with style=\"\", [style]=\"\" and [style.prop]=\"\", class=\"\",\n        // [class.prop]=\"\". [class]=\"\" assignments\n        var binding = null;\n        var name = input.name;\n        switch (input.type) {\n            case 0 /* Property */:\n                binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);\n                break;\n            case 3 /* Style */:\n                binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);\n                break;\n            case 2 /* Class */:\n                binding = this.registerClassInput(name, false, input.value, input.sourceSpan);\n                break;\n        }\n        return binding ? true : false;\n    };\n    StylingBuilder.prototype.registerInputBasedOnName = function (name, expression, sourceSpan) {\n        var binding = null;\n        var nameToMatch = name.substring(0, 5); // class | style\n        var isStyle = nameToMatch === 'style';\n        var isClass = isStyle ? false : (nameToMatch === 'class');\n        if (isStyle || isClass) {\n            var isMapBased = name.charAt(5) !== '.'; // style.prop or class.prop makes this a no\n            var property = name.substr(isMapBased ? 5 : 6); // the dot explains why there's a +1\n            if (isStyle) {\n                binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);\n            }\n            else {\n                binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);\n            }\n        }\n        return binding;\n    };\n    StylingBuilder.prototype.registerStyleInput = function (name, isMapBased, value, sourceSpan, unit) {\n        if (isEmptyExpression(value)) {\n            return null;\n        }\n        name = normalizePropName(name);\n        var _a = parseProperty(name), property = _a.property, hasOverrideFlag = _a.hasOverrideFlag, bindingUnit = _a.unit;\n        var entry = {\n            name: property,\n            unit: unit || bindingUnit, value: value, sourceSpan: sourceSpan, hasOverrideFlag: hasOverrideFlag\n        };\n        if (isMapBased) {\n            this._useDefaultSanitizer = true;\n            this._styleMapInput = entry;\n        }\n        else {\n            (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);\n            this._useDefaultSanitizer = this._useDefaultSanitizer || isStyleSanitizable(name);\n            registerIntoMap(this._stylesIndex, property);\n        }\n        this._lastStylingInput = entry;\n        this._firstStylingInput = this._firstStylingInput || entry;\n        this.hasBindings = true;\n        return entry;\n    };\n    StylingBuilder.prototype.registerClassInput = function (name, isMapBased, value, sourceSpan) {\n        if (isEmptyExpression(value)) {\n            return null;\n        }\n        var _a = parseProperty(name), property = _a.property, hasOverrideFlag = _a.hasOverrideFlag;\n        var entry = { name: property, value: value, sourceSpan: sourceSpan, hasOverrideFlag: hasOverrideFlag, unit: null };\n        if (isMapBased) {\n            this._classMapInput = entry;\n        }\n        else {\n            (this._singleClassInputs = this._singleClassInputs || []).push(entry);\n            registerIntoMap(this._classesIndex, property);\n        }\n        this._lastStylingInput = entry;\n        this._firstStylingInput = this._firstStylingInput || entry;\n        this.hasBindings = true;\n        return entry;\n    };\n    /**\n     * Registers the element's static style string value to the builder.\n     *\n     * @param value the style string (e.g. `width:100px; height:200px;`)\n     */\n    StylingBuilder.prototype.registerStyleAttr = function (value) {\n        this._initialStyleValues = parse(value);\n        this._hasInitialValues = true;\n    };\n    /**\n     * Registers the element's static class string value to the builder.\n     *\n     * @param value the className string (e.g. `disabled gold zoom`)\n     */\n    StylingBuilder.prototype.registerClassAttr = function (value) {\n        this._initialClassValues = value.trim().split(/\\s+/g);\n        this._hasInitialValues = true;\n    };\n    /**\n     * Appends all styling-related expressions to the provided attrs array.\n     *\n     * @param attrs an existing array where each of the styling expressions\n     * will be inserted into.\n     */\n    StylingBuilder.prototype.populateInitialStylingAttrs = function (attrs) {\n        // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]\n        if (this._initialClassValues.length) {\n            attrs.push(literal(1 /* Classes */));\n            for (var i = 0; i < this._initialClassValues.length; i++) {\n                attrs.push(literal(this._initialClassValues[i]));\n            }\n        }\n        // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]\n        if (this._initialStyleValues.length) {\n            attrs.push(literal(2 /* Styles */));\n            for (var i = 0; i < this._initialStyleValues.length; i += 2) {\n                attrs.push(literal(this._initialStyleValues[i]), literal(this._initialStyleValues[i + 1]));\n            }\n        }\n    };\n    /**\n     * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.\n     *\n     * The instruction generation code below is used for producing the AOT statement code which is\n     * responsible for registering initial styles (within a directive hostBindings' creation block),\n     * as well as any of the provided attribute values, to the directive host element.\n     */\n    StylingBuilder.prototype.buildHostAttrsInstruction = function (sourceSpan, attrs, constantPool) {\n        var _this = this;\n        if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {\n            return {\n                sourceSpan: sourceSpan,\n                reference: Identifiers$1.elementHostAttrs,\n                allocateBindingSlots: 0,\n                params: function () {\n                    // params => elementHostAttrs(attrs)\n                    _this.populateInitialStylingAttrs(attrs);\n                    var attrArray = !attrs.some(function (attr) { return attr instanceof WrappedNodeExpr; }) ?\n                        getConstantLiteralFromArray(constantPool, attrs) :\n                        literalArr(attrs);\n                    return [attrArray];\n                }\n            };\n        }\n        return null;\n    };\n    /**\n     * Builds an instruction with all the expressions and parameters for `styling`.\n     *\n     * The instruction generation code below is used for producing the AOT statement code which is\n     * responsible for registering style/class bindings to an element.\n     */\n    StylingBuilder.prototype.buildStylingInstruction = function (sourceSpan, constantPool) {\n        if (this.hasBindings) {\n            return {\n                sourceSpan: sourceSpan,\n                allocateBindingSlots: 0,\n                reference: Identifiers$1.styling,\n                params: function () { return []; },\n            };\n        }\n        return null;\n    };\n    /**\n     * Builds an instruction with all the expressions and parameters for `classMap`.\n     *\n     * The instruction data will contain all expressions for `classMap` to function\n     * which includes the `[class]` expression params.\n     */\n    StylingBuilder.prototype.buildClassMapInstruction = function (valueConverter) {\n        if (this._classMapInput) {\n            return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);\n        }\n        return null;\n    };\n    /**\n     * Builds an instruction with all the expressions and parameters for `styleMap`.\n     *\n     * The instruction data will contain all expressions for `styleMap` to function\n     * which includes the `[style]` expression params.\n     */\n    StylingBuilder.prototype.buildStyleMapInstruction = function (valueConverter) {\n        if (this._styleMapInput) {\n            return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);\n        }\n        return null;\n    };\n    StylingBuilder.prototype._buildMapBasedInstruction = function (valueConverter, isClassBased, stylingInput) {\n        // each styling binding value is stored in the LView\n        var totalBindingSlotsRequired = 1;\n        // these values must be outside of the update block so that they can\n        // be evaluated (the AST visit call) during creation time so that any\n        // pipes can be picked up in time before the template is built\n        var mapValue = stylingInput.value.visit(valueConverter);\n        var reference;\n        if (mapValue instanceof Interpolation && isClassBased) {\n            totalBindingSlotsRequired += mapValue.expressions.length;\n            reference = getClassMapInterpolationExpression(mapValue);\n        }\n        else {\n            reference = isClassBased ? Identifiers$1.classMap : Identifiers$1.styleMap;\n        }\n        return {\n            sourceSpan: stylingInput.sourceSpan,\n            reference: reference,\n            allocateBindingSlots: totalBindingSlotsRequired,\n            supportsInterpolation: isClassBased,\n            params: function (convertFn) {\n                var convertResult = convertFn(mapValue);\n                return Array.isArray(convertResult) ? convertResult : [convertResult];\n            }\n        };\n    };\n    StylingBuilder.prototype._buildSingleInputs = function (reference, inputs, mapIndex, allowUnits, valueConverter, getInterpolationExpressionFn) {\n        var totalBindingSlotsRequired = 0;\n        return inputs.map(function (input) {\n            var value = input.value.visit(valueConverter);\n            // each styling binding value is stored in the LView\n            var totalBindingSlotsRequired = 1;\n            if (value instanceof Interpolation) {\n                totalBindingSlotsRequired += value.expressions.length;\n                if (getInterpolationExpressionFn) {\n                    reference = getInterpolationExpressionFn(value);\n                }\n            }\n            return {\n                sourceSpan: input.sourceSpan,\n                supportsInterpolation: !!getInterpolationExpressionFn,\n                allocateBindingSlots: totalBindingSlotsRequired, reference: reference,\n                params: function (convertFn) {\n                    // params => stylingProp(propName, value)\n                    var params = [];\n                    params.push(literal(input.name));\n                    var convertResult = convertFn(value);\n                    if (Array.isArray(convertResult)) {\n                        params.push.apply(params, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(convertResult));\n                    }\n                    else {\n                        params.push(convertResult);\n                    }\n                    if (allowUnits && input.unit) {\n                        params.push(literal(input.unit));\n                    }\n                    return params;\n                }\n            };\n        });\n    };\n    StylingBuilder.prototype._buildClassInputs = function (valueConverter) {\n        if (this._singleClassInputs) {\n            return this._buildSingleInputs(Identifiers$1.classProp, this._singleClassInputs, this._classesIndex, false, valueConverter);\n        }\n        return [];\n    };\n    StylingBuilder.prototype._buildStyleInputs = function (valueConverter) {\n        if (this._singleStyleInputs) {\n            return this._buildSingleInputs(Identifiers$1.styleProp, this._singleStyleInputs, this._stylesIndex, true, valueConverter, getStylePropInterpolationExpression);\n        }\n        return [];\n    };\n    StylingBuilder.prototype._buildApplyFn = function () {\n        return {\n            sourceSpan: this._lastStylingInput ? this._lastStylingInput.sourceSpan : null,\n            reference: Identifiers$1.stylingApply,\n            allocateBindingSlots: 0,\n            params: function () { return []; }\n        };\n    };\n    StylingBuilder.prototype._buildSanitizerFn = function () {\n        return {\n            sourceSpan: this._firstStylingInput ? this._firstStylingInput.sourceSpan : null,\n            reference: Identifiers$1.styleSanitizer,\n            allocateBindingSlots: 0,\n            params: function () { return [importExpr(Identifiers$1.defaultStyleSanitizer)]; }\n        };\n    };\n    /**\n     * Constructs all instructions which contain the expressions that will be placed\n     * into the update block of a template function or a directive hostBindings function.\n     */\n    StylingBuilder.prototype.buildUpdateLevelInstructions = function (valueConverter) {\n        var instructions = [];\n        if (this.hasBindings) {\n            if (this._useDefaultSanitizer) {\n                instructions.push(this._buildSanitizerFn());\n            }\n            var styleMapInstruction = this.buildStyleMapInstruction(valueConverter);\n            if (styleMapInstruction) {\n                instructions.push(styleMapInstruction);\n            }\n            var classMapInstruction = this.buildClassMapInstruction(valueConverter);\n            if (classMapInstruction) {\n                instructions.push(classMapInstruction);\n            }\n            instructions.push.apply(instructions, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this._buildStyleInputs(valueConverter)));\n            instructions.push.apply(instructions, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this._buildClassInputs(valueConverter)));\n            instructions.push(this._buildApplyFn());\n        }\n        return instructions;\n    };\n    return StylingBuilder;\n}());\nfunction registerIntoMap(map, key) {\n    if (!map.has(key)) {\n        map.set(key, map.size);\n    }\n}\nfunction isStyleSanitizable(prop) {\n    // Note that browsers support both the dash case and\n    // camel case property names when setting through JS.\n    return prop === 'background-image' || prop === 'backgroundImage' || prop === 'background' ||\n        prop === 'border-image' || prop === 'borderImage' || prop === 'filter' ||\n        prop === 'list-style' || prop === 'listStyle' || prop === 'list-style-image' ||\n        prop === 'listStyleImage' || prop === 'clip-path' || prop === 'clipPath';\n}\n/**\n * Simple helper function to either provide the constant literal that will house the value\n * here or a null value if the provided values are empty.\n */\nfunction getConstantLiteralFromArray(constantPool, values) {\n    return values.length ? constantPool.getConstLiteral(literalArr(values), true) : NULL_EXPR;\n}\n/**\n * Simple helper function that adds a parameter or does nothing at all depending on the provided\n * predicate and totalExpectedArgs values\n */\nfunction addParam(params, predicate, value, argNumber, totalExpectedArgs) {\n    if (predicate && value) {\n        params.push(value);\n    }\n    else if (argNumber < totalExpectedArgs) {\n        params.push(NULL_EXPR);\n    }\n}\nfunction parseProperty(name) {\n    var hasOverrideFlag = false;\n    var overrideIndex = name.indexOf(IMPORTANT_FLAG);\n    if (overrideIndex !== -1) {\n        name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\n        hasOverrideFlag = true;\n    }\n    var unit = '';\n    var property = name;\n    var unitIndex = name.lastIndexOf('.');\n    if (unitIndex > 0) {\n        unit = name.substr(unitIndex + 1);\n        property = name.substring(0, unitIndex);\n    }\n    return { property: property, unit: unit, hasOverrideFlag: hasOverrideFlag };\n}\n/**\n * Gets the instruction to generate for an interpolated class map.\n * @param interpolation An Interpolation AST\n */\nfunction getClassMapInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers$1.classMap;\n        case 3:\n            return Identifiers$1.classMapInterpolate1;\n        case 5:\n            return Identifiers$1.classMapInterpolate2;\n        case 7:\n            return Identifiers$1.classMapInterpolate3;\n        case 9:\n            return Identifiers$1.classMapInterpolate4;\n        case 11:\n            return Identifiers$1.classMapInterpolate5;\n        case 13:\n            return Identifiers$1.classMapInterpolate6;\n        case 15:\n            return Identifiers$1.classMapInterpolate7;\n        case 17:\n            return Identifiers$1.classMapInterpolate8;\n        default:\n            return Identifiers$1.classMapInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for an interpolated style prop.\n * @param interpolation An Interpolation AST\n */\nfunction getStylePropInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers$1.styleProp;\n        case 3:\n            return Identifiers$1.stylePropInterpolate1;\n        case 5:\n            return Identifiers$1.stylePropInterpolate2;\n        case 7:\n            return Identifiers$1.stylePropInterpolate3;\n        case 9:\n            return Identifiers$1.stylePropInterpolate4;\n        case 11:\n            return Identifiers$1.stylePropInterpolate5;\n        case 13:\n            return Identifiers$1.stylePropInterpolate6;\n        case 15:\n            return Identifiers$1.stylePropInterpolate7;\n        case 17:\n            return Identifiers$1.stylePropInterpolate8;\n        default:\n            return Identifiers$1.stylePropInterpolateV;\n    }\n}\nfunction normalizePropName(prop) {\n    return hyphenate(prop);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TokenType$1;\n(function (TokenType) {\n    TokenType[TokenType[\"Character\"] = 0] = \"Character\";\n    TokenType[TokenType[\"Identifier\"] = 1] = \"Identifier\";\n    TokenType[TokenType[\"Keyword\"] = 2] = \"Keyword\";\n    TokenType[TokenType[\"String\"] = 3] = \"String\";\n    TokenType[TokenType[\"Operator\"] = 4] = \"Operator\";\n    TokenType[TokenType[\"Number\"] = 5] = \"Number\";\n    TokenType[TokenType[\"Error\"] = 6] = \"Error\";\n})(TokenType$1 || (TokenType$1 = {}));\nvar KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\nvar Lexer = /** @class */ (function () {\n    function Lexer() {\n    }\n    Lexer.prototype.tokenize = function (text) {\n        var scanner = new _Scanner(text);\n        var tokens = [];\n        var token = scanner.scanToken();\n        while (token != null) {\n            tokens.push(token);\n            token = scanner.scanToken();\n        }\n        return tokens;\n    };\n    return Lexer;\n}());\nvar Token$1 = /** @class */ (function () {\n    function Token(index, type, numValue, strValue) {\n        this.index = index;\n        this.type = type;\n        this.numValue = numValue;\n        this.strValue = strValue;\n    }\n    Token.prototype.isCharacter = function (code) {\n        return this.type == TokenType$1.Character && this.numValue == code;\n    };\n    Token.prototype.isNumber = function () { return this.type == TokenType$1.Number; };\n    Token.prototype.isString = function () { return this.type == TokenType$1.String; };\n    Token.prototype.isOperator = function (operator) {\n        return this.type == TokenType$1.Operator && this.strValue == operator;\n    };\n    Token.prototype.isIdentifier = function () { return this.type == TokenType$1.Identifier; };\n    Token.prototype.isKeyword = function () { return this.type == TokenType$1.Keyword; };\n    Token.prototype.isKeywordLet = function () { return this.type == TokenType$1.Keyword && this.strValue == 'let'; };\n    Token.prototype.isKeywordAs = function () { return this.type == TokenType$1.Keyword && this.strValue == 'as'; };\n    Token.prototype.isKeywordNull = function () { return this.type == TokenType$1.Keyword && this.strValue == 'null'; };\n    Token.prototype.isKeywordUndefined = function () {\n        return this.type == TokenType$1.Keyword && this.strValue == 'undefined';\n    };\n    Token.prototype.isKeywordTrue = function () { return this.type == TokenType$1.Keyword && this.strValue == 'true'; };\n    Token.prototype.isKeywordFalse = function () { return this.type == TokenType$1.Keyword && this.strValue == 'false'; };\n    Token.prototype.isKeywordThis = function () { return this.type == TokenType$1.Keyword && this.strValue == 'this'; };\n    Token.prototype.isError = function () { return this.type == TokenType$1.Error; };\n    Token.prototype.toNumber = function () { return this.type == TokenType$1.Number ? this.numValue : -1; };\n    Token.prototype.toString = function () {\n        switch (this.type) {\n            case TokenType$1.Character:\n            case TokenType$1.Identifier:\n            case TokenType$1.Keyword:\n            case TokenType$1.Operator:\n            case TokenType$1.String:\n            case TokenType$1.Error:\n                return this.strValue;\n            case TokenType$1.Number:\n                return this.numValue.toString();\n            default:\n                return null;\n        }\n    };\n    return Token;\n}());\nfunction newCharacterToken(index, code) {\n    return new Token$1(index, TokenType$1.Character, code, String.fromCharCode(code));\n}\nfunction newIdentifierToken(index, text) {\n    return new Token$1(index, TokenType$1.Identifier, 0, text);\n}\nfunction newKeywordToken(index, text) {\n    return new Token$1(index, TokenType$1.Keyword, 0, text);\n}\nfunction newOperatorToken(index, text) {\n    return new Token$1(index, TokenType$1.Operator, 0, text);\n}\nfunction newStringToken(index, text) {\n    return new Token$1(index, TokenType$1.String, 0, text);\n}\nfunction newNumberToken(index, n) {\n    return new Token$1(index, TokenType$1.Number, n, '');\n}\nfunction newErrorToken(index, message) {\n    return new Token$1(index, TokenType$1.Error, 0, message);\n}\nvar EOF = new Token$1(-1, TokenType$1.Character, 0, '');\nvar _Scanner = /** @class */ (function () {\n    function _Scanner(input) {\n        this.input = input;\n        this.peek = 0;\n        this.index = -1;\n        this.length = input.length;\n        this.advance();\n    }\n    _Scanner.prototype.advance = function () {\n        this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);\n    };\n    _Scanner.prototype.scanToken = function () {\n        var input = this.input, length = this.length;\n        var peek = this.peek, index = this.index;\n        // Skip whitespace.\n        while (peek <= $SPACE) {\n            if (++index >= length) {\n                peek = $EOF;\n                break;\n            }\n            else {\n                peek = input.charCodeAt(index);\n            }\n        }\n        this.peek = peek;\n        this.index = index;\n        if (index >= length) {\n            return null;\n        }\n        // Handle identifiers and numbers.\n        if (isIdentifierStart(peek))\n            return this.scanIdentifier();\n        if (isDigit(peek))\n            return this.scanNumber(index);\n        var start = index;\n        switch (peek) {\n            case $PERIOD:\n                this.advance();\n                return isDigit(this.peek) ? this.scanNumber(start) :\n                    newCharacterToken(start, $PERIOD);\n            case $LPAREN:\n            case $RPAREN:\n            case $LBRACE:\n            case $RBRACE:\n            case $LBRACKET:\n            case $RBRACKET:\n            case $COMMA:\n            case $COLON:\n            case $SEMICOLON:\n                return this.scanCharacter(start, peek);\n            case $SQ:\n            case $DQ:\n                return this.scanString();\n            case $HASH:\n            case $PLUS:\n            case $MINUS:\n            case $STAR:\n            case $SLASH:\n            case $PERCENT:\n            case $CARET:\n                return this.scanOperator(start, String.fromCharCode(peek));\n            case $QUESTION:\n                return this.scanComplexOperator(start, '?', $PERIOD, '.');\n            case $LT:\n            case $GT:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');\n            case $BANG:\n            case $EQ:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');\n            case $AMPERSAND:\n                return this.scanComplexOperator(start, '&', $AMPERSAND, '&');\n            case $BAR:\n                return this.scanComplexOperator(start, '|', $BAR, '|');\n            case $NBSP:\n                while (isWhitespace(this.peek))\n                    this.advance();\n                return this.scanToken();\n        }\n        this.advance();\n        return this.error(\"Unexpected character [\" + String.fromCharCode(peek) + \"]\", 0);\n    };\n    _Scanner.prototype.scanCharacter = function (start, code) {\n        this.advance();\n        return newCharacterToken(start, code);\n    };\n    _Scanner.prototype.scanOperator = function (start, str) {\n        this.advance();\n        return newOperatorToken(start, str);\n    };\n    /**\n     * Tokenize a 2/3 char long operator\n     *\n     * @param start start index in the expression\n     * @param one first symbol (always part of the operator)\n     * @param twoCode code point for the second symbol\n     * @param two second symbol (part of the operator when the second code point matches)\n     * @param threeCode code point for the third symbol\n     * @param three third symbol (part of the operator when provided and matches source expression)\n     */\n    _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {\n        this.advance();\n        var str = one;\n        if (this.peek == twoCode) {\n            this.advance();\n            str += two;\n        }\n        if (threeCode != null && this.peek == threeCode) {\n            this.advance();\n            str += three;\n        }\n        return newOperatorToken(start, str);\n    };\n    _Scanner.prototype.scanIdentifier = function () {\n        var start = this.index;\n        this.advance();\n        while (isIdentifierPart(this.peek))\n            this.advance();\n        var str = this.input.substring(start, this.index);\n        return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n            newIdentifierToken(start, str);\n    };\n    _Scanner.prototype.scanNumber = function (start) {\n        var simple = (this.index === start);\n        this.advance(); // Skip initial digit.\n        while (true) {\n            if (isDigit(this.peek)) {\n                // Do nothing.\n            }\n            else if (this.peek == $PERIOD) {\n                simple = false;\n            }\n            else if (isExponentStart(this.peek)) {\n                this.advance();\n                if (isExponentSign(this.peek))\n                    this.advance();\n                if (!isDigit(this.peek))\n                    return this.error('Invalid exponent', -1);\n                simple = false;\n            }\n            else {\n                break;\n            }\n            this.advance();\n        }\n        var str = this.input.substring(start, this.index);\n        var value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n        return newNumberToken(start, value);\n    };\n    _Scanner.prototype.scanString = function () {\n        var start = this.index;\n        var quote = this.peek;\n        this.advance(); // Skip initial quote.\n        var buffer = '';\n        var marker = this.index;\n        var input = this.input;\n        while (this.peek != quote) {\n            if (this.peek == $BACKSLASH) {\n                buffer += input.substring(marker, this.index);\n                this.advance();\n                var unescapedCode = void 0;\n                // Workaround for TS2.1-introduced type strictness\n                this.peek = this.peek;\n                if (this.peek == $u) {\n                    // 4 character hex code for unicode character.\n                    var hex = input.substring(this.index + 1, this.index + 5);\n                    if (/^[0-9a-f]+$/i.test(hex)) {\n                        unescapedCode = parseInt(hex, 16);\n                    }\n                    else {\n                        return this.error(\"Invalid unicode escape [\\\\u\" + hex + \"]\", 0);\n                    }\n                    for (var i = 0; i < 5; i++) {\n                        this.advance();\n                    }\n                }\n                else {\n                    unescapedCode = unescape(this.peek);\n                    this.advance();\n                }\n                buffer += String.fromCharCode(unescapedCode);\n                marker = this.index;\n            }\n            else if (this.peek == $EOF) {\n                return this.error('Unterminated quote', 0);\n            }\n            else {\n                this.advance();\n            }\n        }\n        var last = input.substring(marker, this.index);\n        this.advance(); // Skip terminating quote.\n        return newStringToken(start, buffer + last);\n    };\n    _Scanner.prototype.error = function (message, offset) {\n        var position = this.index + offset;\n        return newErrorToken(position, \"Lexer Error: \" + message + \" at column \" + position + \" in expression [\" + this.input + \"]\");\n    };\n    return _Scanner;\n}());\nfunction isIdentifierStart(code) {\n    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||\n        (code == $_) || (code == $$);\n}\nfunction isIdentifier(input) {\n    if (input.length == 0)\n        return false;\n    var scanner = new _Scanner(input);\n    if (!isIdentifierStart(scanner.peek))\n        return false;\n    scanner.advance();\n    while (scanner.peek !== $EOF) {\n        if (!isIdentifierPart(scanner.peek))\n            return false;\n        scanner.advance();\n    }\n    return true;\n}\nfunction isIdentifierPart(code) {\n    return isAsciiLetter(code) || isDigit(code) || (code == $_) ||\n        (code == $$);\n}\nfunction isExponentStart(code) {\n    return code == $e || code == $E;\n}\nfunction isExponentSign(code) {\n    return code == $MINUS || code == $PLUS;\n}\nfunction isQuote(code) {\n    return code === $SQ || code === $DQ || code === $BT;\n}\nfunction unescape(code) {\n    switch (code) {\n        case $n:\n            return $LF;\n        case $f:\n            return $FF;\n        case $r:\n            return $CR;\n        case $t:\n            return $TAB;\n        case $v:\n            return $VTAB;\n        default:\n            return code;\n    }\n}\nfunction parseIntAutoRadix(text) {\n    var result = parseInt(text);\n    if (isNaN(result)) {\n        throw new Error('Invalid integer literal when parsing ' + text);\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar SplitInterpolation = /** @class */ (function () {\n    function SplitInterpolation(strings, expressions, offsets) {\n        this.strings = strings;\n        this.expressions = expressions;\n        this.offsets = offsets;\n    }\n    return SplitInterpolation;\n}());\nvar TemplateBindingParseResult = /** @class */ (function () {\n    function TemplateBindingParseResult(templateBindings, warnings, errors) {\n        this.templateBindings = templateBindings;\n        this.warnings = warnings;\n        this.errors = errors;\n    }\n    return TemplateBindingParseResult;\n}());\nfunction _createInterpolateRegExp(config) {\n    var pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n    return new RegExp(pattern, 'g');\n}\nvar Parser$1 = /** @class */ (function () {\n    function Parser(_lexer) {\n        this._lexer = _lexer;\n        this.errors = [];\n    }\n    Parser.prototype.parseAction = function (input, location, absoluteOffset, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        var sourceToLex = this._stripComments(input);\n        var tokens = this._lexer.tokenize(this._stripComments(input));\n        var ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length)\n            .parseChain();\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    };\n    Parser.prototype.parseBinding = function (input, location, absoluteOffset, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    };\n    Parser.prototype.parseSimpleBinding = function (input, location, absoluteOffset, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n        var errors = SimpleExpressionChecker.check(ast);\n        if (errors.length > 0) {\n            this._reportError(\"Host binding expression cannot contain \" + errors.join(' '), input, location);\n        }\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    };\n    Parser.prototype._reportError = function (message, input, errLocation, ctxLocation) {\n        this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n    };\n    Parser.prototype._parseBindingAst = function (input, location, absoluteOffset, interpolationConfig) {\n        // Quotes expressions use 3rd-party expression language. We don't want to use\n        // our lexer or parser for that, so we check for that ahead of time.\n        var quote = this._parseQuote(input, location);\n        if (quote != null) {\n            return quote;\n        }\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        var sourceToLex = this._stripComments(input);\n        var tokens = this._lexer.tokenize(sourceToLex);\n        return new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length)\n            .parseChain();\n    };\n    Parser.prototype._parseQuote = function (input, location) {\n        if (input == null)\n            return null;\n        var prefixSeparatorIndex = input.indexOf(':');\n        if (prefixSeparatorIndex == -1)\n            return null;\n        var prefix = input.substring(0, prefixSeparatorIndex).trim();\n        if (!isIdentifier(prefix))\n            return null;\n        var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n        return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n    };\n    Parser.prototype.parseTemplateBindings = function (tplKey, tplValue, location, absoluteOffset) {\n        var tokens = this._lexer.tokenize(tplValue);\n        return new _ParseAST(tplValue, location, absoluteOffset, tokens, tplValue.length, false, this.errors, 0)\n            .parseTemplateBindings(tplKey);\n    };\n    Parser.prototype.parseInterpolation = function (input, location, absoluteOffset, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var split = this.splitInterpolation(input, location, interpolationConfig);\n        if (split == null)\n            return null;\n        var expressions = [];\n        for (var i = 0; i < split.expressions.length; ++i) {\n            var expressionText = split.expressions[i];\n            var sourceToLex = this._stripComments(expressionText);\n            var tokens = this._lexer.tokenize(sourceToLex);\n            var ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length))\n                .parseChain();\n            expressions.push(ast);\n        }\n        return new ASTWithSource(new Interpolation(new ParseSpan(0, input == null ? 0 : input.length), split.strings, expressions), input, location, absoluteOffset, this.errors);\n    };\n    Parser.prototype.splitInterpolation = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var regexp = _createInterpolateRegExp(interpolationConfig);\n        var parts = input.split(regexp);\n        if (parts.length <= 1) {\n            return null;\n        }\n        var strings = [];\n        var expressions = [];\n        var offsets = [];\n        var offset = 0;\n        for (var i = 0; i < parts.length; i++) {\n            var part = parts[i];\n            if (i % 2 === 0) {\n                // fixed string\n                strings.push(part);\n                offset += part.length;\n            }\n            else if (part.trim().length > 0) {\n                offset += interpolationConfig.start.length;\n                expressions.push(part);\n                offsets.push(offset);\n                offset += part.length + interpolationConfig.end.length;\n            }\n            else {\n                this._reportError('Blank expressions are not allowed in interpolated strings', input, \"at column \" + this._findInterpolationErrorColumn(parts, i, interpolationConfig) + \" in\", location);\n                expressions.push('$implict');\n                offsets.push(offset);\n            }\n        }\n        return new SplitInterpolation(strings, expressions, offsets);\n    };\n    Parser.prototype.wrapLiteralPrimitive = function (input, location, absoluteOffset) {\n        return new ASTWithSource(new LiteralPrimitive(new ParseSpan(0, input == null ? 0 : input.length), input), input, location, absoluteOffset, this.errors);\n    };\n    Parser.prototype._stripComments = function (input) {\n        var i = this._commentStart(input);\n        return i != null ? input.substring(0, i).trim() : input;\n    };\n    Parser.prototype._commentStart = function (input) {\n        var outerQuote = null;\n        for (var i = 0; i < input.length - 1; i++) {\n            var char = input.charCodeAt(i);\n            var nextChar = input.charCodeAt(i + 1);\n            if (char === $SLASH && nextChar == $SLASH && outerQuote == null)\n                return i;\n            if (outerQuote === char) {\n                outerQuote = null;\n            }\n            else if (outerQuote == null && isQuote(char)) {\n                outerQuote = char;\n            }\n        }\n        return null;\n    };\n    Parser.prototype._checkNoInterpolation = function (input, location, interpolationConfig) {\n        var regexp = _createInterpolateRegExp(interpolationConfig);\n        var parts = input.split(regexp);\n        if (parts.length > 1) {\n            this._reportError(\"Got interpolation (\" + interpolationConfig.start + interpolationConfig.end + \") where expression was expected\", input, \"at column \" + this._findInterpolationErrorColumn(parts, 1, interpolationConfig) + \" in\", location);\n        }\n    };\n    Parser.prototype._findInterpolationErrorColumn = function (parts, partInErrIdx, interpolationConfig) {\n        var errLocation = '';\n        for (var j = 0; j < partInErrIdx; j++) {\n            errLocation += j % 2 === 0 ?\n                parts[j] :\n                \"\" + interpolationConfig.start + parts[j] + interpolationConfig.end;\n        }\n        return errLocation.length;\n    };\n    return Parser;\n}());\nvar _ParseAST = /** @class */ (function () {\n    function _ParseAST(input, location, absoluteOffset, tokens, inputLength, parseAction, errors, offset) {\n        this.input = input;\n        this.location = location;\n        this.absoluteOffset = absoluteOffset;\n        this.tokens = tokens;\n        this.inputLength = inputLength;\n        this.parseAction = parseAction;\n        this.errors = errors;\n        this.offset = offset;\n        this.rparensExpected = 0;\n        this.rbracketsExpected = 0;\n        this.rbracesExpected = 0;\n        this.index = 0;\n    }\n    _ParseAST.prototype.peek = function (offset) {\n        var i = this.index + offset;\n        return i < this.tokens.length ? this.tokens[i] : EOF;\n    };\n    Object.defineProperty(_ParseAST.prototype, \"next\", {\n        get: function () { return this.peek(0); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(_ParseAST.prototype, \"inputIndex\", {\n        get: function () {\n            return (this.index < this.tokens.length) ? this.next.index + this.offset :\n                this.inputLength + this.offset;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    _ParseAST.prototype.span = function (start) { return new ParseSpan(start, this.inputIndex); };\n    _ParseAST.prototype.advance = function () { this.index++; };\n    _ParseAST.prototype.optionalCharacter = function (code) {\n        if (this.next.isCharacter(code)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    _ParseAST.prototype.peekKeywordLet = function () { return this.next.isKeywordLet(); };\n    _ParseAST.prototype.peekKeywordAs = function () { return this.next.isKeywordAs(); };\n    _ParseAST.prototype.expectCharacter = function (code) {\n        if (this.optionalCharacter(code))\n            return;\n        this.error(\"Missing expected \" + String.fromCharCode(code));\n    };\n    _ParseAST.prototype.optionalOperator = function (op) {\n        if (this.next.isOperator(op)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    _ParseAST.prototype.expectOperator = function (operator) {\n        if (this.optionalOperator(operator))\n            return;\n        this.error(\"Missing expected operator \" + operator);\n    };\n    _ParseAST.prototype.expectIdentifierOrKeyword = function () {\n        var n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword()) {\n            this.error(\"Unexpected token \" + n + \", expected identifier or keyword\");\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    };\n    _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {\n        var n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n            this.error(\"Unexpected token \" + n + \", expected identifier, keyword, or string\");\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    };\n    _ParseAST.prototype.parseChain = function () {\n        var exprs = [];\n        var start = this.inputIndex;\n        while (this.index < this.tokens.length) {\n            var expr = this.parsePipe();\n            exprs.push(expr);\n            if (this.optionalCharacter($SEMICOLON)) {\n                if (!this.parseAction) {\n                    this.error('Binding expression cannot contain chained expression');\n                }\n                while (this.optionalCharacter($SEMICOLON)) {\n                } // read all semicolons\n            }\n            else if (this.index < this.tokens.length) {\n                this.error(\"Unexpected token '\" + this.next + \"'\");\n            }\n        }\n        if (exprs.length == 0)\n            return new EmptyExpr(this.span(start));\n        if (exprs.length == 1)\n            return exprs[0];\n        return new Chain(this.span(start), exprs);\n    };\n    _ParseAST.prototype.parsePipe = function () {\n        var result = this.parseExpression();\n        if (this.optionalOperator('|')) {\n            if (this.parseAction) {\n                this.error('Cannot have a pipe in an action expression');\n            }\n            do {\n                var name_1 = this.expectIdentifierOrKeyword();\n                var args = [];\n                while (this.optionalCharacter($COLON)) {\n                    args.push(this.parseExpression());\n                }\n                result = new BindingPipe(this.span(result.span.start), result, name_1, args);\n            } while (this.optionalOperator('|'));\n        }\n        return result;\n    };\n    _ParseAST.prototype.parseExpression = function () { return this.parseConditional(); };\n    _ParseAST.prototype.parseConditional = function () {\n        var start = this.inputIndex;\n        var result = this.parseLogicalOr();\n        if (this.optionalOperator('?')) {\n            var yes = this.parsePipe();\n            var no = void 0;\n            if (!this.optionalCharacter($COLON)) {\n                var end = this.inputIndex;\n                var expression = this.input.substring(start, end);\n                this.error(\"Conditional expression \" + expression + \" requires all 3 expressions\");\n                no = new EmptyExpr(this.span(start));\n            }\n            else {\n                no = this.parsePipe();\n            }\n            return new Conditional(this.span(start), result, yes, no);\n        }\n        else {\n            return result;\n        }\n    };\n    _ParseAST.prototype.parseLogicalOr = function () {\n        // '||'\n        var result = this.parseLogicalAnd();\n        while (this.optionalOperator('||')) {\n            var right = this.parseLogicalAnd();\n            result = new Binary(this.span(result.span.start), '||', result, right);\n        }\n        return result;\n    };\n    _ParseAST.prototype.parseLogicalAnd = function () {\n        // '&&'\n        var result = this.parseEquality();\n        while (this.optionalOperator('&&')) {\n            var right = this.parseEquality();\n            result = new Binary(this.span(result.span.start), '&&', result, right);\n        }\n        return result;\n    };\n    _ParseAST.prototype.parseEquality = function () {\n        // '==','!=','===','!=='\n        var result = this.parseRelational();\n        while (this.next.type == TokenType$1.Operator) {\n            var operator = this.next.strValue;\n            switch (operator) {\n                case '==':\n                case '===':\n                case '!=':\n                case '!==':\n                    this.advance();\n                    var right = this.parseRelational();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    _ParseAST.prototype.parseRelational = function () {\n        // '<', '>', '<=', '>='\n        var result = this.parseAdditive();\n        while (this.next.type == TokenType$1.Operator) {\n            var operator = this.next.strValue;\n            switch (operator) {\n                case '<':\n                case '>':\n                case '<=':\n                case '>=':\n                    this.advance();\n                    var right = this.parseAdditive();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    _ParseAST.prototype.parseAdditive = function () {\n        // '+', '-'\n        var result = this.parseMultiplicative();\n        while (this.next.type == TokenType$1.Operator) {\n            var operator = this.next.strValue;\n            switch (operator) {\n                case '+':\n                case '-':\n                    this.advance();\n                    var right = this.parseMultiplicative();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    _ParseAST.prototype.parseMultiplicative = function () {\n        // '*', '%', '/'\n        var result = this.parsePrefix();\n        while (this.next.type == TokenType$1.Operator) {\n            var operator = this.next.strValue;\n            switch (operator) {\n                case '*':\n                case '%':\n                case '/':\n                    this.advance();\n                    var right = this.parsePrefix();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    _ParseAST.prototype.parsePrefix = function () {\n        if (this.next.type == TokenType$1.Operator) {\n            var start = this.inputIndex;\n            var operator = this.next.strValue;\n            var result = void 0;\n            switch (operator) {\n                case '+':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new Binary(this.span(start), '-', result, new LiteralPrimitive(new ParseSpan(start, start), 0));\n                case '-':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);\n                case '!':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new PrefixNot(this.span(start), result);\n            }\n        }\n        return this.parseCallChain();\n    };\n    _ParseAST.prototype.parseCallChain = function () {\n        var result = this.parsePrimary();\n        while (true) {\n            if (this.optionalCharacter($PERIOD)) {\n                result = this.parseAccessMemberOrMethodCall(result, false);\n            }\n            else if (this.optionalOperator('?.')) {\n                result = this.parseAccessMemberOrMethodCall(result, true);\n            }\n            else if (this.optionalCharacter($LBRACKET)) {\n                this.rbracketsExpected++;\n                var key = this.parsePipe();\n                this.rbracketsExpected--;\n                this.expectCharacter($RBRACKET);\n                if (this.optionalOperator('=')) {\n                    var value = this.parseConditional();\n                    result = new KeyedWrite(this.span(result.span.start), result, key, value);\n                }\n                else {\n                    result = new KeyedRead(this.span(result.span.start), result, key);\n                }\n            }\n            else if (this.optionalCharacter($LPAREN)) {\n                this.rparensExpected++;\n                var args = this.parseCallArguments();\n                this.rparensExpected--;\n                this.expectCharacter($RPAREN);\n                result = new FunctionCall(this.span(result.span.start), result, args);\n            }\n            else if (this.optionalOperator('!')) {\n                result = new NonNullAssert(this.span(result.span.start), result);\n            }\n            else {\n                return result;\n            }\n        }\n    };\n    _ParseAST.prototype.parsePrimary = function () {\n        var start = this.inputIndex;\n        if (this.optionalCharacter($LPAREN)) {\n            this.rparensExpected++;\n            var result = this.parsePipe();\n            this.rparensExpected--;\n            this.expectCharacter($RPAREN);\n            return result;\n        }\n        else if (this.next.isKeywordNull()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), null);\n        }\n        else if (this.next.isKeywordUndefined()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), void 0);\n        }\n        else if (this.next.isKeywordTrue()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), true);\n        }\n        else if (this.next.isKeywordFalse()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), false);\n        }\n        else if (this.next.isKeywordThis()) {\n            this.advance();\n            return new ImplicitReceiver(this.span(start));\n        }\n        else if (this.optionalCharacter($LBRACKET)) {\n            this.rbracketsExpected++;\n            var elements = this.parseExpressionList($RBRACKET);\n            this.rbracketsExpected--;\n            this.expectCharacter($RBRACKET);\n            return new LiteralArray(this.span(start), elements);\n        }\n        else if (this.next.isCharacter($LBRACE)) {\n            return this.parseLiteralMap();\n        }\n        else if (this.next.isIdentifier()) {\n            return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n        }\n        else if (this.next.isNumber()) {\n            var value = this.next.toNumber();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), value);\n        }\n        else if (this.next.isString()) {\n            var literalValue = this.next.toString();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), literalValue);\n        }\n        else if (this.index >= this.tokens.length) {\n            this.error(\"Unexpected end of expression: \" + this.input);\n            return new EmptyExpr(this.span(start));\n        }\n        else {\n            this.error(\"Unexpected token \" + this.next);\n            return new EmptyExpr(this.span(start));\n        }\n    };\n    _ParseAST.prototype.parseExpressionList = function (terminator) {\n        var result = [];\n        if (!this.next.isCharacter(terminator)) {\n            do {\n                result.push(this.parsePipe());\n            } while (this.optionalCharacter($COMMA));\n        }\n        return result;\n    };\n    _ParseAST.prototype.parseLiteralMap = function () {\n        var keys = [];\n        var values = [];\n        var start = this.inputIndex;\n        this.expectCharacter($LBRACE);\n        if (!this.optionalCharacter($RBRACE)) {\n            this.rbracesExpected++;\n            do {\n                var quoted = this.next.isString();\n                var key = this.expectIdentifierOrKeywordOrString();\n                keys.push({ key: key, quoted: quoted });\n                this.expectCharacter($COLON);\n                values.push(this.parsePipe());\n            } while (this.optionalCharacter($COMMA));\n            this.rbracesExpected--;\n            this.expectCharacter($RBRACE);\n        }\n        return new LiteralMap(this.span(start), keys, values);\n    };\n    _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, isSafe) {\n        if (isSafe === void 0) { isSafe = false; }\n        var start = receiver.span.start;\n        var id = this.expectIdentifierOrKeyword();\n        if (this.optionalCharacter($LPAREN)) {\n            this.rparensExpected++;\n            var args = this.parseCallArguments();\n            this.expectCharacter($RPAREN);\n            this.rparensExpected--;\n            var span = this.span(start);\n            return isSafe ? new SafeMethodCall(span, receiver, id, args) :\n                new MethodCall(span, receiver, id, args);\n        }\n        else {\n            if (isSafe) {\n                if (this.optionalOperator('=')) {\n                    this.error('The \\'?.\\' operator cannot be used in the assignment');\n                    return new EmptyExpr(this.span(start));\n                }\n                else {\n                    return new SafePropertyRead(this.span(start), receiver, id);\n                }\n            }\n            else {\n                if (this.optionalOperator('=')) {\n                    if (!this.parseAction) {\n                        this.error('Bindings cannot contain assignments');\n                        return new EmptyExpr(this.span(start));\n                    }\n                    var value = this.parseConditional();\n                    return new PropertyWrite(this.span(start), receiver, id, value);\n                }\n                else {\n                    return new PropertyRead(this.span(start), receiver, id);\n                }\n            }\n        }\n    };\n    _ParseAST.prototype.parseCallArguments = function () {\n        if (this.next.isCharacter($RPAREN))\n            return [];\n        var positionals = [];\n        do {\n            positionals.push(this.parsePipe());\n        } while (this.optionalCharacter($COMMA));\n        return positionals;\n    };\n    /**\n     * An identifier, a keyword, a string with an optional `-` in between.\n     */\n    _ParseAST.prototype.expectTemplateBindingKey = function () {\n        var result = '';\n        var operatorFound = false;\n        do {\n            result += this.expectIdentifierOrKeywordOrString();\n            operatorFound = this.optionalOperator('-');\n            if (operatorFound) {\n                result += '-';\n            }\n        } while (operatorFound);\n        return result.toString();\n    };\n    // Parses the AST for `<some-tag *tplKey=AST>`\n    _ParseAST.prototype.parseTemplateBindings = function (tplKey) {\n        var firstBinding = true;\n        var bindings = [];\n        var warnings = [];\n        do {\n            var start = this.inputIndex;\n            var rawKey = void 0;\n            var key = void 0;\n            var isVar = false;\n            if (firstBinding) {\n                rawKey = key = tplKey;\n                firstBinding = false;\n            }\n            else {\n                isVar = this.peekKeywordLet();\n                if (isVar)\n                    this.advance();\n                rawKey = this.expectTemplateBindingKey();\n                key = isVar ? rawKey : tplKey + rawKey[0].toUpperCase() + rawKey.substring(1);\n                this.optionalCharacter($COLON);\n            }\n            var name_2 = null;\n            var expression = null;\n            if (isVar) {\n                if (this.optionalOperator('=')) {\n                    name_2 = this.expectTemplateBindingKey();\n                }\n                else {\n                    name_2 = '\\$implicit';\n                }\n            }\n            else if (this.peekKeywordAs()) {\n                this.advance(); // consume `as`\n                name_2 = rawKey;\n                key = this.expectTemplateBindingKey(); // read local var name\n                isVar = true;\n            }\n            else if (this.next !== EOF && !this.peekKeywordLet()) {\n                var start_1 = this.inputIndex;\n                var ast = this.parsePipe();\n                var source = this.input.substring(start_1 - this.offset, this.inputIndex - this.offset);\n                expression =\n                    new ASTWithSource(ast, source, this.location, this.absoluteOffset, this.errors);\n            }\n            bindings.push(new TemplateBinding(this.span(start), key, isVar, name_2, expression));\n            if (this.peekKeywordAs() && !isVar) {\n                var letStart = this.inputIndex;\n                this.advance(); // consume `as`\n                var letName = this.expectTemplateBindingKey(); // read local var name\n                bindings.push(new TemplateBinding(this.span(letStart), letName, true, key, null));\n            }\n            if (!this.optionalCharacter($SEMICOLON)) {\n                this.optionalCharacter($COMMA);\n            }\n        } while (this.index < this.tokens.length);\n        return new TemplateBindingParseResult(bindings, warnings, this.errors);\n    };\n    _ParseAST.prototype.error = function (message, index) {\n        if (index === void 0) { index = null; }\n        this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n        this.skip();\n    };\n    _ParseAST.prototype.locationText = function (index) {\n        if (index === void 0) { index = null; }\n        if (index == null)\n            index = this.index;\n        return (index < this.tokens.length) ? \"at column \" + (this.tokens[index].index + 1) + \" in\" :\n            \"at the end of the expression\";\n    };\n    // Error recovery should skip tokens until it encounters a recovery point. skip() treats\n    // the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n    // '}' and ']' as conditional recovery points if one of calling productions is expecting\n    // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n    // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n    // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n    // must be conditional as they must be skipped if none of the calling productions are not\n    // expecting the closing token else we will never make progress in the case of an\n    // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n    // parseChain() is always the root production and it expects a ';'.\n    // If a production expects one of these token it increments the corresponding nesting count,\n    // and then decrements it just prior to checking if the token is in the input.\n    _ParseAST.prototype.skip = function () {\n        var n = this.next;\n        while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&\n            (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&\n            (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&\n            (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET))) {\n            if (this.next.isError()) {\n                this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\n            }\n            this.advance();\n            n = this.next;\n        }\n    };\n    return _ParseAST;\n}());\nvar SimpleExpressionChecker = /** @class */ (function () {\n    function SimpleExpressionChecker() {\n        this.errors = [];\n    }\n    SimpleExpressionChecker.check = function (ast) {\n        var s = new SimpleExpressionChecker();\n        ast.visit(s);\n        return s.errors;\n    };\n    SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitInterpolation = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitPropertyRead = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitMethodCall = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitFunctionCall = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitLiteralArray = function (ast, context) { this.visitAll(ast.expressions); };\n    SimpleExpressionChecker.prototype.visitLiteralMap = function (ast, context) { this.visitAll(ast.values); };\n    SimpleExpressionChecker.prototype.visitBinary = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitPrefixNot = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitNonNullAssert = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitConditional = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitPipe = function (ast, context) { this.errors.push('pipes'); };\n    SimpleExpressionChecker.prototype.visitKeyedRead = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitAll = function (asts) {\n        var _this = this;\n        return asts.map(function (node) { return node.visit(_this); });\n    };\n    SimpleExpressionChecker.prototype.visitChain = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitQuote = function (ast, context) { };\n    return SimpleExpressionChecker;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!\n//                               Reach out to mprobst for details.\n//\n// =================================================================================================\n/** Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'. */\nvar _SECURITY_SCHEMA;\nfunction SECURITY_SCHEMA() {\n    if (!_SECURITY_SCHEMA) {\n        _SECURITY_SCHEMA = {};\n        // Case is insignificant below, all element and attribute names are lower-cased for lookup.\n        registerContext(SecurityContext.HTML, [\n            'iframe|srcdoc',\n            '*|innerHTML',\n            '*|outerHTML',\n        ]);\n        registerContext(SecurityContext.STYLE, ['*|style']);\n        // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\n        registerContext(SecurityContext.URL, [\n            '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',\n            'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',\n            'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',\n            'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',\n        ]);\n        registerContext(SecurityContext.RESOURCE_URL, [\n            'applet|code',\n            'applet|codebase',\n            'base|href',\n            'embed|src',\n            'frame|src',\n            'head|profile',\n            'html|manifest',\n            'iframe|src',\n            'link|href',\n            'media|src',\n            'object|codebase',\n            'object|data',\n            'script|src',\n        ]);\n    }\n    return _SECURITY_SCHEMA;\n}\nfunction registerContext(ctx, specs) {\n    var e_1, _a;\n    try {\n        for (var specs_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(specs), specs_1_1 = specs_1.next(); !specs_1_1.done; specs_1_1 = specs_1.next()) {\n            var spec = specs_1_1.value;\n            _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (specs_1_1 && !specs_1_1.done && (_a = specs_1.return)) _a.call(specs_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ElementSchemaRegistry = /** @class */ (function () {\n    function ElementSchemaRegistry() {\n    }\n    return ElementSchemaRegistry;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar BOOLEAN = 'boolean';\nvar NUMBER = 'number';\nvar STRING = 'string';\nvar OBJECT = 'object';\n/**\n * This array represents the DOM schema. It encodes inheritance, properties, and events.\n *\n * ## Overview\n *\n * Each line represents one kind of element. The `element_inheritance` and properties are joined\n * using `element_inheritance|properties` syntax.\n *\n * ## Element Inheritance\n *\n * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\n * Here the individual elements are separated by `,` (commas). Every element in the list\n * has identical properties.\n *\n * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\n * specified then `\"\"` (blank) element is assumed.\n *\n * NOTE: The blank element inherits from root `[Element]` element, the super element of all\n * elements.\n *\n * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\n *\n * ## Properties\n *\n * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\n * by a special character designating its type:\n *\n * - (no prefix): property is a string.\n * - `*`: property represents an event.\n * - `!`: property is a boolean.\n * - `#`: property is a number.\n * - `%`: property is an object.\n *\n * ## Query\n *\n * The class creates an internal squas representation which allows to easily answer the query of\n * if a given property exist on a given element.\n *\n * NOTE: We don't yet support querying for types or events.\n * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\n *       see dom_element_schema_registry_spec.ts\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!\n//\n// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in\n// dom_security_schema.ts. Reach out to mprobst & rjamet for details.\n//\n// =================================================================================================\nvar SCHEMA = [\n    '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +\n        /* added manually to avoid breaking changes */\n        ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',\n    '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume',\n    ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',\n    ':svg:graphics^:svg:|',\n    ':svg:animation^:svg:|*begin,*end,*repeat',\n    ':svg:geometry^:svg:|',\n    ':svg:componentTransferFunction^:svg:|',\n    ':svg:gradient^:svg:|',\n    ':svg:textContent^:svg:graphics|',\n    ':svg:textPositioning^:svg:textContent|',\n    'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',\n    'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username',\n    'audio^media|',\n    'br^[HTMLElement]|clear',\n    'base^[HTMLElement]|href,target',\n    'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',\n    'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',\n    'canvas^[HTMLElement]|#height,#width',\n    'content^[HTMLElement]|select',\n    'dl^[HTMLElement]|!compact',\n    'datalist^[HTMLElement]|',\n    'details^[HTMLElement]|!open',\n    'dialog^[HTMLElement]|!open,returnValue',\n    'dir^[HTMLElement]|!compact',\n    'div^[HTMLElement]|align',\n    'embed^[HTMLElement]|align,height,name,src,type,width',\n    'fieldset^[HTMLElement]|!disabled,name',\n    'font^[HTMLElement]|color,face,size',\n    'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',\n    'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',\n    'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',\n    'hr^[HTMLElement]|align,color,!noShade,size,width',\n    'head^[HTMLElement]|',\n    'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',\n    'html^[HTMLElement]|version',\n    'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',\n    'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',\n    'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',\n    'li^[HTMLElement]|type,#value',\n    'label^[HTMLElement]|htmlFor',\n    'legend^[HTMLElement]|align',\n    'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',\n    'map^[HTMLElement]|name',\n    'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',\n    'menu^[HTMLElement]|!compact',\n    'meta^[HTMLElement]|content,httpEquiv,name,scheme',\n    'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',\n    'ins,del^[HTMLElement]|cite,dateTime',\n    'ol^[HTMLElement]|!compact,!reversed,#start,type',\n    'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',\n    'optgroup^[HTMLElement]|!disabled,label',\n    'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',\n    'output^[HTMLElement]|defaultValue,%htmlFor,name,value',\n    'p^[HTMLElement]|align',\n    'param^[HTMLElement]|name,type,value,valueType',\n    'picture^[HTMLElement]|',\n    'pre^[HTMLElement]|#width',\n    'progress^[HTMLElement]|#max,#value',\n    'q,blockquote,cite^[HTMLElement]|',\n    'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',\n    'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',\n    'shadow^[HTMLElement]|',\n    'slot^[HTMLElement]|name',\n    'source^[HTMLElement]|media,sizes,src,srcset,type',\n    'span^[HTMLElement]|',\n    'style^[HTMLElement]|!disabled,media,type',\n    'caption^[HTMLElement]|align',\n    'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',\n    'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',\n    'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',\n    'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',\n    'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',\n    'template^[HTMLElement]|',\n    'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',\n    'title^[HTMLElement]|text',\n    'track^[HTMLElement]|!default,kind,label,src,srclang',\n    'ul^[HTMLElement]|!compact,type',\n    'unknown^[HTMLElement]|',\n    'video^media|#height,poster,#width',\n    ':svg:a^:svg:graphics|',\n    ':svg:animate^:svg:animation|',\n    ':svg:animateMotion^:svg:animation|',\n    ':svg:animateTransform^:svg:animation|',\n    ':svg:circle^:svg:geometry|',\n    ':svg:clipPath^:svg:graphics|',\n    ':svg:defs^:svg:graphics|',\n    ':svg:desc^:svg:|',\n    ':svg:discard^:svg:|',\n    ':svg:ellipse^:svg:geometry|',\n    ':svg:feBlend^:svg:|',\n    ':svg:feColorMatrix^:svg:|',\n    ':svg:feComponentTransfer^:svg:|',\n    ':svg:feComposite^:svg:|',\n    ':svg:feConvolveMatrix^:svg:|',\n    ':svg:feDiffuseLighting^:svg:|',\n    ':svg:feDisplacementMap^:svg:|',\n    ':svg:feDistantLight^:svg:|',\n    ':svg:feDropShadow^:svg:|',\n    ':svg:feFlood^:svg:|',\n    ':svg:feFuncA^:svg:componentTransferFunction|',\n    ':svg:feFuncB^:svg:componentTransferFunction|',\n    ':svg:feFuncG^:svg:componentTransferFunction|',\n    ':svg:feFuncR^:svg:componentTransferFunction|',\n    ':svg:feGaussianBlur^:svg:|',\n    ':svg:feImage^:svg:|',\n    ':svg:feMerge^:svg:|',\n    ':svg:feMergeNode^:svg:|',\n    ':svg:feMorphology^:svg:|',\n    ':svg:feOffset^:svg:|',\n    ':svg:fePointLight^:svg:|',\n    ':svg:feSpecularLighting^:svg:|',\n    ':svg:feSpotLight^:svg:|',\n    ':svg:feTile^:svg:|',\n    ':svg:feTurbulence^:svg:|',\n    ':svg:filter^:svg:|',\n    ':svg:foreignObject^:svg:graphics|',\n    ':svg:g^:svg:graphics|',\n    ':svg:image^:svg:graphics|',\n    ':svg:line^:svg:geometry|',\n    ':svg:linearGradient^:svg:gradient|',\n    ':svg:mpath^:svg:|',\n    ':svg:marker^:svg:|',\n    ':svg:mask^:svg:|',\n    ':svg:metadata^:svg:|',\n    ':svg:path^:svg:geometry|',\n    ':svg:pattern^:svg:|',\n    ':svg:polygon^:svg:geometry|',\n    ':svg:polyline^:svg:geometry|',\n    ':svg:radialGradient^:svg:gradient|',\n    ':svg:rect^:svg:geometry|',\n    ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',\n    ':svg:script^:svg:|type',\n    ':svg:set^:svg:animation|',\n    ':svg:stop^:svg:|',\n    ':svg:style^:svg:|!disabled,media,title,type',\n    ':svg:switch^:svg:graphics|',\n    ':svg:symbol^:svg:|',\n    ':svg:tspan^:svg:textPositioning|',\n    ':svg:text^:svg:textPositioning|',\n    ':svg:textPath^:svg:textContent|',\n    ':svg:title^:svg:|',\n    ':svg:use^:svg:graphics|',\n    ':svg:view^:svg:|#zoomAndPan',\n    'data^[HTMLElement]|value',\n    'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',\n    'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',\n    'summary^[HTMLElement]|',\n    'time^[HTMLElement]|dateTime',\n    ':svg:cursor^:svg:|',\n];\nvar _ATTR_TO_PROP = {\n    'class': 'className',\n    'for': 'htmlFor',\n    'formaction': 'formAction',\n    'innerHtml': 'innerHTML',\n    'readonly': 'readOnly',\n    'tabindex': 'tabIndex',\n};\nvar DomElementSchemaRegistry = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(DomElementSchemaRegistry, _super);\n    function DomElementSchemaRegistry() {\n        var _this = _super.call(this) || this;\n        _this._schema = {};\n        SCHEMA.forEach(function (encodedType) {\n            var type = {};\n            var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(encodedType.split('|'), 2), strType = _a[0], strProperties = _a[1];\n            var properties = strProperties.split(',');\n            var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(strType.split('^'), 2), typeNames = _b[0], superName = _b[1];\n            typeNames.split(',').forEach(function (tag) { return _this._schema[tag.toLowerCase()] = type; });\n            var superType = superName && _this._schema[superName.toLowerCase()];\n            if (superType) {\n                Object.keys(superType).forEach(function (prop) { type[prop] = superType[prop]; });\n            }\n            properties.forEach(function (property) {\n                if (property.length > 0) {\n                    switch (property[0]) {\n                        case '*':\n                            // We don't yet support events.\n                            // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events\n                            // will\n                            // almost certainly introduce bad XSS vulnerabilities.\n                            // type[property.substring(1)] = EVENT;\n                            break;\n                        case '!':\n                            type[property.substring(1)] = BOOLEAN;\n                            break;\n                        case '#':\n                            type[property.substring(1)] = NUMBER;\n                            break;\n                        case '%':\n                            type[property.substring(1)] = OBJECT;\n                            break;\n                        default:\n                            type[property] = STRING;\n                    }\n                }\n            });\n        });\n        return _this;\n    }\n    DomElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) {\n        if (schemaMetas.some(function (schema) { return schema.name === NO_ERRORS_SCHEMA.name; })) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\n                return false;\n            }\n            if (schemaMetas.some(function (schema) { return schema.name === CUSTOM_ELEMENTS_SCHEMA.name; })) {\n                // Can't tell now as we don't know which properties a custom element will get\n                // once it is instantiated\n                return true;\n            }\n        }\n        var elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];\n        return !!elementProperties[propName];\n    };\n    DomElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) {\n        if (schemaMetas.some(function (schema) { return schema.name === NO_ERRORS_SCHEMA.name; })) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\n                return true;\n            }\n            if (schemaMetas.some(function (schema) { return schema.name === CUSTOM_ELEMENTS_SCHEMA.name; })) {\n                // Allow any custom elements\n                return true;\n            }\n        }\n        return !!this._schema[tagName.toLowerCase()];\n    };\n    /**\n     * securityContext returns the security context for the given property on the given DOM tag.\n     *\n     * Tag and property name are statically known and cannot change at runtime, i.e. it is not\n     * possible to bind a value into a changing attribute or tag name.\n     *\n     * The filtering is based on a list of allowed tags|attributes. All attributes in the schema\n     * above are assumed to have the 'NONE' security context, i.e. that they are safe inert\n     * string values. Only specific well known attack vectors are assigned their appropriate context.\n     */\n    DomElementSchemaRegistry.prototype.securityContext = function (tagName, propName, isAttribute) {\n        if (isAttribute) {\n            // NB: For security purposes, use the mapped property name, not the attribute name.\n            propName = this.getMappedPropName(propName);\n        }\n        // Make sure comparisons are case insensitive, so that case differences between attribute and\n        // property names do not have a security impact.\n        tagName = tagName.toLowerCase();\n        propName = propName.toLowerCase();\n        var ctx = SECURITY_SCHEMA()[tagName + '|' + propName];\n        if (ctx) {\n            return ctx;\n        }\n        ctx = SECURITY_SCHEMA()['*|' + propName];\n        return ctx ? ctx : SecurityContext.NONE;\n    };\n    DomElementSchemaRegistry.prototype.getMappedPropName = function (propName) { return _ATTR_TO_PROP[propName] || propName; };\n    DomElementSchemaRegistry.prototype.getDefaultComponentElementName = function () { return 'ng-component'; };\n    DomElementSchemaRegistry.prototype.validateProperty = function (name) {\n        if (name.toLowerCase().startsWith('on')) {\n            var msg = \"Binding to event property '\" + name + \"' is disallowed for security reasons, \" +\n                (\"please use (\" + name.slice(2) + \")=...\") +\n                (\"\\nIf '\" + name + \"' is a directive input, make sure the directive is imported by the\") +\n                \" current module.\";\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    };\n    DomElementSchemaRegistry.prototype.validateAttribute = function (name) {\n        if (name.toLowerCase().startsWith('on')) {\n            var msg = \"Binding to event attribute '\" + name + \"' is disallowed for security reasons, \" +\n                (\"please use (\" + name.slice(2) + \")=...\");\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    };\n    DomElementSchemaRegistry.prototype.allKnownElementNames = function () { return Object.keys(this._schema); };\n    DomElementSchemaRegistry.prototype.normalizeAnimationStyleProperty = function (propName) {\n        return dashCaseToCamelCase(propName);\n    };\n    DomElementSchemaRegistry.prototype.normalizeAnimationStyleValue = function (camelCaseProp, userProvidedProp, val) {\n        var unit = '';\n        var strVal = val.toString().trim();\n        var errorMsg = null;\n        if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n            if (typeof val === 'number') {\n                unit = 'px';\n            }\n            else {\n                var valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n                    errorMsg = \"Please provide a CSS unit value for \" + userProvidedProp + \":\" + val;\n                }\n            }\n        }\n        return { error: errorMsg, value: strVal + unit };\n    };\n    return DomElementSchemaRegistry;\n}(ElementSchemaRegistry));\nfunction _isPixelDimensionStyle(prop) {\n    switch (prop) {\n        case 'width':\n        case 'height':\n        case 'minWidth':\n        case 'minHeight':\n        case 'maxWidth':\n        case 'maxHeight':\n        case 'left':\n        case 'top':\n        case 'bottom':\n        case 'right':\n        case 'fontSize':\n        case 'outlineWidth':\n        case 'outlineOffset':\n        case 'paddingTop':\n        case 'paddingLeft':\n        case 'paddingBottom':\n        case 'paddingRight':\n        case 'marginTop':\n        case 'marginLeft':\n        case 'marginBottom':\n        case 'marginRight':\n        case 'borderRadius':\n        case 'borderWidth':\n        case 'borderTopWidth':\n        case 'borderLeftWidth':\n        case 'borderRightWidth':\n        case 'borderBottomWidth':\n        case 'textIndent':\n            return true;\n        default:\n            return false;\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar BIND_NAME_REGEXP$1 = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n// Group 1 = \"bind-\"\nvar KW_BIND_IDX$1 = 1;\n// Group 2 = \"let-\"\nvar KW_LET_IDX$1 = 2;\n// Group 3 = \"ref-/#\"\nvar KW_REF_IDX$1 = 3;\n// Group 4 = \"on-\"\nvar KW_ON_IDX$1 = 4;\n// Group 5 = \"bindon-\"\nvar KW_BINDON_IDX$1 = 5;\n// Group 6 = \"@\"\nvar KW_AT_IDX$1 = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nvar IDENT_KW_IDX$1 = 7;\n// Group 8 = identifier inside [()]\nvar IDENT_BANANA_BOX_IDX$1 = 8;\n// Group 9 = identifier inside []\nvar IDENT_PROPERTY_IDX$1 = 9;\n// Group 10 = identifier inside ()\nvar IDENT_EVENT_IDX$1 = 10;\nvar TEMPLATE_ATTR_PREFIX$1 = '*';\nfunction htmlAstToRender3Ast(htmlNodes, bindingParser) {\n    var transformer = new HtmlAstToIvyAst(bindingParser);\n    var ivyNodes = visitAll$1(transformer, htmlNodes);\n    // Errors might originate in either the binding parser or the html to ivy transformer\n    var allErrors = bindingParser.errors.concat(transformer.errors);\n    var errors = allErrors.filter(function (e) { return e.level === ParseErrorLevel.ERROR; });\n    if (errors.length > 0) {\n        var errorString = errors.join('\\n');\n        throw syntaxError(\"Template parse errors:\\n\" + errorString, errors);\n    }\n    return {\n        nodes: ivyNodes,\n        errors: allErrors,\n        styleUrls: transformer.styleUrls,\n        styles: transformer.styles,\n    };\n}\nvar HtmlAstToIvyAst = /** @class */ (function () {\n    function HtmlAstToIvyAst(bindingParser) {\n        this.bindingParser = bindingParser;\n        this.errors = [];\n        this.styles = [];\n        this.styleUrls = [];\n    }\n    // HTML visitor\n    HtmlAstToIvyAst.prototype.visitElement = function (element) {\n        var e_1, _a;\n        var _this = this;\n        var preparsedElement = preparseElement(element);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT) {\n            return null;\n        }\n        else if (preparsedElement.type === PreparsedElementType.STYLE) {\n            var contents = textContents(element);\n            if (contents !== null) {\n                this.styles.push(contents);\n            }\n            return null;\n        }\n        else if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n            isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n            this.styleUrls.push(preparsedElement.hrefAttr);\n            return null;\n        }\n        // Whether the element is a `<ng-template>`\n        var isTemplateElement = isNgTemplate(element.name);\n        var parsedProperties = [];\n        var boundEvents = [];\n        var variables = [];\n        var references = [];\n        var attributes = [];\n        var i18nAttrsMeta = {};\n        var templateParsedProperties = [];\n        var templateVariables = [];\n        // Whether the element has any *-attribute\n        var elementHasInlineTemplate = false;\n        try {\n            for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(element.attrs), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var attribute = _c.value;\n                var hasBinding = false;\n                var normalizedName = normalizeAttributeName(attribute.name);\n                // `*attr` defines template bindings\n                var isTemplateBinding = false;\n                if (attribute.i18n) {\n                    i18nAttrsMeta[attribute.name] = attribute.i18n;\n                }\n                if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX$1)) {\n                    // *-attributes\n                    if (elementHasInlineTemplate) {\n                        this.reportError(\"Can't have multiple template bindings on one element. Use only one attribute prefixed with *\", attribute.sourceSpan);\n                    }\n                    isTemplateBinding = true;\n                    elementHasInlineTemplate = true;\n                    var templateValue = attribute.value;\n                    var templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX$1.length);\n                    var parsedVariables = [];\n                    var absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset :\n                        attribute.sourceSpan.start.offset;\n                    this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteOffset, [], templateParsedProperties, parsedVariables);\n                    templateVariables.push.apply(templateVariables, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(parsedVariables.map(function (v) { return new Variable(v.name, v.value, v.sourceSpan); })));\n                }\n                else {\n                    // Check for variables, events, property bindings, interpolation\n                    hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);\n                }\n                if (!hasBinding && !isTemplateBinding) {\n                    // don't include the bindings as attributes as well in the AST\n                    attributes.push(this.visitAttribute(attribute));\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var children = visitAll$1(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR$1 : this, element.children);\n        var parsedElement;\n        if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n            // `<ng-content>`\n            if (element.children &&\n                !element.children.every(function (node) { return isEmptyTextNode(node) || isCommentNode(node); })) {\n                this.reportError(\"<ng-content> element cannot have content.\", element.sourceSpan);\n            }\n            var selector = preparsedElement.selectAttr;\n            var attrs = element.attrs.map(function (attr) { return _this.visitAttribute(attr); });\n            parsedElement = new Content(selector, attrs, element.sourceSpan, element.i18n);\n        }\n        else if (isTemplateElement) {\n            // `<ng-template>`\n            var attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n            parsedElement = new Template(element.name, attributes, attrs.bound, boundEvents, [ /* no template attributes */], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n        }\n        else {\n            var attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n            parsedElement = new Element(element.name, attributes, attrs.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n        }\n        if (elementHasInlineTemplate) {\n            // If this node is an inline-template (e.g. has *ngFor) then we need to create a template\n            // node that contains this node.\n            // Moreover, if the node is an element, then we need to hoist its attributes to the template\n            // node for matching against content projection selectors.\n            var attrs = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);\n            var templateAttrs_1 = [];\n            attrs.literal.forEach(function (attr) { return templateAttrs_1.push(attr); });\n            attrs.bound.forEach(function (attr) { return templateAttrs_1.push(attr); });\n            var hoistedAttrs = parsedElement instanceof Element ?\n                {\n                    attributes: parsedElement.attributes,\n                    inputs: parsedElement.inputs,\n                    outputs: parsedElement.outputs,\n                } :\n                { attributes: [], inputs: [], outputs: [] };\n            // TODO(pk): test for this case\n            parsedElement = new Template(parsedElement.name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs_1, [parsedElement], [ /* no references */], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n        }\n        return parsedElement;\n    };\n    HtmlAstToIvyAst.prototype.visitAttribute = function (attribute) {\n        return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.valueSpan, attribute.i18n);\n    };\n    HtmlAstToIvyAst.prototype.visitText = function (text) {\n        return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.i18n);\n    };\n    HtmlAstToIvyAst.prototype.visitExpansion = function (expansion) {\n        var _this = this;\n        var meta = expansion.i18n;\n        // do not generate Icu in case it was created\n        // outside of i18n block in a template\n        if (!meta) {\n            return null;\n        }\n        var vars = {};\n        var placeholders = {};\n        // extract VARs from ICUs - we process them separately while\n        // assembling resulting message via goog.getMsg function, since\n        // we need to pass them to top-level goog.getMsg call\n        Object.keys(meta.placeholders).forEach(function (key) {\n            var value = meta.placeholders[key];\n            if (key.startsWith(I18N_ICU_VAR_PREFIX)) {\n                var config = _this.bindingParser.interpolationConfig;\n                // ICU expression is a plain string, not wrapped into start\n                // and end tags, so we wrap it before passing to binding parser\n                var wrapped = \"\" + config.start + value + config.end;\n                vars[key] = _this._visitTextWithInterpolation(wrapped, expansion.sourceSpan);\n            }\n            else {\n                placeholders[key] = _this._visitTextWithInterpolation(value, expansion.sourceSpan);\n            }\n        });\n        return new Icu(vars, placeholders, expansion.sourceSpan, meta);\n    };\n    HtmlAstToIvyAst.prototype.visitExpansionCase = function (expansionCase) { return null; };\n    HtmlAstToIvyAst.prototype.visitComment = function (comment) { return null; };\n    // convert view engine `ParsedProperty` to a format suitable for IVY\n    HtmlAstToIvyAst.prototype.extractAttributes = function (elementName, properties, i18nPropsMeta) {\n        var _this = this;\n        var bound = [];\n        var literal = [];\n        properties.forEach(function (prop) {\n            var i18n = i18nPropsMeta[prop.name];\n            if (prop.isLiteral) {\n                literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, undefined, i18n));\n            }\n            else {\n                // Note that validation is skipped and property mapping is disabled\n                // due to the fact that we need to make sure a given prop is not an\n                // input of a directive and directive matching happens at runtime.\n                var bep = _this.bindingParser.createBoundElementProperty(elementName, prop, /* skipValidation */ true, /* mapPropertyName */ false);\n                bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));\n            }\n        });\n        return { bound: bound, literal: literal };\n    };\n    HtmlAstToIvyAst.prototype.parseAttribute = function (isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {\n        var name = normalizeAttributeName(attribute.name);\n        var value = attribute.value;\n        var srcSpan = attribute.sourceSpan;\n        var absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;\n        var bindParts = name.match(BIND_NAME_REGEXP$1);\n        var hasBinding = false;\n        if (bindParts) {\n            hasBinding = true;\n            if (bindParts[KW_BIND_IDX$1] != null) {\n                this.bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX$1], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);\n            }\n            else if (bindParts[KW_LET_IDX$1]) {\n                if (isTemplateElement) {\n                    var identifier = bindParts[IDENT_KW_IDX$1];\n                    this.parseVariable(identifier, value, srcSpan, attribute.valueSpan, variables);\n                }\n                else {\n                    this.reportError(\"\\\"let-\\\" is only supported on ng-template elements.\", srcSpan);\n                }\n            }\n            else if (bindParts[KW_REF_IDX$1]) {\n                var identifier = bindParts[IDENT_KW_IDX$1];\n                this.parseReference(identifier, value, srcSpan, attribute.valueSpan, references);\n            }\n            else if (bindParts[KW_ON_IDX$1]) {\n                var events = [];\n                this.bindingParser.parseEvent(bindParts[IDENT_KW_IDX$1], value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events);\n                addEvents(events, boundEvents);\n            }\n            else if (bindParts[KW_BINDON_IDX$1]) {\n                this.bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX$1], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);\n                this.parseAssignmentEvent(bindParts[IDENT_KW_IDX$1], value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents);\n            }\n            else if (bindParts[KW_AT_IDX$1]) {\n                this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);\n            }\n            else if (bindParts[IDENT_BANANA_BOX_IDX$1]) {\n                this.bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX$1], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);\n                this.parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX$1], value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents);\n            }\n            else if (bindParts[IDENT_PROPERTY_IDX$1]) {\n                this.bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX$1], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);\n            }\n            else if (bindParts[IDENT_EVENT_IDX$1]) {\n                var events = [];\n                this.bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX$1], value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events);\n                addEvents(events, boundEvents);\n            }\n        }\n        else {\n            hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties);\n        }\n        return hasBinding;\n    };\n    HtmlAstToIvyAst.prototype._visitTextWithInterpolation = function (value, sourceSpan, i18n) {\n        var valueNoNgsp = replaceNgsp(value);\n        var expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan);\n        return expr ? new BoundText(expr, sourceSpan, i18n) : new Text(valueNoNgsp, sourceSpan);\n    };\n    HtmlAstToIvyAst.prototype.parseVariable = function (identifier, value, sourceSpan, valueSpan, variables) {\n        if (identifier.indexOf('-') > -1) {\n            this.reportError(\"\\\"-\\\" is not allowed in variable names\", sourceSpan);\n        }\n        variables.push(new Variable(identifier, value, sourceSpan, valueSpan));\n    };\n    HtmlAstToIvyAst.prototype.parseReference = function (identifier, value, sourceSpan, valueSpan, references) {\n        if (identifier.indexOf('-') > -1) {\n            this.reportError(\"\\\"-\\\" is not allowed in reference names\", sourceSpan);\n        }\n        references.push(new Reference(identifier, value, sourceSpan, valueSpan));\n    };\n    HtmlAstToIvyAst.prototype.parseAssignmentEvent = function (name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents) {\n        var events = [];\n        this.bindingParser.parseEvent(name + \"Change\", expression + \"=$event\", sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events);\n        addEvents(events, boundEvents);\n    };\n    HtmlAstToIvyAst.prototype.reportError = function (message, sourceSpan, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this.errors.push(new ParseError(sourceSpan, message, level));\n    };\n    return HtmlAstToIvyAst;\n}());\nvar NonBindableVisitor$1 = /** @class */ (function () {\n    function NonBindableVisitor() {\n    }\n    NonBindableVisitor.prototype.visitElement = function (ast) {\n        var preparsedElement = preparseElement(ast);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE ||\n            preparsedElement.type === PreparsedElementType.STYLESHEET) {\n            // Skipping <script> for security reasons\n            // Skipping <style> and stylesheets as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        var children = visitAll$1(this, ast.children, null);\n        return new Element(ast.name, visitAll$1(this, ast.attrs), \n        /* inputs */ [], /* outputs */ [], children, /* references */ [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);\n    };\n    NonBindableVisitor.prototype.visitComment = function (comment) { return null; };\n    NonBindableVisitor.prototype.visitAttribute = function (attribute) {\n        return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, undefined, attribute.i18n);\n    };\n    NonBindableVisitor.prototype.visitText = function (text) { return new Text(text.value, text.sourceSpan); };\n    NonBindableVisitor.prototype.visitExpansion = function (expansion) { return null; };\n    NonBindableVisitor.prototype.visitExpansionCase = function (expansionCase) { return null; };\n    return NonBindableVisitor;\n}());\nvar NON_BINDABLE_VISITOR$1 = new NonBindableVisitor$1();\nfunction normalizeAttributeName(attrName) {\n    return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n}\nfunction addEvents(events, boundEvents) {\n    boundEvents.push.apply(boundEvents, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(events.map(function (e) { return BoundEvent.fromParsedEvent(e); })));\n}\nfunction isEmptyTextNode(node) {\n    return node instanceof Text$3 && node.value.trim().length == 0;\n}\nfunction isCommentNode(node) {\n    return node instanceof Comment;\n}\nfunction textContents(node) {\n    if (node.children.length !== 1 || !(node.children[0] instanceof Text$3)) {\n        return null;\n    }\n    else {\n        return node.children[0].value;\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TagType;\n(function (TagType) {\n    TagType[TagType[\"ELEMENT\"] = 0] = \"ELEMENT\";\n    TagType[TagType[\"TEMPLATE\"] = 1] = \"TEMPLATE\";\n    TagType[TagType[\"PROJECTION\"] = 2] = \"PROJECTION\";\n})(TagType || (TagType = {}));\n/**\n * Generates an object that is used as a shared state between parent and all child contexts.\n */\nfunction setupRegistry() {\n    return { getUniqueId: getSeqNumberGenerator(), icus: new Map() };\n}\n/**\n * I18nContext is a helper class which keeps track of all i18n-related aspects\n * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.\n *\n * When we enter a nested template, the top-level context is being passed down\n * to the nested component, which uses this context to generate a child instance\n * of I18nContext class (to handle nested template) and at the end, reconciles it back\n * with the parent context.\n *\n * @param index Instruction index of i18nStart, which initiates this context\n * @param ref Reference to a translation const that represents the content if thus context\n * @param level Nestng level defined for child contexts\n * @param templateIndex Instruction index of a template which this context belongs to\n * @param meta Meta information (id, meaning, description, etc) associated with this context\n */\nvar I18nContext = /** @class */ (function () {\n    function I18nContext(index, ref, level, templateIndex, meta, registry) {\n        if (level === void 0) { level = 0; }\n        if (templateIndex === void 0) { templateIndex = null; }\n        this.index = index;\n        this.ref = ref;\n        this.level = level;\n        this.templateIndex = templateIndex;\n        this.meta = meta;\n        this.registry = registry;\n        this.bindings = new Set();\n        this.placeholders = new Map();\n        this.isEmitted = false;\n        this._unresolvedCtxCount = 0;\n        this._registry = registry || setupRegistry();\n        this.id = this._registry.getUniqueId();\n    }\n    I18nContext.prototype.appendTag = function (type, node, index, closed) {\n        if (node.isVoid && closed) {\n            return; // ignore \"close\" for void tags\n        }\n        var ph = node.isVoid || !closed ? node.startName : node.closeName;\n        var content = { type: type, index: index, ctx: this.id, isVoid: node.isVoid, closed: closed };\n        updatePlaceholderMap(this.placeholders, ph, content);\n    };\n    Object.defineProperty(I18nContext.prototype, \"icus\", {\n        get: function () { return this._registry.icus; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(I18nContext.prototype, \"isRoot\", {\n        get: function () { return this.level === 0; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(I18nContext.prototype, \"isResolved\", {\n        get: function () { return this._unresolvedCtxCount === 0; },\n        enumerable: true,\n        configurable: true\n    });\n    I18nContext.prototype.getSerializedPlaceholders = function () {\n        var result = new Map();\n        this.placeholders.forEach(function (values, key) { return result.set(key, values.map(serializePlaceholderValue)); });\n        return result;\n    };\n    // public API to accumulate i18n-related content\n    I18nContext.prototype.appendBinding = function (binding) { this.bindings.add(binding); };\n    I18nContext.prototype.appendIcu = function (name, ref) {\n        updatePlaceholderMap(this._registry.icus, name, ref);\n    };\n    I18nContext.prototype.appendBoundText = function (node) {\n        var _this = this;\n        var phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);\n        phs.forEach(function (values, key) { return updatePlaceholderMap.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([_this.placeholders, key], values)); });\n    };\n    I18nContext.prototype.appendTemplate = function (node, index) {\n        // add open and close tags at the same time,\n        // since we process nested templates separately\n        this.appendTag(TagType.TEMPLATE, node, index, false);\n        this.appendTag(TagType.TEMPLATE, node, index, true);\n        this._unresolvedCtxCount++;\n    };\n    I18nContext.prototype.appendElement = function (node, index, closed) {\n        this.appendTag(TagType.ELEMENT, node, index, closed);\n    };\n    I18nContext.prototype.appendProjection = function (node, index) {\n        // add open and close tags at the same time,\n        // since we process projected content separately\n        this.appendTag(TagType.PROJECTION, node, index, false);\n        this.appendTag(TagType.PROJECTION, node, index, true);\n    };\n    /**\n     * Generates an instance of a child context based on the root one,\n     * when we enter a nested template within I18n section.\n     *\n     * @param index Instruction index of corresponding i18nStart, which initiates this context\n     * @param templateIndex Instruction index of a template which this context belongs to\n     * @param meta Meta information (id, meaning, description, etc) associated with this context\n     *\n     * @returns I18nContext instance\n     */\n    I18nContext.prototype.forkChildContext = function (index, templateIndex, meta) {\n        return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);\n    };\n    /**\n     * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).\n     *\n     * @param context Child I18nContext instance to be reconciled with parent context.\n     */\n    I18nContext.prototype.reconcileChildContext = function (context) {\n        var _this = this;\n        // set the right context id for open and close\n        // template tags, so we can use it as sub-block ids\n        ['start', 'close'].forEach(function (op) {\n            var key = context.meta[op + \"Name\"];\n            var phs = _this.placeholders.get(key) || [];\n            var tag = phs.find(findTemplateFn(_this.id, context.templateIndex));\n            if (tag) {\n                tag.ctx = context.id;\n            }\n        });\n        // reconcile placeholders\n        var childPhs = context.placeholders;\n        childPhs.forEach(function (values, key) {\n            var phs = _this.placeholders.get(key);\n            if (!phs) {\n                _this.placeholders.set(key, values);\n                return;\n            }\n            // try to find matching template...\n            var tmplIdx = findIndex(phs, findTemplateFn(context.id, context.templateIndex));\n            if (tmplIdx >= 0) {\n                // ... if found - replace it with nested template content\n                var isCloseTag = key.startsWith('CLOSE');\n                var isTemplateTag = key.endsWith('NG-TEMPLATE');\n                if (isTemplateTag) {\n                    // current template's content is placed before or after\n                    // parent template tag, depending on the open/close atrribute\n                    phs.splice.apply(phs, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([tmplIdx + (isCloseTag ? 0 : 1), 0], values));\n                }\n                else {\n                    var idx = isCloseTag ? values.length - 1 : 0;\n                    values[idx].tmpl = phs[tmplIdx];\n                    phs.splice.apply(phs, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([tmplIdx, 1], values));\n                }\n            }\n            else {\n                // ... otherwise just append content to placeholder value\n                phs.push.apply(phs, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(values));\n            }\n            _this.placeholders.set(key, phs);\n        });\n        this._unresolvedCtxCount--;\n    };\n    return I18nContext;\n}());\n//\n// Helper methods\n//\nfunction wrap(symbol, index, contextId, closed) {\n    var state = closed ? '/' : '';\n    return wrapI18nPlaceholder(\"\" + state + symbol + index, contextId);\n}\nfunction wrapTag(symbol, _a, closed) {\n    var index = _a.index, ctx = _a.ctx, isVoid = _a.isVoid;\n    return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) :\n        wrap(symbol, index, ctx, closed);\n}\nfunction findTemplateFn(ctx, templateIndex) {\n    return function (token) { return typeof token === 'object' && token.type === TagType.TEMPLATE &&\n        token.index === templateIndex && token.ctx === ctx; };\n}\nfunction serializePlaceholderValue(value) {\n    var element = function (data, closed) { return wrapTag('#', data, closed); };\n    var template = function (data, closed) { return wrapTag('*', data, closed); };\n    var projection = function (data, closed) { return wrapTag('!', data, closed); };\n    switch (value.type) {\n        case TagType.ELEMENT:\n            // close element tag\n            if (value.closed) {\n                return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');\n            }\n            // open element tag that also initiates a template\n            if (value.tmpl) {\n                return template(value.tmpl) + element(value) +\n                    (value.isVoid ? template(value.tmpl, true) : '');\n            }\n            return element(value);\n        case TagType.TEMPLATE:\n            return template(value, value.closed);\n        case TagType.PROJECTION:\n            return projection(value, value.closed);\n        default:\n            return value;\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TAG_TO_PLACEHOLDER_NAMES = {\n    'A': 'LINK',\n    'B': 'BOLD_TEXT',\n    'BR': 'LINE_BREAK',\n    'EM': 'EMPHASISED_TEXT',\n    'H1': 'HEADING_LEVEL1',\n    'H2': 'HEADING_LEVEL2',\n    'H3': 'HEADING_LEVEL3',\n    'H4': 'HEADING_LEVEL4',\n    'H5': 'HEADING_LEVEL5',\n    'H6': 'HEADING_LEVEL6',\n    'HR': 'HORIZONTAL_RULE',\n    'I': 'ITALIC_TEXT',\n    'LI': 'LIST_ITEM',\n    'LINK': 'MEDIA_LINK',\n    'OL': 'ORDERED_LIST',\n    'P': 'PARAGRAPH',\n    'Q': 'QUOTATION',\n    'S': 'STRIKETHROUGH_TEXT',\n    'SMALL': 'SMALL_TEXT',\n    'SUB': 'SUBSTRIPT',\n    'SUP': 'SUPERSCRIPT',\n    'TBODY': 'TABLE_BODY',\n    'TD': 'TABLE_CELL',\n    'TFOOT': 'TABLE_FOOTER',\n    'TH': 'TABLE_HEADER_CELL',\n    'THEAD': 'TABLE_HEADER',\n    'TR': 'TABLE_ROW',\n    'TT': 'MONOSPACED_TEXT',\n    'U': 'UNDERLINED_TEXT',\n    'UL': 'UNORDERED_LIST',\n};\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n */\nvar PlaceholderRegistry = /** @class */ (function () {\n    function PlaceholderRegistry() {\n        // Count the occurrence of the base name top generate a unique name\n        this._placeHolderNameCounts = {};\n        // Maps signature to placeholder names\n        this._signatureToName = {};\n    }\n    PlaceholderRegistry.prototype.getStartTagPlaceholderName = function (tag, attrs, isVoid) {\n        var signature = this._hashTag(tag, attrs, isVoid);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var upperTag = tag.toUpperCase();\n        var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\" + upperTag;\n        var name = this._generateUniqueName(isVoid ? baseName : \"START_\" + baseName);\n        this._signatureToName[signature] = name;\n        return name;\n    };\n    PlaceholderRegistry.prototype.getCloseTagPlaceholderName = function (tag) {\n        var signature = this._hashClosingTag(tag);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var upperTag = tag.toUpperCase();\n        var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\" + upperTag;\n        var name = this._generateUniqueName(\"CLOSE_\" + baseName);\n        this._signatureToName[signature] = name;\n        return name;\n    };\n    PlaceholderRegistry.prototype.getPlaceholderName = function (name, content) {\n        var upperName = name.toUpperCase();\n        var signature = \"PH: \" + upperName + \"=\" + content;\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var uniqueName = this._generateUniqueName(upperName);\n        this._signatureToName[signature] = uniqueName;\n        return uniqueName;\n    };\n    PlaceholderRegistry.prototype.getUniquePlaceholder = function (name) {\n        return this._generateUniqueName(name.toUpperCase());\n    };\n    // Generate a hash for a tag - does not take attribute order into account\n    PlaceholderRegistry.prototype._hashTag = function (tag, attrs, isVoid) {\n        var start = \"<\" + tag;\n        var strAttrs = Object.keys(attrs).sort().map(function (name) { return \" \" + name + \"=\" + attrs[name]; }).join('');\n        var end = isVoid ? '/>' : \"></\" + tag + \">\";\n        return start + strAttrs + end;\n    };\n    PlaceholderRegistry.prototype._hashClosingTag = function (tag) { return this._hashTag(\"/\" + tag, {}, false); };\n    PlaceholderRegistry.prototype._generateUniqueName = function (base) {\n        var seen = this._placeHolderNameCounts.hasOwnProperty(base);\n        if (!seen) {\n            this._placeHolderNameCounts[base] = 1;\n            return base;\n        }\n        var id = this._placeHolderNameCounts[base];\n        this._placeHolderNameCounts[base] = id + 1;\n        return base + \"_\" + id;\n    };\n    return PlaceholderRegistry;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _expParser = new Parser$1(new Lexer());\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n */\nfunction createI18nMessageFactory(interpolationConfig) {\n    var visitor = new _I18nVisitor(_expParser, interpolationConfig);\n    return function (nodes, meaning, description, id, visitNodeFn) {\n        return visitor.toI18nMessage(nodes, meaning, description, id, visitNodeFn);\n    };\n}\nvar _I18nVisitor = /** @class */ (function () {\n    function _I18nVisitor(_expressionParser, _interpolationConfig) {\n        this._expressionParser = _expressionParser;\n        this._interpolationConfig = _interpolationConfig;\n    }\n    _I18nVisitor.prototype.toI18nMessage = function (nodes, meaning, description, id, visitNodeFn) {\n        this._isIcu = nodes.length == 1 && nodes[0] instanceof Expansion;\n        this._icuDepth = 0;\n        this._placeholderRegistry = new PlaceholderRegistry();\n        this._placeholderToContent = {};\n        this._placeholderToMessage = {};\n        this._visitNodeFn = visitNodeFn;\n        var i18nodes = visitAll$1(this, nodes, {});\n        return new Message(i18nodes, this._placeholderToContent, this._placeholderToMessage, meaning, description, id);\n    };\n    _I18nVisitor.prototype._visitNode = function (html, i18n) {\n        if (this._visitNodeFn) {\n            this._visitNodeFn(html, i18n);\n        }\n        return i18n;\n    };\n    _I18nVisitor.prototype.visitElement = function (el, context) {\n        var children = visitAll$1(this, el.children);\n        var attrs = {};\n        el.attrs.forEach(function (attr) {\n            // Do not visit the attributes, translatable ones are top-level ASTs\n            attrs[attr.name] = attr.value;\n        });\n        var isVoid = getHtmlTagDefinition(el.name).isVoid;\n        var startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n        this._placeholderToContent[startPhName] = el.sourceSpan.toString();\n        var closePhName = '';\n        if (!isVoid) {\n            closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);\n            this._placeholderToContent[closePhName] = \"</\" + el.name + \">\";\n        }\n        var node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan);\n        return this._visitNode(el, node);\n    };\n    _I18nVisitor.prototype.visitAttribute = function (attribute, context) {\n        var node = this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);\n        return this._visitNode(attribute, node);\n    };\n    _I18nVisitor.prototype.visitText = function (text, context) {\n        var node = this._visitTextWithInterpolation(text.value, text.sourceSpan);\n        return this._visitNode(text, node);\n    };\n    _I18nVisitor.prototype.visitComment = function (comment, context) { return null; };\n    _I18nVisitor.prototype.visitExpansion = function (icu, context) {\n        var _this = this;\n        this._icuDepth++;\n        var i18nIcuCases = {};\n        var i18nIcu = new Icu$1(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n        icu.cases.forEach(function (caze) {\n            i18nIcuCases[caze.value] = new Container(caze.expression.map(function (node) { return node.visit(_this, {}); }), caze.expSourceSpan);\n        });\n        this._icuDepth--;\n        if (this._isIcu || this._icuDepth > 0) {\n            // Returns an ICU node when:\n            // - the message (vs a part of the message) is an ICU message, or\n            // - the ICU message is nested.\n            var expPh = this._placeholderRegistry.getUniquePlaceholder(\"VAR_\" + icu.type);\n            i18nIcu.expressionPlaceholder = expPh;\n            this._placeholderToContent[expPh] = icu.switchValue;\n            return this._visitNode(icu, i18nIcu);\n        }\n        // Else returns a placeholder\n        // ICU placeholders should not be replaced with their original content but with the their\n        // translations. We need to create a new visitor (they are not re-entrant) to compute the\n        // message id.\n        // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n        var phName = this._placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n        var visitor = new _I18nVisitor(this._expressionParser, this._interpolationConfig);\n        this._placeholderToMessage[phName] = visitor.toI18nMessage([icu], '', '', '');\n        var node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n        return this._visitNode(icu, node);\n    };\n    _I18nVisitor.prototype.visitExpansionCase = function (icuCase, context) {\n        throw new Error('Unreachable code');\n    };\n    _I18nVisitor.prototype._visitTextWithInterpolation = function (text, sourceSpan) {\n        var splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);\n        if (!splitInterpolation) {\n            // No expression, return a single text\n            return new Text$1(text, sourceSpan);\n        }\n        // Return a group of text + expressions\n        var nodes = [];\n        var container = new Container(nodes, sourceSpan);\n        var _a = this._interpolationConfig, sDelimiter = _a.start, eDelimiter = _a.end;\n        for (var i = 0; i < splitInterpolation.strings.length - 1; i++) {\n            var expression = splitInterpolation.expressions[i];\n            var baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';\n            var phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);\n            if (splitInterpolation.strings[i].length) {\n                // No need to add empty strings\n                nodes.push(new Text$1(splitInterpolation.strings[i], sourceSpan));\n            }\n            nodes.push(new Placeholder(expression, phName, sourceSpan));\n            this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;\n        }\n        // The last index contains no expression\n        var lastStringIdx = splitInterpolation.strings.length - 1;\n        if (splitInterpolation.strings[lastStringIdx].length) {\n            nodes.push(new Text$1(splitInterpolation.strings[lastStringIdx], sourceSpan));\n        }\n        return container;\n    };\n    return _I18nVisitor;\n}());\nvar _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\nfunction _extractPlaceholderName(input) {\n    return input.split(_CUSTOM_PH_EXP)[2];\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction setI18nRefs(html, i18n) {\n    html.i18n = i18n;\n}\n/**\n * This visitor walks over HTML parse tree and converts information stored in\n * i18n-related attributes (\"i18n\" and \"i18n-*\") into i18n meta object that is\n * stored with other element's and attribute's information.\n */\nvar I18nMetaVisitor = /** @class */ (function () {\n    function I18nMetaVisitor(interpolationConfig, keepI18nAttrs) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        if (keepI18nAttrs === void 0) { keepI18nAttrs = false; }\n        this.interpolationConfig = interpolationConfig;\n        this.keepI18nAttrs = keepI18nAttrs;\n        // i18n message generation factory\n        this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\n    }\n    I18nMetaVisitor.prototype._generateI18nMessage = function (nodes, meta, visitNodeFn) {\n        if (meta === void 0) { meta = ''; }\n        var parsed = typeof meta === 'string' ? parseI18nMeta(meta) : metaFromI18nMessage(meta);\n        var message = this._createI18nMessage(nodes, parsed.meaning || '', parsed.description || '', parsed.id || '', visitNodeFn);\n        if (!message.id) {\n            // generate (or restore) message id if not specified in template\n            message.id = typeof meta !== 'string' && meta.id || decimalDigest(message);\n        }\n        return message;\n    };\n    I18nMetaVisitor.prototype.visitElement = function (element, context) {\n        var e_1, _a, e_2, _b;\n        if (hasI18nAttrs(element)) {\n            var attrs = [];\n            var attrsMeta = {};\n            try {\n                for (var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(element.attrs), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var attr = _d.value;\n                    if (attr.name === I18N_ATTR) {\n                        // root 'i18n' node attribute\n                        var i18n_1 = element.i18n || attr.value;\n                        var message = this._generateI18nMessage(element.children, i18n_1, setI18nRefs);\n                        // do not assign empty i18n meta\n                        if (message.nodes.length) {\n                            element.i18n = message;\n                        }\n                    }\n                    else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {\n                        // 'i18n-*' attributes\n                        var key = attr.name.slice(I18N_ATTR_PREFIX.length);\n                        attrsMeta[key] = attr.value;\n                    }\n                    else {\n                        // non-i18n attributes\n                        attrs.push(attr);\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            // set i18n meta for attributes\n            if (Object.keys(attrsMeta).length) {\n                try {\n                    for (var attrs_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(attrs), attrs_1_1 = attrs_1.next(); !attrs_1_1.done; attrs_1_1 = attrs_1.next()) {\n                        var attr = attrs_1_1.value;\n                        var meta = attrsMeta[attr.name];\n                        // do not create translation for empty attributes\n                        if (meta !== undefined && attr.value) {\n                            attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (attrs_1_1 && !attrs_1_1.done && (_b = attrs_1.return)) _b.call(attrs_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n            if (!this.keepI18nAttrs) {\n                // update element's attributes,\n                // keeping only non-i18n related ones\n                element.attrs = attrs;\n            }\n        }\n        visitAll$1(this, element.children);\n        return element;\n    };\n    I18nMetaVisitor.prototype.visitExpansion = function (expansion, context) {\n        var message;\n        var meta = expansion.i18n;\n        if (meta instanceof IcuPlaceholder) {\n            // set ICU placeholder name (e.g. \"ICU_1\"),\n            // generated while processing root element contents,\n            // so we can reference it when we output translation\n            var name_1 = meta.name;\n            message = this._generateI18nMessage([expansion], meta);\n            var icu = icuFromI18nMessage(message);\n            icu.name = name_1;\n        }\n        else {\n            // when ICU is a root level translation\n            message = this._generateI18nMessage([expansion], meta);\n        }\n        expansion.i18n = message;\n        return expansion;\n    };\n    I18nMetaVisitor.prototype.visitText = function (text, context) { return text; };\n    I18nMetaVisitor.prototype.visitAttribute = function (attribute, context) { return attribute; };\n    I18nMetaVisitor.prototype.visitComment = function (comment, context) { return comment; };\n    I18nMetaVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return expansionCase; };\n    return I18nMetaVisitor;\n}());\nfunction processI18nMeta(htmlAstWithErrors, interpolationConfig) {\n    if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n    return new ParseTreeResult(visitAll$1(new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ false), htmlAstWithErrors.rootNodes), htmlAstWithErrors.errors);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This visitor walks over i18n tree and generates its string representation, including ICUs and\n * placeholders in `{$placeholder}` (for plain messages) or `{PLACEHOLDER}` (inside ICUs) format.\n */\nvar SerializerVisitor = /** @class */ (function () {\n    function SerializerVisitor() {\n        /**\n         * Keeps track of ICU nesting level, allowing to detect that we are processing elements of an ICU.\n         *\n         * This is needed due to the fact that placeholders in ICUs and in other messages are represented\n         * differently in Closure:\n         * - {$placeholder} in non-ICU case\n         * - {PLACEHOLDER} inside ICU\n         */\n        this.icuNestingLevel = 0;\n    }\n    SerializerVisitor.prototype.formatPh = function (value) {\n        var isInsideIcu = this.icuNestingLevel > 0;\n        var formatted = formatI18nPlaceholderName(value, /* useCamelCase */ !isInsideIcu);\n        return isInsideIcu ? \"{\" + formatted + \"}\" : \"{$\" + formatted + \"}\";\n    };\n    SerializerVisitor.prototype.visitText = function (text, context) { return text.value; };\n    SerializerVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        return container.children.map(function (child) { return child.visit(_this); }).join('');\n    };\n    SerializerVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        this.icuNestingLevel++;\n        var strCases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        var result = \"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \" + strCases.join(' ') + \"}\";\n        this.icuNestingLevel--;\n        return result;\n    };\n    SerializerVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        return ph.isVoid ?\n            this.formatPh(ph.startName) :\n            \"\" + this.formatPh(ph.startName) + ph.children.map(function (child) { return child.visit(_this); }).join('') + this.formatPh(ph.closeName);\n    };\n    SerializerVisitor.prototype.visitPlaceholder = function (ph, context) { return this.formatPh(ph.name); };\n    SerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return this.formatPh(ph.name);\n    };\n    return SerializerVisitor;\n}());\nvar serializerVisitor$1 = new SerializerVisitor();\nfunction getSerializedI18nContent(message) {\n    return message.nodes.map(function (node) { return node.visit(serializerVisitor$1, null); }).join('');\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Selector attribute name of `<ng-content>`\nvar NG_CONTENT_SELECT_ATTR$1 = 'select';\n// Attribute name of `ngProjectAs`.\nvar NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs';\n// List of supported global targets for event listeners\nvar GLOBAL_TARGET_RESOLVERS = new Map([['window', Identifiers$1.resolveWindow], ['document', Identifiers$1.resolveDocument], ['body', Identifiers$1.resolveBody]]);\nvar LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t'];\n//  if (rf & flags) { .. }\nfunction renderFlagCheckIfStmt(flags, statements) {\n    return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);\n}\nfunction prepareEventListenerParameters(eventAst, handlerName, scope) {\n    if (handlerName === void 0) { handlerName = null; }\n    if (scope === void 0) { scope = null; }\n    var type = eventAst.type, name = eventAst.name, target = eventAst.target, phase = eventAst.phase, handler = eventAst.handler;\n    if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {\n        throw new Error(\"Unexpected global target '\" + target + \"' defined for '\" + name + \"' event.\\n        Supported list of global targets: \" + Array.from(GLOBAL_TARGET_RESOLVERS.keys()) + \".\");\n    }\n    var implicitReceiverExpr = (scope === null || scope.bindingLevel === 0) ?\n        variable(CONTEXT_NAME) :\n        scope.getOrCreateSharedContextVar(0);\n    var bindingExpr = convertActionBinding(scope, implicitReceiverExpr, handler, 'b', function () { return error('Unexpected interpolation'); }, eventAst.handlerSpan);\n    var statements = [];\n    if (scope) {\n        statements.push.apply(statements, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(scope.restoreViewStatement()));\n        statements.push.apply(statements, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(scope.variableDeclarations()));\n    }\n    statements.push.apply(statements, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(bindingExpr.render3Stmts));\n    var eventName = type === 1 /* Animation */ ? prepareSyntheticListenerName(name, phase) : name;\n    var fnName = handlerName && sanitizeIdentifier(handlerName);\n    var fnArgs = [new FnParam('$event', DYNAMIC_TYPE)];\n    var handlerFn = fn(fnArgs, statements, INFERRED_TYPE, null, fnName);\n    var params = [literal(eventName), handlerFn];\n    if (target) {\n        params.push(literal(false), // `useCapture` flag, defaults to `false`\n        importExpr(GLOBAL_TARGET_RESOLVERS.get(target)));\n    }\n    return params;\n}\nvar TemplateDefinitionBuilder = /** @class */ (function () {\n    function TemplateDefinitionBuilder(constantPool, parentBindingScope, level, contextName, i18nContext, templateIndex, templateName, directiveMatcher, directives, pipeTypeByName, pipes, _namespace, relativeContextFilePath, i18nUseExternalIds) {\n        var _this = this;\n        if (level === void 0) { level = 0; }\n        this.constantPool = constantPool;\n        this.level = level;\n        this.contextName = contextName;\n        this.i18nContext = i18nContext;\n        this.templateIndex = templateIndex;\n        this.templateName = templateName;\n        this.directiveMatcher = directiveMatcher;\n        this.directives = directives;\n        this.pipeTypeByName = pipeTypeByName;\n        this.pipes = pipes;\n        this._namespace = _namespace;\n        this.relativeContextFilePath = relativeContextFilePath;\n        this.i18nUseExternalIds = i18nUseExternalIds;\n        this._dataIndex = 0;\n        this._bindingContext = 0;\n        this._prefixCode = [];\n        /**\n         * List of callbacks to generate creation mode instructions. We store them here as we process\n         * the template so bindings in listeners are resolved only once all nodes have been visited.\n         * This ensures all local refs and context variables are available for matching.\n         */\n        this._creationCodeFns = [];\n        /**\n         * List of callbacks to generate update mode instructions. We store them here as we process\n         * the template so bindings are resolved only once all nodes have been visited. This ensures\n         * all local refs and context variables are available for matching.\n         */\n        this._updateCodeFns = [];\n        /**\n         * Memorizes the last node index for which a select instruction has been generated.\n         * We're initializing this to -1 to ensure the `select(0)` instruction is generated before any\n         * relevant update instructions.\n         */\n        this._lastNodeIndexWithFlush = -1;\n        /** Temporary variable declarations generated from visiting pipes, literals, etc. */\n        this._tempVariables = [];\n        /**\n         * List of callbacks to build nested templates. Nested templates must not be visited until\n         * after the parent template has finished visiting all of its nodes. This ensures that all\n         * local ref bindings in nested templates are able to find local ref values if the refs\n         * are defined after the template declaration.\n         */\n        this._nestedTemplateFns = [];\n        this._unsupported = unsupported;\n        // i18n context local to this template\n        this.i18n = null;\n        // Number of slots to reserve for pureFunctions\n        this._pureFunctionSlots = 0;\n        // Number of binding slots\n        this._bindingSlots = 0;\n        // Projection slots found in the template. Projection slots can distribute projected\n        // nodes based on a selector, or can just use the wildcard selector to match\n        // all nodes which aren't matching any selector.\n        this._ngContentReservedSlots = [];\n        // Number of non-default selectors found in all parent templates of this template. We need to\n        // track it to properly adjust projection slot index in the `projection` instruction.\n        this._ngContentSelectorsOffset = 0;\n        // Expression that should be used as implicit receiver when converting template\n        // expressions to output AST.\n        this._implicitReceiverExpr = null;\n        // These should be handled in the template or element directly.\n        this.visitReference = invalid$1;\n        this.visitVariable = invalid$1;\n        this.visitTextAttribute = invalid$1;\n        this.visitBoundAttribute = invalid$1;\n        this.visitBoundEvent = invalid$1;\n        this._bindingScope = parentBindingScope.nestedScope(level);\n        // Turn the relative context file path into an identifier by replacing non-alphanumeric\n        // characters with underscores.\n        this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';\n        this._valueConverter = new ValueConverter(constantPool, function () { return _this.allocateDataSlot(); }, function (numSlots) { return _this.allocatePureFunctionSlots(numSlots); }, function (name, localName, slot, value) {\n            var pipeType = pipeTypeByName.get(name);\n            if (pipeType) {\n                _this.pipes.add(pipeType);\n            }\n            _this._bindingScope.set(_this.level, localName, value);\n            _this.creationInstruction(null, Identifiers$1.pipe, [literal(slot), literal(name)]);\n        });\n    }\n    TemplateDefinitionBuilder.prototype.registerContextVariables = function (variable$1) {\n        var scopedName = this._bindingScope.freshReferenceName();\n        var retrievalLevel = this.level;\n        var lhs = variable(variable$1.name + scopedName);\n        this._bindingScope.set(retrievalLevel, variable$1.name, lhs, 1 /* CONTEXT */, function (scope, relativeLevel) {\n            var rhs;\n            if (scope.bindingLevel === retrievalLevel) {\n                // e.g. ctx\n                rhs = variable(CONTEXT_NAME);\n            }\n            else {\n                var sharedCtxVar = scope.getSharedContextName(retrievalLevel);\n                // e.g. ctx_r0   OR  x(2);\n                rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);\n            }\n            // e.g. const $item$ = x(2).$implicit;\n            return [lhs.set(rhs.prop(variable$1.value || IMPLICIT_REFERENCE)).toConstDecl()];\n        });\n    };\n    TemplateDefinitionBuilder.prototype.buildTemplateFunction = function (nodes, variables, ngContentSelectorsOffset, i18n) {\n        var _this = this;\n        if (ngContentSelectorsOffset === void 0) { ngContentSelectorsOffset = 0; }\n        this._ngContentSelectorsOffset = ngContentSelectorsOffset;\n        if (this._namespace !== Identifiers$1.namespaceHTML) {\n            this.creationInstruction(null, this._namespace);\n        }\n        // Create variable bindings\n        variables.forEach(function (v) { return _this.registerContextVariables(v); });\n        // Initiate i18n context in case:\n        // - this template has parent i18n context\n        // - or the template has i18n meta associated with it,\n        //   but it's not initiated by the Element (e.g. <ng-template i18n>)\n        var initI18nContext = this.i18nContext || (isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) &&\n            !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n));\n        var selfClosingI18nInstruction = hasTextChildrenOnly(nodes);\n        if (initI18nContext) {\n            this.i18nStart(null, i18n, selfClosingI18nInstruction);\n        }\n        // This is the initial pass through the nodes of this template. In this pass, we\n        // queue all creation mode and update mode instructions for generation in the second\n        // pass. It's necessary to separate the passes to ensure local refs are defined before\n        // resolving bindings. We also count bindings in this pass as we walk bound expressions.\n        visitAll(this, nodes);\n        // Add total binding count to pure function count so pure function instructions are\n        // generated with the correct slot offset when update instructions are processed.\n        this._pureFunctionSlots += this._bindingSlots;\n        // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and\n        // `pipeBind` update instructions), so we have to update the slot offsets manually\n        // to account for bindings.\n        this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);\n        // Nested templates must be processed before creation instructions so template()\n        // instructions can be generated with the correct internal const count.\n        this._nestedTemplateFns.forEach(function (buildTemplateFn) { return buildTemplateFn(); });\n        // Output the `projectionDef` instruction when some `<ng-content>` tags are present.\n        // The `projectionDef` instruction is only emitted for the component template and\n        // is skipped for nested templates (<ng-template> tags).\n        if (this.level === 0 && this._ngContentReservedSlots.length) {\n            var parameters = [];\n            // By default the `projectionDef` instructions creates one slot for the wildcard\n            // selector if no parameters are passed. Therefore we only want to allocate a new\n            // array for the projection slots if the default projection slot is not sufficient.\n            if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {\n                var r3ReservedSlots = this._ngContentReservedSlots.map(function (s) { return s !== '*' ? parseSelectorToR3Selector(s) : s; });\n                parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));\n            }\n            // Since we accumulate ngContent selectors while processing template elements,\n            // we *prepend* `projectionDef` to creation instructions block, to put it before\n            // any `projection` instructions\n            this.creationInstruction(null, Identifiers$1.projectionDef, parameters, /* prepend */ true);\n        }\n        if (initI18nContext) {\n            this.i18nEnd(null, selfClosingI18nInstruction);\n        }\n        // Generate all the creation mode instructions (e.g. resolve bindings in listeners)\n        var creationStatements = this._creationCodeFns.map(function (fn) { return fn(); });\n        // Generate all the update mode instructions (e.g. resolve property or text bindings)\n        var updateStatements = this._updateCodeFns.map(function (fn) { return fn(); });\n        //  Variable declaration must occur after binding resolution so we can generate context\n        //  instructions that build on each other.\n        // e.g. const b = nextContext().$implicit(); const b = nextContext();\n        var creationVariables = this._bindingScope.viewSnapshotStatements();\n        var updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);\n        var creationBlock = creationStatements.length > 0 ?\n            [renderFlagCheckIfStmt(1 /* Create */, creationVariables.concat(creationStatements))] :\n            [];\n        var updateBlock = updateStatements.length > 0 ?\n            [renderFlagCheckIfStmt(2 /* Update */, updateVariables.concat(updateStatements))] :\n            [];\n        return fn(\n        // i.e. (rf: RenderFlags, ctx: any)\n        [new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this._prefixCode, creationBlock, updateBlock), INFERRED_TYPE, null, this.templateName);\n    };\n    // LocalResolver\n    TemplateDefinitionBuilder.prototype.getLocal = function (name) { return this._bindingScope.get(name); };\n    // LocalResolver\n    TemplateDefinitionBuilder.prototype.notifyImplicitReceiverUse = function () { this._bindingScope.notifyImplicitReceiverUse(); };\n    TemplateDefinitionBuilder.prototype.i18nTranslate = function (message, params, ref, transformFn) {\n        var _a;\n        if (params === void 0) { params = {}; }\n        var _ref = ref || variable(this.constantPool.uniqueName(TRANSLATION_PREFIX));\n        // Closure Compiler requires const names to start with `MSG_` but disallows any other const to\n        // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call\n        var closureVar = this.i18nGenerateClosureVar(message.id);\n        var formattedParams = this.i18nFormatPlaceholderNames(params, /* useCamelCase */ true);\n        var meta = metaFromI18nMessage(message);\n        var content = getSerializedI18nContent(message);\n        var statements = getTranslationDeclStmts(_ref, closureVar, content, meta, formattedParams, transformFn);\n        (_a = this.constantPool.statements).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(statements));\n        return _ref;\n    };\n    TemplateDefinitionBuilder.prototype.i18nFormatPlaceholderNames = function (params, useCamelCase) {\n        if (params === void 0) { params = {}; }\n        var _params = {};\n        if (params && Object.keys(params).length) {\n            Object.keys(params).forEach(function (key) { return _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]; });\n        }\n        return _params;\n    };\n    TemplateDefinitionBuilder.prototype.i18nAppendBindings = function (expressions) {\n        var _this = this;\n        if (expressions.length > 0) {\n            expressions.forEach(function (expression) { return _this.i18n.appendBinding(expression); });\n        }\n    };\n    TemplateDefinitionBuilder.prototype.i18nBindProps = function (props) {\n        var _this = this;\n        var bound = {};\n        Object.keys(props).forEach(function (key) {\n            var prop = props[key];\n            if (prop instanceof Text) {\n                bound[key] = literal(prop.value);\n            }\n            else {\n                var value = prop.value.visit(_this._valueConverter);\n                _this.allocateBindingSlots(value);\n                if (value instanceof Interpolation) {\n                    var strings = value.strings, expressions = value.expressions;\n                    var _a = _this.i18n, id = _a.id, bindings = _a.bindings;\n                    var label = assembleI18nBoundString(strings, bindings.size, id);\n                    _this.i18nAppendBindings(expressions);\n                    bound[key] = literal(label);\n                }\n            }\n        });\n        return bound;\n    };\n    TemplateDefinitionBuilder.prototype.i18nGenerateClosureVar = function (messageId) {\n        var name;\n        var suffix = this.fileBasedI18nSuffix.toUpperCase();\n        if (this.i18nUseExternalIds) {\n            var prefix = getTranslationConstPrefix(\"EXTERNAL_\");\n            var uniqueSuffix = this.constantPool.uniqueName(suffix);\n            name = \"\" + prefix + sanitizeIdentifier(messageId) + \"$$\" + uniqueSuffix;\n        }\n        else {\n            var prefix = getTranslationConstPrefix(suffix);\n            name = this.constantPool.uniqueName(prefix);\n        }\n        return variable(name);\n    };\n    TemplateDefinitionBuilder.prototype.i18nUpdateRef = function (context) {\n        var icus = context.icus, meta = context.meta, isRoot = context.isRoot, isResolved = context.isResolved, isEmitted = context.isEmitted;\n        if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {\n            context.isEmitted = true;\n            var placeholders = context.getSerializedPlaceholders();\n            var icuMapping_1 = {};\n            var params_1 = placeholders.size ? placeholdersToParams(placeholders) : {};\n            if (icus.size) {\n                icus.forEach(function (refs, key) {\n                    if (refs.length === 1) {\n                        // if we have one ICU defined for a given\n                        // placeholder - just output its reference\n                        params_1[key] = refs[0];\n                    }\n                    else {\n                        // ... otherwise we need to activate post-processing\n                        // to replace ICU placeholders with proper values\n                        var placeholder = wrapI18nPlaceholder(\"\" + I18N_ICU_MAPPING_PREFIX + key);\n                        params_1[key] = literal(placeholder);\n                        icuMapping_1[key] = literalArr(refs);\n                    }\n                });\n            }\n            // translation requires post processing in 2 cases:\n            // - if we have placeholders with multiple values (ex. `START_DIV`: [�#1�, �#2�, ...])\n            // - if we have multiple ICUs that refer to the same placeholder name\n            var needsPostprocessing = Array.from(placeholders.values()).some(function (value) { return value.length > 1; }) ||\n                Object.keys(icuMapping_1).length;\n            var transformFn = void 0;\n            if (needsPostprocessing) {\n                transformFn = function (raw) {\n                    var args = [raw];\n                    if (Object.keys(icuMapping_1).length) {\n                        args.push(mapLiteral(icuMapping_1, true));\n                    }\n                    return instruction(null, Identifiers$1.i18nPostprocess, args);\n                };\n            }\n            this.i18nTranslate(meta, params_1, context.ref, transformFn);\n        }\n    };\n    TemplateDefinitionBuilder.prototype.i18nStart = function (span, meta, selfClosing) {\n        if (span === void 0) { span = null; }\n        var index = this.allocateDataSlot();\n        if (this.i18nContext) {\n            this.i18n = this.i18nContext.forkChildContext(index, this.templateIndex, meta);\n        }\n        else {\n            var ref_1 = variable(this.constantPool.uniqueName(TRANSLATION_PREFIX));\n            this.i18n = new I18nContext(index, ref_1, 0, this.templateIndex, meta);\n        }\n        // generate i18nStart instruction\n        var _a = this.i18n, id = _a.id, ref = _a.ref;\n        var params = [literal(index), ref];\n        if (id > 0) {\n            // do not push 3rd argument (sub-block id)\n            // into i18nStart call for top level i18n context\n            params.push(literal(id));\n        }\n        this.creationInstruction(span, selfClosing ? Identifiers$1.i18n : Identifiers$1.i18nStart, params);\n    };\n    TemplateDefinitionBuilder.prototype.i18nEnd = function (span, selfClosing) {\n        var _this = this;\n        if (span === void 0) { span = null; }\n        if (!this.i18n) {\n            throw new Error('i18nEnd is executed with no i18n context present');\n        }\n        if (this.i18nContext) {\n            this.i18nContext.reconcileChildContext(this.i18n);\n            this.i18nUpdateRef(this.i18nContext);\n        }\n        else {\n            this.i18nUpdateRef(this.i18n);\n        }\n        // setup accumulated bindings\n        var _a = this.i18n, index = _a.index, bindings = _a.bindings;\n        if (bindings.size) {\n            var chainBindings_1 = [];\n            bindings.forEach(function (binding) {\n                chainBindings_1.push({ sourceSpan: span, value: function () { return _this.convertPropertyBinding(binding); } });\n            });\n            this.updateInstructionChain(index, Identifiers$1.i18nExp, chainBindings_1);\n            this.updateInstruction(index, span, Identifiers$1.i18nApply, [literal(index)]);\n        }\n        if (!selfClosing) {\n            this.creationInstruction(span, Identifiers$1.i18nEnd);\n        }\n        this.i18n = null; // reset local i18n context\n    };\n    TemplateDefinitionBuilder.prototype.visitContent = function (ngContent) {\n        var slot = this.allocateDataSlot();\n        var projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;\n        var parameters = [literal(slot)];\n        var attributes = [];\n        this._ngContentReservedSlots.push(ngContent.selector);\n        ngContent.attributes.forEach(function (attribute) {\n            var name = attribute.name, value = attribute.value;\n            if (name === NG_PROJECT_AS_ATTR_NAME) {\n                attributes.push.apply(attributes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(getNgProjectAsLiteral(attribute)));\n            }\n            else if (name.toLowerCase() !== NG_CONTENT_SELECT_ATTR$1) {\n                attributes.push(literal(name), literal(value));\n            }\n        });\n        if (attributes.length > 0) {\n            parameters.push(literal(projectionSlotIdx), literalArr(attributes));\n        }\n        else if (projectionSlotIdx !== 0) {\n            parameters.push(literal(projectionSlotIdx));\n        }\n        this.creationInstruction(ngContent.sourceSpan, Identifiers$1.projection, parameters);\n        if (this.i18n) {\n            this.i18n.appendProjection(ngContent.i18n, slot);\n        }\n    };\n    TemplateDefinitionBuilder.prototype.getNamespaceInstruction = function (namespaceKey) {\n        switch (namespaceKey) {\n            case 'math':\n                return Identifiers$1.namespaceMathML;\n            case 'svg':\n                return Identifiers$1.namespaceSVG;\n            default:\n                return Identifiers$1.namespaceHTML;\n        }\n    };\n    TemplateDefinitionBuilder.prototype.addNamespaceInstruction = function (nsInstruction, element) {\n        this._namespace = nsInstruction;\n        this.creationInstruction(element.sourceSpan, nsInstruction);\n    };\n    TemplateDefinitionBuilder.prototype.visitElement = function (element) {\n        var e_1, _a;\n        var _this = this;\n        var elementIndex = this.allocateDataSlot();\n        var stylingBuilder = new StylingBuilder(literal(elementIndex), null);\n        var isNonBindableMode = false;\n        var isI18nRootElement = isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);\n        if (isI18nRootElement && this.i18n) {\n            throw new Error(\"Could not mark an element as translatable inside of a translatable section\");\n        }\n        var i18nAttrs = [];\n        var outputAttrs = [];\n        var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(splitNsName(element.name), 2), namespaceKey = _b[0], elementName = _b[1];\n        var isNgContainer$1 = isNgContainer(element.name);\n        try {\n            // Handle styling, i18n, ngNonBindable attributes\n            for (var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(element.attributes), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var attr = _d.value;\n                var name_1 = attr.name, value = attr.value;\n                if (name_1 === NON_BINDABLE_ATTR) {\n                    isNonBindableMode = true;\n                }\n                else if (name_1 === 'style') {\n                    stylingBuilder.registerStyleAttr(value);\n                }\n                else if (name_1 === 'class') {\n                    stylingBuilder.registerClassAttr(value);\n                }\n                else {\n                    if (attr.i18n) {\n                        // Place attributes into a separate array for i18n processing, but also keep such\n                        // attributes in the main list to make them available for directive matching at runtime.\n                        // TODO(FW-1248): prevent attributes duplication in `i18nAttributes` and `elementStart`\n                        // arguments\n                        i18nAttrs.push(attr);\n                    }\n                    else {\n                        outputAttrs.push(attr);\n                    }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        // Match directives on non i18n attributes\n        this.matchDirectives(element.name, element);\n        // Regular element or ng-container creation mode\n        var parameters = [literal(elementIndex)];\n        if (!isNgContainer$1) {\n            parameters.push(literal(elementName));\n        }\n        // Add the attributes\n        var attributes = [];\n        var allOtherInputs = [];\n        element.inputs.forEach(function (input) {\n            var stylingInputWasSet = stylingBuilder.registerBoundInput(input);\n            if (!stylingInputWasSet) {\n                if (input.type === 0 /* Property */ && input.i18n) {\n                    // Place attributes into a separate array for i18n processing, but also keep such\n                    // attributes in the main list to make them available for directive matching at runtime.\n                    // TODO(FW-1248): prevent attributes duplication in `i18nAttributes` and `elementStart`\n                    // arguments\n                    i18nAttrs.push(input);\n                }\n                else {\n                    allOtherInputs.push(input);\n                }\n            }\n        });\n        outputAttrs.forEach(function (attr) {\n            if (attr.name === NG_PROJECT_AS_ATTR_NAME) {\n                attributes.push.apply(attributes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(getNgProjectAsLiteral(attr)));\n            }\n            else {\n                attributes.push.apply(attributes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(getAttributeNameLiterals(attr.name), [literal(attr.value)]));\n            }\n        });\n        // add attributes for directive and projection matching purposes\n        attributes.push.apply(attributes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this.prepareNonRenderAttrs(allOtherInputs, element.outputs, stylingBuilder, [], i18nAttrs)));\n        parameters.push(this.toAttrsParam(attributes));\n        // local refs (ex.: <div #foo #bar=\"baz\">)\n        parameters.push(this.prepareRefsParameter(element.references));\n        var wasInNamespace = this._namespace;\n        var currentNamespace = this.getNamespaceInstruction(namespaceKey);\n        // If the namespace is changing now, include an instruction to change it\n        // during element creation.\n        if (currentNamespace !== wasInNamespace) {\n            this.addNamespaceInstruction(currentNamespace, element);\n        }\n        if (this.i18n) {\n            this.i18n.appendElement(element.i18n, elementIndex);\n        }\n        // Note that we do not append text node instructions and ICUs inside i18n section,\n        // so we exclude them while calculating whether current element has children\n        var hasChildren = (!isI18nRootElement && this.i18n) ? !hasTextChildrenOnly(element.children) :\n            element.children.length > 0;\n        var createSelfClosingInstruction = !stylingBuilder.hasBindings &&\n            element.outputs.length === 0 && i18nAttrs.length === 0 && !hasChildren;\n        var createSelfClosingI18nInstruction = !createSelfClosingInstruction &&\n            !stylingBuilder.hasBindings && hasTextChildrenOnly(element.children);\n        if (createSelfClosingInstruction) {\n            this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers$1.elementContainer : Identifiers$1.element, trimTrailingNulls(parameters));\n        }\n        else {\n            this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers$1.elementContainerStart : Identifiers$1.elementStart, trimTrailingNulls(parameters));\n            if (isNonBindableMode) {\n                this.creationInstruction(element.sourceSpan, Identifiers$1.disableBindings);\n            }\n            // process i18n element attributes\n            if (i18nAttrs.length) {\n                var hasBindings_1 = false;\n                var i18nAttrArgs_1 = [];\n                var bindings_1 = [];\n                i18nAttrs.forEach(function (attr) {\n                    var message = attr.i18n;\n                    if (attr instanceof TextAttribute) {\n                        i18nAttrArgs_1.push(literal(attr.name), _this.i18nTranslate(message));\n                    }\n                    else {\n                        var converted = attr.value.visit(_this._valueConverter);\n                        _this.allocateBindingSlots(converted);\n                        if (converted instanceof Interpolation) {\n                            var placeholders = assembleBoundTextPlaceholders(message);\n                            var params = placeholdersToParams(placeholders);\n                            i18nAttrArgs_1.push(literal(attr.name), _this.i18nTranslate(message, params));\n                            converted.expressions.forEach(function (expression) {\n                                hasBindings_1 = true;\n                                bindings_1.push({\n                                    sourceSpan: element.sourceSpan,\n                                    value: function () { return _this.convertExpressionBinding(expression); }\n                                });\n                            });\n                        }\n                    }\n                });\n                if (bindings_1.length) {\n                    this.updateInstructionChain(elementIndex, Identifiers$1.i18nExp, bindings_1);\n                }\n                if (i18nAttrArgs_1.length) {\n                    var index = literal(this.allocateDataSlot());\n                    var args = this.constantPool.getConstLiteral(literalArr(i18nAttrArgs_1), true);\n                    this.creationInstruction(element.sourceSpan, Identifiers$1.i18nAttributes, [index, args]);\n                    if (hasBindings_1) {\n                        this.updateInstruction(elementIndex, element.sourceSpan, Identifiers$1.i18nApply, [index]);\n                    }\n                }\n            }\n            // The style bindings code is placed into two distinct blocks within the template function AOT\n            // code: creation and update. The creation code contains the `styling` instructions\n            // which will apply the collected binding values to the element. `styling` is\n            // designed to run inside of `elementStart` and `elementEnd`. The update instructions\n            // (things like `styleProp`, `classProp`, etc..) are applied later on in this\n            // file\n            this.processStylingInstruction(elementIndex, stylingBuilder.buildStylingInstruction(element.sourceSpan, this.constantPool), true);\n            // Generate Listeners (outputs)\n            element.outputs.forEach(function (outputAst) {\n                _this.creationInstruction(outputAst.sourceSpan, Identifiers$1.listener, _this.prepareListenerParameter(element.name, outputAst, elementIndex));\n            });\n            // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and\n            // listeners, to make sure i18nAttributes instruction targets current element at runtime.\n            if (isI18nRootElement) {\n                this.i18nStart(element.sourceSpan, element.i18n, createSelfClosingI18nInstruction);\n            }\n        }\n        // the code here will collect all update-level styling instructions and add them to the\n        // update block of the template function AOT code. Instructions like `styleProp`,\n        // `styleMap`, `classMap`, `classProp` and `stylingApply`\n        // are all generated and assigned in the code below.\n        var stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);\n        var limit = stylingInstructions.length - 1;\n        for (var i = 0; i <= limit; i++) {\n            var instruction_1 = stylingInstructions[i];\n            this._bindingSlots += instruction_1.allocateBindingSlots;\n            this.processStylingInstruction(elementIndex, instruction_1, false);\n        }\n        // the reason why `undefined` is used is because the renderer understands this as a\n        // special value to symbolize that there is no RHS to this binding\n        // TODO (matsko): revisit this once FW-959 is approached\n        var emptyValueBindInstruction = literal(undefined);\n        var propertyBindings = [];\n        var attributeBindings = [];\n        // Generate element input bindings\n        allOtherInputs.forEach(function (input) {\n            var inputType = input.type;\n            if (inputType === 4 /* Animation */) {\n                var value_1 = input.value.visit(_this._valueConverter);\n                // animation bindings can be presented in the following formats:\n                // 1. [@binding]=\"fooExp\"\n                // 2. [@binding]=\"{value:fooExp, params:{...}}\"\n                // 3. [@binding]\n                // 4. @binding\n                // All formats will be valid for when a synthetic binding is created.\n                // The reasoning for this is because the renderer should get each\n                // synthetic binding value in the order of the array that they are\n                // defined in...\n                var hasValue_1 = value_1 instanceof LiteralPrimitive ? !!value_1.value : true;\n                _this.allocateBindingSlots(value_1);\n                propertyBindings.push({\n                    name: prepareSyntheticPropertyName(input.name),\n                    sourceSpan: input.sourceSpan,\n                    value: function () { return hasValue_1 ? _this.convertPropertyBinding(value_1) : emptyValueBindInstruction; }\n                });\n            }\n            else {\n                // we must skip attributes with associated i18n context, since these attributes are handled\n                // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated\n                if (input.i18n)\n                    return;\n                var value_2 = input.value.visit(_this._valueConverter);\n                if (value_2 !== undefined) {\n                    var params_2 = [];\n                    var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(splitNsName(input.name), 2), attrNamespace = _a[0], attrName_1 = _a[1];\n                    var isAttributeBinding = inputType === 1 /* Attribute */;\n                    var sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);\n                    if (sanitizationRef)\n                        params_2.push(sanitizationRef);\n                    if (attrNamespace) {\n                        var namespaceLiteral = literal(attrNamespace);\n                        if (sanitizationRef) {\n                            params_2.push(namespaceLiteral);\n                        }\n                        else {\n                            // If there wasn't a sanitization ref, we need to add\n                            // an extra param so that we can pass in the namespace.\n                            params_2.push(literal(null), namespaceLiteral);\n                        }\n                    }\n                    _this.allocateBindingSlots(value_2);\n                    if (inputType === 0 /* Property */) {\n                        if (value_2 instanceof Interpolation) {\n                            // prop=\"{{value}}\" and friends\n                            _this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value_2), elementIndex, attrName_1, input, value_2, params_2);\n                        }\n                        else {\n                            // [prop]=\"value\"\n                            // Collect all the properties so that we can chain into a single function at the end.\n                            propertyBindings.push({\n                                name: attrName_1,\n                                sourceSpan: input.sourceSpan,\n                                value: function () { return _this.convertPropertyBinding(value_2); }, params: params_2\n                            });\n                        }\n                    }\n                    else if (inputType === 1 /* Attribute */) {\n                        if (value_2 instanceof Interpolation && getInterpolationArgsLength(value_2) > 1) {\n                            // attr.name=\"text{{value}}\" and friends\n                            _this.interpolatedUpdateInstruction(getAttributeInterpolationExpression(value_2), elementIndex, attrName_1, input, value_2, params_2);\n                        }\n                        else {\n                            var boundValue_1 = value_2 instanceof Interpolation ? value_2.expressions[0] : value_2;\n                            // [attr.name]=\"value\" or attr.name=\"{{value}}\"\n                            // Collect the attribute bindings so that they can be chained at the end.\n                            attributeBindings.push({\n                                name: attrName_1,\n                                sourceSpan: input.sourceSpan,\n                                value: function () { return _this.convertPropertyBinding(boundValue_1); }, params: params_2\n                            });\n                        }\n                    }\n                    else {\n                        // class prop\n                        _this.updateInstruction(elementIndex, input.sourceSpan, Identifiers$1.classProp, function () {\n                            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([\n                                literal(elementIndex), literal(attrName_1), _this.convertPropertyBinding(value_2)\n                            ], params_2);\n                        });\n                    }\n                }\n            }\n        });\n        if (propertyBindings.length > 0) {\n            this.updateInstructionChain(elementIndex, Identifiers$1.property, propertyBindings);\n        }\n        if (attributeBindings.length > 0) {\n            this.updateInstructionChain(elementIndex, Identifiers$1.attribute, attributeBindings);\n        }\n        // Traverse element child nodes\n        visitAll(this, element.children);\n        if (!isI18nRootElement && this.i18n) {\n            this.i18n.appendElement(element.i18n, elementIndex, true);\n        }\n        if (!createSelfClosingInstruction) {\n            // Finish element construction mode.\n            var span = element.endSourceSpan || element.sourceSpan;\n            if (isI18nRootElement) {\n                this.i18nEnd(span, createSelfClosingI18nInstruction);\n            }\n            if (isNonBindableMode) {\n                this.creationInstruction(span, Identifiers$1.enableBindings);\n            }\n            this.creationInstruction(span, isNgContainer$1 ? Identifiers$1.elementContainerEnd : Identifiers$1.elementEnd);\n        }\n    };\n    /**\n     * Adds an update instruction for an interpolated property or attribute, such as\n     * `prop=\"{{value}}\"` or `attr.title=\"{{value}}\"`\n     */\n    TemplateDefinitionBuilder.prototype.interpolatedUpdateInstruction = function (instruction, elementIndex, attrName, input, value, params) {\n        var _this = this;\n        this.updateInstruction(elementIndex, input.sourceSpan, instruction, function () { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([literal(attrName)], _this.getUpdateInstructionArguments(value), params); });\n    };\n    TemplateDefinitionBuilder.prototype.visitTemplate = function (template) {\n        var _this = this;\n        var NG_TEMPLATE_TAG_NAME = 'ng-template';\n        var templateIndex = this.allocateDataSlot();\n        if (this.i18n) {\n            this.i18n.appendTemplate(template.i18n, templateIndex);\n        }\n        var tagName = sanitizeIdentifier(template.tagName || '');\n        var contextName = \"\" + this.contextName + (tagName ? '_' + tagName : '') + \"_\" + templateIndex;\n        var templateName = contextName + \"_Template\";\n        var parameters = [\n            literal(templateIndex),\n            variable(templateName),\n            // We don't care about the tag's namespace here, because we infer\n            // it based on the parent nodes inside the template instruction.\n            literal(template.tagName ? splitNsName(template.tagName)[1] : template.tagName),\n        ];\n        // find directives matching on a given <ng-template> node\n        this.matchDirectives(NG_TEMPLATE_TAG_NAME, template);\n        // prepare attributes parameter (including attributes used for directive matching)\n        var attrsExprs = [];\n        template.attributes.forEach(function (a) { attrsExprs.push(asLiteral(a.name), asLiteral(a.value)); });\n        attrsExprs.push.apply(attrsExprs, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this.prepareNonRenderAttrs(template.inputs, template.outputs, undefined, template.templateAttrs)));\n        parameters.push(this.toAttrsParam(attrsExprs));\n        // local refs (ex.: <ng-template #foo>)\n        if (template.references && template.references.length) {\n            parameters.push(this.prepareRefsParameter(template.references));\n            parameters.push(importExpr(Identifiers$1.templateRefExtractor));\n        }\n        // Create the template function\n        var templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this.directiveMatcher, this.directives, this.pipeTypeByName, this.pipes, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds);\n        // Nested templates must not be visited until after their parent templates have completed\n        // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't\n        // be able to support bindings in nested templates to local refs that occur after the\n        // template definition. e.g. <div *ngIf=\"showing\">{{ foo }}</div>  <div #foo></div>\n        this._nestedTemplateFns.push(function () {\n            var _a;\n            var templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, _this._ngContentReservedSlots.length + _this._ngContentSelectorsOffset, template.i18n);\n            _this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName, null));\n            if (templateVisitor._ngContentReservedSlots.length) {\n                (_a = _this._ngContentReservedSlots).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(templateVisitor._ngContentReservedSlots));\n            }\n        });\n        // e.g. template(1, MyComp_Template_1)\n        this.creationInstruction(template.sourceSpan, Identifiers$1.templateCreate, function () {\n            parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));\n            return trimTrailingNulls(parameters);\n        });\n        // handle property bindings e.g. ɵɵproperty('ngForOf', ctx.items), et al;\n        this.templatePropertyBindings(templateIndex, template.templateAttrs);\n        // Only add normal input/output binding instructions on explicit ng-template elements.\n        if (template.tagName === NG_TEMPLATE_TAG_NAME) {\n            // Add the input bindings\n            this.templatePropertyBindings(templateIndex, template.inputs);\n            // Generate listeners for directive output\n            template.outputs.forEach(function (outputAst) {\n                _this.creationInstruction(outputAst.sourceSpan, Identifiers$1.listener, _this.prepareListenerParameter('ng_template', outputAst, templateIndex));\n            });\n        }\n    };\n    TemplateDefinitionBuilder.prototype.visitBoundText = function (text) {\n        var _this = this;\n        if (this.i18n) {\n            var value_3 = text.value.visit(this._valueConverter);\n            this.allocateBindingSlots(value_3);\n            if (value_3 instanceof Interpolation) {\n                this.i18n.appendBoundText(text.i18n);\n                this.i18nAppendBindings(value_3.expressions);\n            }\n            return;\n        }\n        var nodeIndex = this.allocateDataSlot();\n        this.creationInstruction(text.sourceSpan, Identifiers$1.text, [literal(nodeIndex)]);\n        var value = text.value.visit(this._valueConverter);\n        this.allocateBindingSlots(value);\n        if (value instanceof Interpolation) {\n            this.updateInstruction(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), function () { return _this.getUpdateInstructionArguments(value); });\n        }\n        else {\n            this.updateInstruction(nodeIndex, text.sourceSpan, Identifiers$1.textBinding, function () { return [_this.convertPropertyBinding(value)]; });\n        }\n    };\n    TemplateDefinitionBuilder.prototype.visitText = function (text) {\n        // when a text element is located within a translatable\n        // block, we exclude this text element from instructions set,\n        // since it will be captured in i18n content and processed at runtime\n        if (!this.i18n) {\n            this.creationInstruction(text.sourceSpan, Identifiers$1.text, [literal(this.allocateDataSlot()), literal(text.value)]);\n        }\n    };\n    TemplateDefinitionBuilder.prototype.visitIcu = function (icu) {\n        var _this = this;\n        var initWasInvoked = false;\n        // if an ICU was created outside of i18n block, we still treat\n        // it as a translatable entity and invoke i18nStart and i18nEnd\n        // to generate i18n context and the necessary instructions\n        if (!this.i18n) {\n            initWasInvoked = true;\n            this.i18nStart(null, icu.i18n, true);\n        }\n        var i18n = this.i18n;\n        var vars = this.i18nBindProps(icu.vars);\n        var placeholders = this.i18nBindProps(icu.placeholders);\n        // output ICU directly and keep ICU reference in context\n        var message = icu.i18n;\n        // we always need post-processing function for ICUs, to make sure that:\n        // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:\n        // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders\n        // inside ICUs)\n        // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values\n        var transformFn = function (raw) {\n            var params = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, vars, placeholders);\n            var formatted = _this.i18nFormatPlaceholderNames(params, /* useCamelCase */ false);\n            return instruction(null, Identifiers$1.i18nPostprocess, [raw, mapLiteral(formatted, true)]);\n        };\n        // in case the whole i18n message is a single ICU - we do not need to\n        // create a separate top-level translation, we can use the root ref instead\n        // and make this ICU a top-level translation\n        // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function\n        // separately, so we do not pass placeholders into `i18nTranslate` function.\n        if (isSingleI18nIcu(i18n.meta)) {\n            this.i18nTranslate(message, /* placeholders */ {}, i18n.ref, transformFn);\n        }\n        else {\n            // output ICU directly and keep ICU reference in context\n            var ref = this.i18nTranslate(message, /* placeholders */ {}, /* ref */ undefined, transformFn);\n            i18n.appendIcu(icuFromI18nMessage(message).name, ref);\n        }\n        if (initWasInvoked) {\n            this.i18nEnd(null, true);\n        }\n        return null;\n    };\n    TemplateDefinitionBuilder.prototype.allocateDataSlot = function () { return this._dataIndex++; };\n    TemplateDefinitionBuilder.prototype.getConstCount = function () { return this._dataIndex; };\n    TemplateDefinitionBuilder.prototype.getVarCount = function () { return this._pureFunctionSlots; };\n    TemplateDefinitionBuilder.prototype.getNgContentSelectors = function () {\n        return this._ngContentReservedSlots.length ?\n            this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) :\n            null;\n    };\n    TemplateDefinitionBuilder.prototype.bindingContext = function () { return \"\" + this._bindingContext++; };\n    TemplateDefinitionBuilder.prototype.templatePropertyBindings = function (templateIndex, attrs) {\n        var _this = this;\n        var propertyBindings = [];\n        attrs.forEach(function (input) {\n            if (input instanceof BoundAttribute) {\n                var value_4 = input.value.visit(_this._valueConverter);\n                if (value_4 !== undefined) {\n                    _this.allocateBindingSlots(value_4);\n                    propertyBindings.push({\n                        name: input.name,\n                        sourceSpan: input.sourceSpan,\n                        value: function () { return _this.convertPropertyBinding(value_4); }\n                    });\n                }\n            }\n        });\n        if (propertyBindings.length > 0) {\n            this.updateInstructionChain(templateIndex, Identifiers$1.property, propertyBindings);\n        }\n    };\n    // Bindings must only be resolved after all local refs have been visited, so all\n    // instructions are queued in callbacks that execute once the initial pass has completed.\n    // Otherwise, we wouldn't be able to support local refs that are defined after their\n    // bindings. e.g. {{ foo }} <div #foo></div>\n    TemplateDefinitionBuilder.prototype.instructionFn = function (fns, span, reference, paramsOrFn, prepend) {\n        if (prepend === void 0) { prepend = false; }\n        fns[prepend ? 'unshift' : 'push'](function () {\n            var params = Array.isArray(paramsOrFn) ? paramsOrFn : paramsOrFn();\n            return instruction(span, reference, params).toStmt();\n        });\n    };\n    TemplateDefinitionBuilder.prototype.processStylingInstruction = function (elementIndex, instruction, createMode) {\n        var _this = this;\n        if (instruction) {\n            if (createMode) {\n                this.creationInstruction(instruction.sourceSpan, instruction.reference, function () {\n                    return instruction.params(function (value) { return _this.convertPropertyBinding(value); });\n                });\n            }\n            else {\n                this.updateInstruction(elementIndex, instruction.sourceSpan, instruction.reference, function () {\n                    return instruction\n                        .params(function (value) {\n                        return (instruction.supportsInterpolation && value instanceof Interpolation) ?\n                            _this.getUpdateInstructionArguments(value) :\n                            _this.convertPropertyBinding(value);\n                    });\n                });\n            }\n        }\n    };\n    TemplateDefinitionBuilder.prototype.creationInstruction = function (span, reference, paramsOrFn, prepend) {\n        this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);\n    };\n    TemplateDefinitionBuilder.prototype.updateInstruction = function (nodeIndex, span, reference, paramsOrFn) {\n        this.addSelectInstructionIfNecessary(nodeIndex, span);\n        this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);\n    };\n    TemplateDefinitionBuilder.prototype.updateInstructionChain = function (nodeIndex, reference, bindings) {\n        var span = bindings.length ? bindings[0].sourceSpan : null;\n        this.addSelectInstructionIfNecessary(nodeIndex, span);\n        this._updateCodeFns.push(function () {\n            var calls = bindings.map(function (property) {\n                var fnParams = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([property.value()], (property.params || []));\n                if (property.name) {\n                    fnParams.unshift(literal(property.name));\n                }\n                return fnParams;\n            });\n            return chainedInstruction(reference, calls, span).toStmt();\n        });\n    };\n    TemplateDefinitionBuilder.prototype.addSelectInstructionIfNecessary = function (nodeIndex, span) {\n        if (this._lastNodeIndexWithFlush < nodeIndex) {\n            if (nodeIndex > 0) {\n                this.instructionFn(this._updateCodeFns, span, Identifiers$1.select, [literal(nodeIndex)]);\n            }\n            this._lastNodeIndexWithFlush = nodeIndex;\n        }\n    };\n    TemplateDefinitionBuilder.prototype.allocatePureFunctionSlots = function (numSlots) {\n        var originalSlots = this._pureFunctionSlots;\n        this._pureFunctionSlots += numSlots;\n        return originalSlots;\n    };\n    TemplateDefinitionBuilder.prototype.allocateBindingSlots = function (value) {\n        this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;\n    };\n    /**\n     * Gets an expression that refers to the implicit receiver. The implicit\n     * receiver is always the root level context.\n     */\n    TemplateDefinitionBuilder.prototype.getImplicitReceiverExpr = function () {\n        if (this._implicitReceiverExpr) {\n            return this._implicitReceiverExpr;\n        }\n        return this._implicitReceiverExpr = this.level === 0 ?\n            variable(CONTEXT_NAME) :\n            this._bindingScope.getOrCreateSharedContextVar(0);\n    };\n    TemplateDefinitionBuilder.prototype.convertExpressionBinding = function (value) {\n        var convertedPropertyBinding = convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext(), BindingForm.TrySimple);\n        return convertedPropertyBinding.currValExpr;\n    };\n    TemplateDefinitionBuilder.prototype.convertPropertyBinding = function (value) {\n        var _a;\n        var convertedPropertyBinding = convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext(), BindingForm.TrySimple, function () { return error('Unexpected interpolation'); });\n        var valExpr = convertedPropertyBinding.currValExpr;\n        (_a = this._tempVariables).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(convertedPropertyBinding.stmts));\n        return valExpr;\n    };\n    /**\n     * Gets a list of argument expressions to pass to an update instruction expression. Also updates\n     * the temp variables state with temp variables that were identified as needing to be created\n     * while visiting the arguments.\n     * @param value The original expression we will be resolving an arguments list from.\n     */\n    TemplateDefinitionBuilder.prototype.getUpdateInstructionArguments = function (value) {\n        var _a;\n        var _b = convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext()), args = _b.args, stmts = _b.stmts;\n        (_a = this._tempVariables).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(stmts));\n        return args;\n    };\n    TemplateDefinitionBuilder.prototype.matchDirectives = function (tagName, elOrTpl) {\n        var _this = this;\n        if (this.directiveMatcher) {\n            var selector = createCssSelector(tagName, getAttrsForDirectiveMatching(elOrTpl));\n            this.directiveMatcher.match(selector, function (cssSelector, staticType) { _this.directives.add(staticType); });\n        }\n    };\n    /**\n     * Prepares all attribute expression values for the `TAttributes` array.\n     *\n     * The purpose of this function is to properly construct an attributes array that\n     * is passed into the `elementStart` (or just `element`) functions. Because there\n     * are many different types of attributes, the array needs to be constructed in a\n     * special way so that `elementStart` can properly evaluate them.\n     *\n     * The format looks like this:\n     *\n     * ```\n     * attrs = [prop, value, prop2, value2,\n     *   CLASSES, class1, class2,\n     *   STYLES, style1, value1, style2, value2,\n     *   BINDINGS, name1, name2, name3,\n     *   TEMPLATE, name4, name5, name6,\n     *   I18N, name7, name8, ...]\n     * ```\n     *\n     * Note that this function will fully ignore all synthetic (@foo) attribute values\n     * because those values are intended to always be generated as property instructions.\n     */\n    TemplateDefinitionBuilder.prototype.prepareNonRenderAttrs = function (inputs, outputs, styles, templateAttrs, i18nAttrs) {\n        if (templateAttrs === void 0) { templateAttrs = []; }\n        if (i18nAttrs === void 0) { i18nAttrs = []; }\n        var alreadySeen = new Set();\n        var attrExprs = [];\n        function addAttrExpr(key, value) {\n            if (typeof key === 'string') {\n                if (!alreadySeen.has(key)) {\n                    attrExprs.push.apply(attrExprs, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(getAttributeNameLiterals(key)));\n                    value !== undefined && attrExprs.push(value);\n                    alreadySeen.add(key);\n                }\n            }\n            else {\n                attrExprs.push(literal(key));\n            }\n        }\n        // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`\n        // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as\n        // as single property value cell by cell.\n        if (styles) {\n            styles.populateInitialStylingAttrs(attrExprs);\n        }\n        if (inputs.length || outputs.length) {\n            var attrsLengthBeforeInputs = attrExprs.length;\n            for (var i = 0; i < inputs.length; i++) {\n                var input = inputs[i];\n                // We don't want the animation and attribute bindings in the\n                // attributes array since they aren't used for directive matching.\n                if (input.type !== 4 /* Animation */ && input.type !== 1 /* Attribute */) {\n                    addAttrExpr(input.name);\n                }\n            }\n            for (var i = 0; i < outputs.length; i++) {\n                var output = outputs[i];\n                if (output.type !== 1 /* Animation */) {\n                    addAttrExpr(output.name);\n                }\n            }\n            // this is a cheap way of adding the marker only after all the input/output\n            // values have been filtered (by not including the animation ones) and added\n            // to the expressions. The marker is important because it tells the runtime\n            // code that this is where attributes without values start...\n            if (attrExprs.length !== attrsLengthBeforeInputs) {\n                attrExprs.splice(attrsLengthBeforeInputs, 0, literal(3 /* Bindings */));\n            }\n        }\n        if (templateAttrs.length) {\n            attrExprs.push(literal(4 /* Template */));\n            templateAttrs.forEach(function (attr) { return addAttrExpr(attr.name); });\n        }\n        if (i18nAttrs.length) {\n            attrExprs.push(literal(6 /* I18n */));\n            i18nAttrs.forEach(function (attr) { return addAttrExpr(attr.name); });\n        }\n        return attrExprs;\n    };\n    TemplateDefinitionBuilder.prototype.toAttrsParam = function (attrsExprs) {\n        return attrsExprs.length > 0 ?\n            this.constantPool.getConstLiteral(literalArr(attrsExprs), true) :\n            TYPED_NULL_EXPR;\n    };\n    TemplateDefinitionBuilder.prototype.prepareRefsParameter = function (references) {\n        var _this = this;\n        if (!references || references.length === 0) {\n            return TYPED_NULL_EXPR;\n        }\n        var refsParam = flatten(references.map(function (reference) {\n            var slot = _this.allocateDataSlot();\n            // Generate the update temporary.\n            var variableName = _this._bindingScope.freshReferenceName();\n            var retrievalLevel = _this.level;\n            var lhs = variable(variableName);\n            _this._bindingScope.set(retrievalLevel, reference.name, lhs, 0 /* DEFAULT */, function (scope, relativeLevel) {\n                // e.g. nextContext(2);\n                var nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];\n                // e.g. const $foo$ = reference(1);\n                var refExpr = lhs.set(importExpr(Identifiers$1.reference).callFn([literal(slot)]));\n                return nextContextStmt.concat(refExpr.toConstDecl());\n            }, true);\n            return [reference.name, reference.value];\n        }));\n        return this.constantPool.getConstLiteral(asLiteral(refsParam), true);\n    };\n    TemplateDefinitionBuilder.prototype.prepareListenerParameter = function (tagName, outputAst, index) {\n        var _this = this;\n        return function () {\n            var eventName = outputAst.name;\n            var bindingFnName = outputAst.type === 1 /* Animation */ ?\n                // synthetic @listener.foo values are treated the exact same as are standard listeners\n                prepareSyntheticListenerFunctionName(eventName, outputAst.phase) :\n                sanitizeIdentifier(eventName);\n            var handlerName = _this.templateName + \"_\" + tagName + \"_\" + bindingFnName + \"_\" + index + \"_listener\";\n            var scope = _this._bindingScope.nestedScope(_this._bindingScope.bindingLevel);\n            return prepareEventListenerParameters(outputAst, handlerName, scope);\n        };\n    };\n    return TemplateDefinitionBuilder;\n}());\nvar ValueConverter = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ValueConverter, _super);\n    function ValueConverter(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {\n        var _this = _super.call(this) || this;\n        _this.constantPool = constantPool;\n        _this.allocateSlot = allocateSlot;\n        _this.allocatePureFunctionSlots = allocatePureFunctionSlots;\n        _this.definePipe = definePipe;\n        _this._pipeBindExprs = [];\n        return _this;\n    }\n    // AstMemoryEfficientTransformer\n    ValueConverter.prototype.visitPipe = function (pipe, context) {\n        // Allocate a slot to create the pipe\n        var slot = this.allocateSlot();\n        var slotPseudoLocal = \"PIPE:\" + slot;\n        // Allocate one slot for the result plus one slot per pipe argument\n        var pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);\n        var target = new PropertyRead(pipe.span, new ImplicitReceiver(pipe.span), slotPseudoLocal);\n        var _a = pipeBindingCallInfo(pipe.args), identifier = _a.identifier, isVarLength = _a.isVarLength;\n        this.definePipe(pipe.name, slotPseudoLocal, slot, importExpr(identifier));\n        var args = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([pipe.exp], pipe.args);\n        var convertedArgs = isVarLength ? this.visitAll([new LiteralArray(pipe.span, args)]) : this.visitAll(args);\n        var pipeBindExpr = new FunctionCall(pipe.span, target, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([\n            new LiteralPrimitive(pipe.span, slot),\n            new LiteralPrimitive(pipe.span, pureFunctionSlot)\n        ], convertedArgs));\n        this._pipeBindExprs.push(pipeBindExpr);\n        return pipeBindExpr;\n    };\n    ValueConverter.prototype.updatePipeSlotOffsets = function (bindingSlots) {\n        this._pipeBindExprs.forEach(function (pipe) {\n            // update the slot offset arg (index 1) to account for binding slots\n            var slotOffset = pipe.args[1];\n            slotOffset.value += bindingSlots;\n        });\n    };\n    ValueConverter.prototype.visitLiteralArray = function (array, context) {\n        var _this = this;\n        return new BuiltinFunctionCall(array.span, this.visitAll(array.expressions), function (values) {\n            // If the literal has calculated (non-literal) elements transform it into\n            // calls to literal factories that compose the literal and will cache intermediate\n            // values. Otherwise, just return an literal array that contains the values.\n            var literal = literalArr(values);\n            return values.every(function (a) { return a.isConstant(); }) ?\n                _this.constantPool.getConstLiteral(literal, true) :\n                getLiteralFactory(_this.constantPool, literal, _this.allocatePureFunctionSlots);\n        });\n    };\n    ValueConverter.prototype.visitLiteralMap = function (map, context) {\n        var _this = this;\n        return new BuiltinFunctionCall(map.span, this.visitAll(map.values), function (values) {\n            // If the literal has calculated (non-literal) elements  transform it into\n            // calls to literal factories that compose the literal and will cache intermediate\n            // values. Otherwise, just return an literal array that contains the values.\n            var literal = literalMap(values.map(function (value, index) { return ({ key: map.keys[index].key, value: value, quoted: map.keys[index].quoted }); }));\n            return values.every(function (a) { return a.isConstant(); }) ?\n                _this.constantPool.getConstLiteral(literal, true) :\n                getLiteralFactory(_this.constantPool, literal, _this.allocatePureFunctionSlots);\n        });\n    };\n    return ValueConverter;\n}(AstMemoryEfficientTransformer));\n// Pipes always have at least one parameter, the value they operate on\nvar pipeBindingIdentifiers = [Identifiers$1.pipeBind1, Identifiers$1.pipeBind2, Identifiers$1.pipeBind3, Identifiers$1.pipeBind4];\nfunction pipeBindingCallInfo(args) {\n    var identifier = pipeBindingIdentifiers[args.length];\n    return {\n        identifier: identifier || Identifiers$1.pipeBindV,\n        isVarLength: !identifier,\n    };\n}\nvar pureFunctionIdentifiers = [\n    Identifiers$1.pureFunction0, Identifiers$1.pureFunction1, Identifiers$1.pureFunction2, Identifiers$1.pureFunction3, Identifiers$1.pureFunction4,\n    Identifiers$1.pureFunction5, Identifiers$1.pureFunction6, Identifiers$1.pureFunction7, Identifiers$1.pureFunction8\n];\nfunction pureFunctionCallInfo(args) {\n    var identifier = pureFunctionIdentifiers[args.length];\n    return {\n        identifier: identifier || Identifiers$1.pureFunctionV,\n        isVarLength: !identifier,\n    };\n}\nfunction instruction(span, reference, params) {\n    return importExpr(reference, null, span).callFn(params, span);\n}\n// e.g. x(2);\nfunction generateNextContextExpr(relativeLevelDiff) {\n    return importExpr(Identifiers$1.nextContext)\n        .callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);\n}\nfunction getLiteralFactory(constantPool, literal$1, allocateSlots) {\n    var _a = constantPool.getLiteralFactory(literal$1), literalFactory = _a.literalFactory, literalFactoryArguments = _a.literalFactoryArguments;\n    // Allocate 1 slot for the result plus 1 per argument\n    var startSlot = allocateSlots(1 + literalFactoryArguments.length);\n    literalFactoryArguments.length > 0 || error(\"Expected arguments to a literal factory function\");\n    var _b = pureFunctionCallInfo(literalFactoryArguments), identifier = _b.identifier, isVarLength = _b.isVarLength;\n    // Literal factories are pure functions that only need to be re-invoked when the parameters\n    // change.\n    var args = [\n        literal(startSlot),\n        literalFactory,\n    ];\n    if (isVarLength) {\n        args.push(literalArr(literalFactoryArguments));\n    }\n    else {\n        args.push.apply(args, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(literalFactoryArguments));\n    }\n    return importExpr(identifier).callFn(args);\n}\n/**\n * Gets an array of literals that can be added to an expression\n * to represent the name and namespace of an attribute. E.g.\n * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.\n *\n * @param name Name of the attribute, including the namespace.\n */\nfunction getAttributeNameLiterals(name) {\n    var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(splitNsName(name), 2), attributeNamespace = _a[0], attributeName = _a[1];\n    var nameLiteral = literal(attributeName);\n    if (attributeNamespace) {\n        return [\n            literal(0 /* NamespaceURI */), literal(attributeNamespace), nameLiteral\n        ];\n    }\n    return [nameLiteral];\n}\n/** The prefix used to get a shared context in BindingScope's map. */\nvar SHARED_CONTEXT_KEY = '$$shared_ctx$$';\nvar BindingScope = /** @class */ (function () {\n    function BindingScope(bindingLevel, parent) {\n        if (bindingLevel === void 0) { bindingLevel = 0; }\n        if (parent === void 0) { parent = null; }\n        this.bindingLevel = bindingLevel;\n        this.parent = parent;\n        /** Keeps a map from local variables to their BindingData. */\n        this.map = new Map();\n        this.referenceNameIndex = 0;\n        this.restoreViewVariable = null;\n    }\n    Object.defineProperty(BindingScope, \"ROOT_SCOPE\", {\n        get: function () {\n            if (!BindingScope._ROOT_SCOPE) {\n                BindingScope._ROOT_SCOPE = new BindingScope().set(0, '$event', variable('$event'));\n            }\n            return BindingScope._ROOT_SCOPE;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BindingScope.prototype.get = function (name) {\n        var current = this;\n        while (current) {\n            var value = current.map.get(name);\n            if (value != null) {\n                if (current !== this) {\n                    // make a local copy and reset the `declare` state\n                    value = {\n                        retrievalLevel: value.retrievalLevel,\n                        lhs: value.lhs,\n                        declareLocalCallback: value.declareLocalCallback,\n                        declare: false,\n                        priority: value.priority,\n                        localRef: value.localRef\n                    };\n                    // Cache the value locally.\n                    this.map.set(name, value);\n                    // Possibly generate a shared context var\n                    this.maybeGenerateSharedContextVar(value);\n                    this.maybeRestoreView(value.retrievalLevel, value.localRef);\n                }\n                if (value.declareLocalCallback && !value.declare) {\n                    value.declare = true;\n                }\n                return value.lhs;\n            }\n            current = current.parent;\n        }\n        // If we get to this point, we are looking for a property on the top level component\n        // - If level === 0, we are on the top and don't need to re-declare `ctx`.\n        // - If level > 0, we are in an embedded view. We need to retrieve the name of the\n        // local var we used to store the component context, e.g. const $comp$ = x();\n        return this.bindingLevel === 0 ? null : this.getComponentProperty(name);\n    };\n    /**\n     * Create a local variable for later reference.\n     *\n     * @param retrievalLevel The level from which this value can be retrieved\n     * @param name Name of the variable.\n     * @param lhs AST representing the left hand side of the `let lhs = rhs;`.\n     * @param priority The sorting priority of this var\n     * @param declareLocalCallback The callback to invoke when declaring this local var\n     * @param localRef Whether or not this is a local ref\n     */\n    BindingScope.prototype.set = function (retrievalLevel, name, lhs, priority, declareLocalCallback, localRef) {\n        if (priority === void 0) { priority = 0 /* DEFAULT */; }\n        if (this.map.has(name)) {\n            if (localRef) {\n                // Do not throw an error if it's a local ref and do not update existing value,\n                // so the first defined ref is always returned.\n                return this;\n            }\n            error(\"The name \" + name + \" is already defined in scope to be \" + this.map.get(name));\n        }\n        this.map.set(name, {\n            retrievalLevel: retrievalLevel,\n            lhs: lhs,\n            declare: false,\n            declareLocalCallback: declareLocalCallback,\n            priority: priority,\n            localRef: localRef || false\n        });\n        return this;\n    };\n    // Implemented as part of LocalResolver.\n    BindingScope.prototype.getLocal = function (name) { return this.get(name); };\n    // Implemented as part of LocalResolver.\n    BindingScope.prototype.notifyImplicitReceiverUse = function () {\n        if (this.bindingLevel !== 0) {\n            // Since the implicit receiver is accessed in an embedded view, we need to\n            // ensure that we declare a shared context variable for the current template\n            // in the update variables.\n            this.map.get(SHARED_CONTEXT_KEY + 0).declare = true;\n        }\n    };\n    BindingScope.prototype.nestedScope = function (level) {\n        var newScope = new BindingScope(level, this);\n        if (level > 0)\n            newScope.generateSharedContextVar(0);\n        return newScope;\n    };\n    /**\n     * Gets or creates a shared context variable and returns its expression. Note that\n     * this does not mean that the shared variable will be declared. Variables in the\n     * binding scope will be only declared if they are used.\n     */\n    BindingScope.prototype.getOrCreateSharedContextVar = function (retrievalLevel) {\n        var bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;\n        if (!this.map.has(bindingKey)) {\n            this.generateSharedContextVar(retrievalLevel);\n        }\n        // Shared context variables are always generated as \"ReadVarExpr\".\n        return this.map.get(bindingKey).lhs;\n    };\n    BindingScope.prototype.getSharedContextName = function (retrievalLevel) {\n        var sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);\n        // Shared context variables are always generated as \"ReadVarExpr\".\n        return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;\n    };\n    BindingScope.prototype.maybeGenerateSharedContextVar = function (value) {\n        if (value.priority === 1 /* CONTEXT */ &&\n            value.retrievalLevel < this.bindingLevel) {\n            var sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);\n            if (sharedCtxObj) {\n                sharedCtxObj.declare = true;\n            }\n            else {\n                this.generateSharedContextVar(value.retrievalLevel);\n            }\n        }\n    };\n    BindingScope.prototype.generateSharedContextVar = function (retrievalLevel) {\n        var lhs = variable(CONTEXT_NAME + this.freshReferenceName());\n        this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {\n            retrievalLevel: retrievalLevel,\n            lhs: lhs,\n            declareLocalCallback: function (scope, relativeLevel) {\n                // const ctx_r0 = nextContext(2);\n                return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];\n            },\n            declare: false,\n            priority: 2 /* SHARED_CONTEXT */,\n            localRef: false\n        });\n    };\n    BindingScope.prototype.getComponentProperty = function (name) {\n        var componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);\n        componentValue.declare = true;\n        this.maybeRestoreView(0, false);\n        return componentValue.lhs.prop(name);\n    };\n    BindingScope.prototype.maybeRestoreView = function (retrievalLevel, localRefLookup) {\n        // We want to restore the current view in listener fns if:\n        // 1 - we are accessing a value in a parent view, which requires walking the view tree rather\n        // than using the ctx arg. In this case, the retrieval and binding level will be different.\n        // 2 - we are looking up a local ref, which requires restoring the view where the local\n        // ref is stored\n        if (this.isListenerScope() && (retrievalLevel < this.bindingLevel || localRefLookup)) {\n            if (!this.parent.restoreViewVariable) {\n                // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction\n                this.parent.restoreViewVariable = variable(this.parent.freshReferenceName());\n            }\n            this.restoreViewVariable = this.parent.restoreViewVariable;\n        }\n    };\n    BindingScope.prototype.restoreViewStatement = function () {\n        // restoreView($state$);\n        return this.restoreViewVariable ?\n            [instruction(null, Identifiers$1.restoreView, [this.restoreViewVariable]).toStmt()] :\n            [];\n    };\n    BindingScope.prototype.viewSnapshotStatements = function () {\n        // const $state$ = getCurrentView();\n        var getCurrentViewInstruction = instruction(null, Identifiers$1.getCurrentView, []);\n        return this.restoreViewVariable ?\n            [this.restoreViewVariable.set(getCurrentViewInstruction).toConstDecl()] :\n            [];\n    };\n    BindingScope.prototype.isListenerScope = function () { return this.parent && this.parent.bindingLevel === this.bindingLevel; };\n    BindingScope.prototype.variableDeclarations = function () {\n        var _this = this;\n        var currentContextLevel = 0;\n        return Array.from(this.map.values())\n            .filter(function (value) { return value.declare; })\n            .sort(function (a, b) { return b.retrievalLevel - a.retrievalLevel || b.priority - a.priority; })\n            .reduce(function (stmts, value) {\n            var levelDiff = _this.bindingLevel - value.retrievalLevel;\n            var currStmts = value.declareLocalCallback(_this, levelDiff - currentContextLevel);\n            currentContextLevel = levelDiff;\n            return stmts.concat(currStmts);\n        }, []);\n    };\n    BindingScope.prototype.freshReferenceName = function () {\n        var current = this;\n        // Find the top scope as it maintains the global reference count\n        while (current.parent)\n            current = current.parent;\n        var ref = \"\" + REFERENCE_PREFIX + current.referenceNameIndex++;\n        return ref;\n    };\n    return BindingScope;\n}());\n/**\n * Creates a `CssSelector` given a tag name and a map of attributes\n */\nfunction createCssSelector(tag, attributes) {\n    var cssSelector = new CssSelector();\n    cssSelector.setElement(tag);\n    Object.getOwnPropertyNames(attributes).forEach(function (name) {\n        var value = attributes[name];\n        cssSelector.addAttribute(name, value);\n        if (name.toLowerCase() === 'class') {\n            var classes = value.trim().split(/\\s+/);\n            classes.forEach(function (className) { return cssSelector.addClassName(className); });\n        }\n    });\n    return cssSelector;\n}\n/**\n * Creates an array of expressions out of an `ngProjectAs` attributes\n * which can be added to the instruction parameters.\n */\nfunction getNgProjectAsLiteral(attribute) {\n    // Parse the attribute value into a CssSelectorList. Note that we only take the\n    // first selector, because we don't support multiple selectors in ngProjectAs.\n    var parsedR3Selector = parseSelectorToR3Selector(attribute.value)[0];\n    return [literal(5 /* ProjectAs */), asLiteral(parsedR3Selector)];\n}\n/**\n * Gets the instruction to generate for an interpolated property\n * @param interpolation An Interpolation AST\n */\nfunction getPropertyInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers$1.propertyInterpolate;\n        case 3:\n            return Identifiers$1.propertyInterpolate1;\n        case 5:\n            return Identifiers$1.propertyInterpolate2;\n        case 7:\n            return Identifiers$1.propertyInterpolate3;\n        case 9:\n            return Identifiers$1.propertyInterpolate4;\n        case 11:\n            return Identifiers$1.propertyInterpolate5;\n        case 13:\n            return Identifiers$1.propertyInterpolate6;\n        case 15:\n            return Identifiers$1.propertyInterpolate7;\n        case 17:\n            return Identifiers$1.propertyInterpolate8;\n        default:\n            return Identifiers$1.propertyInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for an interpolated attribute\n * @param interpolation An Interpolation AST\n */\nfunction getAttributeInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 3:\n            return Identifiers$1.attributeInterpolate1;\n        case 5:\n            return Identifiers$1.attributeInterpolate2;\n        case 7:\n            return Identifiers$1.attributeInterpolate3;\n        case 9:\n            return Identifiers$1.attributeInterpolate4;\n        case 11:\n            return Identifiers$1.attributeInterpolate5;\n        case 13:\n            return Identifiers$1.attributeInterpolate6;\n        case 15:\n            return Identifiers$1.attributeInterpolate7;\n        case 17:\n            return Identifiers$1.attributeInterpolate8;\n        default:\n            return Identifiers$1.attributeInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for interpolated text.\n * @param interpolation An Interpolation AST\n */\nfunction getTextInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers$1.textInterpolate;\n        case 3:\n            return Identifiers$1.textInterpolate1;\n        case 5:\n            return Identifiers$1.textInterpolate2;\n        case 7:\n            return Identifiers$1.textInterpolate3;\n        case 9:\n            return Identifiers$1.textInterpolate4;\n        case 11:\n            return Identifiers$1.textInterpolate5;\n        case 13:\n            return Identifiers$1.textInterpolate6;\n        case 15:\n            return Identifiers$1.textInterpolate7;\n        case 17:\n            return Identifiers$1.textInterpolate8;\n        default:\n            return Identifiers$1.textInterpolateV;\n    }\n}\n/**\n * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.\n *\n * @param template text of the template to parse\n * @param templateUrl URL to use for source mapping of the parsed template\n * @param options options to modify how the template is parsed\n */\nfunction parseTemplate(template, templateUrl, options) {\n    if (options === void 0) { options = {}; }\n    var interpolationConfig = options.interpolationConfig, preserveWhitespaces = options.preserveWhitespaces;\n    var bindingParser = makeBindingParser(interpolationConfig);\n    var htmlParser = new HtmlParser();\n    var parseResult = htmlParser.parse(template, templateUrl, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ leadingTriviaChars: LEADING_TRIVIA_CHARS }, options, { tokenizeExpansionForms: true }));\n    if (parseResult.errors && parseResult.errors.length > 0) {\n        return { errors: parseResult.errors, nodes: [], styleUrls: [], styles: [] };\n    }\n    var rootNodes = parseResult.rootNodes;\n    // process i18n meta information (scan attributes, generate ids)\n    // before we run whitespace removal process, because existing i18n\n    // extraction process (ng xi18n) relies on a raw content to generate\n    // message ids\n    rootNodes =\n        visitAll$1(new I18nMetaVisitor(interpolationConfig, !preserveWhitespaces), rootNodes);\n    if (!preserveWhitespaces) {\n        rootNodes = visitAll$1(new WhitespaceVisitor(), rootNodes);\n        // run i18n meta visitor again in case we remove whitespaces, because\n        // that might affect generated i18n message content. During this pass\n        // i18n IDs generated at the first pass will be preserved, so we can mimic\n        // existing extraction process (ng xi18n)\n        rootNodes = visitAll$1(new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ false), rootNodes);\n    }\n    var _a = htmlAstToRender3Ast(rootNodes, bindingParser), nodes = _a.nodes, errors = _a.errors, styleUrls = _a.styleUrls, styles = _a.styles;\n    if (errors && errors.length > 0) {\n        return { errors: errors, nodes: [], styleUrls: [], styles: [] };\n    }\n    return { nodes: nodes, styleUrls: styleUrls, styles: styles };\n}\n/**\n * Construct a `BindingParser` with a default configuration.\n */\nfunction makeBindingParser(interpolationConfig) {\n    if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n    return new BindingParser(new Parser$1(new Lexer()), interpolationConfig, new DomElementSchemaRegistry(), null, []);\n}\nfunction resolveSanitizationFn(context, isAttribute) {\n    switch (context) {\n        case SecurityContext.HTML:\n            return importExpr(Identifiers$1.sanitizeHtml);\n        case SecurityContext.SCRIPT:\n            return importExpr(Identifiers$1.sanitizeScript);\n        case SecurityContext.STYLE:\n            // the compiler does not fill in an instruction for [style.prop?] binding\n            // values because the style algorithm knows internally what props are subject\n            // to sanitization (only [attr.style] values are explicitly sanitized)\n            return isAttribute ? importExpr(Identifiers$1.sanitizeStyle) : null;\n        case SecurityContext.URL:\n            return importExpr(Identifiers$1.sanitizeUrl);\n        case SecurityContext.RESOURCE_URL:\n            return importExpr(Identifiers$1.sanitizeResourceUrl);\n        default:\n            return null;\n    }\n}\nfunction isSingleElementTemplate(children) {\n    return children.length === 1 && children[0] instanceof Element;\n}\nfunction isTextNode(node) {\n    return node instanceof Text || node instanceof BoundText || node instanceof Icu;\n}\nfunction hasTextChildrenOnly(children) {\n    return children.every(isTextNode);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar EMPTY_ARRAY = [];\n// This regex matches any binding names that contain the \"attr.\" prefix, e.g. \"attr.required\"\n// If there is a match, the first matching group will contain the attribute name to bind.\nvar ATTR_REGEX = /attr\\.([^\\]]+)/;\nfunction getStylingPrefix(name) {\n    return name.substring(0, 5); // style or class\n}\nfunction baseDirectiveFields(meta, constantPool, bindingParser) {\n    var definitionMap = new DefinitionMap();\n    // e.g. `type: MyDirective`\n    definitionMap.set('type', meta.type);\n    // e.g. `selectors: [['', 'someDir', '']]`\n    definitionMap.set('selectors', createDirectiveSelector(meta.selector));\n    // e.g. `factory: () => new MyApp(directiveInject(ElementRef))`\n    var result = compileFactoryFunction({\n        name: meta.name,\n        type: meta.type,\n        deps: meta.deps,\n        injectFn: Identifiers$1.directiveInject,\n    });\n    definitionMap.set('factory', result.factory);\n    if (meta.queries.length > 0) {\n        // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }\n        definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));\n    }\n    if (meta.viewQueries.length) {\n        definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));\n    }\n    // e.g. `hostBindings: (rf, ctx, elIndex) => { ... }\n    definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '', meta.name));\n    // e.g 'inputs: {a: 'a'}`\n    definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));\n    // e.g 'outputs: {a: 'a'}`\n    definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));\n    if (meta.exportAs !== null) {\n        definitionMap.set('exportAs', literalArr(meta.exportAs.map(function (e) { return literal(e); })));\n    }\n    return { definitionMap: definitionMap, statements: result.statements };\n}\n/**\n * Add features to the definition map.\n */\nfunction addFeatures(definitionMap, meta) {\n    // e.g. `features: [NgOnChangesFeature()]`\n    var features = [];\n    var providers = meta.providers;\n    var viewProviders = meta.viewProviders;\n    if (providers || viewProviders) {\n        var args = [providers || new LiteralArrayExpr([])];\n        if (viewProviders) {\n            args.push(viewProviders);\n        }\n        features.push(importExpr(Identifiers$1.ProvidersFeature).callFn(args));\n    }\n    if (meta.usesInheritance) {\n        features.push(importExpr(Identifiers$1.InheritDefinitionFeature));\n    }\n    if (meta.lifecycle.usesOnChanges) {\n        features.push(importExpr(Identifiers$1.NgOnChangesFeature).callFn(EMPTY_ARRAY));\n    }\n    if (features.length) {\n        definitionMap.set('features', literalArr(features));\n    }\n}\n/**\n * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.\n */\nfunction compileDirectiveFromMetadata(meta, constantPool, bindingParser) {\n    var _a = baseDirectiveFields(meta, constantPool, bindingParser), definitionMap = _a.definitionMap, statements = _a.statements;\n    addFeatures(definitionMap, meta);\n    var expression = importExpr(Identifiers$1.defineDirective).callFn([definitionMap.toLiteralMap()]);\n    if (!meta.selector) {\n        throw new Error(\"Directive \" + meta.name + \" has no selector, please add it!\");\n    }\n    var type = createTypeForDef(meta, Identifiers$1.DirectiveDefWithMeta);\n    return { expression: expression, type: type, statements: statements };\n}\n/**\n * Compile a base definition for the render3 runtime as defined by {@link R3BaseRefMetadata}\n * @param meta the metadata used for compilation.\n */\nfunction compileBaseDefFromMetadata(meta, constantPool, bindingParser) {\n    var definitionMap = new DefinitionMap();\n    if (meta.inputs) {\n        var inputs_1 = meta.inputs;\n        var inputsMap = Object.keys(inputs_1).map(function (key) {\n            var v = inputs_1[key];\n            var value = Array.isArray(v) ? literalArr(v.map(function (vx) { return literal(vx); })) : literal(v);\n            return { key: key, value: value, quoted: false };\n        });\n        definitionMap.set('inputs', literalMap(inputsMap));\n    }\n    if (meta.outputs) {\n        var outputs_1 = meta.outputs;\n        var outputsMap = Object.keys(outputs_1).map(function (key) {\n            var value = literal(outputs_1[key]);\n            return { key: key, value: value, quoted: false };\n        });\n        definitionMap.set('outputs', literalMap(outputsMap));\n    }\n    if (meta.viewQueries && meta.viewQueries.length > 0) {\n        definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool));\n    }\n    if (meta.queries && meta.queries.length > 0) {\n        definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool));\n    }\n    if (meta.host) {\n        definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.name));\n    }\n    var expression = importExpr(Identifiers$1.defineBase).callFn([definitionMap.toLiteralMap()]);\n    var type = new ExpressionType(importExpr(Identifiers$1.BaseDef), /* modifiers */ null, [expressionType(meta.type)]);\n    return { expression: expression, type: type };\n}\n/**\n * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.\n */\nfunction compileComponentFromMetadata(meta, constantPool, bindingParser) {\n    var e_1, _a;\n    var _b = baseDirectiveFields(meta, constantPool, bindingParser), definitionMap = _b.definitionMap, statements = _b.statements;\n    addFeatures(definitionMap, meta);\n    var selector = meta.selector && CssSelector.parse(meta.selector);\n    var firstSelector = selector && selector[0];\n    // e.g. `attr: [\"class\", \".my.app\"]`\n    // This is optional an only included if the first selector of a component specifies attributes.\n    if (firstSelector) {\n        var selectorAttributes = firstSelector.getAttrs();\n        if (selectorAttributes.length) {\n            definitionMap.set('attrs', constantPool.getConstLiteral(literalArr(selectorAttributes.map(function (value) { return value != null ? literal(value) : literal(undefined); })), \n            /* forceShared */ true));\n        }\n    }\n    // Generate the CSS matcher that recognize directive\n    var directiveMatcher = null;\n    if (meta.directives.length > 0) {\n        var matcher = new SelectorMatcher();\n        try {\n            for (var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(meta.directives), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var _e = _d.value, selector_1 = _e.selector, expression_1 = _e.expression;\n                matcher.addSelectables(CssSelector.parse(selector_1), expression_1);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        directiveMatcher = matcher;\n    }\n    // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`\n    var templateTypeName = meta.name;\n    var templateName = templateTypeName ? templateTypeName + \"_Template\" : null;\n    var directivesUsed = new Set();\n    var pipesUsed = new Set();\n    var changeDetection = meta.changeDetection;\n    var template = meta.template;\n    var templateBuilder = new TemplateDefinitionBuilder(constantPool, BindingScope.ROOT_SCOPE, 0, templateTypeName, null, null, templateName, directiveMatcher, directivesUsed, meta.pipes, pipesUsed, Identifiers$1.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);\n    var templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);\n    // We need to provide this so that dynamically generated components know what\n    // projected content blocks to pass through to the component when it is instantiated.\n    var ngContentSelectors = templateBuilder.getNgContentSelectors();\n    if (ngContentSelectors) {\n        definitionMap.set('ngContentSelectors', ngContentSelectors);\n    }\n    // e.g. `consts: 2`\n    definitionMap.set('consts', literal(templateBuilder.getConstCount()));\n    // e.g. `vars: 2`\n    definitionMap.set('vars', literal(templateBuilder.getVarCount()));\n    definitionMap.set('template', templateFunctionExpression);\n    // e.g. `directives: [MyDirective]`\n    if (directivesUsed.size) {\n        var directivesExpr = literalArr(Array.from(directivesUsed));\n        if (meta.wrapDirectivesAndPipesInClosure) {\n            directivesExpr = fn([], [new ReturnStatement(directivesExpr)]);\n        }\n        definitionMap.set('directives', directivesExpr);\n    }\n    // e.g. `pipes: [MyPipe]`\n    if (pipesUsed.size) {\n        var pipesExpr = literalArr(Array.from(pipesUsed));\n        if (meta.wrapDirectivesAndPipesInClosure) {\n            pipesExpr = fn([], [new ReturnStatement(pipesExpr)]);\n        }\n        definitionMap.set('pipes', pipesExpr);\n    }\n    if (meta.encapsulation === null) {\n        meta.encapsulation = ViewEncapsulation.Emulated;\n    }\n    // e.g. `styles: [str1, str2]`\n    if (meta.styles && meta.styles.length) {\n        var styleValues = meta.encapsulation == ViewEncapsulation.Emulated ?\n            compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) :\n            meta.styles;\n        var strings = styleValues.map(function (str) { return literal(str); });\n        definitionMap.set('styles', literalArr(strings));\n    }\n    else if (meta.encapsulation === ViewEncapsulation.Emulated) {\n        // If there is no style, don't generate css selectors on elements\n        meta.encapsulation = ViewEncapsulation.None;\n    }\n    // Only set view encapsulation if it's not the default value\n    if (meta.encapsulation !== ViewEncapsulation.Emulated) {\n        definitionMap.set('encapsulation', literal(meta.encapsulation));\n    }\n    // e.g. `animation: [trigger('123', [])]`\n    if (meta.animations !== null) {\n        definitionMap.set('data', literalMap([{ key: 'animation', value: meta.animations, quoted: false }]));\n    }\n    // Only set the change detection flag if it's defined and it's not the default.\n    if (changeDetection != null && changeDetection !== ChangeDetectionStrategy.Default) {\n        definitionMap.set('changeDetection', literal(changeDetection));\n    }\n    // On the type side, remove newlines from the selector as it will need to fit into a TypeScript\n    // string literal, which must be on one line.\n    var selectorForType = (meta.selector || '').replace(/\\n/g, '');\n    var expression = importExpr(Identifiers$1.defineComponent).callFn([definitionMap.toLiteralMap()]);\n    var type = createTypeForDef(meta, Identifiers$1.ComponentDefWithMeta);\n    return { expression: expression, type: type, statements: statements };\n}\n/**\n * A wrapper around `compileDirective` which depends on render2 global analysis data as its input\n * instead of the `R3DirectiveMetadata`.\n *\n * `R3DirectiveMetadata` is computed from `CompileDirectiveMetadata` and other statically reflected\n * information.\n */\nfunction compileDirectiveFromRender2(outputCtx, directive, reflector, bindingParser) {\n    var name = identifierName(directive.type);\n    name || error(\"Cannot resolver the name of \" + directive.type);\n    var definitionField = outputCtx.constantPool.propertyNameOf(1 /* Directive */);\n    var meta = directiveMetadataFromGlobalMetadata(directive, outputCtx, reflector);\n    var res = compileDirectiveFromMetadata(meta, outputCtx.constantPool, bindingParser);\n    // Create the partial class to be merged with the actual class.\n    outputCtx.statements.push(new ClassStmt(name, null, [new ClassField(definitionField, INFERRED_TYPE, [StmtModifier.Static], res.expression)], [], new ClassMethod(null, [], []), []));\n}\n/**\n * A wrapper around `compileComponent` which depends on render2 global analysis data as its input\n * instead of the `R3DirectiveMetadata`.\n *\n * `R3ComponentMetadata` is computed from `CompileDirectiveMetadata` and other statically reflected\n * information.\n */\nfunction compileComponentFromRender2(outputCtx, component, render3Ast, reflector, bindingParser, directiveTypeBySel, pipeTypeByName) {\n    var name = identifierName(component.type);\n    name || error(\"Cannot resolver the name of \" + component.type);\n    var definitionField = outputCtx.constantPool.propertyNameOf(2 /* Component */);\n    var summary = component.toSummary();\n    // Compute the R3ComponentMetadata from the CompileDirectiveMetadata\n    var meta = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, directiveMetadataFromGlobalMetadata(component, outputCtx, reflector), { selector: component.selector, template: { nodes: render3Ast.nodes }, directives: [], pipes: typeMapToExpressionMap(pipeTypeByName, outputCtx), viewQueries: queriesFromGlobalMetadata(component.viewQueries, outputCtx), wrapDirectivesAndPipesInClosure: false, styles: (summary.template && summary.template.styles) || EMPTY_ARRAY, encapsulation: (summary.template && summary.template.encapsulation) || ViewEncapsulation.Emulated, interpolation: DEFAULT_INTERPOLATION_CONFIG, animations: null, viewProviders: component.viewProviders.length > 0 ? new WrappedNodeExpr(component.viewProviders) : null, relativeContextFilePath: '', i18nUseExternalIds: true });\n    var res = compileComponentFromMetadata(meta, outputCtx.constantPool, bindingParser);\n    // Create the partial class to be merged with the actual class.\n    outputCtx.statements.push(new ClassStmt(name, null, [new ClassField(definitionField, INFERRED_TYPE, [StmtModifier.Static], res.expression)], [], new ClassMethod(null, [], []), []));\n}\n/**\n * Compute `R3DirectiveMetadata` given `CompileDirectiveMetadata` and a `CompileReflector`.\n */\nfunction directiveMetadataFromGlobalMetadata(directive, outputCtx, reflector) {\n    // The global-analysis based Ivy mode in ngc is no longer utilized/supported.\n    throw new Error('unsupported');\n}\n/**\n * Convert `CompileQueryMetadata` into `R3QueryMetadata`.\n */\nfunction queriesFromGlobalMetadata(queries, outputCtx) {\n    return queries.map(function (query) {\n        var read = null;\n        if (query.read && query.read.identifier) {\n            read = outputCtx.importExpr(query.read.identifier.reference);\n        }\n        return {\n            propertyName: query.propertyName,\n            first: query.first,\n            predicate: selectorsFromGlobalMetadata(query.selectors, outputCtx),\n            descendants: query.descendants, read: read,\n            static: !!query.static\n        };\n    });\n}\n/**\n * Convert `CompileTokenMetadata` for query selectors into either an expression for a predicate\n * type, or a list of string predicates.\n */\nfunction selectorsFromGlobalMetadata(selectors, outputCtx) {\n    if (selectors.length > 1 || (selectors.length == 1 && selectors[0].value)) {\n        var selectorStrings = selectors.map(function (value) { return value.value; });\n        selectorStrings.some(function (value) { return !value; }) &&\n            error('Found a type among the string selectors expected');\n        return outputCtx.constantPool.getConstLiteral(literalArr(selectorStrings.map(function (value) { return literal(value); })));\n    }\n    if (selectors.length == 1) {\n        var first = selectors[0];\n        if (first.identifier) {\n            return outputCtx.importExpr(first.identifier.reference);\n        }\n    }\n    error('Unexpected query form');\n    return NULL_EXPR;\n}\nfunction prepareQueryParams(query, constantPool) {\n    var parameters = [getQueryPredicate(query, constantPool), literal(query.descendants)];\n    if (query.read) {\n        parameters.push(query.read);\n    }\n    return parameters;\n}\n// Turn a directive selector into an R3-compatible selector for directive def\nfunction createDirectiveSelector(selector) {\n    return asLiteral(parseSelectorToR3Selector(selector));\n}\nfunction convertAttributesToExpressions(attributes) {\n    var e_2, _a;\n    var values = [];\n    try {\n        for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(Object.getOwnPropertyNames(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var key = _c.value;\n            var value = attributes[key];\n            values.push(literal(key), value);\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return values;\n}\n// Define and update any content queries\nfunction createContentQueriesFunction(queries, constantPool, name) {\n    var e_3, _a;\n    var createStatements = [];\n    var updateStatements = [];\n    var tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n    try {\n        for (var queries_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(queries), queries_1_1 = queries_1.next(); !queries_1_1.done; queries_1_1 = queries_1.next()) {\n            var query = queries_1_1.value;\n            var queryInstruction = query.static ? Identifiers$1.staticContentQuery : Identifiers$1.contentQuery;\n            // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null);\n            createStatements.push(importExpr(queryInstruction)\n                .callFn(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([variable('dirIndex')], prepareQueryParams(query, constantPool)))\n                .toStmt());\n            // update, e.g. (r3.queryRefresh(tmp = r3.loadContentQuery()) && (ctx.someDir = tmp));\n            var temporary = tempAllocator();\n            var getQueryList = importExpr(Identifiers$1.loadContentQuery).callFn([]);\n            var refresh = importExpr(Identifiers$1.queryRefresh).callFn([temporary.set(getQueryList)]);\n            var updateDirective = variable(CONTEXT_NAME)\n                .prop(query.propertyName)\n                .set(query.first ? temporary.prop('first') : temporary);\n            updateStatements.push(refresh.and(updateDirective).toStmt());\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (queries_1_1 && !queries_1_1.done && (_a = queries_1.return)) _a.call(queries_1);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    var contentQueriesFnName = name ? name + \"_ContentQueries\" : null;\n    return fn([\n        new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null),\n        new FnParam('dirIndex', null)\n    ], [\n        renderFlagCheckIfStmt(1 /* Create */, createStatements),\n        renderFlagCheckIfStmt(2 /* Update */, updateStatements)\n    ], INFERRED_TYPE, null, contentQueriesFnName);\n}\nfunction stringAsType(str) {\n    return expressionType(literal(str));\n}\nfunction stringMapAsType(map) {\n    var mapValues = Object.keys(map).map(function (key) {\n        var value = Array.isArray(map[key]) ? map[key][0] : map[key];\n        return {\n            key: key,\n            value: literal(value),\n            quoted: true,\n        };\n    });\n    return expressionType(literalMap(mapValues));\n}\nfunction stringArrayAsType(arr) {\n    return arr.length > 0 ? expressionType(literalArr(arr.map(function (value) { return literal(value); }))) :\n        NONE_TYPE;\n}\nfunction createTypeForDef(meta, typeBase) {\n    // On the type side, remove newlines from the selector as it will need to fit into a TypeScript\n    // string literal, which must be on one line.\n    var selectorForType = (meta.selector || '').replace(/\\n/g, '');\n    return expressionType(importExpr(typeBase, [\n        typeWithParameters(meta.type, meta.typeArgumentCount),\n        stringAsType(selectorForType),\n        meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE,\n        stringMapAsType(meta.inputs),\n        stringMapAsType(meta.outputs),\n        stringArrayAsType(meta.queries.map(function (q) { return q.propertyName; })),\n    ]));\n}\n// Define and update any view queries\nfunction createViewQueriesFunction(viewQueries, constantPool, name) {\n    var createStatements = [];\n    var updateStatements = [];\n    var tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n    viewQueries.forEach(function (query) {\n        var queryInstruction = query.static ? Identifiers$1.staticViewQuery : Identifiers$1.viewQuery;\n        // creation, e.g. r3.viewQuery(somePredicate, true);\n        var queryDefinition = importExpr(queryInstruction).callFn(prepareQueryParams(query, constantPool));\n        createStatements.push(queryDefinition.toStmt());\n        // update, e.g. (r3.queryRefresh(tmp = r3.loadViewQuery()) && (ctx.someDir = tmp));\n        var temporary = tempAllocator();\n        var getQueryList = importExpr(Identifiers$1.loadViewQuery).callFn([]);\n        var refresh = importExpr(Identifiers$1.queryRefresh).callFn([temporary.set(getQueryList)]);\n        var updateDirective = variable(CONTEXT_NAME)\n            .prop(query.propertyName)\n            .set(query.first ? temporary.prop('first') : temporary);\n        updateStatements.push(refresh.and(updateDirective).toStmt());\n    });\n    var viewQueryFnName = name ? name + \"_Query\" : null;\n    return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [\n        renderFlagCheckIfStmt(1 /* Create */, createStatements),\n        renderFlagCheckIfStmt(2 /* Update */, updateStatements)\n    ], INFERRED_TYPE, null, viewQueryFnName);\n}\n// Return a host binding function or null if one is not necessary.\nfunction createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name) {\n    // Initialize hostVarsCount to number of bound host properties (interpolations illegal)\n    var hostVarsCount = Object.keys(hostBindingsMetadata.properties).length;\n    var elVarExp = variable('elIndex');\n    var bindingContext = variable(CONTEXT_NAME);\n    var styleBuilder = new StylingBuilder(elVarExp, bindingContext);\n    var _a = hostBindingsMetadata.specialAttributes, styleAttr = _a.styleAttr, classAttr = _a.classAttr;\n    if (styleAttr !== undefined) {\n        styleBuilder.registerStyleAttr(styleAttr);\n    }\n    if (classAttr !== undefined) {\n        styleBuilder.registerClassAttr(classAttr);\n    }\n    var createStatements = [];\n    var updateStatements = [];\n    var totalHostVarsCount = hostVarsCount;\n    var hostBindingSourceSpan = typeSourceSpan;\n    var directiveSummary = metadataAsSummary(hostBindingsMetadata);\n    var valueConverter;\n    var getValueConverter = function () {\n        if (!valueConverter) {\n            var hostVarsCountFn = function (numSlots) {\n                var originalVarsCount = totalHostVarsCount;\n                totalHostVarsCount += numSlots;\n                return originalVarsCount;\n            };\n            valueConverter = new ValueConverter(constantPool, function () { return error('Unexpected node'); }, // new nodes are illegal here\n            hostVarsCountFn, function () { return error('Unexpected pipe'); }); // pipes are illegal here\n        }\n        return valueConverter;\n    };\n    // Calculate host event bindings\n    var eventBindings = bindingParser.createDirectiveHostEventAsts(directiveSummary, hostBindingSourceSpan);\n    if (eventBindings && eventBindings.length) {\n        var listeners = createHostListeners(eventBindings, name);\n        createStatements.push.apply(createStatements, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(listeners));\n    }\n    // Calculate the host property bindings\n    var bindings = bindingParser.createBoundHostProperties(directiveSummary, hostBindingSourceSpan);\n    var propertyBindings = [];\n    var attributeBindings = [];\n    var syntheticHostBindings = [];\n    bindings && bindings.forEach(function (binding) {\n        var name = binding.name;\n        var stylingInputWasSet = styleBuilder.registerInputBasedOnName(name, binding.expression, binding.sourceSpan);\n        if (!stylingInputWasSet) {\n            // resolve literal arrays and literal objects\n            var value = binding.expression.visit(getValueConverter());\n            var bindingExpr = bindingFn(bindingContext, value);\n            var _a = getBindingNameAndInstruction(binding), bindingName = _a.bindingName, instruction = _a.instruction, isAttribute = _a.isAttribute;\n            var securityContexts = bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute)\n                .filter(function (context) { return context !== SecurityContext.NONE; });\n            var sanitizerFn = null;\n            if (securityContexts.length) {\n                if (securityContexts.length === 2 &&\n                    securityContexts.indexOf(SecurityContext.URL) > -1 &&\n                    securityContexts.indexOf(SecurityContext.RESOURCE_URL) > -1) {\n                    // Special case for some URL attributes (such as \"src\" and \"href\") that may be a part\n                    // of different security contexts. In this case we use special santitization function and\n                    // select the actual sanitizer at runtime based on a tag name that is provided while\n                    // invoking sanitization function.\n                    sanitizerFn = importExpr(Identifiers$1.sanitizeUrlOrResourceUrl);\n                }\n                else {\n                    sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);\n                }\n            }\n            var instructionParams = [literal(bindingName), bindingExpr.currValExpr];\n            if (sanitizerFn) {\n                instructionParams.push(sanitizerFn);\n            }\n            updateStatements.push.apply(updateStatements, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(bindingExpr.stmts));\n            if (instruction === Identifiers$1.hostProperty) {\n                propertyBindings.push(instructionParams);\n            }\n            else if (instruction === Identifiers$1.attribute) {\n                attributeBindings.push(instructionParams);\n            }\n            else if (instruction === Identifiers$1.updateSyntheticHostBinding) {\n                syntheticHostBindings.push(instructionParams);\n            }\n            else {\n                updateStatements.push(importExpr(instruction).callFn(instructionParams).toStmt());\n            }\n        }\n    });\n    if (propertyBindings.length > 0) {\n        updateStatements.push(chainedInstruction(Identifiers$1.hostProperty, propertyBindings).toStmt());\n    }\n    if (attributeBindings.length > 0) {\n        updateStatements.push(chainedInstruction(Identifiers$1.attribute, attributeBindings).toStmt());\n    }\n    if (syntheticHostBindings.length > 0) {\n        updateStatements.push(chainedInstruction(Identifiers$1.updateSyntheticHostBinding, syntheticHostBindings).toStmt());\n    }\n    // since we're dealing with directives/components and both have hostBinding\n    // functions, we need to generate a special hostAttrs instruction that deals\n    // with both the assignment of styling as well as static attributes to the host\n    // element. The instruction below will instruct all initial styling (styling\n    // that is inside of a host binding within a directive/component) to be attached\n    // to the host element alongside any of the provided host attributes that were\n    // collected earlier.\n    var hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);\n    var hostInstruction = styleBuilder.buildHostAttrsInstruction(null, hostAttrs, constantPool);\n    if (hostInstruction) {\n        createStatements.push(createStylingStmt(hostInstruction, bindingContext, bindingFn));\n    }\n    if (styleBuilder.hasBindings) {\n        // singular style/class bindings (things like `[style.prop]` and `[class.name]`)\n        // MUST be registered on a given element within the component/directive\n        // templateFn/hostBindingsFn functions. The instruction below will figure out\n        // what all the bindings are and then generate the statements required to register\n        // those bindings to the element via `styling`.\n        var stylingInstruction = styleBuilder.buildStylingInstruction(null, constantPool);\n        if (stylingInstruction) {\n            createStatements.push(createStylingStmt(stylingInstruction, bindingContext, bindingFn));\n        }\n        // finally each binding that was registered in the statement above will need to be added to\n        // the update block of a component/directive templateFn/hostBindingsFn so that the bindings\n        // are evaluated and updated for the element.\n        styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach(function (instruction) {\n            // we subtract a value of `1` here because the binding slot was already\n            // allocated at the top of this method when all the input bindings were\n            // counted.\n            totalHostVarsCount += Math.max(instruction.allocateBindingSlots - 1, 0);\n            updateStatements.push(createStylingStmt(instruction, bindingContext, bindingFn));\n        });\n    }\n    if (totalHostVarsCount) {\n        createStatements.unshift(importExpr(Identifiers$1.allocHostVars).callFn([literal(totalHostVarsCount)]).toStmt());\n    }\n    if (createStatements.length > 0 || updateStatements.length > 0) {\n        var hostBindingsFnName = name ? name + \"_HostBindings\" : null;\n        var statements = [];\n        if (createStatements.length > 0) {\n            statements.push(renderFlagCheckIfStmt(1 /* Create */, createStatements));\n        }\n        if (updateStatements.length > 0) {\n            statements.push(renderFlagCheckIfStmt(2 /* Update */, updateStatements));\n        }\n        return fn([\n            new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null),\n            new FnParam(elVarExp.name, NUMBER_TYPE)\n        ], statements, INFERRED_TYPE, null, hostBindingsFnName);\n    }\n    return null;\n}\nfunction bindingFn(implicit, value) {\n    return convertPropertyBinding(null, implicit, value, 'b', BindingForm.TrySimple, function () { return error('Unexpected interpolation'); });\n}\nfunction createStylingStmt(instruction, bindingContext, bindingFn) {\n    var params = instruction.params(function (value) { return bindingFn(bindingContext, value).currValExpr; });\n    return importExpr(instruction.reference, null, instruction.sourceSpan)\n        .callFn(params, instruction.sourceSpan)\n        .toStmt();\n}\nfunction getBindingNameAndInstruction(binding) {\n    var bindingName = binding.name;\n    var instruction;\n    // Check to see if this is an attr binding or a property binding\n    var attrMatches = bindingName.match(ATTR_REGEX);\n    if (attrMatches) {\n        bindingName = attrMatches[1];\n        instruction = Identifiers$1.attribute;\n    }\n    else {\n        if (binding.isAnimation) {\n            bindingName = prepareSyntheticPropertyName(bindingName);\n            // host bindings that have a synthetic property (e.g. @foo) should always be rendered\n            // in the context of the component and not the parent. Therefore there is a special\n            // compatibility instruction available for this purpose.\n            instruction = Identifiers$1.updateSyntheticHostBinding;\n        }\n        else {\n            instruction = Identifiers$1.hostProperty;\n        }\n    }\n    return { bindingName: bindingName, instruction: instruction, isAttribute: !!attrMatches };\n}\nfunction createHostListeners(eventBindings, name) {\n    return eventBindings.map(function (binding) {\n        var bindingName = binding.name && sanitizeIdentifier(binding.name);\n        var bindingFnName = binding.type === 1 /* Animation */ ?\n            prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) :\n            bindingName;\n        var handlerName = name && bindingName ? name + \"_\" + bindingFnName + \"_HostBindingHandler\" : null;\n        var params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);\n        var instruction = binding.type == 1 /* Animation */ ? Identifiers$1.componentHostSyntheticListener : Identifiers$1.listener;\n        return importExpr(instruction).callFn(params).toStmt();\n    });\n}\nfunction metadataAsSummary(meta) {\n    // clang-format off\n    return {\n        // This is used by the BindingParser, which only deals with listeners and properties. There's no\n        // need to pass attributes to it.\n        hostAttributes: {},\n        hostListeners: meta.listeners,\n        hostProperties: meta.properties,\n    };\n    // clang-format on\n}\nfunction typeMapToExpressionMap(map, outputCtx) {\n    // Convert each map entry into another entry where the value is an expression importing the type.\n    var entries = Array.from(map).map(function (_a) {\n        var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(_a, 2), key = _b[0], type = _b[1];\n        return [key, outputCtx.importExpr(type)];\n    });\n    return new Map(entries);\n}\nvar HOST_REG_EXP$1 = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\nfunction parseHostBindings(host) {\n    var e_4, _a;\n    var attributes = {};\n    var listeners = {};\n    var properties = {};\n    var specialAttributes = {};\n    try {\n        for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(Object.keys(host)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var key = _c.value;\n            var value = host[key];\n            var matches = key.match(HOST_REG_EXP$1);\n            if (matches === null) {\n                switch (key) {\n                    case 'class':\n                        if (typeof value !== 'string') {\n                            // TODO(alxhub): make this a diagnostic.\n                            throw new Error(\"Class binding must be string\");\n                        }\n                        specialAttributes.classAttr = value;\n                        break;\n                    case 'style':\n                        if (typeof value !== 'string') {\n                            // TODO(alxhub): make this a diagnostic.\n                            throw new Error(\"Style binding must be string\");\n                        }\n                        specialAttributes.styleAttr = value;\n                        break;\n                    default:\n                        if (typeof value === 'string') {\n                            attributes[key] = literal(value);\n                        }\n                        else {\n                            attributes[key] = value;\n                        }\n                }\n            }\n            else if (matches[1 /* Binding */] != null) {\n                if (typeof value !== 'string') {\n                    // TODO(alxhub): make this a diagnostic.\n                    throw new Error(\"Property binding must be string\");\n                }\n                // synthetic properties (the ones that have a `@` as a prefix)\n                // are still treated the same as regular properties. Therefore\n                // there is no point in storing them in a separate map.\n                properties[matches[1 /* Binding */]] = value;\n            }\n            else if (matches[2 /* Event */] != null) {\n                if (typeof value !== 'string') {\n                    // TODO(alxhub): make this a diagnostic.\n                    throw new Error(\"Event binding must be string\");\n                }\n                listeners[matches[2 /* Event */]] = value;\n            }\n        }\n    }\n    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_4) throw e_4.error; }\n    }\n    return { attributes: attributes, listeners: listeners, properties: properties, specialAttributes: specialAttributes };\n}\n/**\n * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a\n * given set of host bindings has no errors.\n *\n * @param bindings set of host bindings to verify.\n * @param sourceSpan source span where host bindings were defined.\n * @returns array of errors associated with a given set of host bindings.\n */\nfunction verifyHostBindings(bindings, sourceSpan) {\n    var summary = metadataAsSummary(bindings);\n    // TODO: abstract out host bindings verification logic and use it instead of\n    // creating events and properties ASTs to detect errors (FW-996)\n    var bindingParser = makeBindingParser();\n    bindingParser.createDirectiveHostEventAsts(summary, sourceSpan);\n    bindingParser.createBoundHostProperties(summary, sourceSpan);\n    return bindingParser.errors;\n}\nfunction compileStyles(styles, selector, hostSelector) {\n    var shadowCss = new ShadowCss();\n    return styles.map(function (style) { return shadowCss.shimCssText(style, selector, hostSelector); });\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An interface for retrieving documents by URL that the compiler uses\n * to load templates.\n */\nvar ResourceLoader = /** @class */ (function () {\n    function ResourceLoader() {\n    }\n    ResourceLoader.prototype.get = function (url) { return ''; };\n    return ResourceLoader;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CompilerFacadeImpl = /** @class */ (function () {\n    function CompilerFacadeImpl(jitEvaluator) {\n        if (jitEvaluator === void 0) { jitEvaluator = new JitEvaluator(); }\n        this.jitEvaluator = jitEvaluator;\n        this.R3ResolvedDependencyType = R3ResolvedDependencyType;\n        this.ResourceLoader = ResourceLoader;\n        this.elementSchemaRegistry = new DomElementSchemaRegistry();\n    }\n    CompilerFacadeImpl.prototype.compilePipe = function (angularCoreEnv, sourceMapUrl, facade) {\n        var res = compilePipeFromMetadata({\n            name: facade.name,\n            type: new WrappedNodeExpr(facade.type),\n            typeArgumentCount: facade.typeArgumentCount,\n            deps: convertR3DependencyMetadataArray(facade.deps),\n            pipeName: facade.pipeName,\n            pure: facade.pure,\n        });\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, res.statements);\n    };\n    CompilerFacadeImpl.prototype.compileInjectable = function (angularCoreEnv, sourceMapUrl, facade) {\n        var _a = compileInjectable({\n            name: facade.name,\n            type: new WrappedNodeExpr(facade.type),\n            typeArgumentCount: facade.typeArgumentCount,\n            providedIn: computeProvidedIn(facade.providedIn),\n            useClass: wrapExpression(facade, USE_CLASS),\n            useFactory: wrapExpression(facade, USE_FACTORY),\n            useValue: wrapExpression(facade, USE_VALUE),\n            useExisting: wrapExpression(facade, USE_EXISTING),\n            ctorDeps: convertR3DependencyMetadataArray(facade.ctorDeps),\n            userDeps: convertR3DependencyMetadataArray(facade.userDeps) || undefined,\n        }), expression = _a.expression, statements = _a.statements;\n        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n    };\n    CompilerFacadeImpl.prototype.compileInjector = function (angularCoreEnv, sourceMapUrl, facade) {\n        var meta = {\n            name: facade.name,\n            type: new WrappedNodeExpr(facade.type),\n            deps: convertR3DependencyMetadataArray(facade.deps),\n            providers: new WrappedNodeExpr(facade.providers),\n            imports: facade.imports.map(function (i) { return new WrappedNodeExpr(i); }),\n        };\n        var res = compileInjector(meta);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, res.statements);\n    };\n    CompilerFacadeImpl.prototype.compileNgModule = function (angularCoreEnv, sourceMapUrl, facade) {\n        var meta = {\n            type: new WrappedNodeExpr(facade.type),\n            bootstrap: facade.bootstrap.map(wrapReference),\n            declarations: facade.declarations.map(wrapReference),\n            imports: facade.imports.map(wrapReference),\n            exports: facade.exports.map(wrapReference),\n            emitInline: true,\n            containsForwardDecls: false,\n            schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,\n            id: facade.id ? new WrappedNodeExpr(facade.id) : null,\n        };\n        var res = compileNgModule(meta);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    };\n    CompilerFacadeImpl.prototype.compileDirective = function (angularCoreEnv, sourceMapUrl, facade) {\n        var constantPool = new ConstantPool();\n        var bindingParser = makeBindingParser();\n        var meta = convertDirectiveFacadeToMetadata(facade);\n        var res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);\n        var preStatements = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(constantPool.statements, res.statements);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, preStatements);\n    };\n    CompilerFacadeImpl.prototype.compileComponent = function (angularCoreEnv, sourceMapUrl, facade) {\n        // The ConstantPool is a requirement of the JIT'er.\n        var constantPool = new ConstantPool();\n        var interpolationConfig = facade.interpolation ?\n            InterpolationConfig.fromArray(facade.interpolation) :\n            DEFAULT_INTERPOLATION_CONFIG;\n        // Parse the template and check for errors.\n        var template = parseTemplate(facade.template, sourceMapUrl, { preserveWhitespaces: facade.preserveWhitespaces, interpolationConfig: interpolationConfig });\n        if (template.errors !== undefined) {\n            var errors = template.errors.map(function (err) { return err.toString(); }).join(', ');\n            throw new Error(\"Errors during JIT compilation of template for \" + facade.name + \": \" + errors);\n        }\n        // Compile the component metadata, including template, into an expression.\n        // TODO(alxhub): implement inputs, outputs, queries, etc.\n        var res = compileComponentFromMetadata(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, facade, convertDirectiveFacadeToMetadata(facade), { selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(), template: template, wrapDirectivesAndPipesInClosure: false, styles: facade.styles || [], encapsulation: facade.encapsulation, interpolation: interpolationConfig, changeDetection: facade.changeDetection, animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null, viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) :\n                null, relativeContextFilePath: '', i18nUseExternalIds: true }), constantPool, makeBindingParser(interpolationConfig));\n        var preStatements = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(constantPool.statements, res.statements);\n        return this.jitExpression(res.expression, angularCoreEnv, \"ng:///\" + facade.name + \".js\", preStatements);\n    };\n    CompilerFacadeImpl.prototype.compileBase = function (angularCoreEnv, sourceMapUrl, facade) {\n        var constantPool = new ConstantPool();\n        var typeSourceSpan = this.createParseSourceSpan('Base', facade.name, \"ng:///\" + facade.name + \".js\");\n        var meta = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, facade, { typeSourceSpan: typeSourceSpan, viewQueries: facade.viewQueries ? facade.viewQueries.map(convertToR3QueryMetadata) :\n                facade.viewQueries, queries: facade.queries ? facade.queries.map(convertToR3QueryMetadata) : facade.queries, host: extractHostBindings(facade.propMetadata, typeSourceSpan) });\n        var res = compileBaseDefFromMetadata(meta, constantPool, makeBindingParser());\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n    };\n    CompilerFacadeImpl.prototype.createParseSourceSpan = function (kind, typeName, sourceUrl) {\n        return r3JitTypeSourceSpan(kind, typeName, sourceUrl);\n    };\n    /**\n     * JIT compiles an expression and returns the result of executing that expression.\n     *\n     * @param def the definition which will be compiled and executed to get the value to patch\n     * @param context an object map of @angular/core symbol names to symbols which will be available\n     * in the context of the compiled expression\n     * @param sourceUrl a URL to use for the source map of the compiled expression\n     * @param preStatements a collection of statements that should be evaluated before the expression.\n     */\n    CompilerFacadeImpl.prototype.jitExpression = function (def, context, sourceUrl, preStatements) {\n        // The ConstantPool may contain Statements which declare variables used in the final expression.\n        // Therefore, its statements need to precede the actual JIT operation. The final statement is a\n        // declaration of $def which is set to the expression being compiled.\n        var statements = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(preStatements, [\n            new DeclareVarStmt('$def', def, undefined, [StmtModifier.Exported]),\n        ]);\n        var res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context), /* enableSourceMaps */ true);\n        return res['$def'];\n    };\n    return CompilerFacadeImpl;\n}());\nvar USE_CLASS = Object.keys({ useClass: null })[0];\nvar USE_FACTORY = Object.keys({ useFactory: null })[0];\nvar USE_VALUE = Object.keys({ useValue: null })[0];\nvar USE_EXISTING = Object.keys({ useExisting: null })[0];\nvar wrapReference = function (value) {\n    var wrapped = new WrappedNodeExpr(value);\n    return { value: wrapped, type: wrapped };\n};\nfunction convertToR3QueryMetadata(facade) {\n    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, facade, { predicate: Array.isArray(facade.predicate) ? facade.predicate :\n            new WrappedNodeExpr(facade.predicate), read: facade.read ? new WrappedNodeExpr(facade.read) : null, static: facade.static });\n}\nfunction convertDirectiveFacadeToMetadata(facade) {\n    var inputsFromMetadata = parseInputOutputs(facade.inputs || []);\n    var outputsFromMetadata = parseInputOutputs(facade.outputs || []);\n    var propMetadata = facade.propMetadata;\n    var inputsFromType = {};\n    var outputsFromType = {};\n    var _loop_1 = function (field) {\n        if (propMetadata.hasOwnProperty(field)) {\n            propMetadata[field].forEach(function (ann) {\n                if (isInput(ann)) {\n                    inputsFromType[field] =\n                        ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;\n                }\n                else if (isOutput(ann)) {\n                    outputsFromType[field] = ann.bindingPropertyName || field;\n                }\n            });\n        }\n    };\n    for (var field in propMetadata) {\n        _loop_1(field);\n    }\n    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, facade, { typeSourceSpan: facade.typeSourceSpan, type: new WrappedNodeExpr(facade.type), deps: convertR3DependencyMetadataArray(facade.deps), host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host), inputs: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, inputsFromMetadata, inputsFromType), outputs: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, outputsFromMetadata, outputsFromType), queries: facade.queries.map(convertToR3QueryMetadata), providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null, viewQueries: facade.viewQueries.map(convertToR3QueryMetadata) });\n}\nfunction wrapExpression(obj, property) {\n    if (obj.hasOwnProperty(property)) {\n        return new WrappedNodeExpr(obj[property]);\n    }\n    else {\n        return undefined;\n    }\n}\nfunction computeProvidedIn(providedIn) {\n    if (providedIn == null || typeof providedIn === 'string') {\n        return new LiteralExpr(providedIn);\n    }\n    else {\n        return new WrappedNodeExpr(providedIn);\n    }\n}\nfunction convertR3DependencyMetadata(facade) {\n    var tokenExpr;\n    if (facade.token === null) {\n        tokenExpr = new LiteralExpr(null);\n    }\n    else if (facade.resolved === R3ResolvedDependencyType.Attribute) {\n        tokenExpr = new LiteralExpr(facade.token);\n    }\n    else {\n        tokenExpr = new WrappedNodeExpr(facade.token);\n    }\n    return {\n        token: tokenExpr,\n        resolved: facade.resolved,\n        host: facade.host,\n        optional: facade.optional,\n        self: facade.self,\n        skipSelf: facade.skipSelf\n    };\n}\nfunction convertR3DependencyMetadataArray(facades) {\n    return facades == null ? null : facades.map(convertR3DependencyMetadata);\n}\nfunction extractHostBindings(propMetadata, sourceSpan, host) {\n    // First parse the declarations from the metadata.\n    var bindings = parseHostBindings(host || {});\n    // After that check host bindings for errors\n    var errors = verifyHostBindings(bindings, sourceSpan);\n    if (errors.length) {\n        throw new Error(errors.map(function (error) { return error.msg; }).join('\\n'));\n    }\n    var _loop_2 = function (field) {\n        if (propMetadata.hasOwnProperty(field)) {\n            propMetadata[field].forEach(function (ann) {\n                if (isHostBinding(ann)) {\n                    bindings.properties[ann.hostPropertyName || field] = field;\n                }\n                else if (isHostListener(ann)) {\n                    bindings.listeners[ann.eventName || field] = field + \"(\" + (ann.args || []).join(',') + \")\";\n                }\n            });\n        }\n    };\n    // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.\n    for (var field in propMetadata) {\n        _loop_2(field);\n    }\n    return bindings;\n}\nfunction isHostBinding(value) {\n    return value.ngMetadataName === 'HostBinding';\n}\nfunction isHostListener(value) {\n    return value.ngMetadataName === 'HostListener';\n}\nfunction isInput(value) {\n    return value.ngMetadataName === 'Input';\n}\nfunction isOutput(value) {\n    return value.ngMetadataName === 'Output';\n}\nfunction parseInputOutputs(values) {\n    return values.reduce(function (map, value) {\n        var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(value.split(',').map(function (piece) { return piece.trim(); }), 2), field = _a[0], property = _a[1];\n        map[field] = property || field;\n        return map;\n    }, {});\n}\nfunction publishFacade(global) {\n    var ng = global.ng || (global.ng = {});\n    ng.ɵcompilerFacade = new CompilerFacadeImpl();\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar VERSION$1 = new Version('8.2.14');\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CompilerConfig = /** @class */ (function () {\n    function CompilerConfig(_a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.defaultEncapsulation, defaultEncapsulation = _c === void 0 ? ViewEncapsulation.Emulated : _c, _d = _b.useJit, useJit = _d === void 0 ? true : _d, _e = _b.jitDevMode, jitDevMode = _e === void 0 ? false : _e, _f = _b.missingTranslation, missingTranslation = _f === void 0 ? null : _f, preserveWhitespaces = _b.preserveWhitespaces, strictInjectionParameters = _b.strictInjectionParameters;\n        this.defaultEncapsulation = defaultEncapsulation;\n        this.useJit = !!useJit;\n        this.jitDevMode = !!jitDevMode;\n        this.missingTranslation = missingTranslation;\n        this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));\n        this.strictInjectionParameters = strictInjectionParameters === true;\n    }\n    return CompilerConfig;\n}());\nfunction preserveWhitespacesDefault(preserveWhitespacesOption, defaultSetting) {\n    if (defaultSetting === void 0) { defaultSetting = false; }\n    return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar DirectiveNormalizer = /** @class */ (function () {\n    function DirectiveNormalizer(_resourceLoader, _urlResolver, _htmlParser, _config) {\n        this._resourceLoader = _resourceLoader;\n        this._urlResolver = _urlResolver;\n        this._htmlParser = _htmlParser;\n        this._config = _config;\n        this._resourceLoaderCache = new Map();\n    }\n    DirectiveNormalizer.prototype.clearCache = function () { this._resourceLoaderCache.clear(); };\n    DirectiveNormalizer.prototype.clearCacheFor = function (normalizedDirective) {\n        var _this = this;\n        if (!normalizedDirective.isComponent) {\n            return;\n        }\n        var template = normalizedDirective.template;\n        this._resourceLoaderCache.delete(template.templateUrl);\n        template.externalStylesheets.forEach(function (stylesheet) { _this._resourceLoaderCache.delete(stylesheet.moduleUrl); });\n    };\n    DirectiveNormalizer.prototype._fetch = function (url) {\n        var result = this._resourceLoaderCache.get(url);\n        if (!result) {\n            result = this._resourceLoader.get(url);\n            this._resourceLoaderCache.set(url, result);\n        }\n        return result;\n    };\n    DirectiveNormalizer.prototype.normalizeTemplate = function (prenormData) {\n        var _this = this;\n        if (isDefined(prenormData.template)) {\n            if (isDefined(prenormData.templateUrl)) {\n                throw syntaxError(\"'\" + stringify(prenormData.componentType) + \"' component cannot define both template and templateUrl\");\n            }\n            if (typeof prenormData.template !== 'string') {\n                throw syntaxError(\"The template specified for component \" + stringify(prenormData.componentType) + \" is not a string\");\n            }\n        }\n        else if (isDefined(prenormData.templateUrl)) {\n            if (typeof prenormData.templateUrl !== 'string') {\n                throw syntaxError(\"The templateUrl specified for component \" + stringify(prenormData.componentType) + \" is not a string\");\n            }\n        }\n        else {\n            throw syntaxError(\"No template specified for component \" + stringify(prenormData.componentType));\n        }\n        if (isDefined(prenormData.preserveWhitespaces) &&\n            typeof prenormData.preserveWhitespaces !== 'boolean') {\n            throw syntaxError(\"The preserveWhitespaces option for component \" + stringify(prenormData.componentType) + \" must be a boolean\");\n        }\n        return SyncAsync.then(this._preParseTemplate(prenormData), function (preparsedTemplate) { return _this._normalizeTemplateMetadata(prenormData, preparsedTemplate); });\n    };\n    DirectiveNormalizer.prototype._preParseTemplate = function (prenomData) {\n        var _this = this;\n        var template;\n        var templateUrl;\n        if (prenomData.template != null) {\n            template = prenomData.template;\n            templateUrl = prenomData.moduleUrl;\n        }\n        else {\n            templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, prenomData.templateUrl);\n            template = this._fetch(templateUrl);\n        }\n        return SyncAsync.then(template, function (template) { return _this._preparseLoadedTemplate(prenomData, template, templateUrl); });\n    };\n    DirectiveNormalizer.prototype._preparseLoadedTemplate = function (prenormData, template, templateAbsUrl) {\n        var isInline = !!prenormData.template;\n        var interpolationConfig = InterpolationConfig.fromArray(prenormData.interpolation);\n        var templateUrl = templateSourceUrl({ reference: prenormData.ngModuleType }, { type: { reference: prenormData.componentType } }, { isInline: isInline, templateUrl: templateAbsUrl });\n        var rootNodesAndErrors = this._htmlParser.parse(template, templateUrl, { tokenizeExpansionForms: true, interpolationConfig: interpolationConfig });\n        if (rootNodesAndErrors.errors.length > 0) {\n            var errorString = rootNodesAndErrors.errors.join('\\n');\n            throw syntaxError(\"Template parse errors:\\n\" + errorString);\n        }\n        var templateMetadataStyles = this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: prenormData.styles, moduleUrl: prenormData.moduleUrl }));\n        var visitor = new TemplatePreparseVisitor();\n        visitAll$1(visitor, rootNodesAndErrors.rootNodes);\n        var templateStyles = this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl }));\n        var styles = templateMetadataStyles.styles.concat(templateStyles.styles);\n        var inlineStyleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);\n        var styleUrls = this\n            ._normalizeStylesheet(new CompileStylesheetMetadata({ styleUrls: prenormData.styleUrls, moduleUrl: prenormData.moduleUrl }))\n            .styleUrls;\n        return {\n            template: template,\n            templateUrl: templateAbsUrl, isInline: isInline,\n            htmlAst: rootNodesAndErrors, styles: styles, inlineStyleUrls: inlineStyleUrls, styleUrls: styleUrls,\n            ngContentSelectors: visitor.ngContentSelectors,\n        };\n    };\n    DirectiveNormalizer.prototype._normalizeTemplateMetadata = function (prenormData, preparsedTemplate) {\n        var _this = this;\n        return SyncAsync.then(this._loadMissingExternalStylesheets(preparsedTemplate.styleUrls.concat(preparsedTemplate.inlineStyleUrls)), function (externalStylesheets) { return _this._normalizeLoadedTemplateMetadata(prenormData, preparsedTemplate, externalStylesheets); });\n    };\n    DirectiveNormalizer.prototype._normalizeLoadedTemplateMetadata = function (prenormData, preparsedTemplate, stylesheets) {\n        // Algorithm:\n        // - produce exactly 1 entry per original styleUrl in\n        // CompileTemplateMetadata.externalStylesheets with all styles inlined\n        // - inline all styles that are referenced by the template into CompileTemplateMetadata.styles.\n        // Reason: be able to determine how many stylesheets there are even without loading\n        // the template nor the stylesheets, so we can create a stub for TypeScript always synchronously\n        // (as resource loading may be async)\n        var _this = this;\n        var styles = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(preparsedTemplate.styles);\n        this._inlineStyles(preparsedTemplate.inlineStyleUrls, stylesheets, styles);\n        var styleUrls = preparsedTemplate.styleUrls;\n        var externalStylesheets = styleUrls.map(function (styleUrl) {\n            var stylesheet = stylesheets.get(styleUrl);\n            var styles = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(stylesheet.styles);\n            _this._inlineStyles(stylesheet.styleUrls, stylesheets, styles);\n            return new CompileStylesheetMetadata({ moduleUrl: styleUrl, styles: styles });\n        });\n        var encapsulation = prenormData.encapsulation;\n        if (encapsulation == null) {\n            encapsulation = this._config.defaultEncapsulation;\n        }\n        if (encapsulation === ViewEncapsulation.Emulated && styles.length === 0 &&\n            styleUrls.length === 0) {\n            encapsulation = ViewEncapsulation.None;\n        }\n        return new CompileTemplateMetadata({\n            encapsulation: encapsulation,\n            template: preparsedTemplate.template,\n            templateUrl: preparsedTemplate.templateUrl,\n            htmlAst: preparsedTemplate.htmlAst, styles: styles, styleUrls: styleUrls,\n            ngContentSelectors: preparsedTemplate.ngContentSelectors,\n            animations: prenormData.animations,\n            interpolation: prenormData.interpolation,\n            isInline: preparsedTemplate.isInline, externalStylesheets: externalStylesheets,\n            preserveWhitespaces: preserveWhitespacesDefault(prenormData.preserveWhitespaces, this._config.preserveWhitespaces),\n        });\n    };\n    DirectiveNormalizer.prototype._inlineStyles = function (styleUrls, stylesheets, targetStyles) {\n        var _this = this;\n        styleUrls.forEach(function (styleUrl) {\n            var stylesheet = stylesheets.get(styleUrl);\n            stylesheet.styles.forEach(function (style) { return targetStyles.push(style); });\n            _this._inlineStyles(stylesheet.styleUrls, stylesheets, targetStyles);\n        });\n    };\n    DirectiveNormalizer.prototype._loadMissingExternalStylesheets = function (styleUrls, loadedStylesheets) {\n        var _this = this;\n        if (loadedStylesheets === void 0) { loadedStylesheets = new Map(); }\n        return SyncAsync.then(SyncAsync.all(styleUrls.filter(function (styleUrl) { return !loadedStylesheets.has(styleUrl); })\n            .map(function (styleUrl) { return SyncAsync.then(_this._fetch(styleUrl), function (loadedStyle) {\n            var stylesheet = _this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: [loadedStyle], moduleUrl: styleUrl }));\n            loadedStylesheets.set(styleUrl, stylesheet);\n            return _this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);\n        }); })), function (_) { return loadedStylesheets; });\n    };\n    DirectiveNormalizer.prototype._normalizeStylesheet = function (stylesheet) {\n        var _this = this;\n        var moduleUrl = stylesheet.moduleUrl;\n        var allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable)\n            .map(function (url) { return _this._urlResolver.resolve(moduleUrl, url); });\n        var allStyles = stylesheet.styles.map(function (style) {\n            var styleWithImports = extractStyleUrls(_this._urlResolver, moduleUrl, style);\n            allStyleUrls.push.apply(allStyleUrls, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(styleWithImports.styleUrls));\n            return styleWithImports.style;\n        });\n        return new CompileStylesheetMetadata({ styles: allStyles, styleUrls: allStyleUrls, moduleUrl: moduleUrl });\n    };\n    return DirectiveNormalizer;\n}());\nvar TemplatePreparseVisitor = /** @class */ (function () {\n    function TemplatePreparseVisitor() {\n        this.ngContentSelectors = [];\n        this.styles = [];\n        this.styleUrls = [];\n        this.ngNonBindableStackCount = 0;\n    }\n    TemplatePreparseVisitor.prototype.visitElement = function (ast, context) {\n        var preparsedElement = preparseElement(ast);\n        switch (preparsedElement.type) {\n            case PreparsedElementType.NG_CONTENT:\n                if (this.ngNonBindableStackCount === 0) {\n                    this.ngContentSelectors.push(preparsedElement.selectAttr);\n                }\n                break;\n            case PreparsedElementType.STYLE:\n                var textContent_1 = '';\n                ast.children.forEach(function (child) {\n                    if (child instanceof Text$3) {\n                        textContent_1 += child.value;\n                    }\n                });\n                this.styles.push(textContent_1);\n                break;\n            case PreparsedElementType.STYLESHEET:\n                this.styleUrls.push(preparsedElement.hrefAttr);\n                break;\n            default:\n                break;\n        }\n        if (preparsedElement.nonBindable) {\n            this.ngNonBindableStackCount++;\n        }\n        visitAll$1(this, ast.children);\n        if (preparsedElement.nonBindable) {\n            this.ngNonBindableStackCount--;\n        }\n        return null;\n    };\n    TemplatePreparseVisitor.prototype.visitExpansion = function (ast, context) { visitAll$1(this, ast.cases); };\n    TemplatePreparseVisitor.prototype.visitExpansionCase = function (ast, context) {\n        visitAll$1(this, ast.expression);\n    };\n    TemplatePreparseVisitor.prototype.visitComment = function (ast, context) { return null; };\n    TemplatePreparseVisitor.prototype.visitAttribute = function (ast, context) { return null; };\n    TemplatePreparseVisitor.prototype.visitText = function (ast, context) { return null; };\n    return TemplatePreparseVisitor;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar QUERY_METADATA_IDENTIFIERS = [\n    createViewChild,\n    createViewChildren,\n    createContentChild,\n    createContentChildren,\n];\n/*\n * Resolve a `Type` for {@link Directive}.\n *\n * This interface can be overridden by the application developer to create custom behavior.\n *\n * See {@link Compiler}\n */\nvar DirectiveResolver = /** @class */ (function () {\n    function DirectiveResolver(_reflector) {\n        this._reflector = _reflector;\n    }\n    DirectiveResolver.prototype.isDirective = function (type) {\n        var typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n        return typeMetadata && typeMetadata.some(isDirectiveMetadata);\n    };\n    DirectiveResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n        if (typeMetadata) {\n            var metadata = findLast(typeMetadata, isDirectiveMetadata);\n            if (metadata) {\n                var propertyMetadata = this._reflector.propMetadata(type);\n                var guards = this._reflector.guards(type);\n                return this._mergeWithPropertyMetadata(metadata, propertyMetadata, guards, type);\n            }\n        }\n        if (throwIfNotFound) {\n            throw new Error(\"No Directive annotation found on \" + stringify(type));\n        }\n        return null;\n    };\n    DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata, guards, directiveType) {\n        var inputs = [];\n        var outputs = [];\n        var host = {};\n        var queries = {};\n        Object.keys(propertyMetadata).forEach(function (propName) {\n            var input = findLast(propertyMetadata[propName], function (a) { return createInput.isTypeOf(a); });\n            if (input) {\n                if (input.bindingPropertyName) {\n                    inputs.push(propName + \": \" + input.bindingPropertyName);\n                }\n                else {\n                    inputs.push(propName);\n                }\n            }\n            var output = findLast(propertyMetadata[propName], function (a) { return createOutput.isTypeOf(a); });\n            if (output) {\n                if (output.bindingPropertyName) {\n                    outputs.push(propName + \": \" + output.bindingPropertyName);\n                }\n                else {\n                    outputs.push(propName);\n                }\n            }\n            var hostBindings = propertyMetadata[propName].filter(function (a) { return createHostBinding.isTypeOf(a); });\n            hostBindings.forEach(function (hostBinding) {\n                if (hostBinding.hostPropertyName) {\n                    var startWith = hostBinding.hostPropertyName[0];\n                    if (startWith === '(') {\n                        throw new Error(\"@HostBinding can not bind to events. Use @HostListener instead.\");\n                    }\n                    else if (startWith === '[') {\n                        throw new Error(\"@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.\");\n                    }\n                    host[\"[\" + hostBinding.hostPropertyName + \"]\"] = propName;\n                }\n                else {\n                    host[\"[\" + propName + \"]\"] = propName;\n                }\n            });\n            var hostListeners = propertyMetadata[propName].filter(function (a) { return createHostListener.isTypeOf(a); });\n            hostListeners.forEach(function (hostListener) {\n                var args = hostListener.args || [];\n                host[\"(\" + hostListener.eventName + \")\"] = propName + \"(\" + args.join(',') + \")\";\n            });\n            var query = findLast(propertyMetadata[propName], function (a) { return QUERY_METADATA_IDENTIFIERS.some(function (i) { return i.isTypeOf(a); }); });\n            if (query) {\n                queries[propName] = query;\n            }\n        });\n        return this._merge(dm, inputs, outputs, host, queries, guards, directiveType);\n    };\n    DirectiveResolver.prototype._extractPublicName = function (def) { return splitAtColon(def, [null, def])[1].trim(); };\n    DirectiveResolver.prototype._dedupeBindings = function (bindings) {\n        var names = new Set();\n        var publicNames = new Set();\n        var reversedResult = [];\n        // go last to first to allow later entries to overwrite previous entries\n        for (var i = bindings.length - 1; i >= 0; i--) {\n            var binding = bindings[i];\n            var name_1 = this._extractPublicName(binding);\n            publicNames.add(name_1);\n            if (!names.has(name_1)) {\n                names.add(name_1);\n                reversedResult.push(binding);\n            }\n        }\n        return reversedResult.reverse();\n    };\n    DirectiveResolver.prototype._merge = function (directive, inputs, outputs, host, queries, guards, directiveType) {\n        var mergedInputs = this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);\n        var mergedOutputs = this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);\n        var mergedHost = directive.host ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, directive.host, host) : host;\n        var mergedQueries = directive.queries ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, directive.queries, queries) : queries;\n        if (createComponent.isTypeOf(directive)) {\n            var comp = directive;\n            return createComponent({\n                selector: comp.selector,\n                inputs: mergedInputs,\n                outputs: mergedOutputs,\n                host: mergedHost,\n                exportAs: comp.exportAs,\n                moduleId: comp.moduleId,\n                queries: mergedQueries,\n                changeDetection: comp.changeDetection,\n                providers: comp.providers,\n                viewProviders: comp.viewProviders,\n                entryComponents: comp.entryComponents,\n                template: comp.template,\n                templateUrl: comp.templateUrl,\n                styles: comp.styles,\n                styleUrls: comp.styleUrls,\n                encapsulation: comp.encapsulation,\n                animations: comp.animations,\n                interpolation: comp.interpolation,\n                preserveWhitespaces: directive.preserveWhitespaces,\n            });\n        }\n        else {\n            return createDirective({\n                selector: directive.selector,\n                inputs: mergedInputs,\n                outputs: mergedOutputs,\n                host: mergedHost,\n                exportAs: directive.exportAs,\n                queries: mergedQueries,\n                providers: directive.providers, guards: guards\n            });\n        }\n    };\n    return DirectiveResolver;\n}());\nfunction isDirectiveMetadata(type) {\n    return createDirective.isTypeOf(type) || createComponent.isTypeOf(type);\n}\nfunction findLast(arr, condition) {\n    for (var i = arr.length - 1; i >= 0; i--) {\n        if (condition(arr[i])) {\n            return arr[i];\n        }\n    }\n    return null;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An i18n error.\n */\nvar I18nError = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(I18nError, _super);\n    function I18nError(span, msg) {\n        return _super.call(this, span, msg) || this;\n    }\n    return I18nError;\n}(ParseError));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _I18N_ATTR = 'i18n';\nvar _I18N_ATTR_PREFIX = 'i18n-';\nvar _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nvar MEANING_SEPARATOR = '|';\nvar ID_SEPARATOR = '@@';\nvar i18nCommentsWarned = false;\n/**\n * Extract translatable messages from an html AST\n */\nfunction extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {\n    var visitor = new _Visitor$2(implicitTags, implicitAttrs);\n    return visitor.extract(nodes, interpolationConfig);\n}\nfunction mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {\n    var visitor = new _Visitor$2(implicitTags, implicitAttrs);\n    return visitor.merge(nodes, translations, interpolationConfig);\n}\nvar ExtractionResult = /** @class */ (function () {\n    function ExtractionResult(messages, errors) {\n        this.messages = messages;\n        this.errors = errors;\n    }\n    return ExtractionResult;\n}());\nvar _VisitorMode;\n(function (_VisitorMode) {\n    _VisitorMode[_VisitorMode[\"Extract\"] = 0] = \"Extract\";\n    _VisitorMode[_VisitorMode[\"Merge\"] = 1] = \"Merge\";\n})(_VisitorMode || (_VisitorMode = {}));\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * @internal\n */\nvar _Visitor$2 = /** @class */ (function () {\n    function _Visitor(_implicitTags, _implicitAttrs) {\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n    }\n    /**\n     * Extracts the messages from the tree\n     */\n    _Visitor.prototype.extract = function (nodes, interpolationConfig) {\n        var _this = this;\n        this._init(_VisitorMode.Extract, interpolationConfig);\n        nodes.forEach(function (node) { return node.visit(_this, null); });\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ExtractionResult(this._messages, this._errors);\n    };\n    /**\n     * Returns a tree where all translatable nodes are translated\n     */\n    _Visitor.prototype.merge = function (nodes, translations, interpolationConfig) {\n        this._init(_VisitorMode.Merge, interpolationConfig);\n        this._translations = translations;\n        // Construct a single fake root element\n        var wrapper = new Element$1('wrapper', [], nodes, undefined, undefined, undefined);\n        var translatedNode = wrapper.visit(this, null);\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ParseTreeResult(translatedNode.children, this._errors);\n    };\n    _Visitor.prototype.visitExpansionCase = function (icuCase, context) {\n        // Parse cases for translatable html attributes\n        var expression = visitAll$1(this, icuCase.expression, context);\n        if (this._mode === _VisitorMode.Merge) {\n            return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\n        }\n    };\n    _Visitor.prototype.visitExpansion = function (icu, context) {\n        this._mayBeAddBlockChildren(icu);\n        var wasInIcu = this._inIcu;\n        if (!this._inIcu) {\n            // nested ICU messages should not be extracted but top-level translated as a whole\n            if (this._isInTranslatableSection) {\n                this._addMessage([icu]);\n            }\n            this._inIcu = true;\n        }\n        var cases = visitAll$1(this, icu.cases, context);\n        if (this._mode === _VisitorMode.Merge) {\n            icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n        }\n        this._inIcu = wasInIcu;\n        return icu;\n    };\n    _Visitor.prototype.visitComment = function (comment, context) {\n        var isOpening = _isOpeningComment(comment);\n        if (isOpening && this._isInTranslatableSection) {\n            this._reportError(comment, 'Could not start a block inside a translatable section');\n            return;\n        }\n        var isClosing = _isClosingComment(comment);\n        if (isClosing && !this._inI18nBlock) {\n            this._reportError(comment, 'Trying to close an unopened block');\n            return;\n        }\n        if (!this._inI18nNode && !this._inIcu) {\n            if (!this._inI18nBlock) {\n                if (isOpening) {\n                    // deprecated from v5 you should use <ng-container i18n> instead of i18n comments\n                    if (!i18nCommentsWarned && console && console.warn) {\n                        i18nCommentsWarned = true;\n                        var details = comment.sourceSpan.details ? \", \" + comment.sourceSpan.details : '';\n                        // TODO(ocombe): use a log service once there is a public one available\n                        console.warn(\"I18n comments are deprecated, use an <ng-container> element instead (\" + comment.sourceSpan.start + details + \")\");\n                    }\n                    this._inI18nBlock = true;\n                    this._blockStartDepth = this._depth;\n                    this._blockChildren = [];\n                    this._blockMeaningAndDesc =\n                        comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n                    this._openTranslatableSection(comment);\n                }\n            }\n            else {\n                if (isClosing) {\n                    if (this._depth == this._blockStartDepth) {\n                        this._closeTranslatableSection(comment, this._blockChildren);\n                        this._inI18nBlock = false;\n                        var message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);\n                        // merge attributes in sections\n                        var nodes = this._translateMessage(comment, message);\n                        return visitAll$1(this, nodes);\n                    }\n                    else {\n                        this._reportError(comment, 'I18N blocks should not cross element boundaries');\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    _Visitor.prototype.visitText = function (text, context) {\n        if (this._isInTranslatableSection) {\n            this._mayBeAddBlockChildren(text);\n        }\n        return text;\n    };\n    _Visitor.prototype.visitElement = function (el, context) {\n        var _this = this;\n        this._mayBeAddBlockChildren(el);\n        this._depth++;\n        var wasInI18nNode = this._inI18nNode;\n        var wasInImplicitNode = this._inImplicitNode;\n        var childNodes = [];\n        var translatedChildNodes = undefined;\n        // Extract:\n        // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n        // - ICU messages\n        var i18nAttr = _getI18nAttr(el);\n        var i18nMeta = i18nAttr ? i18nAttr.value : '';\n        var isImplicit = this._implicitTags.some(function (tag) { return el.name === tag; }) && !this._inIcu &&\n            !this._isInTranslatableSection;\n        var isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n        this._inImplicitNode = wasInImplicitNode || isImplicit;\n        if (!this._isInTranslatableSection && !this._inIcu) {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._inI18nNode = true;\n                var message = this._addMessage(el.children, i18nMeta);\n                translatedChildNodes = this._translateMessage(el, message);\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                var isTranslatable = i18nAttr || isTopLevelImplicit;\n                if (isTranslatable)\n                    this._openTranslatableSection(el);\n                visitAll$1(this, el.children);\n                if (isTranslatable)\n                    this._closeTranslatableSection(el, el.children);\n            }\n        }\n        else {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._reportError(el, 'Could not mark an element as translatable inside a translatable section');\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                // Descend into child nodes for extraction\n                visitAll$1(this, el.children);\n            }\n        }\n        if (this._mode === _VisitorMode.Merge) {\n            var visitNodes = translatedChildNodes || el.children;\n            visitNodes.forEach(function (child) {\n                var visited = child.visit(_this, context);\n                if (visited && !_this._isInTranslatableSection) {\n                    // Do not add the children from translatable sections (= i18n blocks here)\n                    // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n                    childNodes = childNodes.concat(visited);\n                }\n            });\n        }\n        this._visitAttributesOf(el);\n        this._depth--;\n        this._inI18nNode = wasInI18nNode;\n        this._inImplicitNode = wasInImplicitNode;\n        if (this._mode === _VisitorMode.Merge) {\n            var translatedAttrs = this._translateAttributes(el);\n            return new Element$1(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n        }\n        return null;\n    };\n    _Visitor.prototype.visitAttribute = function (attribute, context) {\n        throw new Error('unreachable code');\n    };\n    _Visitor.prototype._init = function (mode, interpolationConfig) {\n        this._mode = mode;\n        this._inI18nBlock = false;\n        this._inI18nNode = false;\n        this._depth = 0;\n        this._inIcu = false;\n        this._msgCountAtSectionStart = undefined;\n        this._errors = [];\n        this._messages = [];\n        this._inImplicitNode = false;\n        this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\n    };\n    // looks for translatable attributes\n    _Visitor.prototype._visitAttributesOf = function (el) {\n        var _this = this;\n        var explicitAttrNameToValue = {};\n        var implicitAttrNames = this._implicitAttrs[el.name] || [];\n        el.attrs.filter(function (attr) { return attr.name.startsWith(_I18N_ATTR_PREFIX); })\n            .forEach(function (attr) { return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n            attr.value; });\n        el.attrs.forEach(function (attr) {\n            if (attr.name in explicitAttrNameToValue) {\n                _this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n            }\n            else if (implicitAttrNames.some(function (name) { return attr.name === name; })) {\n                _this._addMessage([attr]);\n            }\n        });\n    };\n    // add a translatable message\n    _Visitor.prototype._addMessage = function (ast, msgMeta) {\n        if (ast.length == 0 ||\n            ast.length == 1 && ast[0] instanceof Attribute && !ast[0].value) {\n            // Do not create empty messages\n            return null;\n        }\n        var _a = _parseMessageMeta(msgMeta), meaning = _a.meaning, description = _a.description, id = _a.id;\n        var message = this._createI18nMessage(ast, meaning, description, id);\n        this._messages.push(message);\n        return message;\n    };\n    // Translates the given message given the `TranslationBundle`\n    // This is used for translating elements / blocks - see `_translateAttributes` for attributes\n    // no-op when called in extraction mode (returns [])\n    _Visitor.prototype._translateMessage = function (el, message) {\n        if (message && this._mode === _VisitorMode.Merge) {\n            var nodes = this._translations.get(message);\n            if (nodes) {\n                return nodes;\n            }\n            this._reportError(el, \"Translation unavailable for message id=\\\"\" + this._translations.digest(message) + \"\\\"\");\n        }\n        return [];\n    };\n    // translate the attributes of an element and remove i18n specific attributes\n    _Visitor.prototype._translateAttributes = function (el) {\n        var _this = this;\n        var attributes = el.attrs;\n        var i18nParsedMessageMeta = {};\n        attributes.forEach(function (attr) {\n            if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n                    _parseMessageMeta(attr.value);\n            }\n        });\n        var translatedAttributes = [];\n        attributes.forEach(function (attr) {\n            if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                // strip i18n specific attributes\n                return;\n            }\n            if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n                var _a = i18nParsedMessageMeta[attr.name], meaning = _a.meaning, description = _a.description, id = _a.id;\n                var message = _this._createI18nMessage([attr], meaning, description, id);\n                var nodes = _this._translations.get(message);\n                if (nodes) {\n                    if (nodes.length == 0) {\n                        translatedAttributes.push(new Attribute(attr.name, '', attr.sourceSpan));\n                    }\n                    else if (nodes[0] instanceof Text$3) {\n                        var value = nodes[0].value;\n                        translatedAttributes.push(new Attribute(attr.name, value, attr.sourceSpan));\n                    }\n                    else {\n                        _this._reportError(el, \"Unexpected translation for attribute \\\"\" + attr.name + \"\\\" (id=\\\"\" + (id || _this._translations.digest(message)) + \"\\\")\");\n                    }\n                }\n                else {\n                    _this._reportError(el, \"Translation unavailable for attribute \\\"\" + attr.name + \"\\\" (id=\\\"\" + (id || _this._translations.digest(message)) + \"\\\")\");\n                }\n            }\n            else {\n                translatedAttributes.push(attr);\n            }\n        });\n        return translatedAttributes;\n    };\n    /**\n     * Add the node as a child of the block when:\n     * - we are in a block,\n     * - we are not inside a ICU message (those are handled separately),\n     * - the node is a \"direct child\" of the block\n     */\n    _Visitor.prototype._mayBeAddBlockChildren = function (node) {\n        if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n            this._blockChildren.push(node);\n        }\n    };\n    /**\n     * Marks the start of a section, see `_closeTranslatableSection`\n     */\n    _Visitor.prototype._openTranslatableSection = function (node) {\n        if (this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section start');\n        }\n        else {\n            this._msgCountAtSectionStart = this._messages.length;\n        }\n    };\n    Object.defineProperty(_Visitor.prototype, \"_isInTranslatableSection\", {\n        /**\n         * A translatable section could be:\n         * - the content of translatable element,\n         * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n         */\n        get: function () {\n            return this._msgCountAtSectionStart !== void 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Terminates a section.\n     *\n     * If a section has only one significant children (comments not significant) then we should not\n     * keep the message from this children:\n     *\n     * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n     * - one for the <p> content with meaning and description,\n     * - another one for the ICU message.\n     *\n     * In this case the last message is discarded as it contains less information (the AST is\n     * otherwise identical).\n     *\n     * Note that we should still keep messages extracted from attributes inside the section (ie in the\n     * ICU message here)\n     */\n    _Visitor.prototype._closeTranslatableSection = function (node, directChildren) {\n        if (!this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section end');\n            return;\n        }\n        var startIndex = this._msgCountAtSectionStart;\n        var significantChildren = directChildren.reduce(function (count, node) { return count + (node instanceof Comment ? 0 : 1); }, 0);\n        if (significantChildren == 1) {\n            for (var i = this._messages.length - 1; i >= startIndex; i--) {\n                var ast = this._messages[i].nodes;\n                if (!(ast.length == 1 && ast[0] instanceof Text$1)) {\n                    this._messages.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        this._msgCountAtSectionStart = undefined;\n    };\n    _Visitor.prototype._reportError = function (node, msg) {\n        this._errors.push(new I18nError(node.sourceSpan, msg));\n    };\n    return _Visitor;\n}());\nfunction _isOpeningComment(n) {\n    return !!(n instanceof Comment && n.value && n.value.startsWith('i18n'));\n}\nfunction _isClosingComment(n) {\n    return !!(n instanceof Comment && n.value && n.value === '/i18n');\n}\nfunction _getI18nAttr(p) {\n    return p.attrs.find(function (attr) { return attr.name === _I18N_ATTR; }) || null;\n}\nfunction _parseMessageMeta(i18n) {\n    if (!i18n)\n        return { meaning: '', description: '', id: '' };\n    var idIndex = i18n.indexOf(ID_SEPARATOR);\n    var descIndex = i18n.indexOf(MEANING_SEPARATOR);\n    var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])((idIndex > -1) ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''], 2), meaningAndDesc = _a[0], id = _a[1];\n    var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])((descIndex > -1) ?\n        [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n        ['', meaningAndDesc], 2), meaning = _b[0], description = _b[1];\n    return { meaning: meaning, description: description, id: id };\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar XmlTagDefinition = /** @class */ (function () {\n    function XmlTagDefinition() {\n        this.closedByParent = false;\n        this.contentType = TagContentType.PARSABLE_DATA;\n        this.isVoid = false;\n        this.ignoreFirstLf = false;\n        this.canSelfClose = true;\n    }\n    XmlTagDefinition.prototype.requireExtraParent = function (currentParent) { return false; };\n    XmlTagDefinition.prototype.isClosedByChild = function (name) { return false; };\n    return XmlTagDefinition;\n}());\nvar _TAG_DEFINITION = new XmlTagDefinition();\nfunction getXmlTagDefinition(tagName) {\n    return _TAG_DEFINITION;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar XmlParser = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(XmlParser, _super);\n    function XmlParser() {\n        return _super.call(this, getXmlTagDefinition) || this;\n    }\n    XmlParser.prototype.parse = function (source, url, options) {\n        return _super.prototype.parse.call(this, source, url, options);\n    };\n    return XmlParser;\n}(Parser));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _VERSION = '1.2';\nvar _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';\n// TODO(vicb): make this a param (s/_/-/)\nvar _DEFAULT_SOURCE_LANG = 'en';\nvar _PLACEHOLDER_TAG$1 = 'x';\nvar _MARKER_TAG = 'mrk';\nvar _FILE_TAG = 'file';\nvar _SOURCE_TAG$1 = 'source';\nvar _SEGMENT_SOURCE_TAG = 'seg-source';\nvar _ALT_TRANS_TAG = 'alt-trans';\nvar _TARGET_TAG = 'target';\nvar _UNIT_TAG = 'trans-unit';\nvar _CONTEXT_GROUP_TAG = 'context-group';\nvar _CONTEXT_TAG = 'context';\n// http://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html\n// http://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html\nvar Xliff = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Xliff, _super);\n    function Xliff() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Xliff.prototype.write = function (messages, locale) {\n        var visitor = new _WriteVisitor();\n        var transUnits = [];\n        messages.forEach(function (message) {\n            var _a;\n            var contextTags = [];\n            message.sources.forEach(function (source) {\n                var contextGroupTag = new Tag(_CONTEXT_GROUP_TAG, { purpose: 'location' });\n                contextGroupTag.children.push(new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'sourcefile' }, [new Text$2(source.filePath)]), new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'linenumber' }, [new Text$2(\"\" + source.startLine)]), new CR(8));\n                contextTags.push(new CR(8), contextGroupTag);\n            });\n            var transUnit = new Tag(_UNIT_TAG, { id: message.id, datatype: 'html' });\n            (_a = transUnit.children).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes))], contextTags));\n            if (message.description) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'description' }, [new Text$2(message.description)]));\n            }\n            if (message.meaning) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'meaning' }, [new Text$2(message.meaning)]));\n            }\n            transUnit.children.push(new CR(6));\n            transUnits.push(new CR(6), transUnit);\n        });\n        var body = new Tag('body', {}, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(transUnits, [new CR(4)]));\n        var file = new Tag('file', {\n            'source-language': locale || _DEFAULT_SOURCE_LANG,\n            datatype: 'plaintext',\n            original: 'ng2.template',\n        }, [new CR(4), body, new CR(2)]);\n        var xliff = new Tag('xliff', { version: _VERSION, xmlns: _XMLNS }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    };\n    Xliff.prototype.load = function (content, url) {\n        // xliff to xml nodes\n        var xliffParser = new XliffParser();\n        var _a = xliffParser.parse(content, url), locale = _a.locale, msgIdToHtml = _a.msgIdToHtml, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var i18nNodesByMsgId = {};\n        var converter = new XmlToI18n();\n        Object.keys(msgIdToHtml).forEach(function (msgId) {\n            var _a = converter.convert(msgIdToHtml[msgId], url), i18nNodes = _a.i18nNodes, e = _a.errors;\n            errors.push.apply(errors, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(e));\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(\"xliff parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: locale, i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    Xliff.prototype.digest = function (message) { return digest(message); };\n    return Xliff;\n}(Serializer));\nvar _WriteVisitor = /** @class */ (function () {\n    function _WriteVisitor() {\n    }\n    _WriteVisitor.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };\n    _WriteVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(node.visit(_this))); });\n        return nodes;\n    };\n    _WriteVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var nodes = [new Text$2(\"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \")];\n        Object.keys(icu.cases).forEach(function (c) {\n            nodes.push.apply(nodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([new Text$2(c + \" {\")], icu.cases[c].visit(_this), [new Text$2(\"} \")]));\n        });\n        nodes.push(new Text$2(\"}\"));\n        return nodes;\n    };\n    _WriteVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var ctype = getCtypeForTag(ph.tag);\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [new Tag(_PLACEHOLDER_TAG$1, { id: ph.startName, ctype: ctype, 'equiv-text': \"<\" + ph.tag + \"/>\" })];\n        }\n        var startTagPh = new Tag(_PLACEHOLDER_TAG$1, { id: ph.startName, ctype: ctype, 'equiv-text': \"<\" + ph.tag + \">\" });\n        var closeTagPh = new Tag(_PLACEHOLDER_TAG$1, { id: ph.closeName, ctype: ctype, 'equiv-text': \"</\" + ph.tag + \">\" });\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([startTagPh], this.serialize(ph.children), [closeTagPh]);\n    };\n    _WriteVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$1, { id: ph.name, 'equiv-text': \"{{\" + ph.value + \"}}\" })];\n    };\n    _WriteVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        var equivText = \"{\" + ph.value.expression + \", \" + ph.value.type + \", \" + Object.keys(ph.value.cases).map(function (value) { return value + ' {...}'; }).join(' ') + \"}\";\n        return [new Tag(_PLACEHOLDER_TAG$1, { id: ph.name, 'equiv-text': equivText })];\n    };\n    _WriteVisitor.prototype.serialize = function (nodes) {\n        var _this = this;\n        return [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(nodes.map(function (node) { return node.visit(_this); })));\n    };\n    return _WriteVisitor;\n}());\n// TODO(vicb): add error management (structure)\n// Extract messages as xml nodes from the xliff file\nvar XliffParser = /** @class */ (function () {\n    function XliffParser() {\n        this._locale = null;\n    }\n    XliffParser.prototype.parse = function (xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        var xml = new XmlParser().parse(xliff, url);\n        this._errors = xml.errors;\n        visitAll$1(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    XliffParser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _UNIT_TAG:\n                this._unitMlString = null;\n                var idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _UNIT_TAG + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        visitAll$1(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, \"Message \" + id + \" misses a translation\");\n                        }\n                    }\n                }\n                break;\n            // ignore those tags\n            case _SOURCE_TAG$1:\n            case _SEGMENT_SOURCE_TAG:\n            case _ALT_TRANS_TAG:\n                break;\n            case _TARGET_TAG:\n                var innerTextStart = element.startSourceSpan.end.offset;\n                var innerTextEnd = element.endSourceSpan.start.offset;\n                var content = element.startSourceSpan.start.file.content;\n                var innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _FILE_TAG:\n                var localeAttr = element.attrs.find(function (attr) { return attr.name === 'target-language'; });\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                visitAll$1(this, element.children, null);\n                break;\n            default:\n                // TODO(vicb): assert file structure, xliff version\n                // For now only recurse on unhandled nodes\n                visitAll$1(this, element.children, null);\n        }\n    };\n    XliffParser.prototype.visitAttribute = function (attribute, context) { };\n    XliffParser.prototype.visitText = function (text, context) { };\n    XliffParser.prototype.visitComment = function (comment, context) { };\n    XliffParser.prototype.visitExpansion = function (expansion, context) { };\n    XliffParser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    XliffParser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XliffParser;\n}());\n// Convert ml nodes (xliff syntax) to i18n nodes\nvar XmlToI18n = /** @class */ (function () {\n    function XmlToI18n() {\n    }\n    XmlToI18n.prototype.convert = function (message, url) {\n        var xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\n        this._errors = xmlIcu.errors;\n        var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] : [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(visitAll$1(this, xmlIcu.rootNodes)));\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    };\n    XmlToI18n.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };\n    XmlToI18n.prototype.visitElement = function (el, context) {\n        if (el.name === _PLACEHOLDER_TAG$1) {\n            var nameAttr = el.attrs.find(function (attr) { return attr.name === 'id'; });\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, el.sourceSpan);\n            }\n            this._addError(el, \"<\" + _PLACEHOLDER_TAG$1 + \"> misses the \\\"id\\\" attribute\");\n            return null;\n        }\n        if (el.name === _MARKER_TAG) {\n            return [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(visitAll$1(this, el.children)));\n        }\n        this._addError(el, \"Unexpected tag\");\n        return null;\n    };\n    XmlToI18n.prototype.visitExpansion = function (icu, context) {\n        var caseMap = {};\n        visitAll$1(this, icu.cases).forEach(function (c) {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu$1(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    };\n    XmlToI18n.prototype.visitExpansionCase = function (icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: visitAll$1(this, icuCase.expression),\n        };\n    };\n    XmlToI18n.prototype.visitComment = function (comment, context) { };\n    XmlToI18n.prototype.visitAttribute = function (attribute, context) { };\n    XmlToI18n.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XmlToI18n;\n}());\nfunction getCtypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n            return 'lb';\n        case 'img':\n            return 'image';\n        default:\n            return \"x-\" + tag;\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _VERSION$1 = '2.0';\nvar _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:2.0';\n// TODO(vicb): make this a param (s/_/-/)\nvar _DEFAULT_SOURCE_LANG$1 = 'en';\nvar _PLACEHOLDER_TAG$2 = 'ph';\nvar _PLACEHOLDER_SPANNING_TAG = 'pc';\nvar _MARKER_TAG$1 = 'mrk';\nvar _XLIFF_TAG = 'xliff';\nvar _SOURCE_TAG$2 = 'source';\nvar _TARGET_TAG$1 = 'target';\nvar _UNIT_TAG$1 = 'unit';\n// http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\nvar Xliff2 = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Xliff2, _super);\n    function Xliff2() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Xliff2.prototype.write = function (messages, locale) {\n        var visitor = new _WriteVisitor$1();\n        var units = [];\n        messages.forEach(function (message) {\n            var unit = new Tag(_UNIT_TAG$1, { id: message.id });\n            var notes = new Tag('notes');\n            if (message.description || message.meaning) {\n                if (message.description) {\n                    notes.children.push(new CR(8), new Tag('note', { category: 'description' }, [new Text$2(message.description)]));\n                }\n                if (message.meaning) {\n                    notes.children.push(new CR(8), new Tag('note', { category: 'meaning' }, [new Text$2(message.meaning)]));\n                }\n            }\n            message.sources.forEach(function (source) {\n                notes.children.push(new CR(8), new Tag('note', { category: 'location' }, [\n                    new Text$2(source.filePath + \":\" + source.startLine + (source.endLine !== source.startLine ? ',' + source.endLine : ''))\n                ]));\n            });\n            notes.children.push(new CR(6));\n            unit.children.push(new CR(6), notes);\n            var segment = new Tag('segment');\n            segment.children.push(new CR(8), new Tag(_SOURCE_TAG$2, {}, visitor.serialize(message.nodes)), new CR(6));\n            unit.children.push(new CR(6), segment, new CR(4));\n            units.push(new CR(4), unit);\n        });\n        var file = new Tag('file', { 'original': 'ng.template', id: 'ngi18n' }, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(units, [new CR(2)]));\n        var xliff = new Tag(_XLIFF_TAG, { version: _VERSION$1, xmlns: _XMLNS$1, srcLang: locale || _DEFAULT_SOURCE_LANG$1 }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    };\n    Xliff2.prototype.load = function (content, url) {\n        // xliff to xml nodes\n        var xliff2Parser = new Xliff2Parser();\n        var _a = xliff2Parser.parse(content, url), locale = _a.locale, msgIdToHtml = _a.msgIdToHtml, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var i18nNodesByMsgId = {};\n        var converter = new XmlToI18n$1();\n        Object.keys(msgIdToHtml).forEach(function (msgId) {\n            var _a = converter.convert(msgIdToHtml[msgId], url), i18nNodes = _a.i18nNodes, e = _a.errors;\n            errors.push.apply(errors, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(e));\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(\"xliff2 parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: locale, i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    Xliff2.prototype.digest = function (message) { return decimalDigest(message); };\n    return Xliff2;\n}(Serializer));\nvar _WriteVisitor$1 = /** @class */ (function () {\n    function _WriteVisitor() {\n    }\n    _WriteVisitor.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };\n    _WriteVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(node.visit(_this))); });\n        return nodes;\n    };\n    _WriteVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var nodes = [new Text$2(\"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \")];\n        Object.keys(icu.cases).forEach(function (c) {\n            nodes.push.apply(nodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([new Text$2(c + \" {\")], icu.cases[c].visit(_this), [new Text$2(\"} \")]));\n        });\n        nodes.push(new Text$2(\"}\"));\n        return nodes;\n    };\n    _WriteVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var type = getTypeForTag(ph.tag);\n        if (ph.isVoid) {\n            var tagPh = new Tag(_PLACEHOLDER_TAG$2, {\n                id: (this._nextPlaceholderId++).toString(),\n                equiv: ph.startName,\n                type: type,\n                disp: \"<\" + ph.tag + \"/>\",\n            });\n            return [tagPh];\n        }\n        var tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {\n            id: (this._nextPlaceholderId++).toString(),\n            equivStart: ph.startName,\n            equivEnd: ph.closeName,\n            type: type,\n            dispStart: \"<\" + ph.tag + \">\",\n            dispEnd: \"</\" + ph.tag + \">\",\n        });\n        var nodes = [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(ph.children.map(function (node) { return node.visit(_this); })));\n        if (nodes.length) {\n            nodes.forEach(function (node) { return tagPc.children.push(node); });\n        }\n        else {\n            tagPc.children.push(new Text$2(''));\n        }\n        return [tagPc];\n    };\n    _WriteVisitor.prototype.visitPlaceholder = function (ph, context) {\n        var idStr = (this._nextPlaceholderId++).toString();\n        return [new Tag(_PLACEHOLDER_TAG$2, {\n                id: idStr,\n                equiv: ph.name,\n                disp: \"{{\" + ph.value + \"}}\",\n            })];\n    };\n    _WriteVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        var cases = Object.keys(ph.value.cases).map(function (value) { return value + ' {...}'; }).join(' ');\n        var idStr = (this._nextPlaceholderId++).toString();\n        return [new Tag(_PLACEHOLDER_TAG$2, { id: idStr, equiv: ph.name, disp: \"{\" + ph.value.expression + \", \" + ph.value.type + \", \" + cases + \"}\" })];\n    };\n    _WriteVisitor.prototype.serialize = function (nodes) {\n        var _this = this;\n        this._nextPlaceholderId = 0;\n        return [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(nodes.map(function (node) { return node.visit(_this); })));\n    };\n    return _WriteVisitor;\n}());\n// Extract messages as xml nodes from the xliff file\nvar Xliff2Parser = /** @class */ (function () {\n    function Xliff2Parser() {\n        this._locale = null;\n    }\n    Xliff2Parser.prototype.parse = function (xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        var xml = new XmlParser().parse(xliff, url);\n        this._errors = xml.errors;\n        visitAll$1(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    Xliff2Parser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _UNIT_TAG$1:\n                this._unitMlString = null;\n                var idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _UNIT_TAG$1 + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        visitAll$1(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, \"Message \" + id + \" misses a translation\");\n                        }\n                    }\n                }\n                break;\n            case _SOURCE_TAG$2:\n                // ignore source message\n                break;\n            case _TARGET_TAG$1:\n                var innerTextStart = element.startSourceSpan.end.offset;\n                var innerTextEnd = element.endSourceSpan.start.offset;\n                var content = element.startSourceSpan.start.file.content;\n                var innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _XLIFF_TAG:\n                var localeAttr = element.attrs.find(function (attr) { return attr.name === 'trgLang'; });\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                var versionAttr = element.attrs.find(function (attr) { return attr.name === 'version'; });\n                if (versionAttr) {\n                    var version = versionAttr.value;\n                    if (version !== '2.0') {\n                        this._addError(element, \"The XLIFF file version \" + version + \" is not compatible with XLIFF 2.0 serializer\");\n                    }\n                    else {\n                        visitAll$1(this, element.children, null);\n                    }\n                }\n                break;\n            default:\n                visitAll$1(this, element.children, null);\n        }\n    };\n    Xliff2Parser.prototype.visitAttribute = function (attribute, context) { };\n    Xliff2Parser.prototype.visitText = function (text, context) { };\n    Xliff2Parser.prototype.visitComment = function (comment, context) { };\n    Xliff2Parser.prototype.visitExpansion = function (expansion, context) { };\n    Xliff2Parser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    Xliff2Parser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return Xliff2Parser;\n}());\n// Convert ml nodes (xliff syntax) to i18n nodes\nvar XmlToI18n$1 = /** @class */ (function () {\n    function XmlToI18n() {\n    }\n    XmlToI18n.prototype.convert = function (message, url) {\n        var xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\n        this._errors = xmlIcu.errors;\n        var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] : [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(visitAll$1(this, xmlIcu.rootNodes)));\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    };\n    XmlToI18n.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };\n    XmlToI18n.prototype.visitElement = function (el, context) {\n        var _this = this;\n        switch (el.name) {\n            case _PLACEHOLDER_TAG$2:\n                var nameAttr = el.attrs.find(function (attr) { return attr.name === 'equiv'; });\n                if (nameAttr) {\n                    return [new Placeholder('', nameAttr.value, el.sourceSpan)];\n                }\n                this._addError(el, \"<\" + _PLACEHOLDER_TAG$2 + \"> misses the \\\"equiv\\\" attribute\");\n                break;\n            case _PLACEHOLDER_SPANNING_TAG:\n                var startAttr = el.attrs.find(function (attr) { return attr.name === 'equivStart'; });\n                var endAttr = el.attrs.find(function (attr) { return attr.name === 'equivEnd'; });\n                if (!startAttr) {\n                    this._addError(el, \"<\" + _PLACEHOLDER_TAG$2 + \"> misses the \\\"equivStart\\\" attribute\");\n                }\n                else if (!endAttr) {\n                    this._addError(el, \"<\" + _PLACEHOLDER_TAG$2 + \"> misses the \\\"equivEnd\\\" attribute\");\n                }\n                else {\n                    var startId = startAttr.value;\n                    var endId = endAttr.value;\n                    var nodes = [];\n                    return nodes.concat.apply(nodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([new Placeholder('', startId, el.sourceSpan)], el.children.map(function (node) { return node.visit(_this, null); }), [new Placeholder('', endId, el.sourceSpan)]));\n                }\n                break;\n            case _MARKER_TAG$1:\n                return [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(visitAll$1(this, el.children)));\n            default:\n                this._addError(el, \"Unexpected tag\");\n        }\n        return null;\n    };\n    XmlToI18n.prototype.visitExpansion = function (icu, context) {\n        var caseMap = {};\n        visitAll$1(this, icu.cases).forEach(function (c) {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu$1(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    };\n    XmlToI18n.prototype.visitExpansionCase = function (icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(visitAll$1(this, icuCase.expression))),\n        };\n    };\n    XmlToI18n.prototype.visitComment = function (comment, context) { };\n    XmlToI18n.prototype.visitAttribute = function (attribute, context) { };\n    XmlToI18n.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XmlToI18n;\n}());\nfunction getTypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n        case 'b':\n        case 'i':\n        case 'u':\n            return 'fmt';\n        case 'img':\n            return 'image';\n        case 'a':\n            return 'link';\n        default:\n            return 'other';\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _TRANSLATIONS_TAG = 'translationbundle';\nvar _TRANSLATION_TAG = 'translation';\nvar _PLACEHOLDER_TAG$3 = 'ph';\nvar Xtb = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Xtb, _super);\n    function Xtb() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Xtb.prototype.write = function (messages, locale) { throw new Error('Unsupported'); };\n    Xtb.prototype.load = function (content, url) {\n        // xtb to xml nodes\n        var xtbParser = new XtbParser();\n        var _a = xtbParser.parse(content, url), locale = _a.locale, msgIdToHtml = _a.msgIdToHtml, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var i18nNodesByMsgId = {};\n        var converter = new XmlToI18n$2();\n        // Because we should be able to load xtb files that rely on features not supported by angular,\n        // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n        // converted\n        Object.keys(msgIdToHtml).forEach(function (msgId) {\n            var valueFn = function () {\n                var _a = converter.convert(msgIdToHtml[msgId], url), i18nNodes = _a.i18nNodes, errors = _a.errors;\n                if (errors.length) {\n                    throw new Error(\"xtb parse errors:\\n\" + errors.join('\\n'));\n                }\n                return i18nNodes;\n            };\n            createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n        });\n        if (errors.length) {\n            throw new Error(\"xtb parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: locale, i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    Xtb.prototype.digest = function (message) { return digest$1(message); };\n    Xtb.prototype.createNameMapper = function (message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    };\n    return Xtb;\n}(Serializer));\nfunction createLazyProperty(messages, id, valueFn) {\n    Object.defineProperty(messages, id, {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            var value = valueFn();\n            Object.defineProperty(messages, id, { enumerable: true, value: value });\n            return value;\n        },\n        set: function (_) { throw new Error('Could not overwrite an XTB translation'); },\n    });\n}\n// Extract messages as xml nodes from the xtb file\nvar XtbParser = /** @class */ (function () {\n    function XtbParser() {\n        this._locale = null;\n    }\n    XtbParser.prototype.parse = function (xtb, url) {\n        this._bundleDepth = 0;\n        this._msgIdToHtml = {};\n        // We can not parse the ICU messages at this point as some messages might not originate\n        // from Angular that could not be lex'd.\n        var xml = new XmlParser().parse(xtb, url);\n        this._errors = xml.errors;\n        visitAll$1(this, xml.rootNodes);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    XtbParser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _TRANSLATIONS_TAG:\n                this._bundleDepth++;\n                if (this._bundleDepth > 1) {\n                    this._addError(element, \"<\" + _TRANSLATIONS_TAG + \"> elements can not be nested\");\n                }\n                var langAttr = element.attrs.find(function (attr) { return attr.name === 'lang'; });\n                if (langAttr) {\n                    this._locale = langAttr.value;\n                }\n                visitAll$1(this, element.children, null);\n                this._bundleDepth--;\n                break;\n            case _TRANSLATION_TAG:\n                var idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _TRANSLATION_TAG + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        var innerTextStart = element.startSourceSpan.end.offset;\n                        var innerTextEnd = element.endSourceSpan.start.offset;\n                        var content = element.startSourceSpan.start.file.content;\n                        var innerText = content.slice(innerTextStart, innerTextEnd);\n                        this._msgIdToHtml[id] = innerText;\n                    }\n                }\n                break;\n            default:\n                this._addError(element, 'Unexpected tag');\n        }\n    };\n    XtbParser.prototype.visitAttribute = function (attribute, context) { };\n    XtbParser.prototype.visitText = function (text, context) { };\n    XtbParser.prototype.visitComment = function (comment, context) { };\n    XtbParser.prototype.visitExpansion = function (expansion, context) { };\n    XtbParser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    XtbParser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XtbParser;\n}());\n// Convert ml nodes (xtb syntax) to i18n nodes\nvar XmlToI18n$2 = /** @class */ (function () {\n    function XmlToI18n() {\n    }\n    XmlToI18n.prototype.convert = function (message, url) {\n        var xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\n        this._errors = xmlIcu.errors;\n        var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            visitAll$1(this, xmlIcu.rootNodes);\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    };\n    XmlToI18n.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };\n    XmlToI18n.prototype.visitExpansion = function (icu, context) {\n        var caseMap = {};\n        visitAll$1(this, icu.cases).forEach(function (c) {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu$1(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    };\n    XmlToI18n.prototype.visitExpansionCase = function (icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: visitAll$1(this, icuCase.expression),\n        };\n    };\n    XmlToI18n.prototype.visitElement = function (el, context) {\n        if (el.name === _PLACEHOLDER_TAG$3) {\n            var nameAttr = el.attrs.find(function (attr) { return attr.name === 'name'; });\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, el.sourceSpan);\n            }\n            this._addError(el, \"<\" + _PLACEHOLDER_TAG$3 + \"> misses the \\\"name\\\" attribute\");\n        }\n        else {\n            this._addError(el, \"Unexpected tag\");\n        }\n        return null;\n    };\n    XmlToI18n.prototype.visitComment = function (comment, context) { };\n    XmlToI18n.prototype.visitAttribute = function (attribute, context) { };\n    XmlToI18n.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XmlToI18n;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A container for translated messages\n */\nvar TranslationBundle = /** @class */ (function () {\n    function TranslationBundle(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console) {\n        if (_i18nNodesByMsgId === void 0) { _i18nNodesByMsgId = {}; }\n        if (missingTranslationStrategy === void 0) { missingTranslationStrategy = MissingTranslationStrategy.Warning; }\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this.digest = digest;\n        this.mapperFactory = mapperFactory;\n        this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);\n    }\n    // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.\n    TranslationBundle.load = function (content, url, serializer, missingTranslationStrategy, console) {\n        var _a = serializer.load(content, url), locale = _a.locale, i18nNodesByMsgId = _a.i18nNodesByMsgId;\n        var digestFn = function (m) { return serializer.digest(m); };\n        var mapperFactory = function (m) { return serializer.createNameMapper(m); };\n        return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n    };\n    // Returns the translation as HTML nodes from the given source message.\n    TranslationBundle.prototype.get = function (srcMsg) {\n        var html = this._i18nToHtml.convert(srcMsg);\n        if (html.errors.length) {\n            throw new Error(html.errors.join('\\n'));\n        }\n        return html.nodes;\n    };\n    TranslationBundle.prototype.has = function (srcMsg) { return this.digest(srcMsg) in this._i18nNodesByMsgId; };\n    return TranslationBundle;\n}());\nvar I18nToHtmlVisitor = /** @class */ (function () {\n    function I18nToHtmlVisitor(_i18nNodesByMsgId, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {\n        if (_i18nNodesByMsgId === void 0) { _i18nNodesByMsgId = {}; }\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this._locale = _locale;\n        this._digest = _digest;\n        this._mapperFactory = _mapperFactory;\n        this._missingTranslationStrategy = _missingTranslationStrategy;\n        this._console = _console;\n        this._contextStack = [];\n        this._errors = [];\n    }\n    I18nToHtmlVisitor.prototype.convert = function (srcMsg) {\n        this._contextStack.length = 0;\n        this._errors.length = 0;\n        // i18n to text\n        var text = this._convertToText(srcMsg);\n        // text to html\n        var url = srcMsg.nodes[0].sourceSpan.start.file.url;\n        var html = new HtmlParser().parse(text, url, { tokenizeExpansionForms: true });\n        return {\n            nodes: html.rootNodes,\n            errors: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this._errors, html.errors),\n        };\n    };\n    I18nToHtmlVisitor.prototype.visitText = function (text, context) {\n        // `convert()` uses an `HtmlParser` to return `html.Node`s\n        // we should then make sure that any special characters are escaped\n        return escapeXml(text.value);\n    };\n    I18nToHtmlVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        return container.children.map(function (n) { return n.visit(_this); }).join('');\n    };\n    I18nToHtmlVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var cases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        // TODO(vicb): Once all format switch to using expression placeholders\n        // we should throw when the placeholder is not in the source message\n        var exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ?\n            this._srcMsg.placeholders[icu.expression] :\n            icu.expression;\n        return \"{\" + exp + \", \" + icu.type + \", \" + cases.join(' ') + \"}\";\n    };\n    I18nToHtmlVisitor.prototype.visitPlaceholder = function (ph, context) {\n        var phName = this._mapper(ph.name);\n        if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n            return this._srcMsg.placeholders[phName];\n        }\n        if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n            return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n        }\n        this._addError(ph, \"Unknown placeholder \\\"\" + ph.name + \"\\\"\");\n        return '';\n    };\n    // Loaded message contains only placeholders (vs tag and icu placeholders).\n    // However when a translation can not be found, we need to serialize the source message\n    // which can contain tag placeholders\n    I18nToHtmlVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var tag = \"\" + ph.tag;\n        var attrs = Object.keys(ph.attrs).map(function (name) { return name + \"=\\\"\" + ph.attrs[name] + \"\\\"\"; }).join(' ');\n        if (ph.isVoid) {\n            return \"<\" + tag + \" \" + attrs + \"/>\";\n        }\n        var children = ph.children.map(function (c) { return c.visit(_this); }).join('');\n        return \"<\" + tag + \" \" + attrs + \">\" + children + \"</\" + tag + \">\";\n    };\n    // Loaded message contains only placeholders (vs tag and icu placeholders).\n    // However when a translation can not be found, we need to serialize the source message\n    // which can contain tag placeholders\n    I18nToHtmlVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        // An ICU placeholder references the source message to be serialized\n        return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n    };\n    /**\n     * Convert a source message to a translated text string:\n     * - text nodes are replaced with their translation,\n     * - placeholders are replaced with their content,\n     * - ICU nodes are converted to ICU expressions.\n     */\n    I18nToHtmlVisitor.prototype._convertToText = function (srcMsg) {\n        var _this = this;\n        var id = this._digest(srcMsg);\n        var mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n        var nodes;\n        this._contextStack.push({ msg: this._srcMsg, mapper: this._mapper });\n        this._srcMsg = srcMsg;\n        if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n            // When there is a translation use its nodes as the source\n            // And create a mapper to convert serialized placeholder names to internal names\n            nodes = this._i18nNodesByMsgId[id];\n            this._mapper = function (name) { return mapper ? mapper.toInternalName(name) : name; };\n        }\n        else {\n            // When no translation has been found\n            // - report an error / a warning / nothing,\n            // - use the nodes from the original message\n            // - placeholders are already internal and need no mapper\n            if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\n                var ctx = this._locale ? \" for locale \\\"\" + this._locale + \"\\\"\" : '';\n                this._addError(srcMsg.nodes[0], \"Missing translation for message \\\"\" + id + \"\\\"\" + ctx);\n            }\n            else if (this._console &&\n                this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {\n                var ctx = this._locale ? \" for locale \\\"\" + this._locale + \"\\\"\" : '';\n                this._console.warn(\"Missing translation for message \\\"\" + id + \"\\\"\" + ctx);\n            }\n            nodes = srcMsg.nodes;\n            this._mapper = function (name) { return name; };\n        }\n        var text = nodes.map(function (node) { return node.visit(_this); }).join('');\n        var context = this._contextStack.pop();\n        this._srcMsg = context.msg;\n        this._mapper = context.mapper;\n        return text;\n    };\n    I18nToHtmlVisitor.prototype._addError = function (el, msg) {\n        this._errors.push(new I18nError(el.sourceSpan, msg));\n    };\n    return I18nToHtmlVisitor;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar I18NHtmlParser = /** @class */ (function () {\n    function I18NHtmlParser(_htmlParser, translations, translationsFormat, missingTranslation, console) {\n        if (missingTranslation === void 0) { missingTranslation = MissingTranslationStrategy.Warning; }\n        this._htmlParser = _htmlParser;\n        if (translations) {\n            var serializer = createSerializer(translationsFormat);\n            this._translationBundle =\n                TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);\n        }\n        else {\n            this._translationBundle =\n                new TranslationBundle({}, null, digest, undefined, missingTranslation, console);\n        }\n    }\n    I18NHtmlParser.prototype.parse = function (source, url, options) {\n        if (options === void 0) { options = {}; }\n        var interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n        var parseResult = this._htmlParser.parse(source, url, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ interpolationConfig: interpolationConfig }, options));\n        if (parseResult.errors.length) {\n            return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\n        }\n        return mergeTranslations(parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});\n    };\n    return I18NHtmlParser;\n}());\nfunction createSerializer(format) {\n    format = (format || 'xlf').toLowerCase();\n    switch (format) {\n        case 'xmb':\n            return new Xmb();\n        case 'xtb':\n            return new Xtb();\n        case 'xliff2':\n        case 'xlf2':\n            return new Xliff2();\n        case 'xliff':\n        case 'xlf':\n        default:\n            return new Xliff();\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar QUOTED_KEYS = '$quoted$';\nfunction convertValueToOutputAst(ctx, value, type) {\n    if (type === void 0) { type = null; }\n    return visitValue(value, new _ValueOutputAstTransformer(ctx), type);\n}\nvar _ValueOutputAstTransformer = /** @class */ (function () {\n    function _ValueOutputAstTransformer(ctx) {\n        this.ctx = ctx;\n    }\n    _ValueOutputAstTransformer.prototype.visitArray = function (arr, type) {\n        var _this = this;\n        return literalArr(arr.map(function (value) { return visitValue(value, _this, null); }), type);\n    };\n    _ValueOutputAstTransformer.prototype.visitStringMap = function (map, type) {\n        var _this = this;\n        var entries = [];\n        var quotedSet = new Set(map && map[QUOTED_KEYS]);\n        Object.keys(map).forEach(function (key) {\n            entries.push(new LiteralMapEntry(key, visitValue(map[key], _this, null), quotedSet.has(key)));\n        });\n        return new LiteralMapExpr(entries, type);\n    };\n    _ValueOutputAstTransformer.prototype.visitPrimitive = function (value, type) { return literal(value, type); };\n    _ValueOutputAstTransformer.prototype.visitOther = function (value, type) {\n        if (value instanceof Expression) {\n            return value;\n        }\n        else {\n            return this.ctx.importExpr(value);\n        }\n    };\n    return _ValueOutputAstTransformer;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction mapEntry$1(key, value) {\n    return { key: key, value: value, quoted: false };\n}\nvar InjectableCompiler = /** @class */ (function () {\n    function InjectableCompiler(reflector, alwaysGenerateDef) {\n        this.reflector = reflector;\n        this.alwaysGenerateDef = alwaysGenerateDef;\n        this.tokenInjector = reflector.resolveExternalReference(Identifiers.Injector);\n    }\n    InjectableCompiler.prototype.depsArray = function (deps, ctx) {\n        var _this = this;\n        return deps.map(function (dep) {\n            var token = dep;\n            var args = [token];\n            var flags = 0 /* Default */;\n            if (Array.isArray(dep)) {\n                for (var i = 0; i < dep.length; i++) {\n                    var v = dep[i];\n                    if (v) {\n                        if (v.ngMetadataName === 'Optional') {\n                            flags |= 8 /* Optional */;\n                        }\n                        else if (v.ngMetadataName === 'SkipSelf') {\n                            flags |= 4 /* SkipSelf */;\n                        }\n                        else if (v.ngMetadataName === 'Self') {\n                            flags |= 2 /* Self */;\n                        }\n                        else if (v.ngMetadataName === 'Inject') {\n                            token = v.token;\n                        }\n                        else {\n                            token = v;\n                        }\n                    }\n                }\n            }\n            var tokenExpr;\n            if (typeof token === 'string') {\n                tokenExpr = literal(token);\n            }\n            else if (token === _this.tokenInjector) {\n                tokenExpr = importExpr(Identifiers.INJECTOR);\n            }\n            else {\n                tokenExpr = ctx.importExpr(token);\n            }\n            if (flags !== 0 /* Default */) {\n                args = [tokenExpr, literal(flags)];\n            }\n            else {\n                args = [tokenExpr];\n            }\n            return importExpr(Identifiers.inject).callFn(args);\n        });\n    };\n    InjectableCompiler.prototype.factoryFor = function (injectable, ctx) {\n        var retValue;\n        if (injectable.useExisting) {\n            retValue = importExpr(Identifiers.inject).callFn([ctx.importExpr(injectable.useExisting)]);\n        }\n        else if (injectable.useFactory) {\n            var deps = injectable.deps || [];\n            if (deps.length > 0) {\n                retValue = ctx.importExpr(injectable.useFactory).callFn(this.depsArray(deps, ctx));\n            }\n            else {\n                return ctx.importExpr(injectable.useFactory);\n            }\n        }\n        else if (injectable.useValue) {\n            retValue = convertValueToOutputAst(ctx, injectable.useValue);\n        }\n        else {\n            var clazz = injectable.useClass || injectable.symbol;\n            var depArgs = this.depsArray(this.reflector.parameters(clazz), ctx);\n            retValue = new InstantiateExpr(ctx.importExpr(clazz), depArgs);\n        }\n        return fn([], [new ReturnStatement(retValue)], undefined, undefined, injectable.symbol.name + '_Factory');\n    };\n    InjectableCompiler.prototype.injectableDef = function (injectable, ctx) {\n        var providedIn = NULL_EXPR;\n        if (injectable.providedIn !== undefined) {\n            if (injectable.providedIn === null) {\n                providedIn = NULL_EXPR;\n            }\n            else if (typeof injectable.providedIn === 'string') {\n                providedIn = literal(injectable.providedIn);\n            }\n            else {\n                providedIn = ctx.importExpr(injectable.providedIn);\n            }\n        }\n        var def = [\n            mapEntry$1('factory', this.factoryFor(injectable, ctx)),\n            mapEntry$1('token', ctx.importExpr(injectable.type.reference)),\n            mapEntry$1('providedIn', providedIn),\n        ];\n        return importExpr(Identifiers.ɵɵdefineInjectable).callFn([literalMap(def)]);\n    };\n    InjectableCompiler.prototype.compile = function (injectable, ctx) {\n        if (this.alwaysGenerateDef || injectable.providedIn !== undefined) {\n            var className = identifierName(injectable.type);\n            var clazz = new ClassStmt(className, null, [\n                new ClassField('ngInjectableDef', INFERRED_TYPE, [StmtModifier.Static], this.injectableDef(injectable, ctx)),\n            ], [], new ClassMethod(null, [], []), []);\n            ctx.statements.push(clazz);\n        }\n    };\n    return InjectableCompiler;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar STRIP_SRC_FILE_SUFFIXES = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\nvar GENERATED_FILE = /\\.ngfactory\\.|\\.ngsummary\\./;\nvar JIT_SUMMARY_FILE = /\\.ngsummary\\./;\nvar JIT_SUMMARY_NAME = /NgSummary$/;\nfunction ngfactoryFilePath(filePath, forceSourceFile) {\n    if (forceSourceFile === void 0) { forceSourceFile = false; }\n    var urlWithSuffix = splitTypescriptSuffix(filePath, forceSourceFile);\n    return urlWithSuffix[0] + \".ngfactory\" + normalizeGenFileSuffix(urlWithSuffix[1]);\n}\nfunction stripGeneratedFileSuffix(filePath) {\n    return filePath.replace(GENERATED_FILE, '.');\n}\nfunction isGeneratedFile(filePath) {\n    return GENERATED_FILE.test(filePath);\n}\nfunction splitTypescriptSuffix(path, forceSourceFile) {\n    if (forceSourceFile === void 0) { forceSourceFile = false; }\n    if (path.endsWith('.d.ts')) {\n        return [path.slice(0, -5), forceSourceFile ? '.ts' : '.d.ts'];\n    }\n    var lastDot = path.lastIndexOf('.');\n    if (lastDot !== -1) {\n        return [path.substring(0, lastDot), path.substring(lastDot)];\n    }\n    return [path, ''];\n}\nfunction normalizeGenFileSuffix(srcFileSuffix) {\n    return srcFileSuffix === '.tsx' ? '.ts' : srcFileSuffix;\n}\nfunction summaryFileName(fileName) {\n    var fileNameWithoutSuffix = fileName.replace(STRIP_SRC_FILE_SUFFIXES, '');\n    return fileNameWithoutSuffix + \".ngsummary.json\";\n}\nfunction summaryForJitFileName(fileName, forceSourceFile) {\n    if (forceSourceFile === void 0) { forceSourceFile = false; }\n    var urlWithSuffix = splitTypescriptSuffix(stripGeneratedFileSuffix(fileName), forceSourceFile);\n    return urlWithSuffix[0] + \".ngsummary\" + urlWithSuffix[1];\n}\nfunction stripSummaryForJitFileSuffix(filePath) {\n    return filePath.replace(JIT_SUMMARY_FILE, '.');\n}\nfunction summaryForJitName(symbolName) {\n    return symbolName + \"NgSummary\";\n}\nfunction stripSummaryForJitNameSuffix(symbolName) {\n    return symbolName.replace(JIT_SUMMARY_NAME, '');\n}\nvar LOWERED_SYMBOL = /\\u0275\\d+/;\nfunction isLoweredSymbol(name) {\n    return LOWERED_SYMBOL.test(name);\n}\nfunction createLoweredSymbol(id) {\n    return \"\\u0275\" + id;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar LifecycleHooks;\n(function (LifecycleHooks) {\n    LifecycleHooks[LifecycleHooks[\"OnInit\"] = 0] = \"OnInit\";\n    LifecycleHooks[LifecycleHooks[\"OnDestroy\"] = 1] = \"OnDestroy\";\n    LifecycleHooks[LifecycleHooks[\"DoCheck\"] = 2] = \"DoCheck\";\n    LifecycleHooks[LifecycleHooks[\"OnChanges\"] = 3] = \"OnChanges\";\n    LifecycleHooks[LifecycleHooks[\"AfterContentInit\"] = 4] = \"AfterContentInit\";\n    LifecycleHooks[LifecycleHooks[\"AfterContentChecked\"] = 5] = \"AfterContentChecked\";\n    LifecycleHooks[LifecycleHooks[\"AfterViewInit\"] = 6] = \"AfterViewInit\";\n    LifecycleHooks[LifecycleHooks[\"AfterViewChecked\"] = 7] = \"AfterViewChecked\";\n})(LifecycleHooks || (LifecycleHooks = {}));\nvar LIFECYCLE_HOOKS_VALUES = [\n    LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,\n    LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,\n    LifecycleHooks.AfterViewChecked\n];\nfunction hasLifecycleHook(reflector, hook, token) {\n    return reflector.hasLifecycleHook(token, getHookName(hook));\n}\nfunction getAllLifecycleHooks(reflector, token) {\n    return LIFECYCLE_HOOKS_VALUES.filter(function (hook) { return hasLifecycleHook(reflector, hook, token); });\n}\nfunction getHookName(hook) {\n    switch (hook) {\n        case LifecycleHooks.OnInit:\n            return 'ngOnInit';\n        case LifecycleHooks.OnDestroy:\n            return 'ngOnDestroy';\n        case LifecycleHooks.DoCheck:\n            return 'ngDoCheck';\n        case LifecycleHooks.OnChanges:\n            return 'ngOnChanges';\n        case LifecycleHooks.AfterContentInit:\n            return 'ngAfterContentInit';\n        case LifecycleHooks.AfterContentChecked:\n            return 'ngAfterContentChecked';\n        case LifecycleHooks.AfterViewInit:\n            return 'ngAfterViewInit';\n        case LifecycleHooks.AfterViewChecked:\n            return 'ngAfterViewChecked';\n        default:\n            // This default case is not needed by TypeScript compiler, as the switch is exhaustive.\n            // However Closure Compiler does not understand that and reports an error in typed mode.\n            // The `throw new Error` below works around the problem, and the unexpected: never variable\n            // makes sure tsc still checks this code is unreachable.\n            var unexpected = hook;\n            throw new Error(\"unexpected \" + unexpected);\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ERROR_COMPONENT_TYPE = 'ngComponentType';\n// Design notes:\n// - don't lazily create metadata:\n//   For some metadata, we need to do async work sometimes,\n//   so the user has to kick off this loading.\n//   But we want to report errors even when the async work is\n//   not required to check that the user would have been able\n//   to wait correctly.\nvar CompileMetadataResolver = /** @class */ (function () {\n    function CompileMetadataResolver(_config, _htmlParser, _ngModuleResolver, _directiveResolver, _pipeResolver, _summaryResolver, _schemaRegistry, _directiveNormalizer, _console, _staticSymbolCache, _reflector, _errorCollector) {\n        this._config = _config;\n        this._htmlParser = _htmlParser;\n        this._ngModuleResolver = _ngModuleResolver;\n        this._directiveResolver = _directiveResolver;\n        this._pipeResolver = _pipeResolver;\n        this._summaryResolver = _summaryResolver;\n        this._schemaRegistry = _schemaRegistry;\n        this._directiveNormalizer = _directiveNormalizer;\n        this._console = _console;\n        this._staticSymbolCache = _staticSymbolCache;\n        this._reflector = _reflector;\n        this._errorCollector = _errorCollector;\n        this._nonNormalizedDirectiveCache = new Map();\n        this._directiveCache = new Map();\n        this._summaryCache = new Map();\n        this._pipeCache = new Map();\n        this._ngModuleCache = new Map();\n        this._ngModuleOfTypes = new Map();\n        this._shallowModuleCache = new Map();\n    }\n    CompileMetadataResolver.prototype.getReflector = function () { return this._reflector; };\n    CompileMetadataResolver.prototype.clearCacheFor = function (type) {\n        var dirMeta = this._directiveCache.get(type);\n        this._directiveCache.delete(type);\n        this._nonNormalizedDirectiveCache.delete(type);\n        this._summaryCache.delete(type);\n        this._pipeCache.delete(type);\n        this._ngModuleOfTypes.delete(type);\n        // Clear all of the NgModule as they contain transitive information!\n        this._ngModuleCache.clear();\n        if (dirMeta) {\n            this._directiveNormalizer.clearCacheFor(dirMeta);\n        }\n    };\n    CompileMetadataResolver.prototype.clearCache = function () {\n        this._directiveCache.clear();\n        this._nonNormalizedDirectiveCache.clear();\n        this._summaryCache.clear();\n        this._pipeCache.clear();\n        this._ngModuleCache.clear();\n        this._ngModuleOfTypes.clear();\n        this._directiveNormalizer.clearCache();\n    };\n    CompileMetadataResolver.prototype._createProxyClass = function (baseType, name) {\n        var delegate = null;\n        var proxyClass = function () {\n            if (!delegate) {\n                throw new Error(\"Illegal state: Class \" + name + \" for type \" + stringify(baseType) + \" is not compiled yet!\");\n            }\n            return delegate.apply(this, arguments);\n        };\n        proxyClass.setDelegate = function (d) {\n            delegate = d;\n            proxyClass.prototype = d.prototype;\n        };\n        // Make stringify work correctly\n        proxyClass.overriddenName = name;\n        return proxyClass;\n    };\n    CompileMetadataResolver.prototype.getGeneratedClass = function (dirType, name) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), name);\n        }\n        else {\n            return this._createProxyClass(dirType, name);\n        }\n    };\n    CompileMetadataResolver.prototype.getComponentViewClass = function (dirType) {\n        return this.getGeneratedClass(dirType, viewClassName(dirType, 0));\n    };\n    CompileMetadataResolver.prototype.getHostComponentViewClass = function (dirType) {\n        return this.getGeneratedClass(dirType, hostViewClassName(dirType));\n    };\n    CompileMetadataResolver.prototype.getHostComponentType = function (dirType) {\n        var name = identifierName({ reference: dirType }) + \"_Host\";\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(dirType.filePath, name);\n        }\n        return this._createProxyClass(dirType, name);\n    };\n    CompileMetadataResolver.prototype.getRendererType = function (dirType) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), rendererTypeName(dirType));\n        }\n        else {\n            // returning an object as proxy,\n            // that we fill later during runtime compilation.\n            return {};\n        }\n    };\n    CompileMetadataResolver.prototype.getComponentFactory = function (selector, dirType, inputs, outputs) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), componentFactoryName(dirType));\n        }\n        else {\n            var hostView = this.getHostComponentViewClass(dirType);\n            // Note: ngContentSelectors will be filled later once the template is\n            // loaded.\n            var createComponentFactory = this._reflector.resolveExternalReference(Identifiers.createComponentFactory);\n            return createComponentFactory(selector, dirType, hostView, inputs, outputs, []);\n        }\n    };\n    CompileMetadataResolver.prototype.initComponentFactory = function (factory, ngContentSelectors) {\n        var _a;\n        if (!(factory instanceof StaticSymbol)) {\n            (_a = factory.ngContentSelectors).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(ngContentSelectors));\n        }\n    };\n    CompileMetadataResolver.prototype._loadSummary = function (type, kind) {\n        var typeSummary = this._summaryCache.get(type);\n        if (!typeSummary) {\n            var summary = this._summaryResolver.resolveSummary(type);\n            typeSummary = summary ? summary.type : null;\n            this._summaryCache.set(type, typeSummary || null);\n        }\n        return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;\n    };\n    CompileMetadataResolver.prototype.getHostComponentMetadata = function (compMeta, hostViewType) {\n        var hostType = this.getHostComponentType(compMeta.type.reference);\n        if (!hostViewType) {\n            hostViewType = this.getHostComponentViewClass(hostType);\n        }\n        // Note: ! is ok here as this method should only be called with normalized directive\n        // metadata, which always fills in the selector.\n        var template = CssSelector.parse(compMeta.selector)[0].getMatchingElementTemplate();\n        var templateUrl = '';\n        var htmlAst = this._htmlParser.parse(template, templateUrl);\n        return CompileDirectiveMetadata.create({\n            isHost: true,\n            type: { reference: hostType, diDeps: [], lifecycleHooks: [] },\n            template: new CompileTemplateMetadata({\n                encapsulation: ViewEncapsulation.None,\n                template: template,\n                templateUrl: templateUrl,\n                htmlAst: htmlAst,\n                styles: [],\n                styleUrls: [],\n                ngContentSelectors: [],\n                animations: [],\n                isInline: true,\n                externalStylesheets: [],\n                interpolation: null,\n                preserveWhitespaces: false,\n            }),\n            exportAs: null,\n            changeDetection: ChangeDetectionStrategy.Default,\n            inputs: [],\n            outputs: [],\n            host: {},\n            isComponent: true,\n            selector: '*',\n            providers: [],\n            viewProviders: [],\n            queries: [],\n            guards: {},\n            viewQueries: [],\n            componentViewType: hostViewType,\n            rendererType: { id: '__Host__', encapsulation: ViewEncapsulation.None, styles: [], data: {} },\n            entryComponents: [],\n            componentFactory: null\n        });\n    };\n    CompileMetadataResolver.prototype.loadDirectiveMetadata = function (ngModuleType, directiveType, isSync) {\n        var _this = this;\n        if (this._directiveCache.has(directiveType)) {\n            return null;\n        }\n        directiveType = resolveForwardRef(directiveType);\n        var _a = this.getNonNormalizedDirectiveMetadata(directiveType), annotation = _a.annotation, metadata = _a.metadata;\n        var createDirectiveMetadata = function (templateMetadata) {\n            var normalizedDirMeta = new CompileDirectiveMetadata({\n                isHost: false,\n                type: metadata.type,\n                isComponent: metadata.isComponent,\n                selector: metadata.selector,\n                exportAs: metadata.exportAs,\n                changeDetection: metadata.changeDetection,\n                inputs: metadata.inputs,\n                outputs: metadata.outputs,\n                hostListeners: metadata.hostListeners,\n                hostProperties: metadata.hostProperties,\n                hostAttributes: metadata.hostAttributes,\n                providers: metadata.providers,\n                viewProviders: metadata.viewProviders,\n                queries: metadata.queries,\n                guards: metadata.guards,\n                viewQueries: metadata.viewQueries,\n                entryComponents: metadata.entryComponents,\n                componentViewType: metadata.componentViewType,\n                rendererType: metadata.rendererType,\n                componentFactory: metadata.componentFactory,\n                template: templateMetadata\n            });\n            if (templateMetadata) {\n                _this.initComponentFactory(metadata.componentFactory, templateMetadata.ngContentSelectors);\n            }\n            _this._directiveCache.set(directiveType, normalizedDirMeta);\n            _this._summaryCache.set(directiveType, normalizedDirMeta.toSummary());\n            return null;\n        };\n        if (metadata.isComponent) {\n            var template = metadata.template;\n            var templateMeta = this._directiveNormalizer.normalizeTemplate({\n                ngModuleType: ngModuleType,\n                componentType: directiveType,\n                moduleUrl: this._reflector.componentModuleUrl(directiveType, annotation),\n                encapsulation: template.encapsulation,\n                template: template.template,\n                templateUrl: template.templateUrl,\n                styles: template.styles,\n                styleUrls: template.styleUrls,\n                animations: template.animations,\n                interpolation: template.interpolation,\n                preserveWhitespaces: template.preserveWhitespaces\n            });\n            if (isPromise(templateMeta) && isSync) {\n                this._reportError(componentStillLoadingError(directiveType), directiveType);\n                return null;\n            }\n            return SyncAsync.then(templateMeta, createDirectiveMetadata);\n        }\n        else {\n            // directive\n            createDirectiveMetadata(null);\n            return null;\n        }\n    };\n    CompileMetadataResolver.prototype.getNonNormalizedDirectiveMetadata = function (directiveType) {\n        var _this = this;\n        directiveType = resolveForwardRef(directiveType);\n        if (!directiveType) {\n            return null;\n        }\n        var cacheEntry = this._nonNormalizedDirectiveCache.get(directiveType);\n        if (cacheEntry) {\n            return cacheEntry;\n        }\n        var dirMeta = this._directiveResolver.resolve(directiveType, false);\n        if (!dirMeta) {\n            return null;\n        }\n        var nonNormalizedTemplateMetadata = undefined;\n        if (createComponent.isTypeOf(dirMeta)) {\n            // component\n            var compMeta = dirMeta;\n            assertArrayOfStrings('styles', compMeta.styles);\n            assertArrayOfStrings('styleUrls', compMeta.styleUrls);\n            assertInterpolationSymbols('interpolation', compMeta.interpolation);\n            var animations = compMeta.animations;\n            nonNormalizedTemplateMetadata = new CompileTemplateMetadata({\n                encapsulation: noUndefined(compMeta.encapsulation),\n                template: noUndefined(compMeta.template),\n                templateUrl: noUndefined(compMeta.templateUrl),\n                htmlAst: null,\n                styles: compMeta.styles || [],\n                styleUrls: compMeta.styleUrls || [],\n                animations: animations || [],\n                interpolation: noUndefined(compMeta.interpolation),\n                isInline: !!compMeta.template,\n                externalStylesheets: [],\n                ngContentSelectors: [],\n                preserveWhitespaces: noUndefined(dirMeta.preserveWhitespaces),\n            });\n        }\n        var changeDetectionStrategy = null;\n        var viewProviders = [];\n        var entryComponentMetadata = [];\n        var selector = dirMeta.selector;\n        if (createComponent.isTypeOf(dirMeta)) {\n            // Component\n            var compMeta = dirMeta;\n            changeDetectionStrategy = compMeta.changeDetection;\n            if (compMeta.viewProviders) {\n                viewProviders = this._getProvidersMetadata(compMeta.viewProviders, entryComponentMetadata, \"viewProviders for \\\"\" + stringifyType(directiveType) + \"\\\"\", [], directiveType);\n            }\n            if (compMeta.entryComponents) {\n                entryComponentMetadata = flattenAndDedupeArray(compMeta.entryComponents)\n                    .map(function (type) { return _this._getEntryComponentMetadata(type); })\n                    .concat(entryComponentMetadata);\n            }\n            if (!selector) {\n                selector = this._schemaRegistry.getDefaultComponentElementName();\n            }\n        }\n        else {\n            // Directive\n            if (!selector) {\n                this._reportError(syntaxError(\"Directive \" + stringifyType(directiveType) + \" has no selector, please add it!\"), directiveType);\n                selector = 'error';\n            }\n        }\n        var providers = [];\n        if (dirMeta.providers != null) {\n            providers = this._getProvidersMetadata(dirMeta.providers, entryComponentMetadata, \"providers for \\\"\" + stringifyType(directiveType) + \"\\\"\", [], directiveType);\n        }\n        var queries = [];\n        var viewQueries = [];\n        if (dirMeta.queries != null) {\n            queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);\n            viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);\n        }\n        var metadata = CompileDirectiveMetadata.create({\n            isHost: false,\n            selector: selector,\n            exportAs: noUndefined(dirMeta.exportAs),\n            isComponent: !!nonNormalizedTemplateMetadata,\n            type: this._getTypeMetadata(directiveType),\n            template: nonNormalizedTemplateMetadata,\n            changeDetection: changeDetectionStrategy,\n            inputs: dirMeta.inputs || [],\n            outputs: dirMeta.outputs || [],\n            host: dirMeta.host || {},\n            providers: providers || [],\n            viewProviders: viewProviders || [],\n            queries: queries || [],\n            guards: dirMeta.guards || {},\n            viewQueries: viewQueries || [],\n            entryComponents: entryComponentMetadata,\n            componentViewType: nonNormalizedTemplateMetadata ? this.getComponentViewClass(directiveType) :\n                null,\n            rendererType: nonNormalizedTemplateMetadata ? this.getRendererType(directiveType) : null,\n            componentFactory: null\n        });\n        if (nonNormalizedTemplateMetadata) {\n            metadata.componentFactory =\n                this.getComponentFactory(selector, directiveType, metadata.inputs, metadata.outputs);\n        }\n        cacheEntry = { metadata: metadata, annotation: dirMeta };\n        this._nonNormalizedDirectiveCache.set(directiveType, cacheEntry);\n        return cacheEntry;\n    };\n    /**\n     * Gets the metadata for the given directive.\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n     */\n    CompileMetadataResolver.prototype.getDirectiveMetadata = function (directiveType) {\n        var dirMeta = this._directiveCache.get(directiveType);\n        if (!dirMeta) {\n            this._reportError(syntaxError(\"Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive \" + stringifyType(directiveType) + \".\"), directiveType);\n        }\n        return dirMeta;\n    };\n    CompileMetadataResolver.prototype.getDirectiveSummary = function (dirType) {\n        var dirSummary = this._loadSummary(dirType, CompileSummaryKind.Directive);\n        if (!dirSummary) {\n            this._reportError(syntaxError(\"Illegal state: Could not load the summary for directive \" + stringifyType(dirType) + \".\"), dirType);\n        }\n        return dirSummary;\n    };\n    CompileMetadataResolver.prototype.isDirective = function (type) {\n        return !!this._loadSummary(type, CompileSummaryKind.Directive) ||\n            this._directiveResolver.isDirective(type);\n    };\n    CompileMetadataResolver.prototype.isPipe = function (type) {\n        return !!this._loadSummary(type, CompileSummaryKind.Pipe) ||\n            this._pipeResolver.isPipe(type);\n    };\n    CompileMetadataResolver.prototype.isNgModule = function (type) {\n        return !!this._loadSummary(type, CompileSummaryKind.NgModule) ||\n            this._ngModuleResolver.isNgModule(type);\n    };\n    CompileMetadataResolver.prototype.getNgModuleSummary = function (moduleType, alreadyCollecting) {\n        if (alreadyCollecting === void 0) { alreadyCollecting = null; }\n        var moduleSummary = this._loadSummary(moduleType, CompileSummaryKind.NgModule);\n        if (!moduleSummary) {\n            var moduleMeta = this.getNgModuleMetadata(moduleType, false, alreadyCollecting);\n            moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;\n            if (moduleSummary) {\n                this._summaryCache.set(moduleType, moduleSummary);\n            }\n        }\n        return moduleSummary;\n    };\n    /**\n     * Loads the declared directives and pipes of an NgModule.\n     */\n    CompileMetadataResolver.prototype.loadNgModuleDirectiveAndPipeMetadata = function (moduleType, isSync, throwIfNotFound) {\n        var _this = this;\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);\n        var loading = [];\n        if (ngModule) {\n            ngModule.declaredDirectives.forEach(function (id) {\n                var promise = _this.loadDirectiveMetadata(moduleType, id.reference, isSync);\n                if (promise) {\n                    loading.push(promise);\n                }\n            });\n            ngModule.declaredPipes.forEach(function (id) { return _this._loadPipeMetadata(id.reference); });\n        }\n        return Promise.all(loading);\n    };\n    CompileMetadataResolver.prototype.getShallowModuleMetadata = function (moduleType) {\n        var compileMeta = this._shallowModuleCache.get(moduleType);\n        if (compileMeta) {\n            return compileMeta;\n        }\n        var ngModuleMeta = findLast(this._reflector.shallowAnnotations(moduleType), createNgModule.isTypeOf);\n        compileMeta = {\n            type: this._getTypeMetadata(moduleType),\n            rawExports: ngModuleMeta.exports,\n            rawImports: ngModuleMeta.imports,\n            rawProviders: ngModuleMeta.providers,\n        };\n        this._shallowModuleCache.set(moduleType, compileMeta);\n        return compileMeta;\n    };\n    CompileMetadataResolver.prototype.getNgModuleMetadata = function (moduleType, throwIfNotFound, alreadyCollecting) {\n        var _this = this;\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        if (alreadyCollecting === void 0) { alreadyCollecting = null; }\n        moduleType = resolveForwardRef(moduleType);\n        var compileMeta = this._ngModuleCache.get(moduleType);\n        if (compileMeta) {\n            return compileMeta;\n        }\n        var meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);\n        if (!meta) {\n            return null;\n        }\n        var declaredDirectives = [];\n        var exportedNonModuleIdentifiers = [];\n        var declaredPipes = [];\n        var importedModules = [];\n        var exportedModules = [];\n        var providers = [];\n        var entryComponents = [];\n        var bootstrapComponents = [];\n        var schemas = [];\n        if (meta.imports) {\n            flattenAndDedupeArray(meta.imports).forEach(function (importedType) {\n                var importedModuleType = undefined;\n                if (isValidType(importedType)) {\n                    importedModuleType = importedType;\n                }\n                else if (importedType && importedType.ngModule) {\n                    var moduleWithProviders = importedType;\n                    importedModuleType = moduleWithProviders.ngModule;\n                    if (moduleWithProviders.providers) {\n                        providers.push.apply(providers, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(_this._getProvidersMetadata(moduleWithProviders.providers, entryComponents, \"provider for the NgModule '\" + stringifyType(importedModuleType) + \"'\", [], importedType)));\n                    }\n                }\n                if (importedModuleType) {\n                    if (_this._checkSelfImport(moduleType, importedModuleType))\n                        return;\n                    if (!alreadyCollecting)\n                        alreadyCollecting = new Set();\n                    if (alreadyCollecting.has(importedModuleType)) {\n                        _this._reportError(syntaxError(_this._getTypeDescriptor(importedModuleType) + \" '\" + stringifyType(importedType) + \"' is imported recursively by the module '\" + stringifyType(moduleType) + \"'.\"), moduleType);\n                        return;\n                    }\n                    alreadyCollecting.add(importedModuleType);\n                    var importedModuleSummary = _this.getNgModuleSummary(importedModuleType, alreadyCollecting);\n                    alreadyCollecting.delete(importedModuleType);\n                    if (!importedModuleSummary) {\n                        _this._reportError(syntaxError(\"Unexpected \" + _this._getTypeDescriptor(importedType) + \" '\" + stringifyType(importedType) + \"' imported by the module '\" + stringifyType(moduleType) + \"'. Please add a @NgModule annotation.\"), moduleType);\n                        return;\n                    }\n                    importedModules.push(importedModuleSummary);\n                }\n                else {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(importedType) + \"' imported by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n            });\n        }\n        if (meta.exports) {\n            flattenAndDedupeArray(meta.exports).forEach(function (exportedType) {\n                if (!isValidType(exportedType)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(exportedType) + \"' exported by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                if (!alreadyCollecting)\n                    alreadyCollecting = new Set();\n                if (alreadyCollecting.has(exportedType)) {\n                    _this._reportError(syntaxError(_this._getTypeDescriptor(exportedType) + \" '\" + stringify(exportedType) + \"' is exported recursively by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                alreadyCollecting.add(exportedType);\n                var exportedModuleSummary = _this.getNgModuleSummary(exportedType, alreadyCollecting);\n                alreadyCollecting.delete(exportedType);\n                if (exportedModuleSummary) {\n                    exportedModules.push(exportedModuleSummary);\n                }\n                else {\n                    exportedNonModuleIdentifiers.push(_this._getIdentifierMetadata(exportedType));\n                }\n            });\n        }\n        // Note: This will be modified later, so we rely on\n        // getting a new instance every time!\n        var transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);\n        if (meta.declarations) {\n            flattenAndDedupeArray(meta.declarations).forEach(function (declaredType) {\n                if (!isValidType(declaredType)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(declaredType) + \"' declared by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                var declaredIdentifier = _this._getIdentifierMetadata(declaredType);\n                if (_this.isDirective(declaredType)) {\n                    transitiveModule.addDirective(declaredIdentifier);\n                    declaredDirectives.push(declaredIdentifier);\n                    _this._addTypeToModule(declaredType, moduleType);\n                }\n                else if (_this.isPipe(declaredType)) {\n                    transitiveModule.addPipe(declaredIdentifier);\n                    transitiveModule.pipes.push(declaredIdentifier);\n                    declaredPipes.push(declaredIdentifier);\n                    _this._addTypeToModule(declaredType, moduleType);\n                }\n                else {\n                    _this._reportError(syntaxError(\"Unexpected \" + _this._getTypeDescriptor(declaredType) + \" '\" + stringifyType(declaredType) + \"' declared by the module '\" + stringifyType(moduleType) + \"'. Please add a @Pipe/@Directive/@Component annotation.\"), moduleType);\n                    return;\n                }\n            });\n        }\n        var exportedDirectives = [];\n        var exportedPipes = [];\n        exportedNonModuleIdentifiers.forEach(function (exportedId) {\n            if (transitiveModule.directivesSet.has(exportedId.reference)) {\n                exportedDirectives.push(exportedId);\n                transitiveModule.addExportedDirective(exportedId);\n            }\n            else if (transitiveModule.pipesSet.has(exportedId.reference)) {\n                exportedPipes.push(exportedId);\n                transitiveModule.addExportedPipe(exportedId);\n            }\n            else {\n                _this._reportError(syntaxError(\"Can't export \" + _this._getTypeDescriptor(exportedId.reference) + \" \" + stringifyType(exportedId.reference) + \" from \" + stringifyType(moduleType) + \" as it was neither declared nor imported!\"), moduleType);\n                return;\n            }\n        });\n        // The providers of the module have to go last\n        // so that they overwrite any other provider we already added.\n        if (meta.providers) {\n            providers.push.apply(providers, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this._getProvidersMetadata(meta.providers, entryComponents, \"provider for the NgModule '\" + stringifyType(moduleType) + \"'\", [], moduleType)));\n        }\n        if (meta.entryComponents) {\n            entryComponents.push.apply(entryComponents, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(flattenAndDedupeArray(meta.entryComponents)\n                .map(function (type) { return _this._getEntryComponentMetadata(type); })));\n        }\n        if (meta.bootstrap) {\n            flattenAndDedupeArray(meta.bootstrap).forEach(function (type) {\n                if (!isValidType(type)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(type) + \"' used in the bootstrap property of module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                bootstrapComponents.push(_this._getIdentifierMetadata(type));\n            });\n        }\n        entryComponents.push.apply(entryComponents, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(bootstrapComponents.map(function (type) { return _this._getEntryComponentMetadata(type.reference); })));\n        if (meta.schemas) {\n            schemas.push.apply(schemas, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(flattenAndDedupeArray(meta.schemas)));\n        }\n        compileMeta = new CompileNgModuleMetadata({\n            type: this._getTypeMetadata(moduleType),\n            providers: providers,\n            entryComponents: entryComponents,\n            bootstrapComponents: bootstrapComponents,\n            schemas: schemas,\n            declaredDirectives: declaredDirectives,\n            exportedDirectives: exportedDirectives,\n            declaredPipes: declaredPipes,\n            exportedPipes: exportedPipes,\n            importedModules: importedModules,\n            exportedModules: exportedModules,\n            transitiveModule: transitiveModule,\n            id: meta.id || null,\n        });\n        entryComponents.forEach(function (id) { return transitiveModule.addEntryComponent(id); });\n        providers.forEach(function (provider) { return transitiveModule.addProvider(provider, compileMeta.type); });\n        transitiveModule.addModule(compileMeta.type);\n        this._ngModuleCache.set(moduleType, compileMeta);\n        return compileMeta;\n    };\n    CompileMetadataResolver.prototype._checkSelfImport = function (moduleType, importedModuleType) {\n        if (moduleType === importedModuleType) {\n            this._reportError(syntaxError(\"'\" + stringifyType(moduleType) + \"' module can't import itself\"), moduleType);\n            return true;\n        }\n        return false;\n    };\n    CompileMetadataResolver.prototype._getTypeDescriptor = function (type) {\n        if (isValidType(type)) {\n            if (this.isDirective(type)) {\n                return 'directive';\n            }\n            if (this.isPipe(type)) {\n                return 'pipe';\n            }\n            if (this.isNgModule(type)) {\n                return 'module';\n            }\n        }\n        if (type.provide) {\n            return 'provider';\n        }\n        return 'value';\n    };\n    CompileMetadataResolver.prototype._addTypeToModule = function (type, moduleType) {\n        var oldModule = this._ngModuleOfTypes.get(type);\n        if (oldModule && oldModule !== moduleType) {\n            this._reportError(syntaxError(\"Type \" + stringifyType(type) + \" is part of the declarations of 2 modules: \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \"! \" +\n                (\"Please consider moving \" + stringifyType(type) + \" to a higher module that imports \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \". \") +\n                (\"You can also create a new NgModule that exports and includes \" + stringifyType(type) + \" then import that NgModule in \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \".\")), moduleType);\n            return;\n        }\n        this._ngModuleOfTypes.set(type, moduleType);\n    };\n    CompileMetadataResolver.prototype._getTransitiveNgModuleMetadata = function (importedModules, exportedModules) {\n        // collect `providers` / `entryComponents` from all imported and all exported modules\n        var result = new TransitiveCompileNgModuleMetadata();\n        var modulesByToken = new Map();\n        importedModules.concat(exportedModules).forEach(function (modSummary) {\n            modSummary.modules.forEach(function (mod) { return result.addModule(mod); });\n            modSummary.entryComponents.forEach(function (comp) { return result.addEntryComponent(comp); });\n            var addedTokens = new Set();\n            modSummary.providers.forEach(function (entry) {\n                var tokenRef = tokenReference(entry.provider.token);\n                var prevModules = modulesByToken.get(tokenRef);\n                if (!prevModules) {\n                    prevModules = new Set();\n                    modulesByToken.set(tokenRef, prevModules);\n                }\n                var moduleRef = entry.module.reference;\n                // Note: the providers of one module may still contain multiple providers\n                // per token (e.g. for multi providers), and we need to preserve these.\n                if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {\n                    prevModules.add(moduleRef);\n                    addedTokens.add(tokenRef);\n                    result.addProvider(entry.provider, entry.module);\n                }\n            });\n        });\n        exportedModules.forEach(function (modSummary) {\n            modSummary.exportedDirectives.forEach(function (id) { return result.addExportedDirective(id); });\n            modSummary.exportedPipes.forEach(function (id) { return result.addExportedPipe(id); });\n        });\n        importedModules.forEach(function (modSummary) {\n            modSummary.exportedDirectives.forEach(function (id) { return result.addDirective(id); });\n            modSummary.exportedPipes.forEach(function (id) { return result.addPipe(id); });\n        });\n        return result;\n    };\n    CompileMetadataResolver.prototype._getIdentifierMetadata = function (type) {\n        type = resolveForwardRef(type);\n        return { reference: type };\n    };\n    CompileMetadataResolver.prototype.isInjectable = function (type) {\n        var annotations = this._reflector.tryAnnotations(type);\n        return annotations.some(function (ann) { return createInjectable.isTypeOf(ann); });\n    };\n    CompileMetadataResolver.prototype.getInjectableSummary = function (type) {\n        return {\n            summaryKind: CompileSummaryKind.Injectable,\n            type: this._getTypeMetadata(type, null, false)\n        };\n    };\n    CompileMetadataResolver.prototype.getInjectableMetadata = function (type, dependencies, throwOnUnknownDeps) {\n        if (dependencies === void 0) { dependencies = null; }\n        if (throwOnUnknownDeps === void 0) { throwOnUnknownDeps = true; }\n        var typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);\n        var typeMetadata = typeSummary ?\n            typeSummary.type :\n            this._getTypeMetadata(type, dependencies, throwOnUnknownDeps);\n        var annotations = this._reflector.annotations(type).filter(function (ann) { return createInjectable.isTypeOf(ann); });\n        if (annotations.length === 0) {\n            return null;\n        }\n        var meta = annotations[annotations.length - 1];\n        return {\n            symbol: type,\n            type: typeMetadata,\n            providedIn: meta.providedIn,\n            useValue: meta.useValue,\n            useClass: meta.useClass,\n            useExisting: meta.useExisting,\n            useFactory: meta.useFactory,\n            deps: meta.deps,\n        };\n    };\n    CompileMetadataResolver.prototype._getTypeMetadata = function (type, dependencies, throwOnUnknownDeps) {\n        if (dependencies === void 0) { dependencies = null; }\n        if (throwOnUnknownDeps === void 0) { throwOnUnknownDeps = true; }\n        var identifier = this._getIdentifierMetadata(type);\n        return {\n            reference: identifier.reference,\n            diDeps: this._getDependenciesMetadata(identifier.reference, dependencies, throwOnUnknownDeps),\n            lifecycleHooks: getAllLifecycleHooks(this._reflector, identifier.reference),\n        };\n    };\n    CompileMetadataResolver.prototype._getFactoryMetadata = function (factory, dependencies) {\n        if (dependencies === void 0) { dependencies = null; }\n        factory = resolveForwardRef(factory);\n        return { reference: factory, diDeps: this._getDependenciesMetadata(factory, dependencies) };\n    };\n    /**\n     * Gets the metadata for the given pipe.\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n     */\n    CompileMetadataResolver.prototype.getPipeMetadata = function (pipeType) {\n        var pipeMeta = this._pipeCache.get(pipeType);\n        if (!pipeMeta) {\n            this._reportError(syntaxError(\"Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe \" + stringifyType(pipeType) + \".\"), pipeType);\n        }\n        return pipeMeta || null;\n    };\n    CompileMetadataResolver.prototype.getPipeSummary = function (pipeType) {\n        var pipeSummary = this._loadSummary(pipeType, CompileSummaryKind.Pipe);\n        if (!pipeSummary) {\n            this._reportError(syntaxError(\"Illegal state: Could not load the summary for pipe \" + stringifyType(pipeType) + \".\"), pipeType);\n        }\n        return pipeSummary;\n    };\n    CompileMetadataResolver.prototype.getOrLoadPipeMetadata = function (pipeType) {\n        var pipeMeta = this._pipeCache.get(pipeType);\n        if (!pipeMeta) {\n            pipeMeta = this._loadPipeMetadata(pipeType);\n        }\n        return pipeMeta;\n    };\n    CompileMetadataResolver.prototype._loadPipeMetadata = function (pipeType) {\n        pipeType = resolveForwardRef(pipeType);\n        var pipeAnnotation = this._pipeResolver.resolve(pipeType);\n        var pipeMeta = new CompilePipeMetadata({\n            type: this._getTypeMetadata(pipeType),\n            name: pipeAnnotation.name,\n            pure: !!pipeAnnotation.pure\n        });\n        this._pipeCache.set(pipeType, pipeMeta);\n        this._summaryCache.set(pipeType, pipeMeta.toSummary());\n        return pipeMeta;\n    };\n    CompileMetadataResolver.prototype._getDependenciesMetadata = function (typeOrFunc, dependencies, throwOnUnknownDeps) {\n        var _this = this;\n        if (throwOnUnknownDeps === void 0) { throwOnUnknownDeps = true; }\n        var hasUnknownDeps = false;\n        var params = dependencies || this._reflector.parameters(typeOrFunc) || [];\n        var dependenciesMetadata = params.map(function (param) {\n            var isAttribute = false;\n            var isHost = false;\n            var isSelf = false;\n            var isSkipSelf = false;\n            var isOptional = false;\n            var token = null;\n            if (Array.isArray(param)) {\n                param.forEach(function (paramEntry) {\n                    if (createHost.isTypeOf(paramEntry)) {\n                        isHost = true;\n                    }\n                    else if (createSelf.isTypeOf(paramEntry)) {\n                        isSelf = true;\n                    }\n                    else if (createSkipSelf.isTypeOf(paramEntry)) {\n                        isSkipSelf = true;\n                    }\n                    else if (createOptional.isTypeOf(paramEntry)) {\n                        isOptional = true;\n                    }\n                    else if (createAttribute.isTypeOf(paramEntry)) {\n                        isAttribute = true;\n                        token = paramEntry.attributeName;\n                    }\n                    else if (createInject.isTypeOf(paramEntry)) {\n                        token = paramEntry.token;\n                    }\n                    else if (createInjectionToken.isTypeOf(paramEntry) ||\n                        paramEntry instanceof StaticSymbol) {\n                        token = paramEntry;\n                    }\n                    else if (isValidType(paramEntry) && token == null) {\n                        token = paramEntry;\n                    }\n                });\n            }\n            else {\n                token = param;\n            }\n            if (token == null) {\n                hasUnknownDeps = true;\n                return {};\n            }\n            return {\n                isAttribute: isAttribute,\n                isHost: isHost,\n                isSelf: isSelf,\n                isSkipSelf: isSkipSelf,\n                isOptional: isOptional,\n                token: _this._getTokenMetadata(token)\n            };\n        });\n        if (hasUnknownDeps) {\n            var depsTokens = dependenciesMetadata.map(function (dep) { return dep.token ? stringifyType(dep.token) : '?'; }).join(', ');\n            var message = \"Can't resolve all parameters for \" + stringifyType(typeOrFunc) + \": (\" + depsTokens + \").\";\n            if (throwOnUnknownDeps || this._config.strictInjectionParameters) {\n                this._reportError(syntaxError(message), typeOrFunc);\n            }\n            else {\n                this._console.warn(\"Warning: \" + message + \" This will become an error in Angular v6.x\");\n            }\n        }\n        return dependenciesMetadata;\n    };\n    CompileMetadataResolver.prototype._getTokenMetadata = function (token) {\n        token = resolveForwardRef(token);\n        var compileToken;\n        if (typeof token === 'string') {\n            compileToken = { value: token };\n        }\n        else {\n            compileToken = { identifier: { reference: token } };\n        }\n        return compileToken;\n    };\n    CompileMetadataResolver.prototype._getProvidersMetadata = function (providers, targetEntryComponents, debugInfo, compileProviders, type) {\n        var _this = this;\n        if (compileProviders === void 0) { compileProviders = []; }\n        providers.forEach(function (provider, providerIdx) {\n            if (Array.isArray(provider)) {\n                _this._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);\n            }\n            else {\n                provider = resolveForwardRef(provider);\n                var providerMeta = undefined;\n                if (provider && typeof provider === 'object' && provider.hasOwnProperty('provide')) {\n                    _this._validateProvider(provider);\n                    providerMeta = new ProviderMeta(provider.provide, provider);\n                }\n                else if (isValidType(provider)) {\n                    providerMeta = new ProviderMeta(provider, { useClass: provider });\n                }\n                else if (provider === void 0) {\n                    _this._reportError(syntaxError(\"Encountered undefined provider! Usually this means you have a circular dependencies. This might be caused by using 'barrel' index.ts files.\"));\n                    return;\n                }\n                else {\n                    var providersInfo = providers.reduce(function (soFar, seenProvider, seenProviderIdx) {\n                        if (seenProviderIdx < providerIdx) {\n                            soFar.push(\"\" + stringifyType(seenProvider));\n                        }\n                        else if (seenProviderIdx == providerIdx) {\n                            soFar.push(\"?\" + stringifyType(seenProvider) + \"?\");\n                        }\n                        else if (seenProviderIdx == providerIdx + 1) {\n                            soFar.push('...');\n                        }\n                        return soFar;\n                    }, [])\n                        .join(', ');\n                    _this._reportError(syntaxError(\"Invalid \" + (debugInfo ? debugInfo : 'provider') + \" - only instances of Provider and Type are allowed, got: [\" + providersInfo + \"]\"), type);\n                    return;\n                }\n                if (providerMeta.token ===\n                    _this._reflector.resolveExternalReference(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS)) {\n                    targetEntryComponents.push.apply(targetEntryComponents, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(_this._getEntryComponentsFromProvider(providerMeta, type)));\n                }\n                else {\n                    compileProviders.push(_this.getProviderMetadata(providerMeta));\n                }\n            }\n        });\n        return compileProviders;\n    };\n    CompileMetadataResolver.prototype._validateProvider = function (provider) {\n        if (provider.hasOwnProperty('useClass') && provider.useClass == null) {\n            this._reportError(syntaxError(\"Invalid provider for \" + stringifyType(provider.provide) + \". useClass cannot be \" + provider.useClass + \".\\n           Usually it happens when:\\n           1. There's a circular dependency (might be caused by using index.ts (barrel) files).\\n           2. Class was used before it was declared. Use forwardRef in this case.\"));\n        }\n    };\n    CompileMetadataResolver.prototype._getEntryComponentsFromProvider = function (provider, type) {\n        var _this = this;\n        var components = [];\n        var collectedIdentifiers = [];\n        if (provider.useFactory || provider.useExisting || provider.useClass) {\n            this._reportError(syntaxError(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!\"), type);\n            return [];\n        }\n        if (!provider.multi) {\n            this._reportError(syntaxError(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!\"), type);\n            return [];\n        }\n        extractIdentifiers(provider.useValue, collectedIdentifiers);\n        collectedIdentifiers.forEach(function (identifier) {\n            var entry = _this._getEntryComponentMetadata(identifier.reference, false);\n            if (entry) {\n                components.push(entry);\n            }\n        });\n        return components;\n    };\n    CompileMetadataResolver.prototype._getEntryComponentMetadata = function (dirType, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var dirMeta = this.getNonNormalizedDirectiveMetadata(dirType);\n        if (dirMeta && dirMeta.metadata.isComponent) {\n            return { componentType: dirType, componentFactory: dirMeta.metadata.componentFactory };\n        }\n        var dirSummary = this._loadSummary(dirType, CompileSummaryKind.Directive);\n        if (dirSummary && dirSummary.isComponent) {\n            return { componentType: dirType, componentFactory: dirSummary.componentFactory };\n        }\n        if (throwIfNotFound) {\n            throw syntaxError(dirType.name + \" cannot be used as an entry component.\");\n        }\n        return null;\n    };\n    CompileMetadataResolver.prototype._getInjectableTypeMetadata = function (type, dependencies) {\n        if (dependencies === void 0) { dependencies = null; }\n        var typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);\n        if (typeSummary) {\n            return typeSummary.type;\n        }\n        return this._getTypeMetadata(type, dependencies);\n    };\n    CompileMetadataResolver.prototype.getProviderMetadata = function (provider) {\n        var compileDeps = undefined;\n        var compileTypeMetadata = null;\n        var compileFactoryMetadata = null;\n        var token = this._getTokenMetadata(provider.token);\n        if (provider.useClass) {\n            compileTypeMetadata =\n                this._getInjectableTypeMetadata(provider.useClass, provider.dependencies);\n            compileDeps = compileTypeMetadata.diDeps;\n            if (provider.token === provider.useClass) {\n                // use the compileTypeMetadata as it contains information about lifecycleHooks...\n                token = { identifier: compileTypeMetadata };\n            }\n        }\n        else if (provider.useFactory) {\n            compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);\n            compileDeps = compileFactoryMetadata.diDeps;\n        }\n        return {\n            token: token,\n            useClass: compileTypeMetadata,\n            useValue: provider.useValue,\n            useFactory: compileFactoryMetadata,\n            useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : undefined,\n            deps: compileDeps,\n            multi: provider.multi\n        };\n    };\n    CompileMetadataResolver.prototype._getQueriesMetadata = function (queries, isViewQuery, directiveType) {\n        var _this = this;\n        var res = [];\n        Object.keys(queries).forEach(function (propertyName) {\n            var query = queries[propertyName];\n            if (query.isViewQuery === isViewQuery) {\n                res.push(_this._getQueryMetadata(query, propertyName, directiveType));\n            }\n        });\n        return res;\n    };\n    CompileMetadataResolver.prototype._queryVarBindings = function (selector) { return selector.split(/\\s*,\\s*/); };\n    CompileMetadataResolver.prototype._getQueryMetadata = function (q, propertyName, typeOrFunc) {\n        var _this = this;\n        var selectors;\n        if (typeof q.selector === 'string') {\n            selectors =\n                this._queryVarBindings(q.selector).map(function (varName) { return _this._getTokenMetadata(varName); });\n        }\n        else {\n            if (!q.selector) {\n                this._reportError(syntaxError(\"Can't construct a query for the property \\\"\" + propertyName + \"\\\" of \\\"\" + stringifyType(typeOrFunc) + \"\\\" since the query selector wasn't defined.\"), typeOrFunc);\n                selectors = [];\n            }\n            else {\n                selectors = [this._getTokenMetadata(q.selector)];\n            }\n        }\n        return {\n            selectors: selectors,\n            first: q.first,\n            descendants: q.descendants, propertyName: propertyName,\n            read: q.read ? this._getTokenMetadata(q.read) : null,\n            static: q.static\n        };\n    };\n    CompileMetadataResolver.prototype._reportError = function (error, type, otherType) {\n        if (this._errorCollector) {\n            this._errorCollector(error, type);\n            if (otherType) {\n                this._errorCollector(error, otherType);\n            }\n        }\n        else {\n            throw error;\n        }\n    };\n    return CompileMetadataResolver;\n}());\nfunction flattenArray(tree, out) {\n    if (out === void 0) { out = []; }\n    if (tree) {\n        for (var i = 0; i < tree.length; i++) {\n            var item = resolveForwardRef(tree[i]);\n            if (Array.isArray(item)) {\n                flattenArray(item, out);\n            }\n            else {\n                out.push(item);\n            }\n        }\n    }\n    return out;\n}\nfunction dedupeArray(array) {\n    if (array) {\n        return Array.from(new Set(array));\n    }\n    return [];\n}\nfunction flattenAndDedupeArray(tree) {\n    return dedupeArray(flattenArray(tree));\n}\nfunction isValidType(value) {\n    return (value instanceof StaticSymbol) || (value instanceof Type);\n}\nfunction extractIdentifiers(value, targetIdentifiers) {\n    visitValue(value, new _CompileValueConverter(), targetIdentifiers);\n}\nvar _CompileValueConverter = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(_CompileValueConverter, _super);\n    function _CompileValueConverter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    _CompileValueConverter.prototype.visitOther = function (value, targetIdentifiers) {\n        targetIdentifiers.push({ reference: value });\n    };\n    return _CompileValueConverter;\n}(ValueTransformer));\nfunction stringifyType(type) {\n    if (type instanceof StaticSymbol) {\n        return type.name + \" in \" + type.filePath;\n    }\n    else {\n        return stringify(type);\n    }\n}\n/**\n * Indicates that a component is still being loaded in a synchronous compile.\n */\nfunction componentStillLoadingError(compType) {\n    var error = Error(\"Can't compile synchronously as \" + stringify(compType) + \" is still being loaded!\");\n    error[ERROR_COMPONENT_TYPE] = compType;\n    return error;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction providerDef(ctx, providerAst) {\n    var flags = 0 /* None */;\n    if (!providerAst.eager) {\n        flags |= 4096 /* LazyProvider */;\n    }\n    if (providerAst.providerType === ProviderAstType.PrivateService) {\n        flags |= 8192 /* PrivateProvider */;\n    }\n    if (providerAst.isModule) {\n        flags |= 1073741824 /* TypeModuleProvider */;\n    }\n    providerAst.lifecycleHooks.forEach(function (lifecycleHook) {\n        // for regular providers, we only support ngOnDestroy\n        if (lifecycleHook === LifecycleHooks.OnDestroy ||\n            providerAst.providerType === ProviderAstType.Directive ||\n            providerAst.providerType === ProviderAstType.Component) {\n            flags |= lifecycleHookToNodeFlag(lifecycleHook);\n        }\n    });\n    var _a = providerAst.multiProvider ?\n        multiProviderDef(ctx, flags, providerAst.providers) :\n        singleProviderDef(ctx, flags, providerAst.providerType, providerAst.providers[0]), providerExpr = _a.providerExpr, providerFlags = _a.flags, depsExpr = _a.depsExpr;\n    return {\n        providerExpr: providerExpr,\n        flags: providerFlags, depsExpr: depsExpr,\n        tokenExpr: tokenExpr(ctx, providerAst.token),\n    };\n}\nfunction multiProviderDef(ctx, flags, providers) {\n    var allDepDefs = [];\n    var allParams = [];\n    var exprs = providers.map(function (provider, providerIndex) {\n        var expr;\n        if (provider.useClass) {\n            var depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);\n            expr = ctx.importExpr(provider.useClass.reference).instantiate(depExprs);\n        }\n        else if (provider.useFactory) {\n            var depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);\n            expr = ctx.importExpr(provider.useFactory.reference).callFn(depExprs);\n        }\n        else if (provider.useExisting) {\n            var depExprs = convertDeps(providerIndex, [{ token: provider.useExisting }]);\n            expr = depExprs[0];\n        }\n        else {\n            expr = convertValueToOutputAst(ctx, provider.useValue);\n        }\n        return expr;\n    });\n    var providerExpr = fn(allParams, [new ReturnStatement(literalArr(exprs))], INFERRED_TYPE);\n    return {\n        providerExpr: providerExpr,\n        flags: flags | 1024 /* TypeFactoryProvider */,\n        depsExpr: literalArr(allDepDefs)\n    };\n    function convertDeps(providerIndex, deps) {\n        return deps.map(function (dep, depIndex) {\n            var paramName = \"p\" + providerIndex + \"_\" + depIndex;\n            allParams.push(new FnParam(paramName, DYNAMIC_TYPE));\n            allDepDefs.push(depDef(ctx, dep));\n            return variable(paramName);\n        });\n    }\n}\nfunction singleProviderDef(ctx, flags, providerType, providerMeta) {\n    var providerExpr;\n    var deps;\n    if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {\n        providerExpr = ctx.importExpr(providerMeta.useClass.reference);\n        flags |= 16384 /* TypeDirective */;\n        deps = providerMeta.deps || providerMeta.useClass.diDeps;\n    }\n    else {\n        if (providerMeta.useClass) {\n            providerExpr = ctx.importExpr(providerMeta.useClass.reference);\n            flags |= 512 /* TypeClassProvider */;\n            deps = providerMeta.deps || providerMeta.useClass.diDeps;\n        }\n        else if (providerMeta.useFactory) {\n            providerExpr = ctx.importExpr(providerMeta.useFactory.reference);\n            flags |= 1024 /* TypeFactoryProvider */;\n            deps = providerMeta.deps || providerMeta.useFactory.diDeps;\n        }\n        else if (providerMeta.useExisting) {\n            providerExpr = NULL_EXPR;\n            flags |= 2048 /* TypeUseExistingProvider */;\n            deps = [{ token: providerMeta.useExisting }];\n        }\n        else {\n            providerExpr = convertValueToOutputAst(ctx, providerMeta.useValue);\n            flags |= 256 /* TypeValueProvider */;\n            deps = [];\n        }\n    }\n    var depsExpr = literalArr(deps.map(function (dep) { return depDef(ctx, dep); }));\n    return { providerExpr: providerExpr, flags: flags, depsExpr: depsExpr };\n}\nfunction tokenExpr(ctx, tokenMeta) {\n    return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) :\n        literal(tokenMeta.value);\n}\nfunction depDef(ctx, dep) {\n    // Note: the following fields have already been normalized out by provider_analyzer:\n    // - isAttribute, isHost\n    var expr = dep.isValue ? convertValueToOutputAst(ctx, dep.value) : tokenExpr(ctx, dep.token);\n    var flags = 0 /* None */;\n    if (dep.isSkipSelf) {\n        flags |= 1 /* SkipSelf */;\n    }\n    if (dep.isOptional) {\n        flags |= 2 /* Optional */;\n    }\n    if (dep.isSelf) {\n        flags |= 4 /* Self */;\n    }\n    if (dep.isValue) {\n        flags |= 8 /* Value */;\n    }\n    return flags === 0 /* None */ ? expr : literalArr([literal(flags), expr]);\n}\nfunction lifecycleHookToNodeFlag(lifecycleHook) {\n    var nodeFlag = 0 /* None */;\n    switch (lifecycleHook) {\n        case LifecycleHooks.AfterContentChecked:\n            nodeFlag = 2097152 /* AfterContentChecked */;\n            break;\n        case LifecycleHooks.AfterContentInit:\n            nodeFlag = 1048576 /* AfterContentInit */;\n            break;\n        case LifecycleHooks.AfterViewChecked:\n            nodeFlag = 8388608 /* AfterViewChecked */;\n            break;\n        case LifecycleHooks.AfterViewInit:\n            nodeFlag = 4194304 /* AfterViewInit */;\n            break;\n        case LifecycleHooks.DoCheck:\n            nodeFlag = 262144 /* DoCheck */;\n            break;\n        case LifecycleHooks.OnChanges:\n            nodeFlag = 524288 /* OnChanges */;\n            break;\n        case LifecycleHooks.OnDestroy:\n            nodeFlag = 131072 /* OnDestroy */;\n            break;\n        case LifecycleHooks.OnInit:\n            nodeFlag = 65536 /* OnInit */;\n            break;\n    }\n    return nodeFlag;\n}\nfunction componentFactoryResolverProviderDef(reflector, ctx, flags, entryComponents) {\n    var entryComponentFactories = entryComponents.map(function (entryComponent) { return ctx.importExpr(entryComponent.componentFactory); });\n    var token = createTokenForExternalReference(reflector, Identifiers.ComponentFactoryResolver);\n    var classMeta = {\n        diDeps: [\n            { isValue: true, value: literalArr(entryComponentFactories) },\n            { token: token, isSkipSelf: true, isOptional: true },\n            { token: createTokenForExternalReference(reflector, Identifiers.NgModuleRef) },\n        ],\n        lifecycleHooks: [],\n        reference: reflector.resolveExternalReference(Identifiers.CodegenComponentFactoryResolver)\n    };\n    var _a = singleProviderDef(ctx, flags, ProviderAstType.PrivateService, {\n        token: token,\n        multi: false,\n        useClass: classMeta,\n    }), providerExpr = _a.providerExpr, providerFlags = _a.flags, depsExpr = _a.depsExpr;\n    return { providerExpr: providerExpr, flags: providerFlags, depsExpr: depsExpr, tokenExpr: tokenExpr(ctx, token) };\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar NgModuleCompileResult = /** @class */ (function () {\n    function NgModuleCompileResult(ngModuleFactoryVar) {\n        this.ngModuleFactoryVar = ngModuleFactoryVar;\n    }\n    return NgModuleCompileResult;\n}());\nvar LOG_VAR = variable('_l');\nvar NgModuleCompiler = /** @class */ (function () {\n    function NgModuleCompiler(reflector) {\n        this.reflector = reflector;\n    }\n    NgModuleCompiler.prototype.compile = function (ctx, ngModuleMeta, extraProviders) {\n        var sourceSpan = typeSourceSpan('NgModule', ngModuleMeta.type);\n        var entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents;\n        var bootstrapComponents = ngModuleMeta.bootstrapComponents;\n        var providerParser = new NgModuleProviderAnalyzer(this.reflector, ngModuleMeta, extraProviders, sourceSpan);\n        var providerDefs = [componentFactoryResolverProviderDef(this.reflector, ctx, 0 /* None */, entryComponentFactories)]\n            .concat(providerParser.parse().map(function (provider) { return providerDef(ctx, provider); }))\n            .map(function (_a) {\n            var providerExpr = _a.providerExpr, depsExpr = _a.depsExpr, flags = _a.flags, tokenExpr = _a.tokenExpr;\n            return importExpr(Identifiers.moduleProviderDef).callFn([\n                literal(flags), tokenExpr, providerExpr, depsExpr\n            ]);\n        });\n        var ngModuleDef = importExpr(Identifiers.moduleDef).callFn([literalArr(providerDefs)]);\n        var ngModuleDefFactory = fn([new FnParam(LOG_VAR.name)], [new ReturnStatement(ngModuleDef)], INFERRED_TYPE);\n        var ngModuleFactoryVar = identifierName(ngModuleMeta.type) + \"NgFactory\";\n        this._createNgModuleFactory(ctx, ngModuleMeta.type.reference, importExpr(Identifiers.createModuleFactory).callFn([\n            ctx.importExpr(ngModuleMeta.type.reference),\n            literalArr(bootstrapComponents.map(function (id) { return ctx.importExpr(id.reference); })),\n            ngModuleDefFactory\n        ]));\n        if (ngModuleMeta.id) {\n            var id = typeof ngModuleMeta.id === 'string' ? literal(ngModuleMeta.id) :\n                ctx.importExpr(ngModuleMeta.id);\n            var registerFactoryStmt = importExpr(Identifiers.RegisterModuleFactoryFn)\n                .callFn([id, variable(ngModuleFactoryVar)])\n                .toStmt();\n            ctx.statements.push(registerFactoryStmt);\n        }\n        return new NgModuleCompileResult(ngModuleFactoryVar);\n    };\n    NgModuleCompiler.prototype.createStub = function (ctx, ngModuleReference) {\n        this._createNgModuleFactory(ctx, ngModuleReference, NULL_EXPR);\n    };\n    NgModuleCompiler.prototype._createNgModuleFactory = function (ctx, reference, value) {\n        var ngModuleFactoryVar = identifierName({ reference: reference }) + \"NgFactory\";\n        var ngModuleFactoryStmt = variable(ngModuleFactoryVar)\n            .set(value)\n            .toDeclStmt(importType(Identifiers.NgModuleFactory, [expressionType(ctx.importExpr(reference))], [TypeModifier.Const]), [StmtModifier.Final, StmtModifier.Exported]);\n        ctx.statements.push(ngModuleFactoryStmt);\n    };\n    return NgModuleCompiler;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Resolves types to {@link NgModule}.\n */\nvar NgModuleResolver = /** @class */ (function () {\n    function NgModuleResolver(_reflector) {\n        this._reflector = _reflector;\n    }\n    NgModuleResolver.prototype.isNgModule = function (type) { return this._reflector.annotations(type).some(createNgModule.isTypeOf); };\n    NgModuleResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var ngModuleMeta = findLast(this._reflector.annotations(type), createNgModule.isTypeOf);\n        if (ngModuleMeta) {\n            return ngModuleMeta;\n        }\n        else {\n            if (throwIfNotFound) {\n                throw new Error(\"No NgModule metadata found for '\" + stringify(type) + \"'.\");\n            }\n            return null;\n        }\n    };\n    return NgModuleResolver;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _debugFilePath = '/debug/lib';\nfunction debugOutputAstAsTypeScript(ast) {\n    var converter = new _TsEmitterVisitor();\n    var ctx = EmitterVisitorContext.createRoot();\n    var asts = Array.isArray(ast) ? ast : [ast];\n    asts.forEach(function (ast) {\n        if (ast instanceof Statement) {\n            ast.visitStatement(converter, ctx);\n        }\n        else if (ast instanceof Expression) {\n            ast.visitExpression(converter, ctx);\n        }\n        else if (ast instanceof Type$1) {\n            ast.visitType(converter, ctx);\n        }\n        else {\n            throw new Error(\"Don't know how to print debug info for \" + ast);\n        }\n    });\n    return ctx.toSource();\n}\nvar TypeScriptEmitter = /** @class */ (function () {\n    function TypeScriptEmitter() {\n    }\n    TypeScriptEmitter.prototype.emitStatementsAndContext = function (genFilePath, stmts, preamble, emitSourceMaps, referenceFilter, importFilter) {\n        if (preamble === void 0) { preamble = ''; }\n        if (emitSourceMaps === void 0) { emitSourceMaps = true; }\n        var converter = new _TsEmitterVisitor(referenceFilter, importFilter);\n        var ctx = EmitterVisitorContext.createRoot();\n        converter.visitAllStatements(stmts, ctx);\n        var preambleLines = preamble ? preamble.split('\\n') : [];\n        converter.reexports.forEach(function (reexports, exportedModuleName) {\n            var reexportsCode = reexports.map(function (reexport) { return reexport.name + \" as \" + reexport.as; }).join(',');\n            preambleLines.push(\"export {\" + reexportsCode + \"} from '\" + exportedModuleName + \"';\");\n        });\n        converter.importsWithPrefixes.forEach(function (prefix, importedModuleName) {\n            // Note: can't write the real word for import as it screws up system.js auto detection...\n            preambleLines.push(\"imp\" +\n                (\"ort * as \" + prefix + \" from '\" + importedModuleName + \"';\"));\n        });\n        var sm = emitSourceMaps ?\n            ctx.toSourceMapGenerator(genFilePath, preambleLines.length).toJsComment() :\n            '';\n        var lines = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(preambleLines, [ctx.toSource(), sm]);\n        if (sm) {\n            // always add a newline at the end, as some tools have bugs without it.\n            lines.push('');\n        }\n        ctx.setPreambleLineCount(preambleLines.length);\n        return { sourceText: lines.join('\\n'), context: ctx };\n    };\n    TypeScriptEmitter.prototype.emitStatements = function (genFilePath, stmts, preamble) {\n        if (preamble === void 0) { preamble = ''; }\n        return this.emitStatementsAndContext(genFilePath, stmts, preamble).sourceText;\n    };\n    return TypeScriptEmitter;\n}());\nvar _TsEmitterVisitor = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(_TsEmitterVisitor, _super);\n    function _TsEmitterVisitor(referenceFilter, importFilter) {\n        var _this = _super.call(this, false) || this;\n        _this.referenceFilter = referenceFilter;\n        _this.importFilter = importFilter;\n        _this.typeExpression = 0;\n        _this.importsWithPrefixes = new Map();\n        _this.reexports = new Map();\n        return _this;\n    }\n    _TsEmitterVisitor.prototype.visitType = function (t, ctx, defaultType) {\n        if (defaultType === void 0) { defaultType = 'any'; }\n        if (t) {\n            this.typeExpression++;\n            t.visitType(this, ctx);\n            this.typeExpression--;\n        }\n        else {\n            ctx.print(null, defaultType);\n        }\n    };\n    _TsEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {\n        var value = ast.value;\n        if (value == null && ast.type != INFERRED_TYPE) {\n            ctx.print(ast, \"(\" + value + \" as any)\");\n            return null;\n        }\n        return _super.prototype.visitLiteralExpr.call(this, ast, ctx);\n    };\n    // Temporary workaround to support strictNullCheck enabled consumers of ngc emit.\n    // In SNC mode, [] have the type never[], so we cast here to any[].\n    // TODO: narrow the cast to a more explicit type, or use a pattern that does not\n    // start with [].concat. see https://github.com/angular/angular/pull/11846\n    _TsEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        if (ast.entries.length === 0) {\n            ctx.print(ast, '(');\n        }\n        var result = _super.prototype.visitLiteralArrayExpr.call(this, ast, ctx);\n        if (ast.entries.length === 0) {\n            ctx.print(ast, ' as any[])');\n        }\n        return result;\n    };\n    _TsEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {\n        this._visitIdentifier(ast.value, ast.typeParams, ctx);\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitAssertNotNullExpr = function (ast, ctx) {\n        var result = _super.prototype.visitAssertNotNullExpr.call(this, ast, ctx);\n        ctx.print(ast, '!');\n        return result;\n    };\n    _TsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported) && stmt.value instanceof ExternalExpr &&\n            !stmt.type) {\n            // check for a reexport\n            var _a = stmt.value.value, name_1 = _a.name, moduleName = _a.moduleName;\n            if (moduleName) {\n                var reexports = this.reexports.get(moduleName);\n                if (!reexports) {\n                    reexports = [];\n                    this.reexports.set(moduleName, reexports);\n                }\n                reexports.push({ name: name_1, as: stmt.name });\n                return null;\n            }\n        }\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.print(stmt, \"export \");\n        }\n        if (stmt.hasModifier(StmtModifier.Final)) {\n            ctx.print(stmt, \"const\");\n        }\n        else {\n            ctx.print(stmt, \"var\");\n        }\n        ctx.print(stmt, \" \" + stmt.name);\n        this._printColonType(stmt.type, ctx);\n        if (stmt.value) {\n            ctx.print(stmt, \" = \");\n            stmt.value.visitExpression(this, ctx);\n        }\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitWrappedNodeExpr = function (ast, ctx) {\n        throw new Error('Cannot visit a WrappedNodeExpr when outputting Typescript.');\n    };\n    _TsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {\n        ctx.print(ast, \"(<\");\n        ast.type.visitType(this, ctx);\n        ctx.print(ast, \">\");\n        ast.value.visitExpression(this, ctx);\n        ctx.print(ast, \")\");\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {\n        ctx.print(ast, \"new \");\n        this.typeExpression++;\n        ast.classExpr.visitExpression(this, ctx);\n        this.typeExpression--;\n        ctx.print(ast, \"(\");\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, \")\");\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var _this = this;\n        ctx.pushClass(stmt);\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.print(stmt, \"export \");\n        }\n        ctx.print(stmt, \"class \" + stmt.name);\n        if (stmt.parent != null) {\n            ctx.print(stmt, \" extends \");\n            this.typeExpression++;\n            stmt.parent.visitExpression(this, ctx);\n            this.typeExpression--;\n        }\n        ctx.println(stmt, \" {\");\n        ctx.incIndent();\n        stmt.fields.forEach(function (field) { return _this._visitClassField(field, ctx); });\n        if (stmt.constructorMethod != null) {\n            this._visitClassConstructor(stmt, ctx);\n        }\n        stmt.getters.forEach(function (getter) { return _this._visitClassGetter(getter, ctx); });\n        stmt.methods.forEach(function (method) { return _this._visitClassMethod(method, ctx); });\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        ctx.popClass();\n        return null;\n    };\n    _TsEmitterVisitor.prototype._visitClassField = function (field, ctx) {\n        if (field.hasModifier(StmtModifier.Private)) {\n            // comment out as a workaround for #10967\n            ctx.print(null, \"/*private*/ \");\n        }\n        if (field.hasModifier(StmtModifier.Static)) {\n            ctx.print(null, 'static ');\n        }\n        ctx.print(null, field.name);\n        this._printColonType(field.type, ctx);\n        if (field.initializer) {\n            ctx.print(null, ' = ');\n            field.initializer.visitExpression(this, ctx);\n        }\n        ctx.println(null, \";\");\n    };\n    _TsEmitterVisitor.prototype._visitClassGetter = function (getter, ctx) {\n        if (getter.hasModifier(StmtModifier.Private)) {\n            ctx.print(null, \"private \");\n        }\n        ctx.print(null, \"get \" + getter.name + \"()\");\n        this._printColonType(getter.type, ctx);\n        ctx.println(null, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(getter.body, ctx);\n        ctx.decIndent();\n        ctx.println(null, \"}\");\n    };\n    _TsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {\n        ctx.print(stmt, \"constructor(\");\n        this._visitParams(stmt.constructorMethod.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.constructorMethod.body, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n    };\n    _TsEmitterVisitor.prototype._visitClassMethod = function (method, ctx) {\n        if (method.hasModifier(StmtModifier.Private)) {\n            ctx.print(null, \"private \");\n        }\n        ctx.print(null, method.name + \"(\");\n        this._visitParams(method.params, ctx);\n        ctx.print(null, \")\");\n        this._printColonType(method.type, ctx, 'void');\n        ctx.println(null, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(method.body, ctx);\n        ctx.decIndent();\n        ctx.println(null, \"}\");\n    };\n    _TsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {\n        if (ast.name) {\n            ctx.print(ast, 'function ');\n            ctx.print(ast, ast.name);\n        }\n        ctx.print(ast, \"(\");\n        this._visitParams(ast.params, ctx);\n        ctx.print(ast, \")\");\n        this._printColonType(ast.type, ctx, 'void');\n        if (!ast.name) {\n            ctx.print(ast, \" => \");\n        }\n        ctx.println(ast, '{');\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, \"}\");\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.print(stmt, \"export \");\n        }\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        this._visitParams(stmt.params, ctx);\n        ctx.print(stmt, \")\");\n        this._printColonType(stmt.type, ctx, 'void');\n        ctx.println(stmt, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        ctx.println(stmt, \"try {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.bodyStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"} catch (\" + CATCH_ERROR_VAR$1.name + \") {\");\n        ctx.incIndent();\n        var catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack', null)).toDeclStmt(null, [\n                StmtModifier.Final\n            ])].concat(stmt.catchStmts);\n        this.visitAllStatements(catchStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitBuiltinType = function (type, ctx) {\n        var typeStr;\n        switch (type.name) {\n            case BuiltinTypeName.Bool:\n                typeStr = 'boolean';\n                break;\n            case BuiltinTypeName.Dynamic:\n                typeStr = 'any';\n                break;\n            case BuiltinTypeName.Function:\n                typeStr = 'Function';\n                break;\n            case BuiltinTypeName.Number:\n                typeStr = 'number';\n                break;\n            case BuiltinTypeName.Int:\n                typeStr = 'number';\n                break;\n            case BuiltinTypeName.String:\n                typeStr = 'string';\n                break;\n            case BuiltinTypeName.None:\n                typeStr = 'never';\n                break;\n            default:\n                throw new Error(\"Unsupported builtin type \" + type.name);\n        }\n        ctx.print(null, typeStr);\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitExpressionType = function (ast, ctx) {\n        var _this = this;\n        ast.value.visitExpression(this, ctx);\n        if (ast.typeParams !== null) {\n            ctx.print(null, '<');\n            this.visitAllObjects(function (type) { return _this.visitType(type, ctx); }, ast.typeParams, ctx, ',');\n            ctx.print(null, '>');\n        }\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitArrayType = function (type, ctx) {\n        this.visitType(type.of, ctx);\n        ctx.print(null, \"[]\");\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitMapType = function (type, ctx) {\n        ctx.print(null, \"{[key: string]:\");\n        this.visitType(type.valueType, ctx);\n        ctx.print(null, \"}\");\n        return null;\n    };\n    _TsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {\n        var name;\n        switch (method) {\n            case BuiltinMethod.ConcatArray:\n                name = 'concat';\n                break;\n            case BuiltinMethod.SubscribeObservable:\n                name = 'subscribe';\n                break;\n            case BuiltinMethod.Bind:\n                name = 'bind';\n                break;\n            default:\n                throw new Error(\"Unknown builtin method: \" + method);\n        }\n        return name;\n    };\n    _TsEmitterVisitor.prototype._visitParams = function (params, ctx) {\n        var _this = this;\n        this.visitAllObjects(function (param) {\n            ctx.print(null, param.name);\n            _this._printColonType(param.type, ctx);\n        }, params, ctx, ',');\n    };\n    _TsEmitterVisitor.prototype._visitIdentifier = function (value, typeParams, ctx) {\n        var _this = this;\n        var name = value.name, moduleName = value.moduleName;\n        if (this.referenceFilter && this.referenceFilter(value)) {\n            ctx.print(null, '(null as any)');\n            return;\n        }\n        if (moduleName && (!this.importFilter || !this.importFilter(value))) {\n            var prefix = this.importsWithPrefixes.get(moduleName);\n            if (prefix == null) {\n                prefix = \"i\" + this.importsWithPrefixes.size;\n                this.importsWithPrefixes.set(moduleName, prefix);\n            }\n            ctx.print(null, prefix + \".\");\n        }\n        ctx.print(null, name);\n        if (this.typeExpression > 0) {\n            // If we are in a type expression that refers to a generic type then supply\n            // the required type parameters. If there were not enough type parameters\n            // supplied, supply any as the type. Outside a type expression the reference\n            // should not supply type parameters and be treated as a simple value reference\n            // to the constructor function itself.\n            var suppliedParameters = typeParams || [];\n            if (suppliedParameters.length > 0) {\n                ctx.print(null, \"<\");\n                this.visitAllObjects(function (type) { return type.visitType(_this, ctx); }, typeParams, ctx, ',');\n                ctx.print(null, \">\");\n            }\n        }\n    };\n    _TsEmitterVisitor.prototype._printColonType = function (type, ctx, defaultType) {\n        if (type !== INFERRED_TYPE) {\n            ctx.print(null, ':');\n            this.visitType(type, ctx, defaultType);\n        }\n    };\n    return _TsEmitterVisitor;\n}(AbstractEmitterVisitor));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Resolve a `Type` for {@link Pipe}.\n *\n * This interface can be overridden by the application developer to create custom behavior.\n *\n * See {@link Compiler}\n */\nvar PipeResolver = /** @class */ (function () {\n    function PipeResolver(_reflector) {\n        this._reflector = _reflector;\n    }\n    PipeResolver.prototype.isPipe = function (type) {\n        var typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n        return typeMetadata && typeMetadata.some(createPipe.isTypeOf);\n    };\n    /**\n     * Return {@link Pipe} for a given `Type`.\n     */\n    PipeResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var metas = this._reflector.annotations(resolveForwardRef(type));\n        if (metas) {\n            var annotation = findLast(metas, createPipe.isTypeOf);\n            if (annotation) {\n                return annotation;\n            }\n        }\n        if (throwIfNotFound) {\n            throw new Error(\"No Pipe decorator found on \" + stringify(type));\n        }\n        return null;\n    };\n    return PipeResolver;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generates code that is used to type check templates.\n */\nvar TypeCheckCompiler = /** @class */ (function () {\n    function TypeCheckCompiler(options, reflector) {\n        this.options = options;\n        this.reflector = reflector;\n    }\n    /**\n     * Important notes:\n     * - This must not produce new `import` statements, but only refer to types outside\n     *   of the file via the variables provided via externalReferenceVars.\n     *   This allows Typescript to reuse the old program's structure as no imports have changed.\n     * - This must not produce any exports, as this would pollute the .d.ts file\n     *   and also violate the point above.\n     */\n    TypeCheckCompiler.prototype.compileComponent = function (componentId, component, template, usedPipes, externalReferenceVars, ctx) {\n        var _this = this;\n        var pipes = new Map();\n        usedPipes.forEach(function (p) { return pipes.set(p.name, p.type.reference); });\n        var embeddedViewCount = 0;\n        var viewBuilderFactory = function (parent, guards) {\n            var embeddedViewIndex = embeddedViewCount++;\n            return new ViewBuilder(_this.options, _this.reflector, externalReferenceVars, parent, component.type.reference, component.isHost, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory);\n        };\n        var visitor = viewBuilderFactory(null, []);\n        visitor.visitAll([], template);\n        return visitor.build(componentId);\n    };\n    return TypeCheckCompiler;\n}());\nvar DYNAMIC_VAR_NAME = '_any';\nvar TypeCheckLocalResolver = /** @class */ (function () {\n    function TypeCheckLocalResolver() {\n    }\n    TypeCheckLocalResolver.prototype.notifyImplicitReceiverUse = function () { };\n    TypeCheckLocalResolver.prototype.getLocal = function (name) {\n        if (name === EventHandlerVars.event.name) {\n            // References to the event should not be type-checked.\n            // TODO(chuckj): determine a better type for the event.\n            return variable(DYNAMIC_VAR_NAME);\n        }\n        return null;\n    };\n    return TypeCheckLocalResolver;\n}());\nvar defaultResolver = new TypeCheckLocalResolver();\nvar ViewBuilder = /** @class */ (function () {\n    function ViewBuilder(options, reflector, externalReferenceVars, parent, component, isHostComponent, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory) {\n        this.options = options;\n        this.reflector = reflector;\n        this.externalReferenceVars = externalReferenceVars;\n        this.parent = parent;\n        this.component = component;\n        this.isHostComponent = isHostComponent;\n        this.embeddedViewIndex = embeddedViewIndex;\n        this.pipes = pipes;\n        this.guards = guards;\n        this.ctx = ctx;\n        this.viewBuilderFactory = viewBuilderFactory;\n        this.refOutputVars = new Map();\n        this.variables = [];\n        this.children = [];\n        this.updates = [];\n        this.actions = [];\n    }\n    ViewBuilder.prototype.getOutputVar = function (type) {\n        var varName;\n        if (type === this.component && this.isHostComponent) {\n            varName = DYNAMIC_VAR_NAME;\n        }\n        else if (type instanceof StaticSymbol) {\n            varName = this.externalReferenceVars.get(type);\n        }\n        else {\n            varName = DYNAMIC_VAR_NAME;\n        }\n        if (!varName) {\n            throw new Error(\"Illegal State: referring to a type without a variable \" + JSON.stringify(type));\n        }\n        return varName;\n    };\n    ViewBuilder.prototype.getTypeGuardExpressions = function (ast) {\n        var e_1, _a, e_2, _b;\n        var result = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this.guards);\n        try {\n            for (var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(ast.directives), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var directive = _d.value;\n                try {\n                    for (var _e = (e_2 = void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(directive.inputs)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                        var input = _f.value;\n                        var guard = directive.directive.guards[input.directiveName];\n                        if (guard) {\n                            var useIf = guard === 'UseIf';\n                            result.push({\n                                guard: guard,\n                                useIf: useIf,\n                                expression: { context: this.component, value: input.value }\n                            });\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return result;\n    };\n    ViewBuilder.prototype.visitAll = function (variables, astNodes) {\n        this.variables = variables;\n        templateVisitAll(this, astNodes);\n    };\n    ViewBuilder.prototype.build = function (componentId, targetStatements) {\n        var e_3, _a;\n        var _this = this;\n        if (targetStatements === void 0) { targetStatements = []; }\n        this.children.forEach(function (child) { return child.build(componentId, targetStatements); });\n        var viewStmts = [variable(DYNAMIC_VAR_NAME).set(NULL_EXPR).toDeclStmt(DYNAMIC_TYPE)];\n        var bindingCount = 0;\n        this.updates.forEach(function (expression) {\n            var _a = _this.preprocessUpdateExpression(expression), sourceSpan = _a.sourceSpan, context = _a.context, value = _a.value;\n            var bindingId = \"\" + bindingCount++;\n            var nameResolver = context === _this.component ? _this : defaultResolver;\n            var _b = convertPropertyBinding(nameResolver, variable(_this.getOutputVar(context)), value, bindingId, BindingForm.General), stmts = _b.stmts, currValExpr = _b.currValExpr;\n            stmts.push(new ExpressionStatement(currValExpr));\n            viewStmts.push.apply(viewStmts, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(stmts.map(function (stmt) { return applySourceSpanToStatementIfNeeded(stmt, sourceSpan); })));\n        });\n        this.actions.forEach(function (_a) {\n            var sourceSpan = _a.sourceSpan, context = _a.context, value = _a.value;\n            var bindingId = \"\" + bindingCount++;\n            var nameResolver = context === _this.component ? _this : defaultResolver;\n            var stmts = convertActionBinding(nameResolver, variable(_this.getOutputVar(context)), value, bindingId).stmts;\n            viewStmts.push.apply(viewStmts, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(stmts.map(function (stmt) { return applySourceSpanToStatementIfNeeded(stmt, sourceSpan); })));\n        });\n        if (this.guards.length) {\n            var guardExpression = undefined;\n            try {\n                for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(this.guards), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var guard = _c.value;\n                    var _d = this.preprocessUpdateExpression(guard.expression), context = _d.context, value = _d.value;\n                    var bindingId = \"\" + bindingCount++;\n                    var nameResolver = context === this.component ? this : defaultResolver;\n                    // We only support support simple expressions and ignore others as they\n                    // are unlikely to affect type narrowing.\n                    var _e = convertPropertyBinding(nameResolver, variable(this.getOutputVar(context)), value, bindingId, BindingForm.TrySimple), stmts = _e.stmts, currValExpr = _e.currValExpr;\n                    if (stmts.length == 0) {\n                        var guardClause = guard.useIf ? currValExpr : this.ctx.importExpr(guard.guard).callFn([currValExpr]);\n                        guardExpression = guardExpression ? guardExpression.and(guardClause) : guardClause;\n                    }\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n            if (guardExpression) {\n                viewStmts = [new IfStmt(guardExpression, viewStmts)];\n            }\n        }\n        var viewName = \"_View_\" + componentId + \"_\" + this.embeddedViewIndex;\n        var viewFactory = new DeclareFunctionStmt(viewName, [], viewStmts);\n        targetStatements.push(viewFactory);\n        return targetStatements;\n    };\n    ViewBuilder.prototype.visitBoundText = function (ast, context) {\n        var _this = this;\n        var astWithSource = ast.value;\n        var inter = astWithSource.ast;\n        inter.expressions.forEach(function (expr) {\n            return _this.updates.push({ context: _this.component, value: expr, sourceSpan: ast.sourceSpan });\n        });\n    };\n    ViewBuilder.prototype.visitEmbeddedTemplate = function (ast, context) {\n        this.visitElementOrTemplate(ast);\n        // Note: The old view compiler used to use an `any` type\n        // for the context in any embedded view.\n        // We keep this behaivor behind a flag for now.\n        if (this.options.fullTemplateTypeCheck) {\n            // Find any applicable type guards. For example, NgIf has a type guard on ngIf\n            // (see NgIf.ngIfTypeGuard) that can be used to indicate that a template is only\n            // stamped out if ngIf is truthy so any bindings in the template can assume that,\n            // if a nullable type is used for ngIf, that expression is not null or undefined.\n            var guards = this.getTypeGuardExpressions(ast);\n            var childVisitor = this.viewBuilderFactory(this, guards);\n            this.children.push(childVisitor);\n            childVisitor.visitAll(ast.variables, ast.children);\n        }\n    };\n    ViewBuilder.prototype.visitElement = function (ast, context) {\n        var _this = this;\n        this.visitElementOrTemplate(ast);\n        var inputDefs = [];\n        var updateRendererExpressions = [];\n        var outputDefs = [];\n        ast.inputs.forEach(function (inputAst) {\n            _this.updates.push({ context: _this.component, value: inputAst.value, sourceSpan: inputAst.sourceSpan });\n        });\n        templateVisitAll(this, ast.children);\n    };\n    ViewBuilder.prototype.visitElementOrTemplate = function (ast) {\n        var _this = this;\n        ast.directives.forEach(function (dirAst) { _this.visitDirective(dirAst); });\n        ast.references.forEach(function (ref) {\n            var outputVarType = null;\n            // Note: The old view compiler used to use an `any` type\n            // for directives exposed via `exportAs`.\n            // We keep this behaivor behind a flag for now.\n            if (ref.value && ref.value.identifier && _this.options.fullTemplateTypeCheck) {\n                outputVarType = ref.value.identifier.reference;\n            }\n            else {\n                outputVarType = BuiltinTypeName.Dynamic;\n            }\n            _this.refOutputVars.set(ref.name, outputVarType);\n        });\n        ast.outputs.forEach(function (outputAst) {\n            _this.actions.push({ context: _this.component, value: outputAst.handler, sourceSpan: outputAst.sourceSpan });\n        });\n    };\n    ViewBuilder.prototype.visitDirective = function (dirAst) {\n        var _this = this;\n        var dirType = dirAst.directive.type.reference;\n        dirAst.inputs.forEach(function (input) { return _this.updates.push({ context: _this.component, value: input.value, sourceSpan: input.sourceSpan }); });\n        // Note: The old view compiler used to use an `any` type\n        // for expressions in host properties / events.\n        // We keep this behaivor behind a flag for now.\n        if (this.options.fullTemplateTypeCheck) {\n            dirAst.hostProperties.forEach(function (inputAst) { return _this.updates.push({ context: dirType, value: inputAst.value, sourceSpan: inputAst.sourceSpan }); });\n            dirAst.hostEvents.forEach(function (hostEventAst) { return _this.actions.push({\n                context: dirType,\n                value: hostEventAst.handler,\n                sourceSpan: hostEventAst.sourceSpan\n            }); });\n        }\n    };\n    ViewBuilder.prototype.notifyImplicitReceiverUse = function () { };\n    ViewBuilder.prototype.getLocal = function (name) {\n        if (name == EventHandlerVars.event.name) {\n            return variable(this.getOutputVar(BuiltinTypeName.Dynamic));\n        }\n        for (var currBuilder = this; currBuilder; currBuilder = currBuilder.parent) {\n            var outputVarType = void 0;\n            // check references\n            outputVarType = currBuilder.refOutputVars.get(name);\n            if (outputVarType == null) {\n                // check variables\n                var varAst = currBuilder.variables.find(function (varAst) { return varAst.name === name; });\n                if (varAst) {\n                    outputVarType = BuiltinTypeName.Dynamic;\n                }\n            }\n            if (outputVarType != null) {\n                return variable(this.getOutputVar(outputVarType));\n            }\n        }\n        return null;\n    };\n    ViewBuilder.prototype.pipeOutputVar = function (name) {\n        var pipe = this.pipes.get(name);\n        if (!pipe) {\n            throw new Error(\"Illegal State: Could not find pipe \" + name + \" in template of \" + this.component);\n        }\n        return this.getOutputVar(pipe);\n    };\n    ViewBuilder.prototype.preprocessUpdateExpression = function (expression) {\n        var _this = this;\n        return {\n            sourceSpan: expression.sourceSpan,\n            context: expression.context,\n            value: convertPropertyBindingBuiltins({\n                createLiteralArrayConverter: function (argCount) { return function (args) {\n                    var arr = literalArr(args);\n                    // Note: The old view compiler used to use an `any` type\n                    // for arrays.\n                    return _this.options.fullTemplateTypeCheck ? arr : arr.cast(DYNAMIC_TYPE);\n                }; },\n                createLiteralMapConverter: function (keys) { return function (values) {\n                    var entries = keys.map(function (k, i) { return ({\n                        key: k.key,\n                        value: values[i],\n                        quoted: k.quoted,\n                    }); });\n                    var map = literalMap(entries);\n                    // Note: The old view compiler used to use an `any` type\n                    // for maps.\n                    return _this.options.fullTemplateTypeCheck ? map : map.cast(DYNAMIC_TYPE);\n                }; },\n                createPipeConverter: function (name, argCount) { return function (args) {\n                    // Note: The old view compiler used to use an `any` type\n                    // for pipes.\n                    var pipeExpr = _this.options.fullTemplateTypeCheck ?\n                        variable(_this.pipeOutputVar(name)) :\n                        variable(_this.getOutputVar(BuiltinTypeName.Dynamic));\n                    return pipeExpr.callMethod('transform', args);\n                }; },\n            }, expression.value)\n        };\n    };\n    ViewBuilder.prototype.visitNgContent = function (ast, context) { };\n    ViewBuilder.prototype.visitText = function (ast, context) { };\n    ViewBuilder.prototype.visitDirectiveProperty = function (ast, context) { };\n    ViewBuilder.prototype.visitReference = function (ast, context) { };\n    ViewBuilder.prototype.visitVariable = function (ast, context) { };\n    ViewBuilder.prototype.visitEvent = function (ast, context) { };\n    ViewBuilder.prototype.visitElementProperty = function (ast, context) { };\n    ViewBuilder.prototype.visitAttr = function (ast, context) { };\n    return ViewBuilder;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CLASS_ATTR$1 = 'class';\nvar STYLE_ATTR = 'style';\nvar IMPLICIT_TEMPLATE_VAR = '\\$implicit';\nvar ViewCompileResult = /** @class */ (function () {\n    function ViewCompileResult(viewClassVar, rendererTypeVar) {\n        this.viewClassVar = viewClassVar;\n        this.rendererTypeVar = rendererTypeVar;\n    }\n    return ViewCompileResult;\n}());\nvar ViewCompiler = /** @class */ (function () {\n    function ViewCompiler(_reflector) {\n        this._reflector = _reflector;\n    }\n    ViewCompiler.prototype.compileComponent = function (outputCtx, component, template, styles, usedPipes) {\n        var _a;\n        var _this = this;\n        var embeddedViewCount = 0;\n        var staticQueryIds = findStaticQueryIds(template);\n        var renderComponentVarName = undefined;\n        if (!component.isHost) {\n            var template_1 = component.template;\n            var customRenderData = [];\n            if (template_1.animations && template_1.animations.length) {\n                customRenderData.push(new LiteralMapEntry('animation', convertValueToOutputAst(outputCtx, template_1.animations), true));\n            }\n            var renderComponentVar = variable(rendererTypeName(component.type.reference));\n            renderComponentVarName = renderComponentVar.name;\n            outputCtx.statements.push(renderComponentVar\n                .set(importExpr(Identifiers.createRendererType2).callFn([new LiteralMapExpr([\n                    new LiteralMapEntry('encapsulation', literal(template_1.encapsulation), false),\n                    new LiteralMapEntry('styles', styles, false),\n                    new LiteralMapEntry('data', new LiteralMapExpr(customRenderData), false)\n                ])]))\n                .toDeclStmt(importType(Identifiers.RendererType2), [StmtModifier.Final, StmtModifier.Exported]));\n        }\n        var viewBuilderFactory = function (parent) {\n            var embeddedViewIndex = embeddedViewCount++;\n            return new ViewBuilder$1(_this._reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, staticQueryIds, viewBuilderFactory);\n        };\n        var visitor = viewBuilderFactory(null);\n        visitor.visitAll([], template);\n        (_a = outputCtx.statements).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(visitor.build()));\n        return new ViewCompileResult(visitor.viewName, renderComponentVarName);\n    };\n    return ViewCompiler;\n}());\nvar LOG_VAR$1 = variable('_l');\nvar VIEW_VAR = variable('_v');\nvar CHECK_VAR = variable('_ck');\nvar COMP_VAR = variable('_co');\nvar EVENT_NAME_VAR = variable('en');\nvar ALLOW_DEFAULT_VAR = variable(\"ad\");\nvar ViewBuilder$1 = /** @class */ (function () {\n    function ViewBuilder(reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, staticQueryIds, viewBuilderFactory) {\n        this.reflector = reflector;\n        this.outputCtx = outputCtx;\n        this.parent = parent;\n        this.component = component;\n        this.embeddedViewIndex = embeddedViewIndex;\n        this.usedPipes = usedPipes;\n        this.staticQueryIds = staticQueryIds;\n        this.viewBuilderFactory = viewBuilderFactory;\n        this.nodes = [];\n        this.purePipeNodeIndices = Object.create(null);\n        // Need Object.create so that we don't have builtin values...\n        this.refNodeIndices = Object.create(null);\n        this.variables = [];\n        this.children = [];\n        // TODO(tbosch): The old view compiler used to use an `any` type\n        // for the context in any embedded view. We keep this behaivor for now\n        // to be able to introduce the new view compiler without too many errors.\n        this.compType = this.embeddedViewIndex > 0 ?\n            DYNAMIC_TYPE :\n            expressionType(outputCtx.importExpr(this.component.type.reference));\n        this.viewName = viewClassName(this.component.type.reference, this.embeddedViewIndex);\n    }\n    ViewBuilder.prototype.visitAll = function (variables, astNodes) {\n        var _this = this;\n        this.variables = variables;\n        // create the pipes for the pure pipes immediately, so that we know their indices.\n        if (!this.parent) {\n            this.usedPipes.forEach(function (pipe) {\n                if (pipe.pure) {\n                    _this.purePipeNodeIndices[pipe.name] = _this._createPipe(null, pipe);\n                }\n            });\n        }\n        if (!this.parent) {\n            var queryIds_1 = staticViewQueryIds(this.staticQueryIds);\n            this.component.viewQueries.forEach(function (query, queryIndex) {\n                // Note: queries start with id 1 so we can use the number in a Bloom filter!\n                var queryId = queryIndex + 1;\n                var bindingType = query.first ? 0 /* First */ : 1 /* All */;\n                var flags = 134217728 /* TypeViewQuery */ | calcStaticDynamicQueryFlags(queryIds_1, queryId, query);\n                _this.nodes.push(function () { return ({\n                    sourceSpan: null,\n                    nodeFlags: flags,\n                    nodeDef: importExpr(Identifiers.queryDef).callFn([\n                        literal(flags), literal(queryId),\n                        new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType), false)])\n                    ])\n                }); });\n            });\n        }\n        templateVisitAll(this, astNodes);\n        if (this.parent && (astNodes.length === 0 || needsAdditionalRootNode(astNodes))) {\n            // if the view is an embedded view, then we need to add an additional root node in some cases\n            this.nodes.push(function () { return ({\n                sourceSpan: null,\n                nodeFlags: 1 /* TypeElement */,\n                nodeDef: importExpr(Identifiers.anchorDef).callFn([\n                    literal(0 /* None */), NULL_EXPR, NULL_EXPR, literal(0)\n                ])\n            }); });\n        }\n    };\n    ViewBuilder.prototype.build = function (targetStatements) {\n        if (targetStatements === void 0) { targetStatements = []; }\n        this.children.forEach(function (child) { return child.build(targetStatements); });\n        var _a = this._createNodeExpressions(), updateRendererStmts = _a.updateRendererStmts, updateDirectivesStmts = _a.updateDirectivesStmts, nodeDefExprs = _a.nodeDefExprs;\n        var updateRendererFn = this._createUpdateFn(updateRendererStmts);\n        var updateDirectivesFn = this._createUpdateFn(updateDirectivesStmts);\n        var viewFlags = 0 /* None */;\n        if (!this.parent && this.component.changeDetection === ChangeDetectionStrategy.OnPush) {\n            viewFlags |= 2 /* OnPush */;\n        }\n        var viewFactory = new DeclareFunctionStmt(this.viewName, [new FnParam(LOG_VAR$1.name)], [new ReturnStatement(importExpr(Identifiers.viewDef).callFn([\n                literal(viewFlags),\n                literalArr(nodeDefExprs),\n                updateDirectivesFn,\n                updateRendererFn,\n            ]))], importType(Identifiers.ViewDefinition), this.embeddedViewIndex === 0 ? [StmtModifier.Exported] : []);\n        targetStatements.push(viewFactory);\n        return targetStatements;\n    };\n    ViewBuilder.prototype._createUpdateFn = function (updateStmts) {\n        var updateFn;\n        if (updateStmts.length > 0) {\n            var preStmts = [];\n            if (!this.component.isHost && findReadVarNames(updateStmts).has(COMP_VAR.name)) {\n                preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n            }\n            updateFn = fn([\n                new FnParam(CHECK_VAR.name, INFERRED_TYPE),\n                new FnParam(VIEW_VAR.name, INFERRED_TYPE)\n            ], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(preStmts, updateStmts), INFERRED_TYPE);\n        }\n        else {\n            updateFn = NULL_EXPR;\n        }\n        return updateFn;\n    };\n    ViewBuilder.prototype.visitNgContent = function (ast, context) {\n        // ngContentDef(ngContentIndex: number, index: number): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 8 /* TypeNgContent */,\n            nodeDef: importExpr(Identifiers.ngContentDef).callFn([\n                literal(ast.ngContentIndex), literal(ast.index)\n            ])\n        }); });\n    };\n    ViewBuilder.prototype.visitText = function (ast, context) {\n        // Static text nodes have no check function\n        var checkIndex = -1;\n        this.nodes.push(function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 2 /* TypeText */,\n            nodeDef: importExpr(Identifiers.textDef).callFn([\n                literal(checkIndex),\n                literal(ast.ngContentIndex),\n                literalArr([literal(ast.value)]),\n            ])\n        }); });\n    };\n    ViewBuilder.prototype.visitBoundText = function (ast, context) {\n        var _this = this;\n        var nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array\n        this.nodes.push(null);\n        var astWithSource = ast.value;\n        var inter = astWithSource.ast;\n        var updateRendererExpressions = inter.expressions.map(function (expr, bindingIndex) { return _this._preprocessUpdateExpression({ nodeIndex: nodeIndex, bindingIndex: bindingIndex, sourceSpan: ast.sourceSpan, context: COMP_VAR, value: expr }); });\n        // Check index is the same as the node index during compilation\n        // They might only differ at runtime\n        var checkIndex = nodeIndex;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 2 /* TypeText */,\n            nodeDef: importExpr(Identifiers.textDef).callFn([\n                literal(checkIndex),\n                literal(ast.ngContentIndex),\n                literalArr(inter.strings.map(function (s) { return literal(s); })),\n            ]),\n            updateRenderer: updateRendererExpressions\n        }); };\n    };\n    ViewBuilder.prototype.visitEmbeddedTemplate = function (ast, context) {\n        var _this = this;\n        var nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array\n        this.nodes.push(null);\n        var _a = this._visitElementOrTemplate(nodeIndex, ast), flags = _a.flags, queryMatchesExpr = _a.queryMatchesExpr, hostEvents = _a.hostEvents;\n        var childVisitor = this.viewBuilderFactory(this);\n        this.children.push(childVisitor);\n        childVisitor.visitAll(ast.variables, ast.children);\n        var childCount = this.nodes.length - nodeIndex - 1;\n        // anchorDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], ngContentIndex: number,\n        //   childCount: number, handleEventFn?: ElementHandleEventFn, templateFactory?:\n        //   ViewDefinitionFactory): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 1 /* TypeElement */ | flags,\n            nodeDef: importExpr(Identifiers.anchorDef).callFn([\n                literal(flags),\n                queryMatchesExpr,\n                literal(ast.ngContentIndex),\n                literal(childCount),\n                _this._createElementHandleEventFn(nodeIndex, hostEvents),\n                variable(childVisitor.viewName),\n            ])\n        }); };\n    };\n    ViewBuilder.prototype.visitElement = function (ast, context) {\n        var _this = this;\n        var nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(null);\n        // Using a null element name creates an anchor.\n        var elName = isNgContainer(ast.name) ? null : ast.name;\n        var _a = this._visitElementOrTemplate(nodeIndex, ast), flags = _a.flags, usedEvents = _a.usedEvents, queryMatchesExpr = _a.queryMatchesExpr, dirHostBindings = _a.hostBindings, hostEvents = _a.hostEvents;\n        var inputDefs = [];\n        var updateRendererExpressions = [];\n        var outputDefs = [];\n        if (elName) {\n            var hostBindings = ast.inputs\n                .map(function (inputAst) { return ({\n                context: COMP_VAR,\n                inputAst: inputAst,\n                dirAst: null,\n            }); })\n                .concat(dirHostBindings);\n            if (hostBindings.length) {\n                updateRendererExpressions =\n                    hostBindings.map(function (hostBinding, bindingIndex) { return _this._preprocessUpdateExpression({\n                        context: hostBinding.context,\n                        nodeIndex: nodeIndex,\n                        bindingIndex: bindingIndex,\n                        sourceSpan: hostBinding.inputAst.sourceSpan,\n                        value: hostBinding.inputAst.value\n                    }); });\n                inputDefs = hostBindings.map(function (hostBinding) { return elementBindingDef(hostBinding.inputAst, hostBinding.dirAst); });\n            }\n            outputDefs = usedEvents.map(function (_a) {\n                var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(_a, 2), target = _b[0], eventName = _b[1];\n                return literalArr([literal(target), literal(eventName)]);\n            });\n        }\n        templateVisitAll(this, ast.children);\n        var childCount = this.nodes.length - nodeIndex - 1;\n        var compAst = ast.directives.find(function (dirAst) { return dirAst.directive.isComponent; });\n        var compRendererType = NULL_EXPR;\n        var compView = NULL_EXPR;\n        if (compAst) {\n            compView = this.outputCtx.importExpr(compAst.directive.componentViewType);\n            compRendererType = this.outputCtx.importExpr(compAst.directive.rendererType);\n        }\n        // Check index is the same as the node index during compilation\n        // They might only differ at runtime\n        var checkIndex = nodeIndex;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 1 /* TypeElement */ | flags,\n            nodeDef: importExpr(Identifiers.elementDef).callFn([\n                literal(checkIndex),\n                literal(flags),\n                queryMatchesExpr,\n                literal(ast.ngContentIndex),\n                literal(childCount),\n                literal(elName),\n                elName ? fixedAttrsDef(ast) : NULL_EXPR,\n                inputDefs.length ? literalArr(inputDefs) : NULL_EXPR,\n                outputDefs.length ? literalArr(outputDefs) : NULL_EXPR,\n                _this._createElementHandleEventFn(nodeIndex, hostEvents),\n                compView,\n                compRendererType,\n            ]),\n            updateRenderer: updateRendererExpressions\n        }); };\n    };\n    ViewBuilder.prototype._visitElementOrTemplate = function (nodeIndex, ast) {\n        var _this = this;\n        var flags = 0 /* None */;\n        if (ast.hasViewContainer) {\n            flags |= 16777216 /* EmbeddedViews */;\n        }\n        var usedEvents = new Map();\n        ast.outputs.forEach(function (event) {\n            var _a = elementEventNameAndTarget(event, null), name = _a.name, target = _a.target;\n            usedEvents.set(elementEventFullName(target, name), [target, name]);\n        });\n        ast.directives.forEach(function (dirAst) {\n            dirAst.hostEvents.forEach(function (event) {\n                var _a = elementEventNameAndTarget(event, dirAst), name = _a.name, target = _a.target;\n                usedEvents.set(elementEventFullName(target, name), [target, name]);\n            });\n        });\n        var hostBindings = [];\n        var hostEvents = [];\n        this._visitComponentFactoryResolverProvider(ast.directives);\n        ast.providers.forEach(function (providerAst, providerIndex) {\n            var dirAst = undefined;\n            var dirIndex = undefined;\n            ast.directives.forEach(function (localDirAst, i) {\n                if (localDirAst.directive.type.reference === tokenReference(providerAst.token)) {\n                    dirAst = localDirAst;\n                    dirIndex = i;\n                }\n            });\n            if (dirAst) {\n                var _a = _this._visitDirective(providerAst, dirAst, dirIndex, nodeIndex, ast.references, ast.queryMatches, usedEvents, _this.staticQueryIds.get(ast)), dirHostBindings = _a.hostBindings, dirHostEvents = _a.hostEvents;\n                hostBindings.push.apply(hostBindings, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(dirHostBindings));\n                hostEvents.push.apply(hostEvents, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(dirHostEvents));\n            }\n            else {\n                _this._visitProvider(providerAst, ast.queryMatches);\n            }\n        });\n        var queryMatchExprs = [];\n        ast.queryMatches.forEach(function (match) {\n            var valueType = undefined;\n            if (tokenReference(match.value) ===\n                _this.reflector.resolveExternalReference(Identifiers.ElementRef)) {\n                valueType = 0 /* ElementRef */;\n            }\n            else if (tokenReference(match.value) ===\n                _this.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {\n                valueType = 3 /* ViewContainerRef */;\n            }\n            else if (tokenReference(match.value) ===\n                _this.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n                valueType = 2 /* TemplateRef */;\n            }\n            if (valueType != null) {\n                queryMatchExprs.push(literalArr([literal(match.queryId), literal(valueType)]));\n            }\n        });\n        ast.references.forEach(function (ref) {\n            var valueType = undefined;\n            if (!ref.value) {\n                valueType = 1 /* RenderElement */;\n            }\n            else if (tokenReference(ref.value) ===\n                _this.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n                valueType = 2 /* TemplateRef */;\n            }\n            if (valueType != null) {\n                _this.refNodeIndices[ref.name] = nodeIndex;\n                queryMatchExprs.push(literalArr([literal(ref.name), literal(valueType)]));\n            }\n        });\n        ast.outputs.forEach(function (outputAst) {\n            hostEvents.push({ context: COMP_VAR, eventAst: outputAst, dirAst: null });\n        });\n        return {\n            flags: flags,\n            usedEvents: Array.from(usedEvents.values()),\n            queryMatchesExpr: queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\n            hostBindings: hostBindings,\n            hostEvents: hostEvents\n        };\n    };\n    ViewBuilder.prototype._visitDirective = function (providerAst, dirAst, directiveIndex, elementNodeIndex, refs, queryMatches, usedEvents, queryIds) {\n        var _this = this;\n        var nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(null);\n        dirAst.directive.queries.forEach(function (query, queryIndex) {\n            var queryId = dirAst.contentQueryStartId + queryIndex;\n            var flags = 67108864 /* TypeContentQuery */ | calcStaticDynamicQueryFlags(queryIds, queryId, query);\n            var bindingType = query.first ? 0 /* First */ : 1 /* All */;\n            _this.nodes.push(function () { return ({\n                sourceSpan: dirAst.sourceSpan,\n                nodeFlags: flags,\n                nodeDef: importExpr(Identifiers.queryDef).callFn([\n                    literal(flags), literal(queryId),\n                    new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType), false)])\n                ]),\n            }); });\n        });\n        // Note: the operation below might also create new nodeDefs,\n        // but we don't want them to be a child of a directive,\n        // as they might be a provider/pipe on their own.\n        // I.e. we only allow queries as children of directives nodes.\n        var childCount = this.nodes.length - nodeIndex - 1;\n        var _a = this._visitProviderOrDirective(providerAst, queryMatches), flags = _a.flags, queryMatchExprs = _a.queryMatchExprs, providerExpr = _a.providerExpr, depsExpr = _a.depsExpr;\n        refs.forEach(function (ref) {\n            if (ref.value && tokenReference(ref.value) === tokenReference(providerAst.token)) {\n                _this.refNodeIndices[ref.name] = nodeIndex;\n                queryMatchExprs.push(literalArr([literal(ref.name), literal(4 /* Provider */)]));\n            }\n        });\n        if (dirAst.directive.isComponent) {\n            flags |= 32768 /* Component */;\n        }\n        var inputDefs = dirAst.inputs.map(function (inputAst, inputIndex) {\n            var mapValue = literalArr([literal(inputIndex), literal(inputAst.directiveName)]);\n            // Note: it's important to not quote the key so that we can capture renames by minifiers!\n            return new LiteralMapEntry(inputAst.directiveName, mapValue, false);\n        });\n        var outputDefs = [];\n        var dirMeta = dirAst.directive;\n        Object.keys(dirMeta.outputs).forEach(function (propName) {\n            var eventName = dirMeta.outputs[propName];\n            if (usedEvents.has(eventName)) {\n                // Note: it's important to not quote the key so that we can capture renames by minifiers!\n                outputDefs.push(new LiteralMapEntry(propName, literal(eventName), false));\n            }\n        });\n        var updateDirectiveExpressions = [];\n        if (dirAst.inputs.length || (flags & (262144 /* DoCheck */ | 65536 /* OnInit */)) > 0) {\n            updateDirectiveExpressions =\n                dirAst.inputs.map(function (input, bindingIndex) { return _this._preprocessUpdateExpression({\n                    nodeIndex: nodeIndex,\n                    bindingIndex: bindingIndex,\n                    sourceSpan: input.sourceSpan,\n                    context: COMP_VAR,\n                    value: input.value\n                }); });\n        }\n        var dirContextExpr = importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, literal(nodeIndex)]);\n        var hostBindings = dirAst.hostProperties.map(function (inputAst) { return ({\n            context: dirContextExpr,\n            dirAst: dirAst,\n            inputAst: inputAst,\n        }); });\n        var hostEvents = dirAst.hostEvents.map(function (hostEventAst) { return ({\n            context: dirContextExpr,\n            eventAst: hostEventAst, dirAst: dirAst,\n        }); });\n        // Check index is the same as the node index during compilation\n        // They might only differ at runtime\n        var checkIndex = nodeIndex;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: dirAst.sourceSpan,\n            nodeFlags: 16384 /* TypeDirective */ | flags,\n            nodeDef: importExpr(Identifiers.directiveDef).callFn([\n                literal(checkIndex),\n                literal(flags),\n                queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\n                literal(childCount),\n                providerExpr,\n                depsExpr,\n                inputDefs.length ? new LiteralMapExpr(inputDefs) : NULL_EXPR,\n                outputDefs.length ? new LiteralMapExpr(outputDefs) : NULL_EXPR,\n            ]),\n            updateDirectives: updateDirectiveExpressions,\n            directive: dirAst.directive.type,\n        }); };\n        return { hostBindings: hostBindings, hostEvents: hostEvents };\n    };\n    ViewBuilder.prototype._visitProvider = function (providerAst, queryMatches) {\n        this._addProviderNode(this._visitProviderOrDirective(providerAst, queryMatches));\n    };\n    ViewBuilder.prototype._visitComponentFactoryResolverProvider = function (directives) {\n        var componentDirMeta = directives.find(function (dirAst) { return dirAst.directive.isComponent; });\n        if (componentDirMeta && componentDirMeta.directive.entryComponents.length) {\n            var _a = componentFactoryResolverProviderDef(this.reflector, this.outputCtx, 8192 /* PrivateProvider */, componentDirMeta.directive.entryComponents), providerExpr = _a.providerExpr, depsExpr = _a.depsExpr, flags = _a.flags, tokenExpr = _a.tokenExpr;\n            this._addProviderNode({\n                providerExpr: providerExpr,\n                depsExpr: depsExpr,\n                flags: flags,\n                tokenExpr: tokenExpr,\n                queryMatchExprs: [],\n                sourceSpan: componentDirMeta.sourceSpan\n            });\n        }\n    };\n    ViewBuilder.prototype._addProviderNode = function (data) {\n        var nodeIndex = this.nodes.length;\n        // providerDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], token:any,\n        //   value: any, deps: ([DepFlags, any] | any)[]): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: data.sourceSpan,\n            nodeFlags: data.flags,\n            nodeDef: importExpr(Identifiers.providerDef).callFn([\n                literal(data.flags),\n                data.queryMatchExprs.length ? literalArr(data.queryMatchExprs) : NULL_EXPR,\n                data.tokenExpr, data.providerExpr, data.depsExpr\n            ])\n        }); });\n    };\n    ViewBuilder.prototype._visitProviderOrDirective = function (providerAst, queryMatches) {\n        var flags = 0 /* None */;\n        var queryMatchExprs = [];\n        queryMatches.forEach(function (match) {\n            if (tokenReference(match.value) === tokenReference(providerAst.token)) {\n                queryMatchExprs.push(literalArr([literal(match.queryId), literal(4 /* Provider */)]));\n            }\n        });\n        var _a = providerDef(this.outputCtx, providerAst), providerExpr = _a.providerExpr, depsExpr = _a.depsExpr, providerFlags = _a.flags, tokenExpr = _a.tokenExpr;\n        return {\n            flags: flags | providerFlags,\n            queryMatchExprs: queryMatchExprs,\n            providerExpr: providerExpr,\n            depsExpr: depsExpr,\n            tokenExpr: tokenExpr,\n            sourceSpan: providerAst.sourceSpan\n        };\n    };\n    ViewBuilder.prototype.getLocal = function (name) {\n        if (name == EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        var currViewExpr = VIEW_VAR;\n        for (var currBuilder = this; currBuilder; currBuilder = currBuilder.parent,\n            currViewExpr = currViewExpr.prop('parent').cast(DYNAMIC_TYPE)) {\n            // check references\n            var refNodeIndex = currBuilder.refNodeIndices[name];\n            if (refNodeIndex != null) {\n                return importExpr(Identifiers.nodeValue).callFn([currViewExpr, literal(refNodeIndex)]);\n            }\n            // check variables\n            var varAst = currBuilder.variables.find(function (varAst) { return varAst.name === name; });\n            if (varAst) {\n                var varValue = varAst.value || IMPLICIT_TEMPLATE_VAR;\n                return currViewExpr.prop('context').prop(varValue);\n            }\n        }\n        return null;\n    };\n    ViewBuilder.prototype.notifyImplicitReceiverUse = function () {\n        // Not needed in View Engine as View Engine walks through the generated\n        // expressions to figure out if the implicit receiver is used and needs\n        // to be generated as part of the pre-update statements.\n    };\n    ViewBuilder.prototype._createLiteralArrayConverter = function (sourceSpan, argCount) {\n        if (argCount === 0) {\n            var valueExpr_1 = importExpr(Identifiers.EMPTY_ARRAY);\n            return function () { return valueExpr_1; };\n        }\n        var checkIndex = this.nodes.length;\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 32 /* TypePureArray */,\n            nodeDef: importExpr(Identifiers.pureArrayDef).callFn([\n                literal(checkIndex),\n                literal(argCount),\n            ])\n        }); });\n        return function (args) { return callCheckStmt(checkIndex, args); };\n    };\n    ViewBuilder.prototype._createLiteralMapConverter = function (sourceSpan, keys) {\n        if (keys.length === 0) {\n            var valueExpr_2 = importExpr(Identifiers.EMPTY_MAP);\n            return function () { return valueExpr_2; };\n        }\n        var map = literalMap(keys.map(function (e, i) { return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, e, { value: literal(i) })); }));\n        var checkIndex = this.nodes.length;\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 64 /* TypePureObject */,\n            nodeDef: importExpr(Identifiers.pureObjectDef).callFn([\n                literal(checkIndex),\n                map,\n            ])\n        }); });\n        return function (args) { return callCheckStmt(checkIndex, args); };\n    };\n    ViewBuilder.prototype._createPipeConverter = function (expression, name, argCount) {\n        var pipe = this.usedPipes.find(function (pipeSummary) { return pipeSummary.name === name; });\n        if (pipe.pure) {\n            var checkIndex_1 = this.nodes.length;\n            this.nodes.push(function () { return ({\n                sourceSpan: expression.sourceSpan,\n                nodeFlags: 128 /* TypePurePipe */,\n                nodeDef: importExpr(Identifiers.purePipeDef).callFn([\n                    literal(checkIndex_1),\n                    literal(argCount),\n                ])\n            }); });\n            // find underlying pipe in the component view\n            var compViewExpr = VIEW_VAR;\n            var compBuilder = this;\n            while (compBuilder.parent) {\n                compBuilder = compBuilder.parent;\n                compViewExpr = compViewExpr.prop('parent').cast(DYNAMIC_TYPE);\n            }\n            var pipeNodeIndex = compBuilder.purePipeNodeIndices[name];\n            var pipeValueExpr_1 = importExpr(Identifiers.nodeValue).callFn([compViewExpr, literal(pipeNodeIndex)]);\n            return function (args) { return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, callCheckStmt(checkIndex_1, [pipeValueExpr_1].concat(args))); };\n        }\n        else {\n            var nodeIndex = this._createPipe(expression.sourceSpan, pipe);\n            var nodeValueExpr_1 = importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, literal(nodeIndex)]);\n            return function (args) { return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, nodeValueExpr_1.callMethod('transform', args)); };\n        }\n    };\n    ViewBuilder.prototype._createPipe = function (sourceSpan, pipe) {\n        var _this = this;\n        var nodeIndex = this.nodes.length;\n        var flags = 0 /* None */;\n        pipe.type.lifecycleHooks.forEach(function (lifecycleHook) {\n            // for pipes, we only support ngOnDestroy\n            if (lifecycleHook === LifecycleHooks.OnDestroy) {\n                flags |= lifecycleHookToNodeFlag(lifecycleHook);\n            }\n        });\n        var depExprs = pipe.type.diDeps.map(function (diDep) { return depDef(_this.outputCtx, diDep); });\n        // function pipeDef(\n        //   flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 16 /* TypePipe */,\n            nodeDef: importExpr(Identifiers.pipeDef).callFn([\n                literal(flags), _this.outputCtx.importExpr(pipe.type.reference), literalArr(depExprs)\n            ])\n        }); });\n        return nodeIndex;\n    };\n    /**\n     * For the AST in `UpdateExpression.value`:\n     * - create nodes for pipes, literal arrays and, literal maps,\n     * - update the AST to replace pipes, literal arrays and, literal maps with calls to check fn.\n     *\n     * WARNING: This might create new nodeDefs (for pipes and literal arrays and literal maps)!\n     */\n    ViewBuilder.prototype._preprocessUpdateExpression = function (expression) {\n        var _this = this;\n        return {\n            nodeIndex: expression.nodeIndex,\n            bindingIndex: expression.bindingIndex,\n            sourceSpan: expression.sourceSpan,\n            context: expression.context,\n            value: convertPropertyBindingBuiltins({\n                createLiteralArrayConverter: function (argCount) { return _this._createLiteralArrayConverter(expression.sourceSpan, argCount); },\n                createLiteralMapConverter: function (keys) {\n                    return _this._createLiteralMapConverter(expression.sourceSpan, keys);\n                },\n                createPipeConverter: function (name, argCount) {\n                    return _this._createPipeConverter(expression, name, argCount);\n                }\n            }, expression.value)\n        };\n    };\n    ViewBuilder.prototype._createNodeExpressions = function () {\n        var self = this;\n        var updateBindingCount = 0;\n        var updateRendererStmts = [];\n        var updateDirectivesStmts = [];\n        var nodeDefExprs = this.nodes.map(function (factory, nodeIndex) {\n            var _a = factory(), nodeDef = _a.nodeDef, nodeFlags = _a.nodeFlags, updateDirectives = _a.updateDirectives, updateRenderer = _a.updateRenderer, sourceSpan = _a.sourceSpan;\n            if (updateRenderer) {\n                updateRendererStmts.push.apply(updateRendererStmts, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(createUpdateStatements(nodeIndex, sourceSpan, updateRenderer, false)));\n            }\n            if (updateDirectives) {\n                updateDirectivesStmts.push.apply(updateDirectivesStmts, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(createUpdateStatements(nodeIndex, sourceSpan, updateDirectives, (nodeFlags & (262144 /* DoCheck */ | 65536 /* OnInit */)) > 0)));\n            }\n            // We use a comma expression to call the log function before\n            // the nodeDef function, but still use the result of the nodeDef function\n            // as the value.\n            // Note: We only add the logger to elements / text nodes,\n            // so we don't generate too much code.\n            var logWithNodeDef = nodeFlags & 3 /* CatRenderNode */ ?\n                new CommaExpr([LOG_VAR$1.callFn([]).callFn([]), nodeDef]) :\n                nodeDef;\n            return applySourceSpanToExpressionIfNeeded(logWithNodeDef, sourceSpan);\n        });\n        return { updateRendererStmts: updateRendererStmts, updateDirectivesStmts: updateDirectivesStmts, nodeDefExprs: nodeDefExprs };\n        function createUpdateStatements(nodeIndex, sourceSpan, expressions, allowEmptyExprs) {\n            var updateStmts = [];\n            var exprs = expressions.map(function (_a) {\n                var sourceSpan = _a.sourceSpan, context = _a.context, value = _a.value;\n                var bindingId = \"\" + updateBindingCount++;\n                var nameResolver = context === COMP_VAR ? self : null;\n                var _b = convertPropertyBinding(nameResolver, context, value, bindingId, BindingForm.General), stmts = _b.stmts, currValExpr = _b.currValExpr;\n                updateStmts.push.apply(updateStmts, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(stmts.map(function (stmt) { return applySourceSpanToStatementIfNeeded(stmt, sourceSpan); })));\n                return applySourceSpanToExpressionIfNeeded(currValExpr, sourceSpan);\n            });\n            if (expressions.length || allowEmptyExprs) {\n                updateStmts.push(applySourceSpanToStatementIfNeeded(callCheckStmt(nodeIndex, exprs).toStmt(), sourceSpan));\n            }\n            return updateStmts;\n        }\n    };\n    ViewBuilder.prototype._createElementHandleEventFn = function (nodeIndex, handlers) {\n        var _this = this;\n        var handleEventStmts = [];\n        var handleEventBindingCount = 0;\n        handlers.forEach(function (_a) {\n            var context = _a.context, eventAst = _a.eventAst, dirAst = _a.dirAst;\n            var bindingId = \"\" + handleEventBindingCount++;\n            var nameResolver = context === COMP_VAR ? _this : null;\n            var _b = convertActionBinding(nameResolver, context, eventAst.handler, bindingId), stmts = _b.stmts, allowDefault = _b.allowDefault;\n            var trueStmts = stmts;\n            if (allowDefault) {\n                trueStmts.push(ALLOW_DEFAULT_VAR.set(allowDefault.and(ALLOW_DEFAULT_VAR)).toStmt());\n            }\n            var _c = elementEventNameAndTarget(eventAst, dirAst), eventTarget = _c.target, eventName = _c.name;\n            var fullEventName = elementEventFullName(eventTarget, eventName);\n            handleEventStmts.push(applySourceSpanToStatementIfNeeded(new IfStmt(literal(fullEventName).identical(EVENT_NAME_VAR), trueStmts), eventAst.sourceSpan));\n        });\n        var handleEventFn;\n        if (handleEventStmts.length > 0) {\n            var preStmts = [ALLOW_DEFAULT_VAR.set(literal(true)).toDeclStmt(BOOL_TYPE)];\n            if (!this.component.isHost && findReadVarNames(handleEventStmts).has(COMP_VAR.name)) {\n                preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n            }\n            handleEventFn = fn([\n                new FnParam(VIEW_VAR.name, INFERRED_TYPE),\n                new FnParam(EVENT_NAME_VAR.name, INFERRED_TYPE),\n                new FnParam(EventHandlerVars.event.name, INFERRED_TYPE)\n            ], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(preStmts, handleEventStmts, [new ReturnStatement(ALLOW_DEFAULT_VAR)]), INFERRED_TYPE);\n        }\n        else {\n            handleEventFn = NULL_EXPR;\n        }\n        return handleEventFn;\n    };\n    ViewBuilder.prototype.visitDirective = function (ast, context) { };\n    ViewBuilder.prototype.visitDirectiveProperty = function (ast, context) { };\n    ViewBuilder.prototype.visitReference = function (ast, context) { };\n    ViewBuilder.prototype.visitVariable = function (ast, context) { };\n    ViewBuilder.prototype.visitEvent = function (ast, context) { };\n    ViewBuilder.prototype.visitElementProperty = function (ast, context) { };\n    ViewBuilder.prototype.visitAttr = function (ast, context) { };\n    return ViewBuilder;\n}());\nfunction needsAdditionalRootNode(astNodes) {\n    var lastAstNode = astNodes[astNodes.length - 1];\n    if (lastAstNode instanceof EmbeddedTemplateAst) {\n        return lastAstNode.hasViewContainer;\n    }\n    if (lastAstNode instanceof ElementAst) {\n        if (isNgContainer(lastAstNode.name) && lastAstNode.children.length) {\n            return needsAdditionalRootNode(lastAstNode.children);\n        }\n        return lastAstNode.hasViewContainer;\n    }\n    return lastAstNode instanceof NgContentAst;\n}\nfunction elementBindingDef(inputAst, dirAst) {\n    var inputType = inputAst.type;\n    switch (inputType) {\n        case 1 /* Attribute */:\n            return literalArr([\n                literal(1 /* TypeElementAttribute */), literal(inputAst.name),\n                literal(inputAst.securityContext)\n            ]);\n        case 0 /* Property */:\n            return literalArr([\n                literal(8 /* TypeProperty */), literal(inputAst.name),\n                literal(inputAst.securityContext)\n            ]);\n        case 4 /* Animation */:\n            var bindingType = 8 /* TypeProperty */ |\n                (dirAst && dirAst.directive.isComponent ? 32 /* SyntheticHostProperty */ :\n                    16 /* SyntheticProperty */);\n            return literalArr([\n                literal(bindingType), literal('@' + inputAst.name), literal(inputAst.securityContext)\n            ]);\n        case 2 /* Class */:\n            return literalArr([literal(2 /* TypeElementClass */), literal(inputAst.name), NULL_EXPR]);\n        case 3 /* Style */:\n            return literalArr([\n                literal(4 /* TypeElementStyle */), literal(inputAst.name), literal(inputAst.unit)\n            ]);\n        default:\n            // This default case is not needed by TypeScript compiler, as the switch is exhaustive.\n            // However Closure Compiler does not understand that and reports an error in typed mode.\n            // The `throw new Error` below works around the problem, and the unexpected: never variable\n            // makes sure tsc still checks this code is unreachable.\n            var unexpected = inputType;\n            throw new Error(\"unexpected \" + unexpected);\n    }\n}\nfunction fixedAttrsDef(elementAst) {\n    var mapResult = Object.create(null);\n    elementAst.attrs.forEach(function (attrAst) { mapResult[attrAst.name] = attrAst.value; });\n    elementAst.directives.forEach(function (dirAst) {\n        Object.keys(dirAst.directive.hostAttributes).forEach(function (name) {\n            var value = dirAst.directive.hostAttributes[name];\n            var prevValue = mapResult[name];\n            mapResult[name] = prevValue != null ? mergeAttributeValue(name, prevValue, value) : value;\n        });\n    });\n    // Note: We need to sort to get a defined output order\n    // for tests and for caching generated artifacts...\n    return literalArr(Object.keys(mapResult).sort().map(function (attrName) { return literalArr([literal(attrName), literal(mapResult[attrName])]); }));\n}\nfunction mergeAttributeValue(attrName, attrValue1, attrValue2) {\n    if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {\n        return attrValue1 + \" \" + attrValue2;\n    }\n    else {\n        return attrValue2;\n    }\n}\nfunction callCheckStmt(nodeIndex, exprs) {\n    if (exprs.length > 10) {\n        return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(1 /* Dynamic */), literalArr(exprs)]);\n    }\n    else {\n        return CHECK_VAR.callFn(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([VIEW_VAR, literal(nodeIndex), literal(0 /* Inline */)], exprs));\n    }\n}\nfunction callUnwrapValue(nodeIndex, bindingIdx, expr) {\n    return importExpr(Identifiers.unwrapValue).callFn([\n        VIEW_VAR, literal(nodeIndex), literal(bindingIdx), expr\n    ]);\n}\nfunction findStaticQueryIds(nodes, result) {\n    if (result === void 0) { result = new Map(); }\n    nodes.forEach(function (node) {\n        var staticQueryIds = new Set();\n        var dynamicQueryIds = new Set();\n        var queryMatches = undefined;\n        if (node instanceof ElementAst) {\n            findStaticQueryIds(node.children, result);\n            node.children.forEach(function (child) {\n                var childData = result.get(child);\n                childData.staticQueryIds.forEach(function (queryId) { return staticQueryIds.add(queryId); });\n                childData.dynamicQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n            });\n            queryMatches = node.queryMatches;\n        }\n        else if (node instanceof EmbeddedTemplateAst) {\n            findStaticQueryIds(node.children, result);\n            node.children.forEach(function (child) {\n                var childData = result.get(child);\n                childData.staticQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n                childData.dynamicQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n            });\n            queryMatches = node.queryMatches;\n        }\n        if (queryMatches) {\n            queryMatches.forEach(function (match) { return staticQueryIds.add(match.queryId); });\n        }\n        dynamicQueryIds.forEach(function (queryId) { return staticQueryIds.delete(queryId); });\n        result.set(node, { staticQueryIds: staticQueryIds, dynamicQueryIds: dynamicQueryIds });\n    });\n    return result;\n}\nfunction staticViewQueryIds(nodeStaticQueryIds) {\n    var staticQueryIds = new Set();\n    var dynamicQueryIds = new Set();\n    Array.from(nodeStaticQueryIds.values()).forEach(function (entry) {\n        entry.staticQueryIds.forEach(function (queryId) { return staticQueryIds.add(queryId); });\n        entry.dynamicQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n    });\n    dynamicQueryIds.forEach(function (queryId) { return staticQueryIds.delete(queryId); });\n    return { staticQueryIds: staticQueryIds, dynamicQueryIds: dynamicQueryIds };\n}\nfunction elementEventNameAndTarget(eventAst, dirAst) {\n    if (eventAst.isAnimation) {\n        return {\n            name: \"@\" + eventAst.name + \".\" + eventAst.phase,\n            target: dirAst && dirAst.directive.isComponent ? 'component' : null\n        };\n    }\n    else {\n        return eventAst;\n    }\n}\nfunction calcStaticDynamicQueryFlags(queryIds, queryId, query) {\n    var flags = 0 /* None */;\n    // Note: We only make queries static that query for a single item.\n    // This is because of backwards compatibility with the old view compiler...\n    if (query.first && shouldResolveAsStaticQuery(queryIds, queryId, query)) {\n        flags |= 268435456 /* StaticQuery */;\n    }\n    else {\n        flags |= 536870912 /* DynamicQuery */;\n    }\n    return flags;\n}\nfunction shouldResolveAsStaticQuery(queryIds, queryId, query) {\n    // If query.static has been set by the user, use that value to determine whether\n    // the query is static. If none has been set, sort the query into static/dynamic\n    // based on query results (i.e. dynamic if CD needs to run to get all results).\n    return query.static ||\n        query.static == null &&\n            (queryIds.staticQueryIds.has(queryId) || !queryIds.dynamicQueryIds.has(queryId));\n}\nfunction elementEventFullName(target, name) {\n    return target ? target + \":\" + name : name;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A container for message extracted from the templates.\n */\nvar MessageBundle = /** @class */ (function () {\n    function MessageBundle(_htmlParser, _implicitTags, _implicitAttrs, _locale) {\n        if (_locale === void 0) { _locale = null; }\n        this._htmlParser = _htmlParser;\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n        this._locale = _locale;\n        this._messages = [];\n    }\n    MessageBundle.prototype.updateFromTemplate = function (html, url, interpolationConfig) {\n        var _a;\n        var htmlParserResult = this._htmlParser.parse(html, url, { tokenizeExpansionForms: true, interpolationConfig: interpolationConfig });\n        if (htmlParserResult.errors.length) {\n            return htmlParserResult.errors;\n        }\n        var i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);\n        if (i18nParserResult.errors.length) {\n            return i18nParserResult.errors;\n        }\n        (_a = this._messages).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(i18nParserResult.messages));\n        return [];\n    };\n    // Return the message in the internal format\n    // The public (serialized) format might be different, see the `write` method.\n    MessageBundle.prototype.getMessages = function () { return this._messages; };\n    MessageBundle.prototype.write = function (serializer, filterSources) {\n        var messages = {};\n        var mapperVisitor = new MapPlaceholderNames();\n        // Deduplicate messages based on their ID\n        this._messages.forEach(function (message) {\n            var _a;\n            var id = serializer.digest(message);\n            if (!messages.hasOwnProperty(id)) {\n                messages[id] = message;\n            }\n            else {\n                (_a = messages[id].sources).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(message.sources));\n            }\n        });\n        // Transform placeholder names using the serializer mapping\n        var msgList = Object.keys(messages).map(function (id) {\n            var mapper = serializer.createNameMapper(messages[id]);\n            var src = messages[id];\n            var nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n            var transformedMessage = new Message(nodes, {}, {}, src.meaning, src.description, id);\n            transformedMessage.sources = src.sources;\n            if (filterSources) {\n                transformedMessage.sources.forEach(function (source) { return source.filePath = filterSources(source.filePath); });\n            }\n            return transformedMessage;\n        });\n        return serializer.write(msgList, this._locale);\n    };\n    return MessageBundle;\n}());\n// Transform an i18n AST by renaming the placeholder nodes with the given mapper\nvar MapPlaceholderNames = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(MapPlaceholderNames, _super);\n    function MapPlaceholderNames() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    MapPlaceholderNames.prototype.convert = function (nodes, mapper) {\n        var _this = this;\n        return mapper ? nodes.map(function (n) { return n.visit(_this, mapper); }) : nodes;\n    };\n    MapPlaceholderNames.prototype.visitTagPlaceholder = function (ph, mapper) {\n        var _this = this;\n        var startName = mapper.toPublicName(ph.startName);\n        var closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;\n        var children = ph.children.map(function (n) { return n.visit(_this, mapper); });\n        return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan);\n    };\n    MapPlaceholderNames.prototype.visitPlaceholder = function (ph, mapper) {\n        return new Placeholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n    };\n    MapPlaceholderNames.prototype.visitIcuPlaceholder = function (ph, mapper) {\n        return new IcuPlaceholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n    };\n    return MapPlaceholderNames;\n}(CloneVisitor));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar GeneratedFile = /** @class */ (function () {\n    function GeneratedFile(srcFileUrl, genFileUrl, sourceOrStmts) {\n        this.srcFileUrl = srcFileUrl;\n        this.genFileUrl = genFileUrl;\n        if (typeof sourceOrStmts === 'string') {\n            this.source = sourceOrStmts;\n            this.stmts = null;\n        }\n        else {\n            this.source = null;\n            this.stmts = sourceOrStmts;\n        }\n    }\n    GeneratedFile.prototype.isEquivalent = function (other) {\n        if (this.genFileUrl !== other.genFileUrl) {\n            return false;\n        }\n        if (this.source) {\n            return this.source === other.source;\n        }\n        if (other.stmts == null) {\n            return false;\n        }\n        // Note: the constructor guarantees that if this.source is not filled,\n        // then this.stmts is.\n        return areAllEquivalent(this.stmts, other.stmts);\n    };\n    return GeneratedFile;\n}());\nfunction toTypeScript(file, preamble) {\n    if (preamble === void 0) { preamble = ''; }\n    if (!file.stmts) {\n        throw new Error(\"Illegal state: No stmts present on GeneratedFile \" + file.genFileUrl);\n    }\n    return new TypeScriptEmitter().emitStatements(file.genFileUrl, file.stmts, preamble);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction listLazyRoutes(moduleMeta, reflector) {\n    var e_1, _a, e_2, _b;\n    var allLazyRoutes = [];\n    try {\n        for (var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(moduleMeta.transitiveModule.providers), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var _e = _d.value, provider = _e.provider, module = _e.module;\n            if (tokenReference(provider.token) === reflector.ROUTES) {\n                var loadChildren = _collectLoadChildren(provider.useValue);\n                try {\n                    for (var loadChildren_1 = (e_2 = void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(loadChildren)), loadChildren_1_1 = loadChildren_1.next(); !loadChildren_1_1.done; loadChildren_1_1 = loadChildren_1.next()) {\n                        var route = loadChildren_1_1.value;\n                        allLazyRoutes.push(parseLazyRoute(route, reflector, module.reference));\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (loadChildren_1_1 && !loadChildren_1_1.done && (_b = loadChildren_1.return)) _b.call(loadChildren_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return allLazyRoutes;\n}\nfunction _collectLoadChildren(routes, target) {\n    var e_3, _a;\n    if (target === void 0) { target = []; }\n    if (typeof routes === 'string') {\n        target.push(routes);\n    }\n    else if (Array.isArray(routes)) {\n        try {\n            for (var routes_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {\n                var route = routes_1_1.value;\n                _collectLoadChildren(route, target);\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n    }\n    else if (routes.loadChildren) {\n        _collectLoadChildren(routes.loadChildren, target);\n    }\n    else if (routes.children) {\n        _collectLoadChildren(routes.children, target);\n    }\n    return target;\n}\nfunction parseLazyRoute(route, reflector, module) {\n    var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(route.split('#'), 2), routePath = _a[0], routeName = _a[1];\n    var referencedModule = reflector.resolveExternalReference({\n        moduleName: routePath,\n        name: routeName,\n    }, module ? module.filePath : undefined);\n    return { route: route, module: module || referencedModule, referencedModule: referencedModule };\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TS = /^(?!.*\\.d\\.ts$).*\\.ts$/;\nvar ResolvedStaticSymbol = /** @class */ (function () {\n    function ResolvedStaticSymbol(symbol, metadata) {\n        this.symbol = symbol;\n        this.metadata = metadata;\n    }\n    return ResolvedStaticSymbol;\n}());\nvar SUPPORTED_SCHEMA_VERSION = 4;\n/**\n * This class is responsible for loading metadata per symbol,\n * and normalizing references between symbols.\n *\n * Internally, it only uses symbols without members,\n * and deduces the values for symbols with members based\n * on these symbols.\n */\nvar StaticSymbolResolver = /** @class */ (function () {\n    function StaticSymbolResolver(host, staticSymbolCache, summaryResolver, errorRecorder) {\n        this.host = host;\n        this.staticSymbolCache = staticSymbolCache;\n        this.summaryResolver = summaryResolver;\n        this.errorRecorder = errorRecorder;\n        this.metadataCache = new Map();\n        // Note: this will only contain StaticSymbols without members!\n        this.resolvedSymbols = new Map();\n        this.resolvedFilePaths = new Set();\n        // Note: this will only contain StaticSymbols without members!\n        this.importAs = new Map();\n        this.symbolResourcePaths = new Map();\n        this.symbolFromFile = new Map();\n        this.knownFileNameToModuleNames = new Map();\n    }\n    StaticSymbolResolver.prototype.resolveSymbol = function (staticSymbol) {\n        if (staticSymbol.members.length > 0) {\n            return this._resolveSymbolMembers(staticSymbol);\n        }\n        // Note: always ask for a summary first,\n        // as we might have read shallow metadata via a .d.ts file\n        // for the symbol.\n        var resultFromSummary = this._resolveSymbolFromSummary(staticSymbol);\n        if (resultFromSummary) {\n            return resultFromSummary;\n        }\n        var resultFromCache = this.resolvedSymbols.get(staticSymbol);\n        if (resultFromCache) {\n            return resultFromCache;\n        }\n        // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n        // have summaries, only .d.ts files. So we always need to check both, the summary\n        // and metadata.\n        this._createSymbolsOf(staticSymbol.filePath);\n        return this.resolvedSymbols.get(staticSymbol);\n    };\n    /**\n     * getImportAs produces a symbol that can be used to import the given symbol.\n     * The import might be different than the symbol if the symbol is exported from\n     * a library with a summary; in which case we want to import the symbol from the\n     * ngfactory re-export instead of directly to avoid introducing a direct dependency\n     * on an otherwise indirect dependency.\n     *\n     * @param staticSymbol the symbol for which to generate a import symbol\n     */\n    StaticSymbolResolver.prototype.getImportAs = function (staticSymbol, useSummaries) {\n        if (useSummaries === void 0) { useSummaries = true; }\n        if (staticSymbol.members.length) {\n            var baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n            var baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n            return baseImportAs ?\n                this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :\n                null;\n        }\n        var summarizedFileName = stripSummaryForJitFileSuffix(staticSymbol.filePath);\n        if (summarizedFileName !== staticSymbol.filePath) {\n            var summarizedName = stripSummaryForJitNameSuffix(staticSymbol.name);\n            var baseSymbol = this.getStaticSymbol(summarizedFileName, summarizedName, staticSymbol.members);\n            var baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n            return baseImportAs ?\n                this.getStaticSymbol(summaryForJitFileName(baseImportAs.filePath), summaryForJitName(baseImportAs.name), baseSymbol.members) :\n                null;\n        }\n        var result = (useSummaries && this.summaryResolver.getImportAs(staticSymbol)) || null;\n        if (!result) {\n            result = this.importAs.get(staticSymbol);\n        }\n        return result;\n    };\n    /**\n     * getResourcePath produces the path to the original location of the symbol and should\n     * be used to determine the relative location of resource references recorded in\n     * symbol metadata.\n     */\n    StaticSymbolResolver.prototype.getResourcePath = function (staticSymbol) {\n        return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;\n    };\n    /**\n     * getTypeArity returns the number of generic type parameters the given symbol\n     * has. If the symbol is not a type the result is null.\n     */\n    StaticSymbolResolver.prototype.getTypeArity = function (staticSymbol) {\n        // If the file is a factory/ngsummary file, don't resolve the symbol as doing so would\n        // cause the metadata for an factory/ngsummary file to be loaded which doesn't exist.\n        // All references to generated classes must include the correct arity whenever\n        // generating code.\n        if (isGeneratedFile(staticSymbol.filePath)) {\n            return null;\n        }\n        var resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(staticSymbol));\n        while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n            resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(resolvedSymbol.metadata));\n        }\n        return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;\n    };\n    StaticSymbolResolver.prototype.getKnownModuleName = function (filePath) {\n        return this.knownFileNameToModuleNames.get(filePath) || null;\n    };\n    StaticSymbolResolver.prototype.recordImportAs = function (sourceSymbol, targetSymbol) {\n        sourceSymbol.assertNoMembers();\n        targetSymbol.assertNoMembers();\n        this.importAs.set(sourceSymbol, targetSymbol);\n    };\n    StaticSymbolResolver.prototype.recordModuleNameForFileName = function (fileName, moduleName) {\n        this.knownFileNameToModuleNames.set(fileName, moduleName);\n    };\n    /**\n     * Invalidate all information derived from the given file.\n     *\n     * @param fileName the file to invalidate\n     */\n    StaticSymbolResolver.prototype.invalidateFile = function (fileName) {\n        var e_1, _a;\n        this.metadataCache.delete(fileName);\n        this.resolvedFilePaths.delete(fileName);\n        var symbols = this.symbolFromFile.get(fileName);\n        if (symbols) {\n            this.symbolFromFile.delete(fileName);\n            try {\n                for (var symbols_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(symbols), symbols_1_1 = symbols_1.next(); !symbols_1_1.done; symbols_1_1 = symbols_1.next()) {\n                    var symbol = symbols_1_1.value;\n                    this.resolvedSymbols.delete(symbol);\n                    this.importAs.delete(symbol);\n                    this.symbolResourcePaths.delete(symbol);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (symbols_1_1 && !symbols_1_1.done && (_a = symbols_1.return)) _a.call(symbols_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n    };\n    /** @internal */\n    StaticSymbolResolver.prototype.ignoreErrorsFor = function (cb) {\n        var recorder = this.errorRecorder;\n        this.errorRecorder = function () { };\n        try {\n            return cb();\n        }\n        finally {\n            this.errorRecorder = recorder;\n        }\n    };\n    StaticSymbolResolver.prototype._resolveSymbolMembers = function (staticSymbol) {\n        var members = staticSymbol.members;\n        var baseResolvedSymbol = this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n        if (!baseResolvedSymbol) {\n            return null;\n        }\n        var baseMetadata = unwrapResolvedMetadata(baseResolvedSymbol.metadata);\n        if (baseMetadata instanceof StaticSymbol) {\n            return new ResolvedStaticSymbol(staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n        }\n        else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n            if (baseMetadata.statics && members.length === 1) {\n                return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n            }\n        }\n        else {\n            var value = baseMetadata;\n            for (var i = 0; i < members.length && value; i++) {\n                value = value[members[i]];\n            }\n            return new ResolvedStaticSymbol(staticSymbol, value);\n        }\n        return null;\n    };\n    StaticSymbolResolver.prototype._resolveSymbolFromSummary = function (staticSymbol) {\n        var summary = this.summaryResolver.resolveSummary(staticSymbol);\n        return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n    };\n    /**\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\n     *\n     * @param declarationFile the absolute path of the file where the symbol is declared\n     * @param name the name of the type.\n     * @param members a symbol for a static member of the named type\n     */\n    StaticSymbolResolver.prototype.getStaticSymbol = function (declarationFile, name, members) {\n        return this.staticSymbolCache.get(declarationFile, name, members);\n    };\n    /**\n     * hasDecorators checks a file's metadata for the presence of decorators without evaluating the\n     * metadata.\n     *\n     * @param filePath the absolute path to examine for decorators.\n     * @returns true if any class in the file has a decorator.\n     */\n    StaticSymbolResolver.prototype.hasDecorators = function (filePath) {\n        var metadata = this.getModuleMetadata(filePath);\n        if (metadata['metadata']) {\n            return Object.keys(metadata['metadata']).some(function (metadataKey) {\n                var entry = metadata['metadata'][metadataKey];\n                return entry && entry.__symbolic === 'class' && entry.decorators;\n            });\n        }\n        return false;\n    };\n    StaticSymbolResolver.prototype.getSymbolsOf = function (filePath) {\n        var summarySymbols = this.summaryResolver.getSymbolsOf(filePath);\n        if (summarySymbols) {\n            return summarySymbols;\n        }\n        // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n        // have summaries, only .d.ts files, but `summaryResolver.isLibraryFile` returns true.\n        this._createSymbolsOf(filePath);\n        var metadataSymbols = [];\n        this.resolvedSymbols.forEach(function (resolvedSymbol) {\n            if (resolvedSymbol.symbol.filePath === filePath) {\n                metadataSymbols.push(resolvedSymbol.symbol);\n            }\n        });\n        return metadataSymbols;\n    };\n    StaticSymbolResolver.prototype._createSymbolsOf = function (filePath) {\n        var e_2, _a;\n        var _this = this;\n        if (this.resolvedFilePaths.has(filePath)) {\n            return;\n        }\n        this.resolvedFilePaths.add(filePath);\n        var resolvedSymbols = [];\n        var metadata = this.getModuleMetadata(filePath);\n        if (metadata['importAs']) {\n            // Index bundle indices should use the importAs module name defined\n            // in the bundle.\n            this.knownFileNameToModuleNames.set(filePath, metadata['importAs']);\n        }\n        // handle the symbols in one of the re-export location\n        if (metadata['exports']) {\n            var _loop_1 = function (moduleExport) {\n                // handle the symbols in the list of explicitly re-exported symbols.\n                if (moduleExport.export) {\n                    moduleExport.export.forEach(function (exportSymbol) {\n                        var symbolName;\n                        if (typeof exportSymbol === 'string') {\n                            symbolName = exportSymbol;\n                        }\n                        else {\n                            symbolName = exportSymbol.as;\n                        }\n                        symbolName = unescapeIdentifier(symbolName);\n                        var symName = symbolName;\n                        if (typeof exportSymbol !== 'string') {\n                            symName = unescapeIdentifier(exportSymbol.name);\n                        }\n                        var resolvedModule = _this.resolveModule(moduleExport.from, filePath);\n                        if (resolvedModule) {\n                            var targetSymbol = _this.getStaticSymbol(resolvedModule, symName);\n                            var sourceSymbol = _this.getStaticSymbol(filePath, symbolName);\n                            resolvedSymbols.push(_this.createExport(sourceSymbol, targetSymbol));\n                        }\n                    });\n                }\n                else {\n                    // handle the symbols via export * directives.\n                    var resolvedModule = this_1.resolveModule(moduleExport.from, filePath);\n                    if (resolvedModule) {\n                        var nestedExports = this_1.getSymbolsOf(resolvedModule);\n                        nestedExports.forEach(function (targetSymbol) {\n                            var sourceSymbol = _this.getStaticSymbol(filePath, targetSymbol.name);\n                            resolvedSymbols.push(_this.createExport(sourceSymbol, targetSymbol));\n                        });\n                    }\n                }\n            };\n            var this_1 = this;\n            try {\n                for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(metadata['exports']), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var moduleExport = _c.value;\n                    _loop_1(moduleExport);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n        // handle the actual metadata. Has to be after the exports\n        // as there might be collisions in the names, and we want the symbols\n        // of the current module to win ofter reexports.\n        if (metadata['metadata']) {\n            // handle direct declarations of the symbol\n            var topLevelSymbolNames_1 = new Set(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n            var origins_1 = metadata['origins'] || {};\n            Object.keys(metadata['metadata']).forEach(function (metadataKey) {\n                var symbolMeta = metadata['metadata'][metadataKey];\n                var name = unescapeIdentifier(metadataKey);\n                var symbol = _this.getStaticSymbol(filePath, name);\n                var origin = origins_1.hasOwnProperty(metadataKey) && origins_1[metadataKey];\n                if (origin) {\n                    // If the symbol is from a bundled index, use the declaration location of the\n                    // symbol so relative references (such as './my.html') will be calculated\n                    // correctly.\n                    var originFilePath = _this.resolveModule(origin, filePath);\n                    if (!originFilePath) {\n                        _this.reportError(new Error(\"Couldn't resolve original symbol for \" + origin + \" from \" + _this.host.getOutputName(filePath)));\n                    }\n                    else {\n                        _this.symbolResourcePaths.set(symbol, originFilePath);\n                    }\n                }\n                resolvedSymbols.push(_this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames_1, symbolMeta));\n            });\n        }\n        resolvedSymbols.forEach(function (resolvedSymbol) { return _this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol); });\n        this.symbolFromFile.set(filePath, resolvedSymbols.map(function (resolvedSymbol) { return resolvedSymbol.symbol; }));\n    };\n    StaticSymbolResolver.prototype.createResolvedSymbol = function (sourceSymbol, topLevelPath, topLevelSymbolNames, metadata) {\n        var _this = this;\n        // For classes that don't have Angular summaries / metadata,\n        // we only keep their arity, but nothing else\n        // (e.g. their constructor parameters).\n        // We do this to prevent introducing deep imports\n        // as we didn't generate .ngfactory.ts files with proper reexports.\n        var isTsFile = TS.test(sourceSymbol.filePath);\n        if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && !isTsFile && metadata &&\n            metadata['__symbolic'] === 'class') {\n            var transformedMeta_1 = { __symbolic: 'class', arity: metadata.arity };\n            return new ResolvedStaticSymbol(sourceSymbol, transformedMeta_1);\n        }\n        var _originalFileMemo;\n        var getOriginalName = function () {\n            if (!_originalFileMemo) {\n                // Guess what the original file name is from the reference. If it has a `.d.ts` extension\n                // replace it with `.ts`. If it already has `.ts` just leave it in place. If it doesn't have\n                // .ts or .d.ts, append `.ts'. Also, if it is in `node_modules`, trim the `node_module`\n                // location as it is not important to finding the file.\n                _originalFileMemo =\n                    _this.host.getOutputName(topLevelPath.replace(/((\\.ts)|(\\.d\\.ts)|)$/, '.ts')\n                        .replace(/^.*node_modules[/\\\\]/, ''));\n            }\n            return _originalFileMemo;\n        };\n        var self = this;\n        var ReferenceTransformer = /** @class */ (function (_super) {\n            Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ReferenceTransformer, _super);\n            function ReferenceTransformer() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            ReferenceTransformer.prototype.visitStringMap = function (map, functionParams) {\n                var symbolic = map['__symbolic'];\n                if (symbolic === 'function') {\n                    var oldLen = functionParams.length;\n                    functionParams.push.apply(functionParams, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])((map['parameters'] || [])));\n                    var result = _super.prototype.visitStringMap.call(this, map, functionParams);\n                    functionParams.length = oldLen;\n                    return result;\n                }\n                else if (symbolic === 'reference') {\n                    var module = map['module'];\n                    var name_1 = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n                    if (!name_1) {\n                        return null;\n                    }\n                    var filePath = void 0;\n                    if (module) {\n                        filePath = self.resolveModule(module, sourceSymbol.filePath);\n                        if (!filePath) {\n                            return {\n                                __symbolic: 'error',\n                                message: \"Could not resolve \" + module + \" relative to \" + self.host.getMetadataFor(sourceSymbol.filePath) + \".\",\n                                line: map['line'],\n                                character: map['character'],\n                                fileName: getOriginalName()\n                            };\n                        }\n                        return {\n                            __symbolic: 'resolved',\n                            symbol: self.getStaticSymbol(filePath, name_1),\n                            line: map['line'],\n                            character: map['character'],\n                            fileName: getOriginalName()\n                        };\n                    }\n                    else if (functionParams.indexOf(name_1) >= 0) {\n                        // reference to a function parameter\n                        return { __symbolic: 'reference', name: name_1 };\n                    }\n                    else {\n                        if (topLevelSymbolNames.has(name_1)) {\n                            return self.getStaticSymbol(topLevelPath, name_1);\n                        }\n                        // ambient value\n                        null;\n                    }\n                }\n                else if (symbolic === 'error') {\n                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, map, { fileName: getOriginalName() });\n                }\n                else {\n                    return _super.prototype.visitStringMap.call(this, map, functionParams);\n                }\n            };\n            return ReferenceTransformer;\n        }(ValueTransformer));\n        var transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n        var unwrappedTransformedMeta = unwrapResolvedMetadata(transformedMeta);\n        if (unwrappedTransformedMeta instanceof StaticSymbol) {\n            return this.createExport(sourceSymbol, unwrappedTransformedMeta);\n        }\n        return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n    };\n    StaticSymbolResolver.prototype.createExport = function (sourceSymbol, targetSymbol) {\n        sourceSymbol.assertNoMembers();\n        targetSymbol.assertNoMembers();\n        if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) &&\n            this.summaryResolver.isLibraryFile(targetSymbol.filePath)) {\n            // This case is for an ng library importing symbols from a plain ts library\n            // transitively.\n            // Note: We rely on the fact that we discover symbols in the direction\n            // from source files to library files\n            this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n        }\n        return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n    };\n    StaticSymbolResolver.prototype.reportError = function (error, context, path) {\n        if (this.errorRecorder) {\n            this.errorRecorder(error, (context && context.filePath) || path);\n        }\n        else {\n            throw error;\n        }\n    };\n    /**\n     * @param module an absolute path to a module file.\n     */\n    StaticSymbolResolver.prototype.getModuleMetadata = function (module) {\n        var moduleMetadata = this.metadataCache.get(module);\n        if (!moduleMetadata) {\n            var moduleMetadatas = this.host.getMetadataFor(module);\n            if (moduleMetadatas) {\n                var maxVersion_1 = -1;\n                moduleMetadatas.forEach(function (md) {\n                    if (md && md['version'] > maxVersion_1) {\n                        maxVersion_1 = md['version'];\n                        moduleMetadata = md;\n                    }\n                });\n            }\n            if (!moduleMetadata) {\n                moduleMetadata =\n                    { __symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {} };\n            }\n            if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n                var errorMessage = moduleMetadata['version'] == 2 ?\n                    \"Unsupported metadata version \" + moduleMetadata['version'] + \" for module \" + module + \". This module should be compiled with a newer version of ngc\" :\n                    \"Metadata version mismatch for module \" + this.host.getOutputName(module) + \", found version \" + moduleMetadata['version'] + \", expected \" + SUPPORTED_SCHEMA_VERSION;\n                this.reportError(new Error(errorMessage));\n            }\n            this.metadataCache.set(module, moduleMetadata);\n        }\n        return moduleMetadata;\n    };\n    StaticSymbolResolver.prototype.getSymbolByModule = function (module, symbolName, containingFile) {\n        var filePath = this.resolveModule(module, containingFile);\n        if (!filePath) {\n            this.reportError(new Error(\"Could not resolve module \" + module + (containingFile ? ' relative to ' +\n                this.host.getOutputName(containingFile) : '')));\n            return this.getStaticSymbol(\"ERROR:\" + module, symbolName);\n        }\n        return this.getStaticSymbol(filePath, symbolName);\n    };\n    StaticSymbolResolver.prototype.resolveModule = function (module, containingFile) {\n        try {\n            return this.host.moduleNameToFileName(module, containingFile);\n        }\n        catch (e) {\n            console.error(\"Could not resolve module '\" + module + \"' relative to file \" + containingFile);\n            this.reportError(e, undefined, containingFile);\n        }\n        return null;\n    };\n    return StaticSymbolResolver;\n}());\n// Remove extra underscore from escaped identifier.\n// See https://github.com/Microsoft/TypeScript/blob/master/src/compiler/utilities.ts\nfunction unescapeIdentifier(identifier) {\n    return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n}\nfunction unwrapResolvedMetadata(metadata) {\n    if (metadata && metadata.__symbolic === 'resolved') {\n        return metadata.symbol;\n    }\n    return metadata;\n}\n\nfunction serializeSummaries(srcFileName, forJitCtx, summaryResolver, symbolResolver, symbols, types, createExternalSymbolReexports) {\n    if (createExternalSymbolReexports === void 0) { createExternalSymbolReexports = false; }\n    var toJsonSerializer = new ToJsonSerializer(symbolResolver, summaryResolver, srcFileName);\n    // for symbols, we use everything except for the class metadata itself\n    // (we keep the statics though), as the class metadata is contained in the\n    // CompileTypeSummary.\n    symbols.forEach(function (resolvedSymbol) { return toJsonSerializer.addSummary({ symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata }); });\n    // Add type summaries.\n    types.forEach(function (_a) {\n        var summary = _a.summary, metadata = _a.metadata;\n        toJsonSerializer.addSummary({ symbol: summary.type.reference, metadata: undefined, type: summary });\n    });\n    var _a = toJsonSerializer.serialize(createExternalSymbolReexports), json = _a.json, exportAs = _a.exportAs;\n    if (forJitCtx) {\n        var forJitSerializer_1 = new ForJitSerializer(forJitCtx, symbolResolver, summaryResolver);\n        types.forEach(function (_a) {\n            var summary = _a.summary, metadata = _a.metadata;\n            forJitSerializer_1.addSourceType(summary, metadata);\n        });\n        toJsonSerializer.unprocessedSymbolSummariesBySymbol.forEach(function (summary) {\n            if (summaryResolver.isLibraryFile(summary.symbol.filePath) && summary.type) {\n                forJitSerializer_1.addLibType(summary.type);\n            }\n        });\n        forJitSerializer_1.serialize(exportAs);\n    }\n    return { json: json, exportAs: exportAs };\n}\nfunction deserializeSummaries(symbolCache, summaryResolver, libraryFileName, json) {\n    var deserializer = new FromJsonDeserializer(symbolCache, summaryResolver);\n    return deserializer.deserialize(libraryFileName, json);\n}\nfunction createForJitStub(outputCtx, reference) {\n    return createSummaryForJitFunction(outputCtx, reference, NULL_EXPR);\n}\nfunction createSummaryForJitFunction(outputCtx, reference, value) {\n    var fnName = summaryForJitName(reference.name);\n    outputCtx.statements.push(fn([], [new ReturnStatement(value)], new ArrayType(DYNAMIC_TYPE)).toDeclStmt(fnName, [\n        StmtModifier.Final, StmtModifier.Exported\n    ]));\n}\nvar ToJsonSerializer = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ToJsonSerializer, _super);\n    function ToJsonSerializer(symbolResolver, summaryResolver, srcFileName) {\n        var _this = _super.call(this) || this;\n        _this.symbolResolver = symbolResolver;\n        _this.summaryResolver = summaryResolver;\n        _this.srcFileName = srcFileName;\n        // Note: This only contains symbols without members.\n        _this.symbols = [];\n        _this.indexBySymbol = new Map();\n        _this.reexportedBy = new Map();\n        // This now contains a `__symbol: number` in the place of\n        // StaticSymbols, but otherwise has the same shape as the original objects.\n        _this.processedSummaryBySymbol = new Map();\n        _this.processedSummaries = [];\n        _this.unprocessedSymbolSummariesBySymbol = new Map();\n        _this.moduleName = symbolResolver.getKnownModuleName(srcFileName);\n        return _this;\n    }\n    ToJsonSerializer.prototype.addSummary = function (summary) {\n        var _this = this;\n        var unprocessedSummary = this.unprocessedSymbolSummariesBySymbol.get(summary.symbol);\n        var processedSummary = this.processedSummaryBySymbol.get(summary.symbol);\n        if (!unprocessedSummary) {\n            unprocessedSummary = { symbol: summary.symbol, metadata: undefined };\n            this.unprocessedSymbolSummariesBySymbol.set(summary.symbol, unprocessedSummary);\n            processedSummary = { symbol: this.processValue(summary.symbol, 0 /* None */) };\n            this.processedSummaries.push(processedSummary);\n            this.processedSummaryBySymbol.set(summary.symbol, processedSummary);\n        }\n        if (!unprocessedSummary.metadata && summary.metadata) {\n            var metadata_1 = summary.metadata || {};\n            if (metadata_1.__symbolic === 'class') {\n                // For classes, we keep everything except their class decorators.\n                // We need to keep e.g. the ctor args, method names, method decorators\n                // so that the class can be extended in another compilation unit.\n                // We don't keep the class decorators as\n                // 1) they refer to data\n                //   that should not cause a rebuild of downstream compilation units\n                //   (e.g. inline templates of @Component, or @NgModule.declarations)\n                // 2) their data is already captured in TypeSummaries, e.g. DirectiveSummary.\n                var clone_1 = {};\n                Object.keys(metadata_1).forEach(function (propName) {\n                    if (propName !== 'decorators') {\n                        clone_1[propName] = metadata_1[propName];\n                    }\n                });\n                metadata_1 = clone_1;\n            }\n            else if (isCall(metadata_1)) {\n                if (!isFunctionCall(metadata_1) && !isMethodCallOnVariable(metadata_1)) {\n                    // Don't store complex calls as we won't be able to simplify them anyways later on.\n                    metadata_1 = {\n                        __symbolic: 'error',\n                        message: 'Complex function calls are not supported.',\n                    };\n                }\n            }\n            // Note: We need to keep storing ctor calls for e.g.\n            // `export const x = new InjectionToken(...)`\n            unprocessedSummary.metadata = metadata_1;\n            processedSummary.metadata = this.processValue(metadata_1, 1 /* ResolveValue */);\n            if (metadata_1 instanceof StaticSymbol &&\n                this.summaryResolver.isLibraryFile(metadata_1.filePath)) {\n                var declarationSymbol = this.symbols[this.indexBySymbol.get(metadata_1)];\n                if (!isLoweredSymbol(declarationSymbol.name)) {\n                    // Note: symbols that were introduced during codegen in the user file can have a reexport\n                    // if a user used `export *`. However, we can't rely on this as tsickle will change\n                    // `export *` into named exports, using only the information from the typechecker.\n                    // As we introduce the new symbols after typecheck, Tsickle does not know about them,\n                    // and omits them when expanding `export *`.\n                    // So we have to keep reexporting these symbols manually via .ngfactory files.\n                    this.reexportedBy.set(declarationSymbol, summary.symbol);\n                }\n            }\n        }\n        if (!unprocessedSummary.type && summary.type) {\n            unprocessedSummary.type = summary.type;\n            // Note: We don't add the summaries of all referenced symbols as for the ResolvedSymbols,\n            // as the type summaries already contain the transitive data that they require\n            // (in a minimal way).\n            processedSummary.type = this.processValue(summary.type, 0 /* None */);\n            // except for reexported directives / pipes, so we need to store\n            // their summaries explicitly.\n            if (summary.type.summaryKind === CompileSummaryKind.NgModule) {\n                var ngModuleSummary = summary.type;\n                ngModuleSummary.exportedDirectives.concat(ngModuleSummary.exportedPipes).forEach(function (id) {\n                    var symbol = id.reference;\n                    if (_this.summaryResolver.isLibraryFile(symbol.filePath) &&\n                        !_this.unprocessedSymbolSummariesBySymbol.has(symbol)) {\n                        var summary_1 = _this.summaryResolver.resolveSummary(symbol);\n                        if (summary_1) {\n                            _this.addSummary(summary_1);\n                        }\n                    }\n                });\n            }\n        }\n    };\n    /**\n     * @param createExternalSymbolReexports Whether external static symbols should be re-exported.\n     * This can be enabled if external symbols should be re-exported by the current module in\n     * order to avoid dynamically generated module dependencies which can break strict dependency\n     * enforcements (as in Google3). Read more here: https://github.com/angular/angular/issues/25644\n     */\n    ToJsonSerializer.prototype.serialize = function (createExternalSymbolReexports) {\n        var _this = this;\n        var exportAs = [];\n        var json = JSON.stringify({\n            moduleName: this.moduleName,\n            summaries: this.processedSummaries,\n            symbols: this.symbols.map(function (symbol, index) {\n                symbol.assertNoMembers();\n                var importAs = undefined;\n                if (_this.summaryResolver.isLibraryFile(symbol.filePath)) {\n                    var reexportSymbol = _this.reexportedBy.get(symbol);\n                    if (reexportSymbol) {\n                        // In case the given external static symbol is already manually exported by the\n                        // user, we just proxy the external static symbol reference to the manual export.\n                        // This ensures that the AOT compiler imports the external symbol through the\n                        // user export and does not introduce another dependency which is not needed.\n                        importAs = _this.indexBySymbol.get(reexportSymbol);\n                    }\n                    else if (createExternalSymbolReexports) {\n                        // In this case, the given external static symbol is *not* manually exported by\n                        // the user, and we manually create a re-export in the factory file so that we\n                        // don't introduce another module dependency. This is useful when running within\n                        // Bazel so that the AOT compiler does not introduce any module dependencies\n                        // which can break the strict dependency enforcement. (e.g. as in Google3)\n                        // Read more about this here: https://github.com/angular/angular/issues/25644\n                        var summary = _this.unprocessedSymbolSummariesBySymbol.get(symbol);\n                        if (!summary || !summary.metadata || summary.metadata.__symbolic !== 'interface') {\n                            importAs = symbol.name + \"_\" + index;\n                            exportAs.push({ symbol: symbol, exportAs: importAs });\n                        }\n                    }\n                }\n                return {\n                    __symbol: index,\n                    name: symbol.name,\n                    filePath: _this.summaryResolver.toSummaryFileName(symbol.filePath, _this.srcFileName),\n                    importAs: importAs\n                };\n            })\n        });\n        return { json: json, exportAs: exportAs };\n    };\n    ToJsonSerializer.prototype.processValue = function (value, flags) {\n        return visitValue(value, this, flags);\n    };\n    ToJsonSerializer.prototype.visitOther = function (value, context) {\n        if (value instanceof StaticSymbol) {\n            var baseSymbol = this.symbolResolver.getStaticSymbol(value.filePath, value.name);\n            var index = this.visitStaticSymbol(baseSymbol, context);\n            return { __symbol: index, members: value.members };\n        }\n    };\n    /**\n     * Strip line and character numbers from ngsummaries.\n     * Emitting them causes white spaces changes to retrigger upstream\n     * recompilations in bazel.\n     * TODO: find out a way to have line and character numbers in errors without\n     * excessive recompilation in bazel.\n     */\n    ToJsonSerializer.prototype.visitStringMap = function (map, context) {\n        if (map['__symbolic'] === 'resolved') {\n            return visitValue(map['symbol'], this, context);\n        }\n        if (map['__symbolic'] === 'error') {\n            delete map['line'];\n            delete map['character'];\n        }\n        return _super.prototype.visitStringMap.call(this, map, context);\n    };\n    /**\n     * Returns null if the options.resolveValue is true, and the summary for the symbol\n     * resolved to a type or could not be resolved.\n     */\n    ToJsonSerializer.prototype.visitStaticSymbol = function (baseSymbol, flags) {\n        var index = this.indexBySymbol.get(baseSymbol);\n        var summary = null;\n        if (flags & 1 /* ResolveValue */ &&\n            this.summaryResolver.isLibraryFile(baseSymbol.filePath)) {\n            if (this.unprocessedSymbolSummariesBySymbol.has(baseSymbol)) {\n                // the summary for this symbol was already added\n                // -> nothing to do.\n                return index;\n            }\n            summary = this.loadSummary(baseSymbol);\n            if (summary && summary.metadata instanceof StaticSymbol) {\n                // The summary is a reexport\n                index = this.visitStaticSymbol(summary.metadata, flags);\n                // reset the summary as it is just a reexport, so we don't want to store it.\n                summary = null;\n            }\n        }\n        else if (index != null) {\n            // Note: == on purpose to compare with undefined!\n            // No summary and the symbol is already added -> nothing to do.\n            return index;\n        }\n        // Note: == on purpose to compare with undefined!\n        if (index == null) {\n            index = this.symbols.length;\n            this.symbols.push(baseSymbol);\n        }\n        this.indexBySymbol.set(baseSymbol, index);\n        if (summary) {\n            this.addSummary(summary);\n        }\n        return index;\n    };\n    ToJsonSerializer.prototype.loadSummary = function (symbol) {\n        var summary = this.summaryResolver.resolveSummary(symbol);\n        if (!summary) {\n            // some symbols might originate from a plain typescript library\n            // that just exported .d.ts and .metadata.json files, i.e. where no summary\n            // files were created.\n            var resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n            if (resolvedSymbol) {\n                summary = { symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata };\n            }\n        }\n        return summary;\n    };\n    return ToJsonSerializer;\n}(ValueTransformer));\nvar ForJitSerializer = /** @class */ (function () {\n    function ForJitSerializer(outputCtx, symbolResolver, summaryResolver) {\n        this.outputCtx = outputCtx;\n        this.symbolResolver = symbolResolver;\n        this.summaryResolver = summaryResolver;\n        this.data = [];\n    }\n    ForJitSerializer.prototype.addSourceType = function (summary, metadata) {\n        this.data.push({ summary: summary, metadata: metadata, isLibrary: false });\n    };\n    ForJitSerializer.prototype.addLibType = function (summary) {\n        this.data.push({ summary: summary, metadata: null, isLibrary: true });\n    };\n    ForJitSerializer.prototype.serialize = function (exportAsArr) {\n        var e_1, _a, e_2, _b, e_3, _c;\n        var _this = this;\n        var exportAsBySymbol = new Map();\n        try {\n            for (var exportAsArr_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(exportAsArr), exportAsArr_1_1 = exportAsArr_1.next(); !exportAsArr_1_1.done; exportAsArr_1_1 = exportAsArr_1.next()) {\n                var _d = exportAsArr_1_1.value, symbol = _d.symbol, exportAs = _d.exportAs;\n                exportAsBySymbol.set(symbol, exportAs);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (exportAsArr_1_1 && !exportAsArr_1_1.done && (_a = exportAsArr_1.return)) _a.call(exportAsArr_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var ngModuleSymbols = new Set();\n        try {\n            for (var _e = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(this.data), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var _g = _f.value, summary = _g.summary, metadata = _g.metadata, isLibrary = _g.isLibrary;\n                if (summary.summaryKind === CompileSummaryKind.NgModule) {\n                    // collect the symbols that refer to NgModule classes.\n                    // Note: we can't just rely on `summary.type.summaryKind` to determine this as\n                    // we don't add the summaries of all referenced symbols when we serialize type summaries.\n                    // See serializeSummaries for details.\n                    ngModuleSymbols.add(summary.type.reference);\n                    var modSummary = summary;\n                    try {\n                        for (var _h = (e_3 = void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(modSummary.modules)), _j = _h.next(); !_j.done; _j = _h.next()) {\n                            var mod = _j.value;\n                            ngModuleSymbols.add(mod.reference);\n                        }\n                    }\n                    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                    finally {\n                        try {\n                            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n                        }\n                        finally { if (e_3) throw e_3.error; }\n                    }\n                }\n                if (!isLibrary) {\n                    var fnName = summaryForJitName(summary.type.reference.name);\n                    createSummaryForJitFunction(this.outputCtx, summary.type.reference, this.serializeSummaryWithDeps(summary, metadata));\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        ngModuleSymbols.forEach(function (ngModuleSymbol) {\n            if (_this.summaryResolver.isLibraryFile(ngModuleSymbol.filePath)) {\n                var exportAs = exportAsBySymbol.get(ngModuleSymbol) || ngModuleSymbol.name;\n                var jitExportAsName = summaryForJitName(exportAs);\n                _this.outputCtx.statements.push(variable(jitExportAsName)\n                    .set(_this.serializeSummaryRef(ngModuleSymbol))\n                    .toDeclStmt(null, [StmtModifier.Exported]));\n            }\n        });\n    };\n    ForJitSerializer.prototype.serializeSummaryWithDeps = function (summary, metadata) {\n        var _this = this;\n        var expressions = [this.serializeSummary(summary)];\n        var providers = [];\n        if (metadata instanceof CompileNgModuleMetadata) {\n            expressions.push.apply(expressions, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(\n            // For directives / pipes, we only add the declared ones,\n            // and rely on transitively importing NgModules to get the transitive\n            // summaries.\n            metadata.declaredDirectives.concat(metadata.declaredPipes)\n                .map(function (type) { return type.reference; })\n                // For modules,\n                // we also add the summaries for modules\n                // from libraries.\n                // This is ok as we produce reexports for all transitive modules.\n                .concat(metadata.transitiveModule.modules.map(function (type) { return type.reference; })\n                .filter(function (ref) { return ref !== metadata.type.reference; }))\n                .map(function (ref) { return _this.serializeSummaryRef(ref); })));\n            // Note: We don't use `NgModuleSummary.providers`, as that one is transitive,\n            // and we already have transitive modules.\n            providers = metadata.providers;\n        }\n        else if (summary.summaryKind === CompileSummaryKind.Directive) {\n            var dirSummary = summary;\n            providers = dirSummary.providers.concat(dirSummary.viewProviders);\n        }\n        // Note: We can't just refer to the `ngsummary.ts` files for `useClass` providers (as we do for\n        // declaredDirectives / declaredPipes), as we allow\n        // providers without ctor arguments to skip the `@Injectable` decorator,\n        // i.e. we didn't generate .ngsummary.ts files for these.\n        expressions.push.apply(expressions, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(providers.filter(function (provider) { return !!provider.useClass; }).map(function (provider) { return _this.serializeSummary({\n            summaryKind: CompileSummaryKind.Injectable, type: provider.useClass\n        }); })));\n        return literalArr(expressions);\n    };\n    ForJitSerializer.prototype.serializeSummaryRef = function (typeSymbol) {\n        var jitImportedSymbol = this.symbolResolver.getStaticSymbol(summaryForJitFileName(typeSymbol.filePath), summaryForJitName(typeSymbol.name));\n        return this.outputCtx.importExpr(jitImportedSymbol);\n    };\n    ForJitSerializer.prototype.serializeSummary = function (data) {\n        var outputCtx = this.outputCtx;\n        var Transformer = /** @class */ (function () {\n            function Transformer() {\n            }\n            Transformer.prototype.visitArray = function (arr, context) {\n                var _this = this;\n                return literalArr(arr.map(function (entry) { return visitValue(entry, _this, context); }));\n            };\n            Transformer.prototype.visitStringMap = function (map, context) {\n                var _this = this;\n                return new LiteralMapExpr(Object.keys(map).map(function (key) { return new LiteralMapEntry(key, visitValue(map[key], _this, context), false); }));\n            };\n            Transformer.prototype.visitPrimitive = function (value, context) { return literal(value); };\n            Transformer.prototype.visitOther = function (value, context) {\n                if (value instanceof StaticSymbol) {\n                    return outputCtx.importExpr(value);\n                }\n                else {\n                    throw new Error(\"Illegal State: Encountered value \" + value);\n                }\n            };\n            return Transformer;\n        }());\n        return visitValue(data, new Transformer(), null);\n    };\n    return ForJitSerializer;\n}());\nvar FromJsonDeserializer = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(FromJsonDeserializer, _super);\n    function FromJsonDeserializer(symbolCache, summaryResolver) {\n        var _this = _super.call(this) || this;\n        _this.symbolCache = symbolCache;\n        _this.summaryResolver = summaryResolver;\n        return _this;\n    }\n    FromJsonDeserializer.prototype.deserialize = function (libraryFileName, json) {\n        var _this = this;\n        var data = JSON.parse(json);\n        var allImportAs = [];\n        this.symbols = data.symbols.map(function (serializedSymbol) { return _this.symbolCache.get(_this.summaryResolver.fromSummaryFileName(serializedSymbol.filePath, libraryFileName), serializedSymbol.name); });\n        data.symbols.forEach(function (serializedSymbol, index) {\n            var symbol = _this.symbols[index];\n            var importAs = serializedSymbol.importAs;\n            if (typeof importAs === 'number') {\n                allImportAs.push({ symbol: symbol, importAs: _this.symbols[importAs] });\n            }\n            else if (typeof importAs === 'string') {\n                allImportAs.push({ symbol: symbol, importAs: _this.symbolCache.get(ngfactoryFilePath(libraryFileName), importAs) });\n            }\n        });\n        var summaries = visitValue(data.summaries, this, null);\n        return { moduleName: data.moduleName, summaries: summaries, importAs: allImportAs };\n    };\n    FromJsonDeserializer.prototype.visitStringMap = function (map, context) {\n        if ('__symbol' in map) {\n            var baseSymbol = this.symbols[map['__symbol']];\n            var members = map['members'];\n            return members.length ? this.symbolCache.get(baseSymbol.filePath, baseSymbol.name, members) :\n                baseSymbol;\n        }\n        else {\n            return _super.prototype.visitStringMap.call(this, map, context);\n        }\n    };\n    return FromJsonDeserializer;\n}(ValueTransformer));\nfunction isCall(metadata) {\n    return metadata && metadata.__symbolic === 'call';\n}\nfunction isFunctionCall(metadata) {\n    return isCall(metadata) && unwrapResolvedMetadata(metadata.expression) instanceof StaticSymbol;\n}\nfunction isMethodCallOnVariable(metadata) {\n    return isCall(metadata) && metadata.expression && metadata.expression.__symbolic === 'select' &&\n        unwrapResolvedMetadata(metadata.expression.expression) instanceof StaticSymbol;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar AotCompiler = /** @class */ (function () {\n    function AotCompiler(_config, _options, _host, reflector, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _typeCheckCompiler, _ngModuleCompiler, _injectableCompiler, _outputEmitter, _summaryResolver, _symbolResolver) {\n        this._config = _config;\n        this._options = _options;\n        this._host = _host;\n        this.reflector = reflector;\n        this._metadataResolver = _metadataResolver;\n        this._templateParser = _templateParser;\n        this._styleCompiler = _styleCompiler;\n        this._viewCompiler = _viewCompiler;\n        this._typeCheckCompiler = _typeCheckCompiler;\n        this._ngModuleCompiler = _ngModuleCompiler;\n        this._injectableCompiler = _injectableCompiler;\n        this._outputEmitter = _outputEmitter;\n        this._summaryResolver = _summaryResolver;\n        this._symbolResolver = _symbolResolver;\n        this._templateAstCache = new Map();\n        this._analyzedFiles = new Map();\n        this._analyzedFilesForInjectables = new Map();\n    }\n    AotCompiler.prototype.clearCache = function () { this._metadataResolver.clearCache(); };\n    AotCompiler.prototype.analyzeModulesSync = function (rootFiles) {\n        var _this = this;\n        var analyzeResult = analyzeAndValidateNgModules(rootFiles, this._host, this._symbolResolver, this._metadataResolver);\n        analyzeResult.ngModules.forEach(function (ngModule) { return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, true); });\n        return analyzeResult;\n    };\n    AotCompiler.prototype.analyzeModulesAsync = function (rootFiles) {\n        var _this = this;\n        var analyzeResult = analyzeAndValidateNgModules(rootFiles, this._host, this._symbolResolver, this._metadataResolver);\n        return Promise\n            .all(analyzeResult.ngModules.map(function (ngModule) { return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false); }))\n            .then(function () { return analyzeResult; });\n    };\n    AotCompiler.prototype._analyzeFile = function (fileName) {\n        var analyzedFile = this._analyzedFiles.get(fileName);\n        if (!analyzedFile) {\n            analyzedFile =\n                analyzeFile(this._host, this._symbolResolver, this._metadataResolver, fileName);\n            this._analyzedFiles.set(fileName, analyzedFile);\n        }\n        return analyzedFile;\n    };\n    AotCompiler.prototype._analyzeFileForInjectables = function (fileName) {\n        var analyzedFile = this._analyzedFilesForInjectables.get(fileName);\n        if (!analyzedFile) {\n            analyzedFile = analyzeFileForInjectables(this._host, this._symbolResolver, this._metadataResolver, fileName);\n            this._analyzedFilesForInjectables.set(fileName, analyzedFile);\n        }\n        return analyzedFile;\n    };\n    AotCompiler.prototype.findGeneratedFileNames = function (fileName) {\n        var _this = this;\n        var genFileNames = [];\n        var file = this._analyzeFile(fileName);\n        // Make sure we create a .ngfactory if we have a injectable/directive/pipe/NgModule\n        // or a reference to a non source file.\n        // Note: This is overestimating the required .ngfactory files as the real calculation is harder.\n        // Only do this for StubEmitFlags.Basic, as adding a type check block\n        // does not change this file (as we generate type check blocks based on NgModules).\n        if (this._options.allowEmptyCodegenFiles || file.directives.length || file.pipes.length ||\n            file.injectables.length || file.ngModules.length || file.exportsNonSourceFiles) {\n            genFileNames.push(ngfactoryFilePath(file.fileName, true));\n            if (this._options.enableSummariesForJit) {\n                genFileNames.push(summaryForJitFileName(file.fileName, true));\n            }\n        }\n        var fileSuffix = normalizeGenFileSuffix(splitTypescriptSuffix(file.fileName, true)[1]);\n        file.directives.forEach(function (dirSymbol) {\n            var compMeta = _this._metadataResolver.getNonNormalizedDirectiveMetadata(dirSymbol).metadata;\n            if (!compMeta.isComponent) {\n                return;\n            }\n            // Note: compMeta is a component and therefore template is non null.\n            compMeta.template.styleUrls.forEach(function (styleUrl) {\n                var normalizedUrl = _this._host.resourceNameToFileName(styleUrl, file.fileName);\n                if (!normalizedUrl) {\n                    throw syntaxError(\"Couldn't resolve resource \" + styleUrl + \" relative to \" + file.fileName);\n                }\n                var needsShim = (compMeta.template.encapsulation ||\n                    _this._config.defaultEncapsulation) === ViewEncapsulation.Emulated;\n                genFileNames.push(_stylesModuleUrl(normalizedUrl, needsShim, fileSuffix));\n                if (_this._options.allowEmptyCodegenFiles) {\n                    genFileNames.push(_stylesModuleUrl(normalizedUrl, !needsShim, fileSuffix));\n                }\n            });\n        });\n        return genFileNames;\n    };\n    AotCompiler.prototype.emitBasicStub = function (genFileName, originalFileName) {\n        var outputCtx = this._createOutputContext(genFileName);\n        if (genFileName.endsWith('.ngfactory.ts')) {\n            if (!originalFileName) {\n                throw new Error(\"Assertion error: require the original file for .ngfactory.ts stubs. File: \" + genFileName);\n            }\n            var originalFile = this._analyzeFile(originalFileName);\n            this._createNgFactoryStub(outputCtx, originalFile, 1 /* Basic */);\n        }\n        else if (genFileName.endsWith('.ngsummary.ts')) {\n            if (this._options.enableSummariesForJit) {\n                if (!originalFileName) {\n                    throw new Error(\"Assertion error: require the original file for .ngsummary.ts stubs. File: \" + genFileName);\n                }\n                var originalFile = this._analyzeFile(originalFileName);\n                _createEmptyStub(outputCtx);\n                originalFile.ngModules.forEach(function (ngModule) {\n                    // create exports that user code can reference\n                    createForJitStub(outputCtx, ngModule.type.reference);\n                });\n            }\n        }\n        else if (genFileName.endsWith('.ngstyle.ts')) {\n            _createEmptyStub(outputCtx);\n        }\n        // Note: for the stubs, we don't need a property srcFileUrl,\n        // as later on in emitAllImpls we will create the proper GeneratedFiles with the\n        // correct srcFileUrl.\n        // This is good as e.g. for .ngstyle.ts files we can't derive\n        // the url of components based on the genFileUrl.\n        return this._codegenSourceModule('unknown', outputCtx);\n    };\n    AotCompiler.prototype.emitTypeCheckStub = function (genFileName, originalFileName) {\n        var originalFile = this._analyzeFile(originalFileName);\n        var outputCtx = this._createOutputContext(genFileName);\n        if (genFileName.endsWith('.ngfactory.ts')) {\n            this._createNgFactoryStub(outputCtx, originalFile, 2 /* TypeCheck */);\n        }\n        return outputCtx.statements.length > 0 ?\n            this._codegenSourceModule(originalFile.fileName, outputCtx) :\n            null;\n    };\n    AotCompiler.prototype.loadFilesAsync = function (fileNames, tsFiles) {\n        var _this = this;\n        var files = fileNames.map(function (fileName) { return _this._analyzeFile(fileName); });\n        var loadingPromises = [];\n        files.forEach(function (file) { return file.ngModules.forEach(function (ngModule) {\n            return loadingPromises.push(_this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false));\n        }); });\n        var analyzedInjectables = tsFiles.map(function (tsFile) { return _this._analyzeFileForInjectables(tsFile); });\n        return Promise.all(loadingPromises).then(function (_) { return ({\n            analyzedModules: mergeAndValidateNgFiles(files),\n            analyzedInjectables: analyzedInjectables,\n        }); });\n    };\n    AotCompiler.prototype.loadFilesSync = function (fileNames, tsFiles) {\n        var _this = this;\n        var files = fileNames.map(function (fileName) { return _this._analyzeFile(fileName); });\n        files.forEach(function (file) { return file.ngModules.forEach(function (ngModule) { return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, true); }); });\n        var analyzedInjectables = tsFiles.map(function (tsFile) { return _this._analyzeFileForInjectables(tsFile); });\n        return {\n            analyzedModules: mergeAndValidateNgFiles(files),\n            analyzedInjectables: analyzedInjectables,\n        };\n    };\n    AotCompiler.prototype._createNgFactoryStub = function (outputCtx, file, emitFlags) {\n        var _this = this;\n        var componentId = 0;\n        file.ngModules.forEach(function (ngModuleMeta, ngModuleIndex) {\n            // Note: the code below needs to executed for StubEmitFlags.Basic and StubEmitFlags.TypeCheck,\n            // so we don't change the .ngfactory file too much when adding the type-check block.\n            // create exports that user code can reference\n            _this._ngModuleCompiler.createStub(outputCtx, ngModuleMeta.type.reference);\n            // add references to the symbols from the metadata.\n            // These can be used by the type check block for components,\n            // and they also cause TypeScript to include these files into the program too,\n            // which will make them part of the analyzedFiles.\n            var externalReferences = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(ngModuleMeta.transitiveModule.directives.map(function (d) { return d.reference; }), ngModuleMeta.transitiveModule.pipes.map(function (d) { return d.reference; }), ngModuleMeta.importedModules.map(function (m) { return m.type.reference; }), ngModuleMeta.exportedModules.map(function (m) { return m.type.reference; }), _this._externalIdentifierReferences([Identifiers.TemplateRef, Identifiers.ElementRef]));\n            var externalReferenceVars = new Map();\n            externalReferences.forEach(function (ref, typeIndex) {\n                externalReferenceVars.set(ref, \"_decl\" + ngModuleIndex + \"_\" + typeIndex);\n            });\n            externalReferenceVars.forEach(function (varName, reference) {\n                outputCtx.statements.push(variable(varName)\n                    .set(NULL_EXPR.cast(DYNAMIC_TYPE))\n                    .toDeclStmt(expressionType(outputCtx.importExpr(reference, /* typeParams */ null, /* useSummaries */ false))));\n            });\n            if (emitFlags & 2 /* TypeCheck */) {\n                // add the type-check block for all components of the NgModule\n                ngModuleMeta.declaredDirectives.forEach(function (dirId) {\n                    var compMeta = _this._metadataResolver.getDirectiveMetadata(dirId.reference);\n                    if (!compMeta.isComponent) {\n                        return;\n                    }\n                    componentId++;\n                    _this._createTypeCheckBlock(outputCtx, compMeta.type.reference.name + \"_Host_\" + componentId, ngModuleMeta, _this._metadataResolver.getHostComponentMetadata(compMeta), [compMeta.type], externalReferenceVars);\n                    _this._createTypeCheckBlock(outputCtx, compMeta.type.reference.name + \"_\" + componentId, ngModuleMeta, compMeta, ngModuleMeta.transitiveModule.directives, externalReferenceVars);\n                });\n            }\n        });\n        if (outputCtx.statements.length === 0) {\n            _createEmptyStub(outputCtx);\n        }\n    };\n    AotCompiler.prototype._externalIdentifierReferences = function (references) {\n        var e_1, _a;\n        var result = [];\n        try {\n            for (var references_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(references), references_1_1 = references_1.next(); !references_1_1.done; references_1_1 = references_1.next()) {\n                var reference = references_1_1.value;\n                var token = createTokenForExternalReference(this.reflector, reference);\n                if (token.identifier) {\n                    result.push(token.identifier.reference);\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (references_1_1 && !references_1_1.done && (_a = references_1.return)) _a.call(references_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return result;\n    };\n    AotCompiler.prototype._createTypeCheckBlock = function (ctx, componentId, moduleMeta, compMeta, directives, externalReferenceVars) {\n        var _a;\n        var _b = this._parseTemplate(compMeta, moduleMeta, directives), parsedTemplate = _b.template, usedPipes = _b.pipes;\n        (_a = ctx.statements).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this._typeCheckCompiler.compileComponent(componentId, compMeta, parsedTemplate, usedPipes, externalReferenceVars, ctx)));\n    };\n    AotCompiler.prototype.emitMessageBundle = function (analyzeResult, locale) {\n        var _this = this;\n        var errors = [];\n        var htmlParser = new HtmlParser();\n        // TODO(vicb): implicit tags & attributes\n        var messageBundle = new MessageBundle(htmlParser, [], {}, locale);\n        analyzeResult.files.forEach(function (file) {\n            var compMetas = [];\n            file.directives.forEach(function (directiveType) {\n                var dirMeta = _this._metadataResolver.getDirectiveMetadata(directiveType);\n                if (dirMeta && dirMeta.isComponent) {\n                    compMetas.push(dirMeta);\n                }\n            });\n            compMetas.forEach(function (compMeta) {\n                var html = compMeta.template.template;\n                // Template URL points to either an HTML or TS file depending on whether\n                // the file is used with `templateUrl:` or `template:`, respectively.\n                var templateUrl = compMeta.template.templateUrl;\n                var interpolationConfig = InterpolationConfig.fromArray(compMeta.template.interpolation);\n                errors.push.apply(errors, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(messageBundle.updateFromTemplate(html, templateUrl, interpolationConfig)));\n            });\n        });\n        if (errors.length) {\n            throw new Error(errors.map(function (e) { return e.toString(); }).join('\\n'));\n        }\n        return messageBundle;\n    };\n    AotCompiler.prototype.emitAllPartialModules = function (_a, r3Files) {\n        var _this = this;\n        var ngModuleByPipeOrDirective = _a.ngModuleByPipeOrDirective, files = _a.files;\n        var contextMap = new Map();\n        var getContext = function (fileName) {\n            if (!contextMap.has(fileName)) {\n                contextMap.set(fileName, _this._createOutputContext(fileName));\n            }\n            return contextMap.get(fileName);\n        };\n        files.forEach(function (file) { return _this._compilePartialModule(file.fileName, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules, file.injectables, getContext(file.fileName)); });\n        r3Files.forEach(function (file) { return _this._compileShallowModules(file.fileName, file.shallowModules, getContext(file.fileName)); });\n        return Array.from(contextMap.values())\n            .map(function (context) { return ({\n            fileName: context.genFilePath,\n            statements: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(context.constantPool.statements, context.statements),\n        }); });\n    };\n    AotCompiler.prototype._compileShallowModules = function (fileName, shallowModules, context) {\n        var _this = this;\n        shallowModules.forEach(function (module) { return compileNgModuleFromRender2(context, module, _this._injectableCompiler); });\n    };\n    AotCompiler.prototype._compilePartialModule = function (fileName, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables, context) {\n        var _this = this;\n        var errors = [];\n        var schemaRegistry = new DomElementSchemaRegistry();\n        var hostBindingParser = new BindingParser(this._templateParser.expressionParser, DEFAULT_INTERPOLATION_CONFIG, schemaRegistry, [], errors);\n        // Process all components and directives\n        directives.forEach(function (directiveType) {\n            var directiveMetadata = _this._metadataResolver.getDirectiveMetadata(directiveType);\n            if (directiveMetadata.isComponent) {\n                var module = ngModuleByPipeOrDirective.get(directiveType);\n                module ||\n                    error(\"Cannot determine the module for component '\" + identifierName(directiveMetadata.type) + \"'\");\n                var htmlAst = directiveMetadata.template.htmlAst;\n                var preserveWhitespaces = directiveMetadata.template.preserveWhitespaces;\n                if (!preserveWhitespaces) {\n                    htmlAst = removeWhitespaces(htmlAst);\n                }\n                var render3Ast = htmlAstToRender3Ast(htmlAst.rootNodes, hostBindingParser);\n                // Map of StaticType by directive selectors\n                var directiveTypeBySel_1 = new Map();\n                var directives_1 = module.transitiveModule.directives.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });\n                directives_1.forEach(function (directive) {\n                    if (directive.selector) {\n                        directiveTypeBySel_1.set(directive.selector, directive.type.reference);\n                    }\n                });\n                // Map of StaticType by pipe names\n                var pipeTypeByName_1 = new Map();\n                var pipes_1 = module.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n                pipes_1.forEach(function (pipe) { pipeTypeByName_1.set(pipe.name, pipe.type.reference); });\n                compileComponentFromRender2(context, directiveMetadata, render3Ast, _this.reflector, hostBindingParser, directiveTypeBySel_1, pipeTypeByName_1);\n            }\n            else {\n                compileDirectiveFromRender2(context, directiveMetadata, _this.reflector, hostBindingParser);\n            }\n        });\n        pipes.forEach(function (pipeType) {\n            var pipeMetadata = _this._metadataResolver.getPipeMetadata(pipeType);\n            if (pipeMetadata) {\n                compilePipeFromRender2(context, pipeMetadata, _this.reflector);\n            }\n        });\n        injectables.forEach(function (injectable) { return _this._injectableCompiler.compile(injectable, context); });\n    };\n    AotCompiler.prototype.emitAllPartialModules2 = function (files) {\n        var _this = this;\n        // Using reduce like this is a select many pattern (where map is a select pattern)\n        return files.reduce(function (r, file) {\n            r.push.apply(r, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(_this._emitPartialModule2(file.fileName, file.injectables)));\n            return r;\n        }, []);\n    };\n    AotCompiler.prototype._emitPartialModule2 = function (fileName, injectables) {\n        var _this = this;\n        var context = this._createOutputContext(fileName);\n        injectables.forEach(function (injectable) { return _this._injectableCompiler.compile(injectable, context); });\n        if (context.statements && context.statements.length > 0) {\n            return [{ fileName: fileName, statements: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(context.constantPool.statements, context.statements) }];\n        }\n        return [];\n    };\n    AotCompiler.prototype.emitAllImpls = function (analyzeResult) {\n        var _this = this;\n        var ngModuleByPipeOrDirective = analyzeResult.ngModuleByPipeOrDirective, files = analyzeResult.files;\n        var sourceModules = files.map(function (file) { return _this._compileImplFile(file.fileName, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules, file.injectables); });\n        return flatten(sourceModules);\n    };\n    AotCompiler.prototype._compileImplFile = function (srcFileUrl, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables) {\n        var _this = this;\n        var fileSuffix = normalizeGenFileSuffix(splitTypescriptSuffix(srcFileUrl, true)[1]);\n        var generatedFiles = [];\n        var outputCtx = this._createOutputContext(ngfactoryFilePath(srcFileUrl, true));\n        generatedFiles.push.apply(generatedFiles, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this._createSummary(srcFileUrl, directives, pipes, ngModules, injectables, outputCtx)));\n        // compile all ng modules\n        ngModules.forEach(function (ngModuleMeta) { return _this._compileModule(outputCtx, ngModuleMeta); });\n        // compile components\n        directives.forEach(function (dirType) {\n            var compMeta = _this._metadataResolver.getDirectiveMetadata(dirType);\n            if (!compMeta.isComponent) {\n                return;\n            }\n            var ngModule = ngModuleByPipeOrDirective.get(dirType);\n            if (!ngModule) {\n                throw new Error(\"Internal Error: cannot determine the module for component \" + identifierName(compMeta.type) + \"!\");\n            }\n            // compile styles\n            var componentStylesheet = _this._styleCompiler.compileComponent(outputCtx, compMeta);\n            // Note: compMeta is a component and therefore template is non null.\n            compMeta.template.externalStylesheets.forEach(function (stylesheetMeta) {\n                // Note: fill non shim and shim style files as they might\n                // be shared by component with and without ViewEncapsulation.\n                var shim = _this._styleCompiler.needsStyleShim(compMeta);\n                generatedFiles.push(_this._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, shim, fileSuffix));\n                if (_this._options.allowEmptyCodegenFiles) {\n                    generatedFiles.push(_this._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, !shim, fileSuffix));\n                }\n            });\n            // compile components\n            var compViewVars = _this._compileComponent(outputCtx, compMeta, ngModule, ngModule.transitiveModule.directives, componentStylesheet, fileSuffix);\n            _this._compileComponentFactory(outputCtx, compMeta, ngModule, fileSuffix);\n        });\n        if (outputCtx.statements.length > 0 || this._options.allowEmptyCodegenFiles) {\n            var srcModule = this._codegenSourceModule(srcFileUrl, outputCtx);\n            generatedFiles.unshift(srcModule);\n        }\n        return generatedFiles;\n    };\n    AotCompiler.prototype._createSummary = function (srcFileName, directives, pipes, ngModules, injectables, ngFactoryCtx) {\n        var _this = this;\n        var symbolSummaries = this._symbolResolver.getSymbolsOf(srcFileName)\n            .map(function (symbol) { return _this._symbolResolver.resolveSymbol(symbol); });\n        var typeData = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(ngModules.map(function (meta) { return ({\n            summary: _this._metadataResolver.getNgModuleSummary(meta.type.reference),\n            metadata: _this._metadataResolver.getNgModuleMetadata(meta.type.reference)\n        }); }), directives.map(function (ref) { return ({\n            summary: _this._metadataResolver.getDirectiveSummary(ref),\n            metadata: _this._metadataResolver.getDirectiveMetadata(ref)\n        }); }), pipes.map(function (ref) { return ({\n            summary: _this._metadataResolver.getPipeSummary(ref),\n            metadata: _this._metadataResolver.getPipeMetadata(ref)\n        }); }), injectables.map(function (ref) { return ({\n            summary: _this._metadataResolver.getInjectableSummary(ref.symbol),\n            metadata: _this._metadataResolver.getInjectableSummary(ref.symbol).type\n        }); }));\n        var forJitOutputCtx = this._options.enableSummariesForJit ?\n            this._createOutputContext(summaryForJitFileName(srcFileName, true)) :\n            null;\n        var _a = serializeSummaries(srcFileName, forJitOutputCtx, this._summaryResolver, this._symbolResolver, symbolSummaries, typeData, this._options.createExternalSymbolFactoryReexports), json = _a.json, exportAs = _a.exportAs;\n        exportAs.forEach(function (entry) {\n            ngFactoryCtx.statements.push(variable(entry.exportAs).set(ngFactoryCtx.importExpr(entry.symbol)).toDeclStmt(null, [\n                StmtModifier.Exported\n            ]));\n        });\n        var summaryJson = new GeneratedFile(srcFileName, summaryFileName(srcFileName), json);\n        var result = [summaryJson];\n        if (forJitOutputCtx) {\n            result.push(this._codegenSourceModule(srcFileName, forJitOutputCtx));\n        }\n        return result;\n    };\n    AotCompiler.prototype._compileModule = function (outputCtx, ngModule) {\n        var providers = [];\n        if (this._options.locale) {\n            var normalizedLocale = this._options.locale.replace(/_/g, '-');\n            providers.push({\n                token: createTokenForExternalReference(this.reflector, Identifiers.LOCALE_ID),\n                useValue: normalizedLocale,\n            });\n        }\n        if (this._options.i18nFormat) {\n            providers.push({\n                token: createTokenForExternalReference(this.reflector, Identifiers.TRANSLATIONS_FORMAT),\n                useValue: this._options.i18nFormat\n            });\n        }\n        this._ngModuleCompiler.compile(outputCtx, ngModule, providers);\n    };\n    AotCompiler.prototype._compileComponentFactory = function (outputCtx, compMeta, ngModule, fileSuffix) {\n        var hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta);\n        var hostViewFactoryVar = this._compileComponent(outputCtx, hostMeta, ngModule, [compMeta.type], null, fileSuffix)\n            .viewClassVar;\n        var compFactoryVar = componentFactoryName(compMeta.type.reference);\n        var inputsExprs = [];\n        for (var propName in compMeta.inputs) {\n            var templateName = compMeta.inputs[propName];\n            // Don't quote so that the key gets minified...\n            inputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));\n        }\n        var outputsExprs = [];\n        for (var propName in compMeta.outputs) {\n            var templateName = compMeta.outputs[propName];\n            // Don't quote so that the key gets minified...\n            outputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));\n        }\n        outputCtx.statements.push(variable(compFactoryVar)\n            .set(importExpr(Identifiers.createComponentFactory).callFn([\n            literal(compMeta.selector), outputCtx.importExpr(compMeta.type.reference),\n            variable(hostViewFactoryVar), new LiteralMapExpr(inputsExprs),\n            new LiteralMapExpr(outputsExprs),\n            literalArr(compMeta.template.ngContentSelectors.map(function (selector) { return literal(selector); }))\n        ]))\n            .toDeclStmt(importType(Identifiers.ComponentFactory, [expressionType(outputCtx.importExpr(compMeta.type.reference))], [TypeModifier.Const]), [StmtModifier.Final, StmtModifier.Exported]));\n    };\n    AotCompiler.prototype._compileComponent = function (outputCtx, compMeta, ngModule, directiveIdentifiers, componentStyles, fileSuffix) {\n        var _a = this._parseTemplate(compMeta, ngModule, directiveIdentifiers), parsedTemplate = _a.template, usedPipes = _a.pipes;\n        var stylesExpr = componentStyles ? variable(componentStyles.stylesVar) : literalArr([]);\n        var viewResult = this._viewCompiler.compileComponent(outputCtx, compMeta, parsedTemplate, stylesExpr, usedPipes);\n        if (componentStyles) {\n            _resolveStyleStatements(this._symbolResolver, componentStyles, this._styleCompiler.needsStyleShim(compMeta), fileSuffix);\n        }\n        return viewResult;\n    };\n    AotCompiler.prototype._parseTemplate = function (compMeta, ngModule, directiveIdentifiers) {\n        var _this = this;\n        if (this._templateAstCache.has(compMeta.type.reference)) {\n            return this._templateAstCache.get(compMeta.type.reference);\n        }\n        var preserveWhitespaces = compMeta.template.preserveWhitespaces;\n        var directives = directiveIdentifiers.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });\n        var pipes = ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n        var result = this._templateParser.parse(compMeta, compMeta.template.htmlAst, directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, compMeta.template), preserveWhitespaces);\n        this._templateAstCache.set(compMeta.type.reference, result);\n        return result;\n    };\n    AotCompiler.prototype._createOutputContext = function (genFilePath) {\n        var _this = this;\n        var importExpr$1 = function (symbol, typeParams, useSummaries) {\n            if (typeParams === void 0) { typeParams = null; }\n            if (useSummaries === void 0) { useSummaries = true; }\n            if (!(symbol instanceof StaticSymbol)) {\n                throw new Error(\"Internal error: unknown identifier \" + JSON.stringify(symbol));\n            }\n            var arity = _this._symbolResolver.getTypeArity(symbol) || 0;\n            var _a = _this._symbolResolver.getImportAs(symbol, useSummaries) || symbol, filePath = _a.filePath, name = _a.name, members = _a.members;\n            var importModule = _this._fileNameToModuleName(filePath, genFilePath);\n            // It should be good enough to compare filePath to genFilePath and if they are equal\n            // there is a self reference. However, ngfactory files generate to .ts but their\n            // symbols have .d.ts so a simple compare is insufficient. They should be canonical\n            // and is tracked by #17705.\n            var selfReference = _this._fileNameToModuleName(genFilePath, genFilePath);\n            var moduleName = importModule === selfReference ? null : importModule;\n            // If we are in a type expression that refers to a generic type then supply\n            // the required type parameters. If there were not enough type parameters\n            // supplied, supply any as the type. Outside a type expression the reference\n            // should not supply type parameters and be treated as a simple value reference\n            // to the constructor function itself.\n            var suppliedTypeParams = typeParams || [];\n            var missingTypeParamsCount = arity - suppliedTypeParams.length;\n            var allTypeParams = suppliedTypeParams.concat(new Array(missingTypeParamsCount).fill(DYNAMIC_TYPE));\n            return members.reduce(function (expr, memberName) { return expr.prop(memberName); }, importExpr(new ExternalReference(moduleName, name, null), allTypeParams));\n        };\n        return { statements: [], genFilePath: genFilePath, importExpr: importExpr$1, constantPool: new ConstantPool() };\n    };\n    AotCompiler.prototype._fileNameToModuleName = function (importedFilePath, containingFilePath) {\n        return this._summaryResolver.getKnownModuleName(importedFilePath) ||\n            this._symbolResolver.getKnownModuleName(importedFilePath) ||\n            this._host.fileNameToModuleName(importedFilePath, containingFilePath);\n    };\n    AotCompiler.prototype._codegenStyles = function (srcFileUrl, compMeta, stylesheetMetadata, isShimmed, fileSuffix) {\n        var outputCtx = this._createOutputContext(_stylesModuleUrl(stylesheetMetadata.moduleUrl, isShimmed, fileSuffix));\n        var compiledStylesheet = this._styleCompiler.compileStyles(outputCtx, compMeta, stylesheetMetadata, isShimmed);\n        _resolveStyleStatements(this._symbolResolver, compiledStylesheet, isShimmed, fileSuffix);\n        return this._codegenSourceModule(srcFileUrl, outputCtx);\n    };\n    AotCompiler.prototype._codegenSourceModule = function (srcFileUrl, ctx) {\n        return new GeneratedFile(srcFileUrl, ctx.genFilePath, ctx.statements);\n    };\n    AotCompiler.prototype.listLazyRoutes = function (entryRoute, analyzedModules) {\n        var e_2, _a, e_3, _b;\n        var self = this;\n        if (entryRoute) {\n            var symbol = parseLazyRoute(entryRoute, this.reflector).referencedModule;\n            return visitLazyRoute(symbol);\n        }\n        else if (analyzedModules) {\n            var allLazyRoutes = [];\n            try {\n                for (var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(analyzedModules.ngModules), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var ngModule = _d.value;\n                    var lazyRoutes = listLazyRoutes(ngModule, this.reflector);\n                    try {\n                        for (var lazyRoutes_1 = (e_3 = void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(lazyRoutes)), lazyRoutes_1_1 = lazyRoutes_1.next(); !lazyRoutes_1_1.done; lazyRoutes_1_1 = lazyRoutes_1.next()) {\n                            var lazyRoute = lazyRoutes_1_1.value;\n                            allLazyRoutes.push(lazyRoute);\n                        }\n                    }\n                    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                    finally {\n                        try {\n                            if (lazyRoutes_1_1 && !lazyRoutes_1_1.done && (_b = lazyRoutes_1.return)) _b.call(lazyRoutes_1);\n                        }\n                        finally { if (e_3) throw e_3.error; }\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            return allLazyRoutes;\n        }\n        else {\n            throw new Error(\"Either route or analyzedModules has to be specified!\");\n        }\n        function visitLazyRoute(symbol, seenRoutes, allLazyRoutes) {\n            var e_4, _a;\n            if (seenRoutes === void 0) { seenRoutes = new Set(); }\n            if (allLazyRoutes === void 0) { allLazyRoutes = []; }\n            // Support pointing to default exports, but stop recursing there,\n            // as the StaticReflector does not yet support default exports.\n            if (seenRoutes.has(symbol) || !symbol.name) {\n                return allLazyRoutes;\n            }\n            seenRoutes.add(symbol);\n            var lazyRoutes = listLazyRoutes(self._metadataResolver.getNgModuleMetadata(symbol, true), self.reflector);\n            try {\n                for (var lazyRoutes_2 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(lazyRoutes), lazyRoutes_2_1 = lazyRoutes_2.next(); !lazyRoutes_2_1.done; lazyRoutes_2_1 = lazyRoutes_2.next()) {\n                    var lazyRoute = lazyRoutes_2_1.value;\n                    allLazyRoutes.push(lazyRoute);\n                    visitLazyRoute(lazyRoute.referencedModule, seenRoutes, allLazyRoutes);\n                }\n            }\n            catch (e_4_1) { e_4 = { error: e_4_1 }; }\n            finally {\n                try {\n                    if (lazyRoutes_2_1 && !lazyRoutes_2_1.done && (_a = lazyRoutes_2.return)) _a.call(lazyRoutes_2);\n                }\n                finally { if (e_4) throw e_4.error; }\n            }\n            return allLazyRoutes;\n        }\n    };\n    return AotCompiler;\n}());\nfunction _createEmptyStub(outputCtx) {\n    // Note: We need to produce at least one import statement so that\n    // TypeScript knows that the file is an es6 module. Otherwise our generated\n    // exports / imports won't be emitted properly by TypeScript.\n    outputCtx.statements.push(importExpr(Identifiers.ComponentFactory).toStmt());\n}\nfunction _resolveStyleStatements(symbolResolver, compileResult, needsShim, fileSuffix) {\n    compileResult.dependencies.forEach(function (dep) {\n        dep.setValue(symbolResolver.getStaticSymbol(_stylesModuleUrl(dep.moduleUrl, needsShim, fileSuffix), dep.name));\n    });\n}\nfunction _stylesModuleUrl(stylesheetUrl, shim, suffix) {\n    return \"\" + stylesheetUrl + (shim ? '.shim' : '') + \".ngstyle\" + suffix;\n}\nfunction analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver) {\n    var files = _analyzeFilesIncludingNonProgramFiles(fileNames, host, staticSymbolResolver, metadataResolver);\n    return mergeAnalyzedFiles(files);\n}\nfunction analyzeAndValidateNgModules(fileNames, host, staticSymbolResolver, metadataResolver) {\n    return validateAnalyzedModules(analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver));\n}\nfunction validateAnalyzedModules(analyzedModules) {\n    if (analyzedModules.symbolsMissingModule && analyzedModules.symbolsMissingModule.length) {\n        var messages = analyzedModules.symbolsMissingModule.map(function (s) {\n            return \"Cannot determine the module for class \" + s.name + \" in \" + s.filePath + \"! Add \" + s.name + \" to the NgModule to fix it.\";\n        });\n        throw syntaxError(messages.join('\\n'));\n    }\n    return analyzedModules;\n}\n// Analyzes all of the program files,\n// including files that are not part of the program\n// but are referenced by an NgModule.\nfunction _analyzeFilesIncludingNonProgramFiles(fileNames, host, staticSymbolResolver, metadataResolver) {\n    var seenFiles = new Set();\n    var files = [];\n    var visitFile = function (fileName) {\n        if (seenFiles.has(fileName) || !host.isSourceFile(fileName)) {\n            return false;\n        }\n        seenFiles.add(fileName);\n        var analyzedFile = analyzeFile(host, staticSymbolResolver, metadataResolver, fileName);\n        files.push(analyzedFile);\n        analyzedFile.ngModules.forEach(function (ngModule) {\n            ngModule.transitiveModule.modules.forEach(function (modMeta) { return visitFile(modMeta.reference.filePath); });\n        });\n    };\n    fileNames.forEach(function (fileName) { return visitFile(fileName); });\n    return files;\n}\nfunction analyzeFile(host, staticSymbolResolver, metadataResolver, fileName) {\n    var directives = [];\n    var pipes = [];\n    var injectables = [];\n    var ngModules = [];\n    var hasDecorators = staticSymbolResolver.hasDecorators(fileName);\n    var exportsNonSourceFiles = false;\n    // Don't analyze .d.ts files that have no decorators as a shortcut\n    // to speed up the analysis. This prevents us from\n    // resolving the references in these files.\n    // Note: exportsNonSourceFiles is only needed when compiling with summaries,\n    // which is not the case when .d.ts files are treated as input files.\n    if (!fileName.endsWith('.d.ts') || hasDecorators) {\n        staticSymbolResolver.getSymbolsOf(fileName).forEach(function (symbol) {\n            var resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n            var symbolMeta = resolvedSymbol.metadata;\n            if (!symbolMeta || symbolMeta.__symbolic === 'error') {\n                return;\n            }\n            var isNgSymbol = false;\n            if (symbolMeta.__symbolic === 'class') {\n                if (metadataResolver.isDirective(symbol)) {\n                    isNgSymbol = true;\n                    directives.push(symbol);\n                }\n                else if (metadataResolver.isPipe(symbol)) {\n                    isNgSymbol = true;\n                    pipes.push(symbol);\n                }\n                else if (metadataResolver.isNgModule(symbol)) {\n                    var ngModule = metadataResolver.getNgModuleMetadata(symbol, false);\n                    if (ngModule) {\n                        isNgSymbol = true;\n                        ngModules.push(ngModule);\n                    }\n                }\n                else if (metadataResolver.isInjectable(symbol)) {\n                    isNgSymbol = true;\n                    var injectable = metadataResolver.getInjectableMetadata(symbol, null, false);\n                    if (injectable) {\n                        injectables.push(injectable);\n                    }\n                }\n            }\n            if (!isNgSymbol) {\n                exportsNonSourceFiles =\n                    exportsNonSourceFiles || isValueExportingNonSourceFile(host, symbolMeta);\n            }\n        });\n    }\n    return {\n        fileName: fileName, directives: directives, pipes: pipes, ngModules: ngModules, injectables: injectables, exportsNonSourceFiles: exportsNonSourceFiles,\n    };\n}\nfunction analyzeFileForInjectables(host, staticSymbolResolver, metadataResolver, fileName) {\n    var injectables = [];\n    var shallowModules = [];\n    if (staticSymbolResolver.hasDecorators(fileName)) {\n        staticSymbolResolver.getSymbolsOf(fileName).forEach(function (symbol) {\n            var resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n            var symbolMeta = resolvedSymbol.metadata;\n            if (!symbolMeta || symbolMeta.__symbolic === 'error') {\n                return;\n            }\n            if (symbolMeta.__symbolic === 'class') {\n                if (metadataResolver.isInjectable(symbol)) {\n                    var injectable = metadataResolver.getInjectableMetadata(symbol, null, false);\n                    if (injectable) {\n                        injectables.push(injectable);\n                    }\n                }\n                else if (metadataResolver.isNgModule(symbol)) {\n                    var module = metadataResolver.getShallowModuleMetadata(symbol);\n                    if (module) {\n                        shallowModules.push(module);\n                    }\n                }\n            }\n        });\n    }\n    return { fileName: fileName, injectables: injectables, shallowModules: shallowModules };\n}\nfunction isValueExportingNonSourceFile(host, metadata) {\n    var exportsNonSourceFiles = false;\n    var Visitor = /** @class */ (function () {\n        function Visitor() {\n        }\n        Visitor.prototype.visitArray = function (arr, context) {\n            var _this = this;\n            arr.forEach(function (v) { return visitValue(v, _this, context); });\n        };\n        Visitor.prototype.visitStringMap = function (map, context) {\n            var _this = this;\n            Object.keys(map).forEach(function (key) { return visitValue(map[key], _this, context); });\n        };\n        Visitor.prototype.visitPrimitive = function (value, context) { };\n        Visitor.prototype.visitOther = function (value, context) {\n            if (value instanceof StaticSymbol && !host.isSourceFile(value.filePath)) {\n                exportsNonSourceFiles = true;\n            }\n        };\n        return Visitor;\n    }());\n    visitValue(metadata, new Visitor(), null);\n    return exportsNonSourceFiles;\n}\nfunction mergeAnalyzedFiles(analyzedFiles) {\n    var allNgModules = [];\n    var ngModuleByPipeOrDirective = new Map();\n    var allPipesAndDirectives = new Set();\n    analyzedFiles.forEach(function (af) {\n        af.ngModules.forEach(function (ngModule) {\n            allNgModules.push(ngModule);\n            ngModule.declaredDirectives.forEach(function (d) { return ngModuleByPipeOrDirective.set(d.reference, ngModule); });\n            ngModule.declaredPipes.forEach(function (p) { return ngModuleByPipeOrDirective.set(p.reference, ngModule); });\n        });\n        af.directives.forEach(function (d) { return allPipesAndDirectives.add(d); });\n        af.pipes.forEach(function (p) { return allPipesAndDirectives.add(p); });\n    });\n    var symbolsMissingModule = [];\n    allPipesAndDirectives.forEach(function (ref) {\n        if (!ngModuleByPipeOrDirective.has(ref)) {\n            symbolsMissingModule.push(ref);\n        }\n    });\n    return {\n        ngModules: allNgModules,\n        ngModuleByPipeOrDirective: ngModuleByPipeOrDirective,\n        symbolsMissingModule: symbolsMissingModule,\n        files: analyzedFiles\n    };\n}\nfunction mergeAndValidateNgFiles(files) {\n    return validateAnalyzedModules(mergeAnalyzedFiles(files));\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar FORMATTED_MESSAGE = 'ngFormattedMessage';\nfunction indentStr(level) {\n    if (level <= 0)\n        return '';\n    if (level < 6)\n        return ['', ' ', '  ', '   ', '    ', '     '][level];\n    var half = indentStr(Math.floor(level / 2));\n    return half + half + (level % 2 === 1 ? ' ' : '');\n}\nfunction formatChain(chain, indent) {\n    if (indent === void 0) { indent = 0; }\n    if (!chain)\n        return '';\n    var position = chain.position ?\n        chain.position.fileName + \"(\" + (chain.position.line + 1) + \",\" + (chain.position.column + 1) + \")\" :\n        '';\n    var prefix = position && indent === 0 ? position + \": \" : '';\n    var postfix = position && indent !== 0 ? \" at \" + position : '';\n    var message = \"\" + prefix + chain.message + postfix;\n    return \"\" + indentStr(indent) + message + ((chain.next && ('\\n' + formatChain(chain.next, indent + 2))) || '');\n}\nfunction formattedError(chain) {\n    var message = formatChain(chain) + '.';\n    var error = syntaxError(message);\n    error[FORMATTED_MESSAGE] = true;\n    error.chain = chain;\n    error.position = chain.position;\n    return error;\n}\nfunction isFormattedError(error) {\n    return !!error[FORMATTED_MESSAGE];\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ANGULAR_CORE = '@angular/core';\nvar ANGULAR_ROUTER = '@angular/router';\nvar HIDDEN_KEY = /^\\$.*\\$$/;\nvar IGNORE = {\n    __symbolic: 'ignore'\n};\nvar USE_VALUE$1 = 'useValue';\nvar PROVIDE = 'provide';\nvar REFERENCE_SET = new Set([USE_VALUE$1, 'useFactory', 'data', 'id', 'loadChildren']);\nvar TYPEGUARD_POSTFIX = 'TypeGuard';\nvar USE_IF = 'UseIf';\nfunction shouldIgnore(value) {\n    return value && value.__symbolic == 'ignore';\n}\n/**\n * A static reflector implements enough of the Reflector API that is necessary to compile\n * templates statically.\n */\nvar StaticReflector = /** @class */ (function () {\n    function StaticReflector(summaryResolver, symbolResolver, knownMetadataClasses, knownMetadataFunctions, errorRecorder) {\n        var _this = this;\n        if (knownMetadataClasses === void 0) { knownMetadataClasses = []; }\n        if (knownMetadataFunctions === void 0) { knownMetadataFunctions = []; }\n        this.summaryResolver = summaryResolver;\n        this.symbolResolver = symbolResolver;\n        this.errorRecorder = errorRecorder;\n        this.annotationCache = new Map();\n        this.shallowAnnotationCache = new Map();\n        this.propertyCache = new Map();\n        this.parameterCache = new Map();\n        this.methodCache = new Map();\n        this.staticCache = new Map();\n        this.conversionMap = new Map();\n        this.resolvedExternalReferences = new Map();\n        this.annotationForParentClassWithSummaryKind = new Map();\n        this.initializeConversionMap();\n        knownMetadataClasses.forEach(function (kc) { return _this._registerDecoratorOrConstructor(_this.getStaticSymbol(kc.filePath, kc.name), kc.ctor); });\n        knownMetadataFunctions.forEach(function (kf) { return _this._registerFunction(_this.getStaticSymbol(kf.filePath, kf.name), kf.fn); });\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Directive, [createDirective, createComponent]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Pipe, [createPipe]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.NgModule, [createNgModule]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Injectable, [createInjectable, createPipe, createDirective, createComponent, createNgModule]);\n    }\n    StaticReflector.prototype.componentModuleUrl = function (typeOrFunc) {\n        var staticSymbol = this.findSymbolDeclaration(typeOrFunc);\n        return this.symbolResolver.getResourcePath(staticSymbol);\n    };\n    StaticReflector.prototype.resolveExternalReference = function (ref, containingFile) {\n        var key = undefined;\n        if (!containingFile) {\n            key = ref.moduleName + \":\" + ref.name;\n            var declarationSymbol_1 = this.resolvedExternalReferences.get(key);\n            if (declarationSymbol_1)\n                return declarationSymbol_1;\n        }\n        var refSymbol = this.symbolResolver.getSymbolByModule(ref.moduleName, ref.name, containingFile);\n        var declarationSymbol = this.findSymbolDeclaration(refSymbol);\n        if (!containingFile) {\n            this.symbolResolver.recordModuleNameForFileName(refSymbol.filePath, ref.moduleName);\n            this.symbolResolver.recordImportAs(declarationSymbol, refSymbol);\n        }\n        if (key) {\n            this.resolvedExternalReferences.set(key, declarationSymbol);\n        }\n        return declarationSymbol;\n    };\n    StaticReflector.prototype.findDeclaration = function (moduleUrl, name, containingFile) {\n        return this.findSymbolDeclaration(this.symbolResolver.getSymbolByModule(moduleUrl, name, containingFile));\n    };\n    StaticReflector.prototype.tryFindDeclaration = function (moduleUrl, name, containingFile) {\n        var _this = this;\n        return this.symbolResolver.ignoreErrorsFor(function () { return _this.findDeclaration(moduleUrl, name, containingFile); });\n    };\n    StaticReflector.prototype.findSymbolDeclaration = function (symbol) {\n        var resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n        if (resolvedSymbol) {\n            var resolvedMetadata = resolvedSymbol.metadata;\n            if (resolvedMetadata && resolvedMetadata.__symbolic === 'resolved') {\n                resolvedMetadata = resolvedMetadata.symbol;\n            }\n            if (resolvedMetadata instanceof StaticSymbol) {\n                return this.findSymbolDeclaration(resolvedSymbol.metadata);\n            }\n        }\n        return symbol;\n    };\n    StaticReflector.prototype.tryAnnotations = function (type) {\n        var originalRecorder = this.errorRecorder;\n        this.errorRecorder = function (error, fileName) { };\n        try {\n            return this.annotations(type);\n        }\n        finally {\n            this.errorRecorder = originalRecorder;\n        }\n    };\n    StaticReflector.prototype.annotations = function (type) {\n        var _this = this;\n        return this._annotations(type, function (type, decorators) { return _this.simplify(type, decorators); }, this.annotationCache);\n    };\n    StaticReflector.prototype.shallowAnnotations = function (type) {\n        var _this = this;\n        return this._annotations(type, function (type, decorators) { return _this.simplify(type, decorators, true); }, this.shallowAnnotationCache);\n    };\n    StaticReflector.prototype._annotations = function (type, simplify, annotationCache) {\n        var annotations = annotationCache.get(type);\n        if (!annotations) {\n            annotations = [];\n            var classMetadata = this.getTypeMetadata(type);\n            var parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var parentAnnotations = this.annotations(parentType);\n                annotations.push.apply(annotations, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(parentAnnotations));\n            }\n            var ownAnnotations_1 = [];\n            if (classMetadata['decorators']) {\n                ownAnnotations_1 = simplify(type, classMetadata['decorators']);\n                if (ownAnnotations_1) {\n                    annotations.push.apply(annotations, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(ownAnnotations_1));\n                }\n            }\n            if (parentType && !this.summaryResolver.isLibraryFile(type.filePath) &&\n                this.summaryResolver.isLibraryFile(parentType.filePath)) {\n                var summary = this.summaryResolver.resolveSummary(parentType);\n                if (summary && summary.type) {\n                    var requiredAnnotationTypes = this.annotationForParentClassWithSummaryKind.get(summary.type.summaryKind);\n                    var typeHasRequiredAnnotation = requiredAnnotationTypes.some(function (requiredType) { return ownAnnotations_1.some(function (ann) { return requiredType.isTypeOf(ann); }); });\n                    if (!typeHasRequiredAnnotation) {\n                        this.reportError(formatMetadataError(metadataError(\"Class \" + type.name + \" in \" + type.filePath + \" extends from a \" + CompileSummaryKind[summary.type.summaryKind] + \" in another compilation unit without duplicating the decorator\", \n                        /* summary */ undefined, \"Please add a \" + requiredAnnotationTypes.map(function (type) { return type.ngMetadataName; }).join(' or ') + \" decorator to the class\"), type), type);\n                    }\n                }\n            }\n            annotationCache.set(type, annotations.filter(function (ann) { return !!ann; }));\n        }\n        return annotations;\n    };\n    StaticReflector.prototype.propMetadata = function (type) {\n        var _this = this;\n        var propMetadata = this.propertyCache.get(type);\n        if (!propMetadata) {\n            var classMetadata = this.getTypeMetadata(type);\n            propMetadata = {};\n            var parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var parentPropMetadata_1 = this.propMetadata(parentType);\n                Object.keys(parentPropMetadata_1).forEach(function (parentProp) {\n                    propMetadata[parentProp] = parentPropMetadata_1[parentProp];\n                });\n            }\n            var members_1 = classMetadata['members'] || {};\n            Object.keys(members_1).forEach(function (propName) {\n                var propData = members_1[propName];\n                var prop = propData\n                    .find(function (a) { return a['__symbolic'] == 'property' || a['__symbolic'] == 'method'; });\n                var decorators = [];\n                if (propMetadata[propName]) {\n                    decorators.push.apply(decorators, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(propMetadata[propName]));\n                }\n                propMetadata[propName] = decorators;\n                if (prop && prop['decorators']) {\n                    decorators.push.apply(decorators, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(_this.simplify(type, prop['decorators'])));\n                }\n            });\n            this.propertyCache.set(type, propMetadata);\n        }\n        return propMetadata;\n    };\n    StaticReflector.prototype.parameters = function (type) {\n        var _this = this;\n        if (!(type instanceof StaticSymbol)) {\n            this.reportError(new Error(\"parameters received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n            return [];\n        }\n        try {\n            var parameters_1 = this.parameterCache.get(type);\n            if (!parameters_1) {\n                var classMetadata = this.getTypeMetadata(type);\n                var parentType = this.findParentType(type, classMetadata);\n                var members = classMetadata ? classMetadata['members'] : null;\n                var ctorData = members ? members['__ctor__'] : null;\n                if (ctorData) {\n                    var ctor = ctorData.find(function (a) { return a['__symbolic'] == 'constructor'; });\n                    var rawParameterTypes = ctor['parameters'] || [];\n                    var parameterDecorators_1 = this.simplify(type, ctor['parameterDecorators'] || []);\n                    parameters_1 = [];\n                    rawParameterTypes.forEach(function (rawParamType, index) {\n                        var nestedResult = [];\n                        var paramType = _this.trySimplify(type, rawParamType);\n                        if (paramType)\n                            nestedResult.push(paramType);\n                        var decorators = parameterDecorators_1 ? parameterDecorators_1[index] : null;\n                        if (decorators) {\n                            nestedResult.push.apply(nestedResult, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(decorators));\n                        }\n                        parameters_1.push(nestedResult);\n                    });\n                }\n                else if (parentType) {\n                    parameters_1 = this.parameters(parentType);\n                }\n                if (!parameters_1) {\n                    parameters_1 = [];\n                }\n                this.parameterCache.set(type, parameters_1);\n            }\n            return parameters_1;\n        }\n        catch (e) {\n            console.error(\"Failed on type \" + JSON.stringify(type) + \" with error \" + e);\n            throw e;\n        }\n    };\n    StaticReflector.prototype._methodNames = function (type) {\n        var methodNames = this.methodCache.get(type);\n        if (!methodNames) {\n            var classMetadata = this.getTypeMetadata(type);\n            methodNames = {};\n            var parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var parentMethodNames_1 = this._methodNames(parentType);\n                Object.keys(parentMethodNames_1).forEach(function (parentProp) {\n                    methodNames[parentProp] = parentMethodNames_1[parentProp];\n                });\n            }\n            var members_2 = classMetadata['members'] || {};\n            Object.keys(members_2).forEach(function (propName) {\n                var propData = members_2[propName];\n                var isMethod = propData.some(function (a) { return a['__symbolic'] == 'method'; });\n                methodNames[propName] = methodNames[propName] || isMethod;\n            });\n            this.methodCache.set(type, methodNames);\n        }\n        return methodNames;\n    };\n    StaticReflector.prototype._staticMembers = function (type) {\n        var staticMembers = this.staticCache.get(type);\n        if (!staticMembers) {\n            var classMetadata = this.getTypeMetadata(type);\n            var staticMemberData = classMetadata['statics'] || {};\n            staticMembers = Object.keys(staticMemberData);\n            this.staticCache.set(type, staticMembers);\n        }\n        return staticMembers;\n    };\n    StaticReflector.prototype.findParentType = function (type, classMetadata) {\n        var parentType = this.trySimplify(type, classMetadata['extends']);\n        if (parentType instanceof StaticSymbol) {\n            return parentType;\n        }\n    };\n    StaticReflector.prototype.hasLifecycleHook = function (type, lcProperty) {\n        if (!(type instanceof StaticSymbol)) {\n            this.reportError(new Error(\"hasLifecycleHook received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n        }\n        try {\n            return !!this._methodNames(type)[lcProperty];\n        }\n        catch (e) {\n            console.error(\"Failed on type \" + JSON.stringify(type) + \" with error \" + e);\n            throw e;\n        }\n    };\n    StaticReflector.prototype.guards = function (type) {\n        var e_1, _a;\n        if (!(type instanceof StaticSymbol)) {\n            this.reportError(new Error(\"guards received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n            return {};\n        }\n        var staticMembers = this._staticMembers(type);\n        var result = {};\n        try {\n            for (var staticMembers_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(staticMembers), staticMembers_1_1 = staticMembers_1.next(); !staticMembers_1_1.done; staticMembers_1_1 = staticMembers_1.next()) {\n                var name_1 = staticMembers_1_1.value;\n                if (name_1.endsWith(TYPEGUARD_POSTFIX)) {\n                    var property = name_1.substr(0, name_1.length - TYPEGUARD_POSTFIX.length);\n                    var value = void 0;\n                    if (property.endsWith(USE_IF)) {\n                        property = name_1.substr(0, property.length - USE_IF.length);\n                        value = USE_IF;\n                    }\n                    else {\n                        value = this.getStaticSymbol(type.filePath, type.name, [name_1]);\n                    }\n                    result[property] = value;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (staticMembers_1_1 && !staticMembers_1_1.done && (_a = staticMembers_1.return)) _a.call(staticMembers_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return result;\n    };\n    StaticReflector.prototype._registerDecoratorOrConstructor = function (type, ctor) {\n        this.conversionMap.set(type, function (context, args) { return new (ctor.bind.apply(ctor, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([void 0], args)))(); });\n    };\n    StaticReflector.prototype._registerFunction = function (type, fn) {\n        this.conversionMap.set(type, function (context, args) { return fn.apply(undefined, args); });\n    };\n    StaticReflector.prototype.initializeConversionMap = function () {\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Injectable'), createInjectable);\n        this.injectionToken = this.findDeclaration(ANGULAR_CORE, 'InjectionToken');\n        this.opaqueToken = this.findDeclaration(ANGULAR_CORE, 'OpaqueToken');\n        this.ROUTES = this.tryFindDeclaration(ANGULAR_ROUTER, 'ROUTES');\n        this.ANALYZE_FOR_ENTRY_COMPONENTS =\n            this.findDeclaration(ANGULAR_CORE, 'ANALYZE_FOR_ENTRY_COMPONENTS');\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Inject'), createInject);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Attribute'), createAttribute);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChild'), createContentChild);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChildren'), createContentChildren);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChild'), createViewChild);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChildren'), createViewChildren);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Input'), createInput);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Output'), createOutput);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Pipe'), createPipe);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostBinding'), createHostBinding);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostListener'), createHostListener);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Directive'), createDirective);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Component'), createComponent);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'NgModule'), createNgModule);\n        // Note: Some metadata classes can be used directly with Provider.deps.\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);\n    };\n    /**\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\n     *\n     * @param declarationFile the absolute path of the file where the symbol is declared\n     * @param name the name of the type.\n     */\n    StaticReflector.prototype.getStaticSymbol = function (declarationFile, name, members) {\n        return this.symbolResolver.getStaticSymbol(declarationFile, name, members);\n    };\n    /**\n     * Simplify but discard any errors\n     */\n    StaticReflector.prototype.trySimplify = function (context, value) {\n        var originalRecorder = this.errorRecorder;\n        this.errorRecorder = function (error, fileName) { };\n        var result = this.simplify(context, value);\n        this.errorRecorder = originalRecorder;\n        return result;\n    };\n    /** @internal */\n    StaticReflector.prototype.simplify = function (context, value, lazy) {\n        if (lazy === void 0) { lazy = false; }\n        var self = this;\n        var scope = BindingScope$1.empty;\n        var calling = new Map();\n        var rootContext = context;\n        function simplifyInContext(context, value, depth, references) {\n            function resolveReferenceValue(staticSymbol) {\n                var resolvedSymbol = self.symbolResolver.resolveSymbol(staticSymbol);\n                return resolvedSymbol ? resolvedSymbol.metadata : null;\n            }\n            function simplifyEagerly(value) {\n                return simplifyInContext(context, value, depth, 0);\n            }\n            function simplifyLazily(value) {\n                return simplifyInContext(context, value, depth, references + 1);\n            }\n            function simplifyNested(nestedContext, value) {\n                if (nestedContext === context) {\n                    // If the context hasn't changed let the exception propagate unmodified.\n                    return simplifyInContext(nestedContext, value, depth + 1, references);\n                }\n                try {\n                    return simplifyInContext(nestedContext, value, depth + 1, references);\n                }\n                catch (e) {\n                    if (isMetadataError(e)) {\n                        // Propagate the message text up but add a message to the chain that explains how we got\n                        // here.\n                        // e.chain implies e.symbol\n                        var summaryMsg = e.chain ? 'references \\'' + e.symbol.name + '\\'' : errorSummary(e);\n                        var summary = \"'\" + nestedContext.name + \"' \" + summaryMsg;\n                        var chain = { message: summary, position: e.position, next: e.chain };\n                        // TODO(chuckj): retrieve the position information indirectly from the collectors node\n                        // map if the metadata is from a .ts file.\n                        self.error({\n                            message: e.message,\n                            advise: e.advise,\n                            context: e.context, chain: chain,\n                            symbol: nestedContext\n                        }, context);\n                    }\n                    else {\n                        // It is probably an internal error.\n                        throw e;\n                    }\n                }\n            }\n            function simplifyCall(functionSymbol, targetFunction, args, targetExpression) {\n                if (targetFunction && targetFunction['__symbolic'] == 'function') {\n                    if (calling.get(functionSymbol)) {\n                        self.error({\n                            message: 'Recursion is not supported',\n                            summary: \"called '\" + functionSymbol.name + \"' recursively\",\n                            value: targetFunction\n                        }, functionSymbol);\n                    }\n                    try {\n                        var value_1 = targetFunction['value'];\n                        if (value_1 && (depth != 0 || value_1.__symbolic != 'error')) {\n                            var parameters = targetFunction['parameters'];\n                            var defaults = targetFunction.defaults;\n                            args = args.map(function (arg) { return simplifyNested(context, arg); })\n                                .map(function (arg) { return shouldIgnore(arg) ? undefined : arg; });\n                            if (defaults && defaults.length > args.length) {\n                                args.push.apply(args, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(defaults.slice(args.length).map(function (value) { return simplify(value); })));\n                            }\n                            calling.set(functionSymbol, true);\n                            var functionScope = BindingScope$1.build();\n                            for (var i = 0; i < parameters.length; i++) {\n                                functionScope.define(parameters[i], args[i]);\n                            }\n                            var oldScope = scope;\n                            var result_1;\n                            try {\n                                scope = functionScope.done();\n                                result_1 = simplifyNested(functionSymbol, value_1);\n                            }\n                            finally {\n                                scope = oldScope;\n                            }\n                            return result_1;\n                        }\n                    }\n                    finally {\n                        calling.delete(functionSymbol);\n                    }\n                }\n                if (depth === 0) {\n                    // If depth is 0 we are evaluating the top level expression that is describing element\n                    // decorator. In this case, it is a decorator we don't understand, such as a custom\n                    // non-angular decorator, and we should just ignore it.\n                    return IGNORE;\n                }\n                var position = undefined;\n                if (targetExpression && targetExpression.__symbolic == 'resolved') {\n                    var line = targetExpression.line;\n                    var character = targetExpression.character;\n                    var fileName = targetExpression.fileName;\n                    if (fileName != null && line != null && character != null) {\n                        position = { fileName: fileName, line: line, column: character };\n                    }\n                }\n                self.error({\n                    message: FUNCTION_CALL_NOT_SUPPORTED,\n                    context: functionSymbol,\n                    value: targetFunction, position: position\n                }, context);\n            }\n            function simplify(expression) {\n                var e_2, _a, e_3, _b;\n                if (isPrimitive(expression)) {\n                    return expression;\n                }\n                if (expression instanceof Array) {\n                    var result_2 = [];\n                    try {\n                        for (var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(expression), _d = _c.next(); !_d.done; _d = _c.next()) {\n                            var item = _d.value;\n                            // Check for a spread expression\n                            if (item && item.__symbolic === 'spread') {\n                                // We call with references as 0 because we require the actual value and cannot\n                                // tolerate a reference here.\n                                var spreadArray = simplifyEagerly(item.expression);\n                                if (Array.isArray(spreadArray)) {\n                                    try {\n                                        for (var spreadArray_1 = (e_3 = void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(spreadArray)), spreadArray_1_1 = spreadArray_1.next(); !spreadArray_1_1.done; spreadArray_1_1 = spreadArray_1.next()) {\n                                            var spreadItem = spreadArray_1_1.value;\n                                            result_2.push(spreadItem);\n                                        }\n                                    }\n                                    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                                    finally {\n                                        try {\n                                            if (spreadArray_1_1 && !spreadArray_1_1.done && (_b = spreadArray_1.return)) _b.call(spreadArray_1);\n                                        }\n                                        finally { if (e_3) throw e_3.error; }\n                                    }\n                                    continue;\n                                }\n                            }\n                            var value_2 = simplify(item);\n                            if (shouldIgnore(value_2)) {\n                                continue;\n                            }\n                            result_2.push(value_2);\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                    return result_2;\n                }\n                if (expression instanceof StaticSymbol) {\n                    // Stop simplification at builtin symbols or if we are in a reference context and\n                    // the symbol doesn't have members.\n                    if (expression === self.injectionToken || self.conversionMap.has(expression) ||\n                        (references > 0 && !expression.members.length)) {\n                        return expression;\n                    }\n                    else {\n                        var staticSymbol = expression;\n                        var declarationValue = resolveReferenceValue(staticSymbol);\n                        if (declarationValue != null) {\n                            return simplifyNested(staticSymbol, declarationValue);\n                        }\n                        else {\n                            return staticSymbol;\n                        }\n                    }\n                }\n                if (expression) {\n                    if (expression['__symbolic']) {\n                        var staticSymbol = void 0;\n                        switch (expression['__symbolic']) {\n                            case 'binop':\n                                var left = simplify(expression['left']);\n                                if (shouldIgnore(left))\n                                    return left;\n                                var right = simplify(expression['right']);\n                                if (shouldIgnore(right))\n                                    return right;\n                                switch (expression['operator']) {\n                                    case '&&':\n                                        return left && right;\n                                    case '||':\n                                        return left || right;\n                                    case '|':\n                                        return left | right;\n                                    case '^':\n                                        return left ^ right;\n                                    case '&':\n                                        return left & right;\n                                    case '==':\n                                        return left == right;\n                                    case '!=':\n                                        return left != right;\n                                    case '===':\n                                        return left === right;\n                                    case '!==':\n                                        return left !== right;\n                                    case '<':\n                                        return left < right;\n                                    case '>':\n                                        return left > right;\n                                    case '<=':\n                                        return left <= right;\n                                    case '>=':\n                                        return left >= right;\n                                    case '<<':\n                                        return left << right;\n                                    case '>>':\n                                        return left >> right;\n                                    case '+':\n                                        return left + right;\n                                    case '-':\n                                        return left - right;\n                                    case '*':\n                                        return left * right;\n                                    case '/':\n                                        return left / right;\n                                    case '%':\n                                        return left % right;\n                                }\n                                return null;\n                            case 'if':\n                                var condition = simplify(expression['condition']);\n                                return condition ? simplify(expression['thenExpression']) :\n                                    simplify(expression['elseExpression']);\n                            case 'pre':\n                                var operand = simplify(expression['operand']);\n                                if (shouldIgnore(operand))\n                                    return operand;\n                                switch (expression['operator']) {\n                                    case '+':\n                                        return operand;\n                                    case '-':\n                                        return -operand;\n                                    case '!':\n                                        return !operand;\n                                    case '~':\n                                        return ~operand;\n                                }\n                                return null;\n                            case 'index':\n                                var indexTarget = simplifyEagerly(expression['expression']);\n                                var index = simplifyEagerly(expression['index']);\n                                if (indexTarget && isPrimitive(index))\n                                    return indexTarget[index];\n                                return null;\n                            case 'select':\n                                var member = expression['member'];\n                                var selectContext = context;\n                                var selectTarget = simplify(expression['expression']);\n                                if (selectTarget instanceof StaticSymbol) {\n                                    var members = selectTarget.members.concat(member);\n                                    selectContext =\n                                        self.getStaticSymbol(selectTarget.filePath, selectTarget.name, members);\n                                    var declarationValue = resolveReferenceValue(selectContext);\n                                    if (declarationValue != null) {\n                                        return simplifyNested(selectContext, declarationValue);\n                                    }\n                                    else {\n                                        return selectContext;\n                                    }\n                                }\n                                if (selectTarget && isPrimitive(member))\n                                    return simplifyNested(selectContext, selectTarget[member]);\n                                return null;\n                            case 'reference':\n                                // Note: This only has to deal with variable references, as symbol references have\n                                // been converted into 'resolved'\n                                // in the StaticSymbolResolver.\n                                var name_2 = expression['name'];\n                                var localValue = scope.resolve(name_2);\n                                if (localValue != BindingScope$1.missing) {\n                                    return localValue;\n                                }\n                                break;\n                            case 'resolved':\n                                try {\n                                    return simplify(expression.symbol);\n                                }\n                                catch (e) {\n                                    // If an error is reported evaluating the symbol record the position of the\n                                    // reference in the error so it can\n                                    // be reported in the error message generated from the exception.\n                                    if (isMetadataError(e) && expression.fileName != null &&\n                                        expression.line != null && expression.character != null) {\n                                        e.position = {\n                                            fileName: expression.fileName,\n                                            line: expression.line,\n                                            column: expression.character\n                                        };\n                                    }\n                                    throw e;\n                                }\n                            case 'class':\n                                return context;\n                            case 'function':\n                                return context;\n                            case 'new':\n                            case 'call':\n                                // Determine if the function is a built-in conversion\n                                staticSymbol = simplifyInContext(context, expression['expression'], depth + 1, /* references */ 0);\n                                if (staticSymbol instanceof StaticSymbol) {\n                                    if (staticSymbol === self.injectionToken || staticSymbol === self.opaqueToken) {\n                                        // if somebody calls new InjectionToken, don't create an InjectionToken,\n                                        // but rather return the symbol to which the InjectionToken is assigned to.\n                                        // OpaqueToken is supported too as it is required by the language service to\n                                        // support v4 and prior versions of Angular.\n                                        return context;\n                                    }\n                                    var argExpressions = expression['arguments'] || [];\n                                    var converter = self.conversionMap.get(staticSymbol);\n                                    if (converter) {\n                                        var args = argExpressions.map(function (arg) { return simplifyNested(context, arg); })\n                                            .map(function (arg) { return shouldIgnore(arg) ? undefined : arg; });\n                                        return converter(context, args);\n                                    }\n                                    else {\n                                        // Determine if the function is one we can simplify.\n                                        var targetFunction = resolveReferenceValue(staticSymbol);\n                                        return simplifyCall(staticSymbol, targetFunction, argExpressions, expression['expression']);\n                                    }\n                                }\n                                return IGNORE;\n                            case 'error':\n                                var message = expression.message;\n                                if (expression['line'] != null) {\n                                    self.error({\n                                        message: message,\n                                        context: expression.context,\n                                        value: expression,\n                                        position: {\n                                            fileName: expression['fileName'],\n                                            line: expression['line'],\n                                            column: expression['character']\n                                        }\n                                    }, context);\n                                }\n                                else {\n                                    self.error({ message: message, context: expression.context }, context);\n                                }\n                                return IGNORE;\n                            case 'ignore':\n                                return expression;\n                        }\n                        return null;\n                    }\n                    return mapStringMap(expression, function (value, name) {\n                        if (REFERENCE_SET.has(name)) {\n                            if (name === USE_VALUE$1 && PROVIDE in expression) {\n                                // If this is a provider expression, check for special tokens that need the value\n                                // during analysis.\n                                var provide = simplify(expression.provide);\n                                if (provide === self.ROUTES || provide == self.ANALYZE_FOR_ENTRY_COMPONENTS) {\n                                    return simplify(value);\n                                }\n                            }\n                            return simplifyLazily(value);\n                        }\n                        return simplify(value);\n                    });\n                }\n                return IGNORE;\n            }\n            return simplify(value);\n        }\n        var result;\n        try {\n            result = simplifyInContext(context, value, 0, lazy ? 1 : 0);\n        }\n        catch (e) {\n            if (this.errorRecorder) {\n                this.reportError(e, context);\n            }\n            else {\n                throw formatMetadataError(e, context);\n            }\n        }\n        if (shouldIgnore(result)) {\n            return undefined;\n        }\n        return result;\n    };\n    StaticReflector.prototype.getTypeMetadata = function (type) {\n        var resolvedSymbol = this.symbolResolver.resolveSymbol(type);\n        return resolvedSymbol && resolvedSymbol.metadata ? resolvedSymbol.metadata :\n            { __symbolic: 'class' };\n    };\n    StaticReflector.prototype.reportError = function (error, context, path) {\n        if (this.errorRecorder) {\n            this.errorRecorder(formatMetadataError(error, context), (context && context.filePath) || path);\n        }\n        else {\n            throw error;\n        }\n    };\n    StaticReflector.prototype.error = function (_a, reportingContext) {\n        var message = _a.message, summary = _a.summary, advise = _a.advise, position = _a.position, context = _a.context, value = _a.value, symbol = _a.symbol, chain = _a.chain;\n        this.reportError(metadataError(message, summary, advise, position, symbol, context, chain), reportingContext);\n    };\n    return StaticReflector;\n}());\nvar METADATA_ERROR = 'ngMetadataError';\nfunction metadataError(message, summary, advise, position, symbol, context, chain) {\n    var error = syntaxError(message);\n    error[METADATA_ERROR] = true;\n    if (advise)\n        error.advise = advise;\n    if (position)\n        error.position = position;\n    if (summary)\n        error.summary = summary;\n    if (context)\n        error.context = context;\n    if (chain)\n        error.chain = chain;\n    if (symbol)\n        error.symbol = symbol;\n    return error;\n}\nfunction isMetadataError(error) {\n    return !!error[METADATA_ERROR];\n}\nvar REFERENCE_TO_NONEXPORTED_CLASS = 'Reference to non-exported class';\nvar VARIABLE_NOT_INITIALIZED = 'Variable not initialized';\nvar DESTRUCTURE_NOT_SUPPORTED = 'Destructuring not supported';\nvar COULD_NOT_RESOLVE_TYPE = 'Could not resolve type';\nvar FUNCTION_CALL_NOT_SUPPORTED = 'Function call not supported';\nvar REFERENCE_TO_LOCAL_SYMBOL = 'Reference to a local symbol';\nvar LAMBDA_NOT_SUPPORTED = 'Lambda not supported';\nfunction expandedMessage(message, context) {\n    switch (message) {\n        case REFERENCE_TO_NONEXPORTED_CLASS:\n            if (context && context.className) {\n                return \"References to a non-exported class are not supported in decorators but \" + context.className + \" was referenced.\";\n            }\n            break;\n        case VARIABLE_NOT_INITIALIZED:\n            return 'Only initialized variables and constants can be referenced in decorators because the value of this variable is needed by the template compiler';\n        case DESTRUCTURE_NOT_SUPPORTED:\n            return 'Referencing an exported destructured variable or constant is not supported in decorators and this value is needed by the template compiler';\n        case COULD_NOT_RESOLVE_TYPE:\n            if (context && context.typeName) {\n                return \"Could not resolve type \" + context.typeName;\n            }\n            break;\n        case FUNCTION_CALL_NOT_SUPPORTED:\n            if (context && context.name) {\n                return \"Function calls are not supported in decorators but '\" + context.name + \"' was called\";\n            }\n            return 'Function calls are not supported in decorators';\n        case REFERENCE_TO_LOCAL_SYMBOL:\n            if (context && context.name) {\n                return \"Reference to a local (non-exported) symbols are not supported in decorators but '\" + context.name + \"' was referenced\";\n            }\n            break;\n        case LAMBDA_NOT_SUPPORTED:\n            return \"Function expressions are not supported in decorators\";\n    }\n    return message;\n}\nfunction messageAdvise(message, context) {\n    switch (message) {\n        case REFERENCE_TO_NONEXPORTED_CLASS:\n            if (context && context.className) {\n                return \"Consider exporting '\" + context.className + \"'\";\n            }\n            break;\n        case DESTRUCTURE_NOT_SUPPORTED:\n            return 'Consider simplifying to avoid destructuring';\n        case REFERENCE_TO_LOCAL_SYMBOL:\n            if (context && context.name) {\n                return \"Consider exporting '\" + context.name + \"'\";\n            }\n            break;\n        case LAMBDA_NOT_SUPPORTED:\n            return \"Consider changing the function expression into an exported function\";\n    }\n    return undefined;\n}\nfunction errorSummary(error) {\n    if (error.summary) {\n        return error.summary;\n    }\n    switch (error.message) {\n        case REFERENCE_TO_NONEXPORTED_CLASS:\n            if (error.context && error.context.className) {\n                return \"references non-exported class \" + error.context.className;\n            }\n            break;\n        case VARIABLE_NOT_INITIALIZED:\n            return 'is not initialized';\n        case DESTRUCTURE_NOT_SUPPORTED:\n            return 'is a destructured variable';\n        case COULD_NOT_RESOLVE_TYPE:\n            return 'could not be resolved';\n        case FUNCTION_CALL_NOT_SUPPORTED:\n            if (error.context && error.context.name) {\n                return \"calls '\" + error.context.name + \"'\";\n            }\n            return \"calls a function\";\n        case REFERENCE_TO_LOCAL_SYMBOL:\n            if (error.context && error.context.name) {\n                return \"references local variable \" + error.context.name;\n            }\n            return \"references a local variable\";\n    }\n    return 'contains the error';\n}\nfunction mapStringMap(input, transform) {\n    if (!input)\n        return {};\n    var result = {};\n    Object.keys(input).forEach(function (key) {\n        var value = transform(input[key], key);\n        if (!shouldIgnore(value)) {\n            if (HIDDEN_KEY.test(key)) {\n                Object.defineProperty(result, key, { enumerable: false, configurable: true, value: value });\n            }\n            else {\n                result[key] = value;\n            }\n        }\n    });\n    return result;\n}\nfunction isPrimitive(o) {\n    return o === null || (typeof o !== 'function' && typeof o !== 'object');\n}\nvar BindingScope$1 = /** @class */ (function () {\n    function BindingScope() {\n    }\n    BindingScope.build = function () {\n        var current = new Map();\n        return {\n            define: function (name, value) {\n                current.set(name, value);\n                return this;\n            },\n            done: function () {\n                return current.size > 0 ? new PopulatedScope(current) : BindingScope.empty;\n            }\n        };\n    };\n    BindingScope.missing = {};\n    BindingScope.empty = { resolve: function (name) { return BindingScope.missing; } };\n    return BindingScope;\n}());\nvar PopulatedScope = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(PopulatedScope, _super);\n    function PopulatedScope(bindings) {\n        var _this = _super.call(this) || this;\n        _this.bindings = bindings;\n        return _this;\n    }\n    PopulatedScope.prototype.resolve = function (name) {\n        return this.bindings.has(name) ? this.bindings.get(name) : BindingScope$1.missing;\n    };\n    return PopulatedScope;\n}(BindingScope$1));\nfunction formatMetadataMessageChain(chain, advise) {\n    var expanded = expandedMessage(chain.message, chain.context);\n    var nesting = chain.symbol ? \" in '\" + chain.symbol.name + \"'\" : '';\n    var message = \"\" + expanded + nesting;\n    var position = chain.position;\n    var next = chain.next ?\n        formatMetadataMessageChain(chain.next, advise) :\n        advise ? { message: advise } : undefined;\n    return { message: message, position: position, next: next };\n}\nfunction formatMetadataError(e, context) {\n    if (isMetadataError(e)) {\n        // Produce a formatted version of the and leaving enough information in the original error\n        // to recover the formatting information to eventually produce a diagnostic error message.\n        var position = e.position;\n        var chain = {\n            message: \"Error during template compile of '\" + context.name + \"'\",\n            position: position,\n            next: { message: e.message, next: e.chain, context: e.context, symbol: e.symbol }\n        };\n        var advise = e.advise || messageAdvise(e.message, e.context);\n        return formattedError(formatMetadataMessageChain(chain, advise));\n    }\n    return e;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar AotSummaryResolver = /** @class */ (function () {\n    function AotSummaryResolver(host, staticSymbolCache) {\n        this.host = host;\n        this.staticSymbolCache = staticSymbolCache;\n        // Note: this will only contain StaticSymbols without members!\n        this.summaryCache = new Map();\n        this.loadedFilePaths = new Map();\n        // Note: this will only contain StaticSymbols without members!\n        this.importAs = new Map();\n        this.knownFileNameToModuleNames = new Map();\n    }\n    AotSummaryResolver.prototype.isLibraryFile = function (filePath) {\n        // Note: We need to strip the .ngfactory. file path,\n        // so this method also works for generated files\n        // (for which host.isSourceFile will always return false).\n        return !this.host.isSourceFile(stripGeneratedFileSuffix(filePath));\n    };\n    AotSummaryResolver.prototype.toSummaryFileName = function (filePath, referringSrcFileName) {\n        return this.host.toSummaryFileName(filePath, referringSrcFileName);\n    };\n    AotSummaryResolver.prototype.fromSummaryFileName = function (fileName, referringLibFileName) {\n        return this.host.fromSummaryFileName(fileName, referringLibFileName);\n    };\n    AotSummaryResolver.prototype.resolveSummary = function (staticSymbol) {\n        var rootSymbol = staticSymbol.members.length ?\n            this.staticSymbolCache.get(staticSymbol.filePath, staticSymbol.name) :\n            staticSymbol;\n        var summary = this.summaryCache.get(rootSymbol);\n        if (!summary) {\n            this._loadSummaryFile(staticSymbol.filePath);\n            summary = this.summaryCache.get(staticSymbol);\n        }\n        return (rootSymbol === staticSymbol && summary) || null;\n    };\n    AotSummaryResolver.prototype.getSymbolsOf = function (filePath) {\n        if (this._loadSummaryFile(filePath)) {\n            return Array.from(this.summaryCache.keys()).filter(function (symbol) { return symbol.filePath === filePath; });\n        }\n        return null;\n    };\n    AotSummaryResolver.prototype.getImportAs = function (staticSymbol) {\n        staticSymbol.assertNoMembers();\n        return this.importAs.get(staticSymbol);\n    };\n    /**\n     * Converts a file path to a module name that can be used as an `import`.\n     */\n    AotSummaryResolver.prototype.getKnownModuleName = function (importedFilePath) {\n        return this.knownFileNameToModuleNames.get(importedFilePath) || null;\n    };\n    AotSummaryResolver.prototype.addSummary = function (summary) { this.summaryCache.set(summary.symbol, summary); };\n    AotSummaryResolver.prototype._loadSummaryFile = function (filePath) {\n        var _this = this;\n        var hasSummary = this.loadedFilePaths.get(filePath);\n        if (hasSummary != null) {\n            return hasSummary;\n        }\n        var json = null;\n        if (this.isLibraryFile(filePath)) {\n            var summaryFilePath = summaryFileName(filePath);\n            try {\n                json = this.host.loadSummary(summaryFilePath);\n            }\n            catch (e) {\n                console.error(\"Error loading summary file \" + summaryFilePath);\n                throw e;\n            }\n        }\n        hasSummary = json != null;\n        this.loadedFilePaths.set(filePath, hasSummary);\n        if (json) {\n            var _a = deserializeSummaries(this.staticSymbolCache, this, filePath, json), moduleName = _a.moduleName, summaries = _a.summaries, importAs = _a.importAs;\n            summaries.forEach(function (summary) { return _this.summaryCache.set(summary.symbol, summary); });\n            if (moduleName) {\n                this.knownFileNameToModuleNames.set(filePath, moduleName);\n            }\n            importAs.forEach(function (importAs) { _this.importAs.set(importAs.symbol, importAs.importAs); });\n        }\n        return hasSummary;\n    };\n    return AotSummaryResolver;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction createAotUrlResolver(host) {\n    return {\n        resolve: function (basePath, url) {\n            var filePath = host.resourceNameToFileName(url, basePath);\n            if (!filePath) {\n                throw syntaxError(\"Couldn't resolve resource \" + url + \" from \" + basePath);\n            }\n            return filePath;\n        }\n    };\n}\n/**\n * Creates a new AotCompiler based on options and a host.\n */\nfunction createAotCompiler(compilerHost, options, errorCollector) {\n    var translations = options.translations || '';\n    var urlResolver = createAotUrlResolver(compilerHost);\n    var symbolCache = new StaticSymbolCache();\n    var summaryResolver = new AotSummaryResolver(compilerHost, symbolCache);\n    var symbolResolver = new StaticSymbolResolver(compilerHost, symbolCache, summaryResolver);\n    var staticReflector = new StaticReflector(summaryResolver, symbolResolver, [], [], errorCollector);\n    var htmlParser;\n    if (!!options.enableIvy) {\n        // Ivy handles i18n at the compiler level so we must use a regular parser\n        htmlParser = new HtmlParser();\n    }\n    else {\n        htmlParser = new I18NHtmlParser(new HtmlParser(), translations, options.i18nFormat, options.missingTranslation, console);\n    }\n    var config = new CompilerConfig({\n        defaultEncapsulation: ViewEncapsulation.Emulated,\n        useJit: false,\n        missingTranslation: options.missingTranslation,\n        preserveWhitespaces: options.preserveWhitespaces,\n        strictInjectionParameters: options.strictInjectionParameters,\n    });\n    var normalizer = new DirectiveNormalizer({ get: function (url) { return compilerHost.loadResource(url); } }, urlResolver, htmlParser, config);\n    var expressionParser = new Parser$1(new Lexer());\n    var elementSchemaRegistry = new DomElementSchemaRegistry();\n    var tmplParser = new TemplateParser(config, staticReflector, expressionParser, elementSchemaRegistry, htmlParser, console, []);\n    var resolver = new CompileMetadataResolver(config, htmlParser, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector, errorCollector);\n    // TODO(vicb): do not pass options.i18nFormat here\n    var viewCompiler = new ViewCompiler(staticReflector);\n    var typeCheckCompiler = new TypeCheckCompiler(options, staticReflector);\n    var compiler = new AotCompiler(config, options, compilerHost, staticReflector, resolver, tmplParser, new StyleCompiler(urlResolver), viewCompiler, typeCheckCompiler, new NgModuleCompiler(staticReflector), new InjectableCompiler(staticReflector, !!options.enableIvy), new TypeScriptEmitter(), summaryResolver, symbolResolver);\n    return { compiler: compiler, reflector: staticReflector };\n}\n\nvar SummaryResolver = /** @class */ (function () {\n    function SummaryResolver() {\n    }\n    return SummaryResolver;\n}());\nvar JitSummaryResolver = /** @class */ (function () {\n    function JitSummaryResolver() {\n        this._summaries = new Map();\n    }\n    JitSummaryResolver.prototype.isLibraryFile = function () { return false; };\n    JitSummaryResolver.prototype.toSummaryFileName = function (fileName) { return fileName; };\n    JitSummaryResolver.prototype.fromSummaryFileName = function (fileName) { return fileName; };\n    JitSummaryResolver.prototype.resolveSummary = function (reference) {\n        return this._summaries.get(reference) || null;\n    };\n    JitSummaryResolver.prototype.getSymbolsOf = function () { return []; };\n    JitSummaryResolver.prototype.getImportAs = function (reference) { return reference; };\n    JitSummaryResolver.prototype.getKnownModuleName = function (fileName) { return null; };\n    JitSummaryResolver.prototype.addSummary = function (summary) { this._summaries.set(summary.symbol, summary); };\n    return JitSummaryResolver;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction interpretStatements(statements, reflector) {\n    var ctx = new _ExecutionContext(null, null, null, new Map());\n    var visitor = new StatementInterpreter(reflector);\n    visitor.visitAllStatements(statements, ctx);\n    var result = {};\n    ctx.exports.forEach(function (exportName) { result[exportName] = ctx.vars.get(exportName); });\n    return result;\n}\nfunction _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {\n    var childCtx = ctx.createChildWihtLocalVars();\n    for (var i = 0; i < varNames.length; i++) {\n        childCtx.vars.set(varNames[i], varValues[i]);\n    }\n    var result = visitor.visitAllStatements(statements, childCtx);\n    return result ? result.value : null;\n}\nvar _ExecutionContext = /** @class */ (function () {\n    function _ExecutionContext(parent, instance, className, vars) {\n        this.parent = parent;\n        this.instance = instance;\n        this.className = className;\n        this.vars = vars;\n        this.exports = [];\n    }\n    _ExecutionContext.prototype.createChildWihtLocalVars = function () {\n        return new _ExecutionContext(this, this.instance, this.className, new Map());\n    };\n    return _ExecutionContext;\n}());\nvar ReturnValue = /** @class */ (function () {\n    function ReturnValue(value) {\n        this.value = value;\n    }\n    return ReturnValue;\n}());\nfunction createDynamicClass(_classStmt, _ctx, _visitor) {\n    var propertyDescriptors = {};\n    _classStmt.getters.forEach(function (getter) {\n        // Note: use `function` instead of arrow function to capture `this`\n        propertyDescriptors[getter.name] = {\n            configurable: false,\n            get: function () {\n                var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n                return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);\n            }\n        };\n    });\n    _classStmt.methods.forEach(function (method) {\n        var paramNames = method.params.map(function (param) { return param.name; });\n        // Note: use `function` instead of arrow function to capture `this`\n        propertyDescriptors[method.name] = {\n            writable: false,\n            configurable: false,\n            value: function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n                return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);\n            }\n        };\n    });\n    var ctorParamNames = _classStmt.constructorMethod.params.map(function (param) { return param.name; });\n    // Note: use `function` instead of arrow function to capture `this`\n    var ctor = function () {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n        _classStmt.fields.forEach(function (field) { _this[field.name] = undefined; });\n        _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);\n    };\n    var superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;\n    ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);\n    return ctor;\n}\nvar StatementInterpreter = /** @class */ (function () {\n    function StatementInterpreter(reflector) {\n        this.reflector = reflector;\n    }\n    StatementInterpreter.prototype.debugAst = function (ast) { return debugOutputAstAsTypeScript(ast); };\n    StatementInterpreter.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        var initialValue = stmt.value ? stmt.value.visitExpression(this, ctx) : undefined;\n        ctx.vars.set(stmt.name, initialValue);\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.exports.push(stmt.name);\n        }\n        return null;\n    };\n    StatementInterpreter.prototype.visitWriteVarExpr = function (expr, ctx) {\n        var value = expr.value.visitExpression(this, ctx);\n        var currCtx = ctx;\n        while (currCtx != null) {\n            if (currCtx.vars.has(expr.name)) {\n                currCtx.vars.set(expr.name, value);\n                return value;\n            }\n            currCtx = currCtx.parent;\n        }\n        throw new Error(\"Not declared variable \" + expr.name);\n    };\n    StatementInterpreter.prototype.visitWrappedNodeExpr = function (ast, ctx) {\n        throw new Error('Cannot interpret a WrappedNodeExpr.');\n    };\n    StatementInterpreter.prototype.visitTypeofExpr = function (ast, ctx) {\n        throw new Error('Cannot interpret a TypeofExpr');\n    };\n    StatementInterpreter.prototype.visitReadVarExpr = function (ast, ctx) {\n        var varName = ast.name;\n        if (ast.builtin != null) {\n            switch (ast.builtin) {\n                case BuiltinVar.Super:\n                    return Object.getPrototypeOf(ctx.instance);\n                case BuiltinVar.This:\n                    return ctx.instance;\n                case BuiltinVar.CatchError:\n                    varName = CATCH_ERROR_VAR$2;\n                    break;\n                case BuiltinVar.CatchStack:\n                    varName = CATCH_STACK_VAR$2;\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin variable \" + ast.builtin);\n            }\n        }\n        var currCtx = ctx;\n        while (currCtx != null) {\n            if (currCtx.vars.has(varName)) {\n                return currCtx.vars.get(varName);\n            }\n            currCtx = currCtx.parent;\n        }\n        throw new Error(\"Not declared variable \" + varName);\n    };\n    StatementInterpreter.prototype.visitWriteKeyExpr = function (expr, ctx) {\n        var receiver = expr.receiver.visitExpression(this, ctx);\n        var index = expr.index.visitExpression(this, ctx);\n        var value = expr.value.visitExpression(this, ctx);\n        receiver[index] = value;\n        return value;\n    };\n    StatementInterpreter.prototype.visitWritePropExpr = function (expr, ctx) {\n        var receiver = expr.receiver.visitExpression(this, ctx);\n        var value = expr.value.visitExpression(this, ctx);\n        receiver[expr.name] = value;\n        return value;\n    };\n    StatementInterpreter.prototype.visitInvokeMethodExpr = function (expr, ctx) {\n        var receiver = expr.receiver.visitExpression(this, ctx);\n        var args = this.visitAllExpressions(expr.args, ctx);\n        var result;\n        if (expr.builtin != null) {\n            switch (expr.builtin) {\n                case BuiltinMethod.ConcatArray:\n                    result = receiver.concat.apply(receiver, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(args));\n                    break;\n                case BuiltinMethod.SubscribeObservable:\n                    result = receiver.subscribe({ next: args[0] });\n                    break;\n                case BuiltinMethod.Bind:\n                    result = receiver.bind.apply(receiver, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(args));\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin method \" + expr.builtin);\n            }\n        }\n        else {\n            result = receiver[expr.name].apply(receiver, args);\n        }\n        return result;\n    };\n    StatementInterpreter.prototype.visitInvokeFunctionExpr = function (stmt, ctx) {\n        var args = this.visitAllExpressions(stmt.args, ctx);\n        var fnExpr = stmt.fn;\n        if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n            ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);\n            return null;\n        }\n        else {\n            var fn = stmt.fn.visitExpression(this, ctx);\n            return fn.apply(null, args);\n        }\n    };\n    StatementInterpreter.prototype.visitReturnStmt = function (stmt, ctx) {\n        return new ReturnValue(stmt.value.visitExpression(this, ctx));\n    };\n    StatementInterpreter.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var clazz = createDynamicClass(stmt, ctx, this);\n        ctx.vars.set(stmt.name, clazz);\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.exports.push(stmt.name);\n        }\n        return null;\n    };\n    StatementInterpreter.prototype.visitExpressionStmt = function (stmt, ctx) {\n        return stmt.expr.visitExpression(this, ctx);\n    };\n    StatementInterpreter.prototype.visitIfStmt = function (stmt, ctx) {\n        var condition = stmt.condition.visitExpression(this, ctx);\n        if (condition) {\n            return this.visitAllStatements(stmt.trueCase, ctx);\n        }\n        else if (stmt.falseCase != null) {\n            return this.visitAllStatements(stmt.falseCase, ctx);\n        }\n        return null;\n    };\n    StatementInterpreter.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        try {\n            return this.visitAllStatements(stmt.bodyStmts, ctx);\n        }\n        catch (e) {\n            var childCtx = ctx.createChildWihtLocalVars();\n            childCtx.vars.set(CATCH_ERROR_VAR$2, e);\n            childCtx.vars.set(CATCH_STACK_VAR$2, e.stack);\n            return this.visitAllStatements(stmt.catchStmts, childCtx);\n        }\n    };\n    StatementInterpreter.prototype.visitThrowStmt = function (stmt, ctx) {\n        throw stmt.error.visitExpression(this, ctx);\n    };\n    StatementInterpreter.prototype.visitCommentStmt = function (stmt, context) { return null; };\n    StatementInterpreter.prototype.visitJSDocCommentStmt = function (stmt, context) { return null; };\n    StatementInterpreter.prototype.visitInstantiateExpr = function (ast, ctx) {\n        var args = this.visitAllExpressions(ast.args, ctx);\n        var clazz = ast.classExpr.visitExpression(this, ctx);\n        return new (clazz.bind.apply(clazz, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([void 0], args)))();\n    };\n    StatementInterpreter.prototype.visitLiteralExpr = function (ast, ctx) { return ast.value; };\n    StatementInterpreter.prototype.visitExternalExpr = function (ast, ctx) {\n        return this.reflector.resolveExternalReference(ast.value);\n    };\n    StatementInterpreter.prototype.visitConditionalExpr = function (ast, ctx) {\n        if (ast.condition.visitExpression(this, ctx)) {\n            return ast.trueCase.visitExpression(this, ctx);\n        }\n        else if (ast.falseCase != null) {\n            return ast.falseCase.visitExpression(this, ctx);\n        }\n        return null;\n    };\n    StatementInterpreter.prototype.visitNotExpr = function (ast, ctx) {\n        return !ast.condition.visitExpression(this, ctx);\n    };\n    StatementInterpreter.prototype.visitAssertNotNullExpr = function (ast, ctx) {\n        return ast.condition.visitExpression(this, ctx);\n    };\n    StatementInterpreter.prototype.visitCastExpr = function (ast, ctx) {\n        return ast.value.visitExpression(this, ctx);\n    };\n    StatementInterpreter.prototype.visitFunctionExpr = function (ast, ctx) {\n        var paramNames = ast.params.map(function (param) { return param.name; });\n        return _declareFn(paramNames, ast.statements, ctx, this);\n    };\n    StatementInterpreter.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        var paramNames = stmt.params.map(function (param) { return param.name; });\n        ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.exports.push(stmt.name);\n        }\n        return null;\n    };\n    StatementInterpreter.prototype.visitBinaryOperatorExpr = function (ast, ctx) {\n        var _this = this;\n        var lhs = function () { return ast.lhs.visitExpression(_this, ctx); };\n        var rhs = function () { return ast.rhs.visitExpression(_this, ctx); };\n        switch (ast.operator) {\n            case BinaryOperator.Equals:\n                return lhs() == rhs();\n            case BinaryOperator.Identical:\n                return lhs() === rhs();\n            case BinaryOperator.NotEquals:\n                return lhs() != rhs();\n            case BinaryOperator.NotIdentical:\n                return lhs() !== rhs();\n            case BinaryOperator.And:\n                return lhs() && rhs();\n            case BinaryOperator.Or:\n                return lhs() || rhs();\n            case BinaryOperator.Plus:\n                return lhs() + rhs();\n            case BinaryOperator.Minus:\n                return lhs() - rhs();\n            case BinaryOperator.Divide:\n                return lhs() / rhs();\n            case BinaryOperator.Multiply:\n                return lhs() * rhs();\n            case BinaryOperator.Modulo:\n                return lhs() % rhs();\n            case BinaryOperator.Lower:\n                return lhs() < rhs();\n            case BinaryOperator.LowerEquals:\n                return lhs() <= rhs();\n            case BinaryOperator.Bigger:\n                return lhs() > rhs();\n            case BinaryOperator.BiggerEquals:\n                return lhs() >= rhs();\n            default:\n                throw new Error(\"Unknown operator \" + ast.operator);\n        }\n    };\n    StatementInterpreter.prototype.visitReadPropExpr = function (ast, ctx) {\n        var result;\n        var receiver = ast.receiver.visitExpression(this, ctx);\n        result = receiver[ast.name];\n        return result;\n    };\n    StatementInterpreter.prototype.visitReadKeyExpr = function (ast, ctx) {\n        var receiver = ast.receiver.visitExpression(this, ctx);\n        var prop = ast.index.visitExpression(this, ctx);\n        return receiver[prop];\n    };\n    StatementInterpreter.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        return this.visitAllExpressions(ast.entries, ctx);\n    };\n    StatementInterpreter.prototype.visitLiteralMapExpr = function (ast, ctx) {\n        var _this = this;\n        var result = {};\n        ast.entries.forEach(function (entry) { return result[entry.key] = entry.value.visitExpression(_this, ctx); });\n        return result;\n    };\n    StatementInterpreter.prototype.visitCommaExpr = function (ast, context) {\n        var values = this.visitAllExpressions(ast.parts, context);\n        return values[values.length - 1];\n    };\n    StatementInterpreter.prototype.visitAllExpressions = function (expressions, ctx) {\n        var _this = this;\n        return expressions.map(function (expr) { return expr.visitExpression(_this, ctx); });\n    };\n    StatementInterpreter.prototype.visitAllStatements = function (statements, ctx) {\n        for (var i = 0; i < statements.length; i++) {\n            var stmt = statements[i];\n            var val = stmt.visitStatement(this, ctx);\n            if (val instanceof ReturnValue) {\n                return val;\n            }\n        }\n        return null;\n    };\n    return StatementInterpreter;\n}());\nfunction _declareFn(varNames, statements, ctx, visitor) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return _executeFunctionStatements(varNames, args, statements, ctx, visitor);\n    };\n}\nvar CATCH_ERROR_VAR$2 = 'error';\nvar CATCH_STACK_VAR$2 = 'stack';\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An internal module of the Angular compiler that begins with component types,\n * extracts templates, and eventually produces a compiled version of the component\n * ready for linking into an application.\n *\n * @security  When compiling templates at runtime, you must ensure that the entire template comes\n * from a trusted source. Attacker-controlled data introduced by a template could expose your\n * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).\n */\nvar JitCompiler = /** @class */ (function () {\n    function JitCompiler(_metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _summaryResolver, _reflector, _jitEvaluator, _compilerConfig, _console, getExtraNgModuleProviders) {\n        this._metadataResolver = _metadataResolver;\n        this._templateParser = _templateParser;\n        this._styleCompiler = _styleCompiler;\n        this._viewCompiler = _viewCompiler;\n        this._ngModuleCompiler = _ngModuleCompiler;\n        this._summaryResolver = _summaryResolver;\n        this._reflector = _reflector;\n        this._jitEvaluator = _jitEvaluator;\n        this._compilerConfig = _compilerConfig;\n        this._console = _console;\n        this.getExtraNgModuleProviders = getExtraNgModuleProviders;\n        this._compiledTemplateCache = new Map();\n        this._compiledHostTemplateCache = new Map();\n        this._compiledDirectiveWrapperCache = new Map();\n        this._compiledNgModuleCache = new Map();\n        this._sharedStylesheetCount = 0;\n        this._addedAotSummaries = new Set();\n    }\n    JitCompiler.prototype.compileModuleSync = function (moduleType) {\n        return SyncAsync.assertSync(this._compileModuleAndComponents(moduleType, true));\n    };\n    JitCompiler.prototype.compileModuleAsync = function (moduleType) {\n        return Promise.resolve(this._compileModuleAndComponents(moduleType, false));\n    };\n    JitCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\n        return SyncAsync.assertSync(this._compileModuleAndAllComponents(moduleType, true));\n    };\n    JitCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\n        return Promise.resolve(this._compileModuleAndAllComponents(moduleType, false));\n    };\n    JitCompiler.prototype.getComponentFactory = function (component) {\n        var summary = this._metadataResolver.getDirectiveSummary(component);\n        return summary.componentFactory;\n    };\n    JitCompiler.prototype.loadAotSummaries = function (summaries) {\n        this.clearCache();\n        this._addAotSummaries(summaries);\n    };\n    JitCompiler.prototype._addAotSummaries = function (fn) {\n        if (this._addedAotSummaries.has(fn)) {\n            return;\n        }\n        this._addedAotSummaries.add(fn);\n        var summaries = fn();\n        for (var i = 0; i < summaries.length; i++) {\n            var entry = summaries[i];\n            if (typeof entry === 'function') {\n                this._addAotSummaries(entry);\n            }\n            else {\n                var summary = entry;\n                this._summaryResolver.addSummary({ symbol: summary.type.reference, metadata: null, type: summary });\n            }\n        }\n    };\n    JitCompiler.prototype.hasAotSummary = function (ref) { return !!this._summaryResolver.resolveSummary(ref); };\n    JitCompiler.prototype._filterJitIdentifiers = function (ids) {\n        var _this = this;\n        return ids.map(function (mod) { return mod.reference; }).filter(function (ref) { return !_this.hasAotSummary(ref); });\n    };\n    JitCompiler.prototype._compileModuleAndComponents = function (moduleType, isSync) {\n        var _this = this;\n        return SyncAsync.then(this._loadModules(moduleType, isSync), function () {\n            _this._compileComponents(moduleType, null);\n            return _this._compileModule(moduleType);\n        });\n    };\n    JitCompiler.prototype._compileModuleAndAllComponents = function (moduleType, isSync) {\n        var _this = this;\n        return SyncAsync.then(this._loadModules(moduleType, isSync), function () {\n            var componentFactories = [];\n            _this._compileComponents(moduleType, componentFactories);\n            return {\n                ngModuleFactory: _this._compileModule(moduleType),\n                componentFactories: componentFactories\n            };\n        });\n    };\n    JitCompiler.prototype._loadModules = function (mainModule, isSync) {\n        var _this = this;\n        var loading = [];\n        var mainNgModule = this._metadataResolver.getNgModuleMetadata(mainModule);\n        // Note: for runtime compilation, we want to transitively compile all modules,\n        // so we also need to load the declared directives / pipes for all nested modules.\n        this._filterJitIdentifiers(mainNgModule.transitiveModule.modules).forEach(function (nestedNgModule) {\n            // getNgModuleMetadata only returns null if the value passed in is not an NgModule\n            var moduleMeta = _this._metadataResolver.getNgModuleMetadata(nestedNgModule);\n            _this._filterJitIdentifiers(moduleMeta.declaredDirectives).forEach(function (ref) {\n                var promise = _this._metadataResolver.loadDirectiveMetadata(moduleMeta.type.reference, ref, isSync);\n                if (promise) {\n                    loading.push(promise);\n                }\n            });\n            _this._filterJitIdentifiers(moduleMeta.declaredPipes)\n                .forEach(function (ref) { return _this._metadataResolver.getOrLoadPipeMetadata(ref); });\n        });\n        return SyncAsync.all(loading);\n    };\n    JitCompiler.prototype._compileModule = function (moduleType) {\n        var ngModuleFactory = this._compiledNgModuleCache.get(moduleType);\n        if (!ngModuleFactory) {\n            var moduleMeta = this._metadataResolver.getNgModuleMetadata(moduleType);\n            // Always provide a bound Compiler\n            var extraProviders = this.getExtraNgModuleProviders(moduleMeta.type.reference);\n            var outputCtx = createOutputContext();\n            var compileResult = this._ngModuleCompiler.compile(outputCtx, moduleMeta, extraProviders);\n            ngModuleFactory = this._interpretOrJit(ngModuleJitUrl(moduleMeta), outputCtx.statements)[compileResult.ngModuleFactoryVar];\n            this._compiledNgModuleCache.set(moduleMeta.type.reference, ngModuleFactory);\n        }\n        return ngModuleFactory;\n    };\n    /**\n     * @internal\n     */\n    JitCompiler.prototype._compileComponents = function (mainModule, allComponentFactories) {\n        var _this = this;\n        var ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);\n        var moduleByJitDirective = new Map();\n        var templates = new Set();\n        var transJitModules = this._filterJitIdentifiers(ngModule.transitiveModule.modules);\n        transJitModules.forEach(function (localMod) {\n            var localModuleMeta = _this._metadataResolver.getNgModuleMetadata(localMod);\n            _this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach(function (dirRef) {\n                moduleByJitDirective.set(dirRef, localModuleMeta);\n                var dirMeta = _this._metadataResolver.getDirectiveMetadata(dirRef);\n                if (dirMeta.isComponent) {\n                    templates.add(_this._createCompiledTemplate(dirMeta, localModuleMeta));\n                    if (allComponentFactories) {\n                        var template = _this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);\n                        templates.add(template);\n                        allComponentFactories.push(dirMeta.componentFactory);\n                    }\n                }\n            });\n        });\n        transJitModules.forEach(function (localMod) {\n            var localModuleMeta = _this._metadataResolver.getNgModuleMetadata(localMod);\n            _this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach(function (dirRef) {\n                var dirMeta = _this._metadataResolver.getDirectiveMetadata(dirRef);\n                if (dirMeta.isComponent) {\n                    dirMeta.entryComponents.forEach(function (entryComponentType) {\n                        var moduleMeta = moduleByJitDirective.get(entryComponentType.componentType);\n                        templates.add(_this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n                    });\n                }\n            });\n            localModuleMeta.entryComponents.forEach(function (entryComponentType) {\n                if (!_this.hasAotSummary(entryComponentType.componentType)) {\n                    var moduleMeta = moduleByJitDirective.get(entryComponentType.componentType);\n                    templates.add(_this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n                }\n            });\n        });\n        templates.forEach(function (template) { return _this._compileTemplate(template); });\n    };\n    JitCompiler.prototype.clearCacheFor = function (type) {\n        this._compiledNgModuleCache.delete(type);\n        this._metadataResolver.clearCacheFor(type);\n        this._compiledHostTemplateCache.delete(type);\n        var compiledTemplate = this._compiledTemplateCache.get(type);\n        if (compiledTemplate) {\n            this._compiledTemplateCache.delete(type);\n        }\n    };\n    JitCompiler.prototype.clearCache = function () {\n        // Note: don't clear the _addedAotSummaries, as they don't change!\n        this._metadataResolver.clearCache();\n        this._compiledTemplateCache.clear();\n        this._compiledHostTemplateCache.clear();\n        this._compiledNgModuleCache.clear();\n    };\n    JitCompiler.prototype._createCompiledHostTemplate = function (compType, ngModule) {\n        if (!ngModule) {\n            throw new Error(\"Component \" + stringify(compType) + \" is not part of any NgModule or the module has not been imported into your module.\");\n        }\n        var compiledTemplate = this._compiledHostTemplateCache.get(compType);\n        if (!compiledTemplate) {\n            var compMeta = this._metadataResolver.getDirectiveMetadata(compType);\n            assertComponent(compMeta);\n            var hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta, compMeta.componentFactory.viewDefFactory);\n            compiledTemplate =\n                new CompiledTemplate(true, compMeta.type, hostMeta, ngModule, [compMeta.type]);\n            this._compiledHostTemplateCache.set(compType, compiledTemplate);\n        }\n        return compiledTemplate;\n    };\n    JitCompiler.prototype._createCompiledTemplate = function (compMeta, ngModule) {\n        var compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);\n        if (!compiledTemplate) {\n            assertComponent(compMeta);\n            compiledTemplate = new CompiledTemplate(false, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);\n            this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);\n        }\n        return compiledTemplate;\n    };\n    JitCompiler.prototype._compileTemplate = function (template) {\n        var _this = this;\n        if (template.isCompiled) {\n            return;\n        }\n        var compMeta = template.compMeta;\n        var externalStylesheetsByModuleUrl = new Map();\n        var outputContext = createOutputContext();\n        var componentStylesheet = this._styleCompiler.compileComponent(outputContext, compMeta);\n        compMeta.template.externalStylesheets.forEach(function (stylesheetMeta) {\n            var compiledStylesheet = _this._styleCompiler.compileStyles(createOutputContext(), compMeta, stylesheetMeta);\n            externalStylesheetsByModuleUrl.set(stylesheetMeta.moduleUrl, compiledStylesheet);\n        });\n        this._resolveStylesCompileResult(componentStylesheet, externalStylesheetsByModuleUrl);\n        var pipes = template.ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n        var _a = this._parseTemplate(compMeta, template.ngModule, template.directives), parsedTemplate = _a.template, usedPipes = _a.pipes;\n        var compileResult = this._viewCompiler.compileComponent(outputContext, compMeta, parsedTemplate, variable(componentStylesheet.stylesVar), usedPipes);\n        var evalResult = this._interpretOrJit(templateJitUrl(template.ngModule.type, template.compMeta), outputContext.statements);\n        var viewClass = evalResult[compileResult.viewClassVar];\n        var rendererType = evalResult[compileResult.rendererTypeVar];\n        template.compiled(viewClass, rendererType);\n    };\n    JitCompiler.prototype._parseTemplate = function (compMeta, ngModule, directiveIdentifiers) {\n        var _this = this;\n        // Note: ! is ok here as components always have a template.\n        var preserveWhitespaces = compMeta.template.preserveWhitespaces;\n        var directives = directiveIdentifiers.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });\n        var pipes = ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n        return this._templateParser.parse(compMeta, compMeta.template.htmlAst, directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, compMeta.template), preserveWhitespaces);\n    };\n    JitCompiler.prototype._resolveStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {\n        var _this = this;\n        result.dependencies.forEach(function (dep, i) {\n            var nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl);\n            var nestedStylesArr = _this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);\n            dep.setValue(nestedStylesArr);\n        });\n    };\n    JitCompiler.prototype._resolveAndEvalStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {\n        this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);\n        return this._interpretOrJit(sharedStylesheetJitUrl(result.meta, this._sharedStylesheetCount++), result.outputCtx.statements)[result.stylesVar];\n    };\n    JitCompiler.prototype._interpretOrJit = function (sourceUrl, statements) {\n        if (!this._compilerConfig.useJit) {\n            return interpretStatements(statements, this._reflector);\n        }\n        else {\n            return this._jitEvaluator.evaluateStatements(sourceUrl, statements, this._reflector, this._compilerConfig.jitDevMode);\n        }\n    };\n    return JitCompiler;\n}());\nvar CompiledTemplate = /** @class */ (function () {\n    function CompiledTemplate(isHost, compType, compMeta, ngModule, directives) {\n        this.isHost = isHost;\n        this.compType = compType;\n        this.compMeta = compMeta;\n        this.ngModule = ngModule;\n        this.directives = directives;\n        this._viewClass = null;\n        this.isCompiled = false;\n    }\n    CompiledTemplate.prototype.compiled = function (viewClass, rendererType) {\n        this._viewClass = viewClass;\n        this.compMeta.componentViewType.setDelegate(viewClass);\n        for (var prop in rendererType) {\n            this.compMeta.rendererType[prop] = rendererType[prop];\n        }\n        this.isCompiled = true;\n    };\n    return CompiledTemplate;\n}());\nfunction assertComponent(meta) {\n    if (!meta.isComponent) {\n        throw new Error(\"Could not compile '\" + identifierName(meta.type) + \"' because it is not a component.\");\n    }\n}\nfunction createOutputContext() {\n    var importExpr$1 = function (symbol) {\n        return importExpr({ name: identifierName(symbol), moduleName: null, runtime: symbol });\n    };\n    return { statements: [], genFilePath: '', importExpr: importExpr$1, constantPool: new ConstantPool() };\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Provides access to reflection data about symbols that the compiler needs.\n */\nvar CompileReflector = /** @class */ (function () {\n    function CompileReflector() {\n    }\n    return CompileReflector;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create a {@link UrlResolver} with no package prefix.\n */\nfunction createUrlResolverWithoutPackagePrefix() {\n    return new UrlResolver();\n}\nfunction createOfflineCompileUrlResolver() {\n    return new UrlResolver('.');\n}\nvar UrlResolver = /** @class */ (function () {\n    function UrlResolverImpl(_packagePrefix) {\n        if (_packagePrefix === void 0) { _packagePrefix = null; }\n        this._packagePrefix = _packagePrefix;\n    }\n    /**\n     * Resolves the `url` given the `baseUrl`:\n     * - when the `url` is null, the `baseUrl` is returned,\n     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\n     * `baseUrl` and `url`,\n     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\n     * returned as is (ignoring the `baseUrl`)\n     */\n    UrlResolverImpl.prototype.resolve = function (baseUrl, url) {\n        var resolvedUrl = url;\n        if (baseUrl != null && baseUrl.length > 0) {\n            resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);\n        }\n        var resolvedParts = _split(resolvedUrl);\n        var prefix = this._packagePrefix;\n        if (prefix != null && resolvedParts != null &&\n            resolvedParts[_ComponentIndex.Scheme] == 'package') {\n            var path = resolvedParts[_ComponentIndex.Path];\n            prefix = prefix.replace(/\\/+$/, '');\n            path = path.replace(/^\\/+/, '');\n            return prefix + \"/\" + path;\n        }\n        return resolvedUrl;\n    };\n    return UrlResolverImpl;\n}());\n/**\n * Extract the scheme of a URL.\n */\nfunction getUrlScheme(url) {\n    var match = _split(url);\n    return (match && match[_ComponentIndex.Scheme]) || '';\n}\n// The code below is adapted from Traceur:\n// https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js\n/**\n * Builds a URI string from already-encoded parts.\n *\n * No encoding is performed.  Any component may be omitted as either null or\n * undefined.\n *\n * @param opt_scheme The scheme such as 'http'.\n * @param opt_userInfo The user name before the '@'.\n * @param opt_domain The domain such as 'www.google.com', already\n *     URI-encoded.\n * @param opt_port The port number.\n * @param opt_path The path, already URI-encoded.  If it is not\n *     empty, it must begin with a slash.\n * @param opt_queryData The URI-encoded query data.\n * @param opt_fragment The URI-encoded fragment identifier.\n * @return The fully combined URI.\n */\nfunction _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n    var out = [];\n    if (opt_scheme != null) {\n        out.push(opt_scheme + ':');\n    }\n    if (opt_domain != null) {\n        out.push('//');\n        if (opt_userInfo != null) {\n            out.push(opt_userInfo + '@');\n        }\n        out.push(opt_domain);\n        if (opt_port != null) {\n            out.push(':' + opt_port);\n        }\n    }\n    if (opt_path != null) {\n        out.push(opt_path);\n    }\n    if (opt_queryData != null) {\n        out.push('?' + opt_queryData);\n    }\n    if (opt_fragment != null) {\n        out.push('#' + opt_fragment);\n    }\n    return out.join('');\n}\n/**\n * A regular expression for breaking a URI into its component parts.\n *\n * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * The regular expression has been modified slightly to expose the\n * userInfo, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       userInfo -\\\n *    $3 = www.ics.uci.edu   domain     | authority\n *    $4 = <undefined>       port     -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n * @internal\n */\nvar _splitRe = new RegExp('^' +\n    '(?:' +\n    '([^:/?#.]+)' + // scheme - ignore special characters\n    // used by other URL parts such as :,\n    // ?, /, #, and .\n    ':)?' +\n    '(?://' +\n    '(?:([^/?#]*)@)?' + // userInfo\n    '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' + // domain - restrict to letters,\n    // digits, dashes, dots, percent\n    // escapes, and unicode characters.\n    '(?::([0-9]+))?' + // port\n    ')?' +\n    '([^?#]+)?' + // path\n    '(?:\\\\?([^#]*))?' + // query\n    '(?:#(.*))?' + // fragment\n    '$');\n/**\n * The index of each URI component in the return value of goog.uri.utils.split.\n * @enum {number}\n */\nvar _ComponentIndex;\n(function (_ComponentIndex) {\n    _ComponentIndex[_ComponentIndex[\"Scheme\"] = 1] = \"Scheme\";\n    _ComponentIndex[_ComponentIndex[\"UserInfo\"] = 2] = \"UserInfo\";\n    _ComponentIndex[_ComponentIndex[\"Domain\"] = 3] = \"Domain\";\n    _ComponentIndex[_ComponentIndex[\"Port\"] = 4] = \"Port\";\n    _ComponentIndex[_ComponentIndex[\"Path\"] = 5] = \"Path\";\n    _ComponentIndex[_ComponentIndex[\"QueryData\"] = 6] = \"QueryData\";\n    _ComponentIndex[_ComponentIndex[\"Fragment\"] = 7] = \"Fragment\";\n})(_ComponentIndex || (_ComponentIndex = {}));\n/**\n * Splits a URI into its component parts.\n *\n * Each component can be accessed via the component indices; for example:\n * <pre>\n * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\n * </pre>\n *\n * @param uri The URI string to examine.\n * @return Each component still URI-encoded.\n *     Each component that is present will contain the encoded value, whereas\n *     components that are not present will be undefined or empty, depending\n *     on the browser's regular expression implementation.  Never null, since\n *     arbitrary strings may still look like path names.\n */\nfunction _split(uri) {\n    return uri.match(_splitRe);\n}\n/**\n  * Removes dot segments in given path component, as described in\n  * RFC 3986, section 5.2.4.\n  *\n  * @param path A non-empty path component.\n  * @return Path component with removed dot segments.\n  */\nfunction _removeDotSegments(path) {\n    if (path == '/')\n        return '/';\n    var leadingSlash = path[0] == '/' ? '/' : '';\n    var trailingSlash = path[path.length - 1] === '/' ? '/' : '';\n    var segments = path.split('/');\n    var out = [];\n    var up = 0;\n    for (var pos = 0; pos < segments.length; pos++) {\n        var segment = segments[pos];\n        switch (segment) {\n            case '':\n            case '.':\n                break;\n            case '..':\n                if (out.length > 0) {\n                    out.pop();\n                }\n                else {\n                    up++;\n                }\n                break;\n            default:\n                out.push(segment);\n        }\n    }\n    if (leadingSlash == '') {\n        while (up-- > 0) {\n            out.unshift('..');\n        }\n        if (out.length === 0)\n            out.push('.');\n    }\n    return leadingSlash + out.join('/') + trailingSlash;\n}\n/**\n * Takes an array of the parts from split and canonicalizes the path part\n * and then joins all the parts.\n */\nfunction _joinAndCanonicalizePath(parts) {\n    var path = parts[_ComponentIndex.Path];\n    path = path == null ? '' : _removeDotSegments(path);\n    parts[_ComponentIndex.Path] = path;\n    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);\n}\n/**\n * Resolves a URL.\n * @param base The URL acting as the base URL.\n * @param to The URL to resolve.\n */\nfunction _resolveUrl(base, url) {\n    var parts = _split(encodeURI(url));\n    var baseParts = _split(base);\n    if (parts[_ComponentIndex.Scheme] != null) {\n        return _joinAndCanonicalizePath(parts);\n    }\n    else {\n        parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];\n    }\n    for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {\n        if (parts[i] == null) {\n            parts[i] = baseParts[i];\n        }\n    }\n    if (parts[_ComponentIndex.Path][0] == '/') {\n        return _joinAndCanonicalizePath(parts);\n    }\n    var path = baseParts[_ComponentIndex.Path];\n    if (path == null)\n        path = '/';\n    var index = path.lastIndexOf('/');\n    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];\n    parts[_ComponentIndex.Path] = path;\n    return _joinAndCanonicalizePath(parts);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Extractor = /** @class */ (function () {\n    function Extractor(host, staticSymbolResolver, messageBundle, metadataResolver) {\n        this.host = host;\n        this.staticSymbolResolver = staticSymbolResolver;\n        this.messageBundle = messageBundle;\n        this.metadataResolver = metadataResolver;\n    }\n    Extractor.prototype.extract = function (rootFiles) {\n        var _this = this;\n        var _a = analyzeAndValidateNgModules(rootFiles, this.host, this.staticSymbolResolver, this.metadataResolver), files = _a.files, ngModules = _a.ngModules;\n        return Promise\n            .all(ngModules.map(function (ngModule) { return _this.metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false); }))\n            .then(function () {\n            var errors = [];\n            files.forEach(function (file) {\n                var compMetas = [];\n                file.directives.forEach(function (directiveType) {\n                    var dirMeta = _this.metadataResolver.getDirectiveMetadata(directiveType);\n                    if (dirMeta && dirMeta.isComponent) {\n                        compMetas.push(dirMeta);\n                    }\n                });\n                compMetas.forEach(function (compMeta) {\n                    var html = compMeta.template.template;\n                    // Template URL points to either an HTML or TS file depending on\n                    // whether the file is used with `templateUrl:` or `template:`,\n                    // respectively.\n                    var templateUrl = compMeta.template.templateUrl;\n                    var interpolationConfig = InterpolationConfig.fromArray(compMeta.template.interpolation);\n                    errors.push.apply(errors, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(_this.messageBundle.updateFromTemplate(html, templateUrl, interpolationConfig)));\n                });\n            });\n            if (errors.length) {\n                throw new Error(errors.map(function (e) { return e.toString(); }).join('\\n'));\n            }\n            return _this.messageBundle;\n        });\n    };\n    Extractor.create = function (host, locale) {\n        var htmlParser = new HtmlParser();\n        var urlResolver = createAotUrlResolver(host);\n        var symbolCache = new StaticSymbolCache();\n        var summaryResolver = new AotSummaryResolver(host, symbolCache);\n        var staticSymbolResolver = new StaticSymbolResolver(host, symbolCache, summaryResolver);\n        var staticReflector = new StaticReflector(summaryResolver, staticSymbolResolver);\n        var config = new CompilerConfig({ defaultEncapsulation: ViewEncapsulation.Emulated, useJit: false });\n        var normalizer = new DirectiveNormalizer({ get: function (url) { return host.loadResource(url); } }, urlResolver, htmlParser, config);\n        var elementSchemaRegistry = new DomElementSchemaRegistry();\n        var resolver = new CompileMetadataResolver(config, htmlParser, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector);\n        // TODO(vicb): implicit tags & attributes\n        var messageBundle = new MessageBundle(htmlParser, [], {}, locale);\n        var extractor = new Extractor(host, staticSymbolResolver, messageBundle, resolver);\n        return { extractor: extractor, staticReflector: staticReflector };\n    };\n    return Extractor;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Processes `Target`s with a given set of directives and performs a binding operation, which\n * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the\n * target.\n */\nvar R3TargetBinder = /** @class */ (function () {\n    function R3TargetBinder(directiveMatcher) {\n        this.directiveMatcher = directiveMatcher;\n    }\n    /**\n     * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains\n     * metadata about the types referenced in the template.\n     */\n    R3TargetBinder.prototype.bind = function (target) {\n        if (!target.template) {\n            // TODO(alxhub): handle targets which contain things like HostBindings, etc.\n            throw new Error('Binding without a template not yet supported');\n        }\n        // First, parse the template into a `Scope` structure. This operation captures the syntactic\n        // scopes in the template and makes them available for later use.\n        var scope = Scope.apply(target.template);\n        // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:\n        //   - directives: Map of nodes (elements & ng-templates) to the directives on them.\n        //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims\n        //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.\n        //   - references: Map of #references to their targets.\n        var _a = DirectiveBinder.apply(target.template, this.directiveMatcher), directives = _a.directives, bindings = _a.bindings, references = _a.references;\n        // Finally, run the TemplateBinder to bind references, variables, and other entities within the\n        // template. This extracts all the metadata that doesn't depend on directive matching.\n        var _b = TemplateBinder.apply(target.template, scope), expressions = _b.expressions, symbols = _b.symbols, nestingLevel = _b.nestingLevel, usedPipes = _b.usedPipes;\n        return new R3BoundTarget(target, directives, bindings, references, expressions, symbols, nestingLevel, usedPipes);\n    };\n    return R3TargetBinder;\n}());\n/**\n * Represents a binding scope within a template.\n *\n * Any variables, references, or other named entities declared within the template will\n * be captured and available by name in `namedEntities`. Additionally, child templates will\n * be analyzed and have their child `Scope`s available in `childScopes`.\n */\nvar Scope = /** @class */ (function () {\n    function Scope(parentScope) {\n        this.parentScope = parentScope;\n        /**\n         * Named members of the `Scope`, such as `Reference`s or `Variable`s.\n         */\n        this.namedEntities = new Map();\n        /**\n         * Child `Scope`s for immediately nested `Template`s.\n         */\n        this.childScopes = new Map();\n    }\n    /**\n     * Process a template (either as a `Template` sub-template with variables, or a plain array of\n     * template `Node`s) and construct its `Scope`.\n     */\n    Scope.apply = function (template) {\n        var scope = new Scope();\n        scope.ingest(template);\n        return scope;\n    };\n    /**\n     * Internal method to process the template and populate the `Scope`.\n     */\n    Scope.prototype.ingest = function (template) {\n        var _this = this;\n        if (template instanceof Template) {\n            // Variables on an <ng-template> are defined in the inner scope.\n            template.variables.forEach(function (node) { return _this.visitVariable(node); });\n            // Process the nodes of the template.\n            template.children.forEach(function (node) { return node.visit(_this); });\n        }\n        else {\n            // No overarching `Template` instance, so process the nodes directly.\n            template.forEach(function (node) { return node.visit(_this); });\n        }\n    };\n    Scope.prototype.visitElement = function (element) {\n        var _this = this;\n        // `Element`s in the template may have `Reference`s which are captured in the scope.\n        element.references.forEach(function (node) { return _this.visitReference(node); });\n        // Recurse into the `Element`'s children.\n        element.children.forEach(function (node) { return node.visit(_this); });\n    };\n    Scope.prototype.visitTemplate = function (template) {\n        var _this = this;\n        // References on a <ng-template> are defined in the outer scope, so capture them before\n        // processing the template's child scope.\n        template.references.forEach(function (node) { return _this.visitReference(node); });\n        // Next, create an inner scope and process the template within it.\n        var scope = new Scope(this);\n        scope.ingest(template);\n        this.childScopes.set(template, scope);\n    };\n    Scope.prototype.visitVariable = function (variable) {\n        // Declare the variable if it's not already.\n        this.maybeDeclare(variable);\n    };\n    Scope.prototype.visitReference = function (reference) {\n        // Declare the variable if it's not already.\n        this.maybeDeclare(reference);\n    };\n    // Unused visitors.\n    Scope.prototype.visitContent = function (content) { };\n    Scope.prototype.visitBoundAttribute = function (attr) { };\n    Scope.prototype.visitBoundEvent = function (event) { };\n    Scope.prototype.visitBoundText = function (text) { };\n    Scope.prototype.visitText = function (text) { };\n    Scope.prototype.visitTextAttribute = function (attr) { };\n    Scope.prototype.visitIcu = function (icu) { };\n    Scope.prototype.maybeDeclare = function (thing) {\n        // Declare something with a name, as long as that name isn't taken.\n        if (!this.namedEntities.has(thing.name)) {\n            this.namedEntities.set(thing.name, thing);\n        }\n    };\n    /**\n     * Look up a variable within this `Scope`.\n     *\n     * This can recurse into a parent `Scope` if it's available.\n     */\n    Scope.prototype.lookup = function (name) {\n        if (this.namedEntities.has(name)) {\n            // Found in the local scope.\n            return this.namedEntities.get(name);\n        }\n        else if (this.parentScope !== undefined) {\n            // Not in the local scope, but there's a parent scope so check there.\n            return this.parentScope.lookup(name);\n        }\n        else {\n            // At the top level and it wasn't found.\n            return null;\n        }\n    };\n    /**\n     * Get the child scope for a `Template`.\n     *\n     * This should always be defined.\n     */\n    Scope.prototype.getChildScope = function (template) {\n        var res = this.childScopes.get(template);\n        if (res === undefined) {\n            throw new Error(\"Assertion error: child scope for \" + template + \" not found\");\n        }\n        return res;\n    };\n    return Scope;\n}());\n/**\n * Processes a template and matches directives on nodes (elements and templates).\n *\n * Usually used via the static `apply()` method.\n */\nvar DirectiveBinder = /** @class */ (function () {\n    function DirectiveBinder(matcher, directives, bindings, references) {\n        this.matcher = matcher;\n        this.directives = directives;\n        this.bindings = bindings;\n        this.references = references;\n    }\n    /**\n     * Process a template (list of `Node`s) and perform directive matching against each node.\n     *\n     * @param template the list of template `Node`s to match (recursively).\n     * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for\n     * this template.\n     * @returns three maps which contain information about directives in the template: the\n     * `directives` map which lists directives matched on each node, the `bindings` map which\n     * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`\n     * map which resolves #references (`Reference`s) within the template to the named directive or\n     * template node.\n     */\n    DirectiveBinder.apply = function (template, selectorMatcher) {\n        var directives = new Map();\n        var bindings = new Map();\n        var references = new Map();\n        var matcher = new DirectiveBinder(selectorMatcher, directives, bindings, references);\n        matcher.ingest(template);\n        return { directives: directives, bindings: bindings, references: references };\n    };\n    DirectiveBinder.prototype.ingest = function (template) {\n        var _this = this;\n        template.forEach(function (node) { return node.visit(_this); });\n    };\n    DirectiveBinder.prototype.visitElement = function (element) { this.visitElementOrTemplate(element.name, element); };\n    DirectiveBinder.prototype.visitTemplate = function (template) { this.visitElementOrTemplate('ng-template', template); };\n    DirectiveBinder.prototype.visitElementOrTemplate = function (tag, node) {\n        var _this = this;\n        // First, determine the HTML shape of the node for the purpose of directive matching.\n        // Do this by building up a `CssSelector` for the node.\n        var cssSelector = new CssSelector();\n        cssSelector.setElement(tag);\n        // Add attributes to the CSS selector.\n        var attrs = getAttrsForDirectiveMatching(node);\n        Object.getOwnPropertyNames(attrs).forEach(function (name) {\n            var value = attrs[name];\n            cssSelector.addAttribute(name, value);\n            // Treat the 'class' attribute specially.\n            if (name.toLowerCase() === 'class') {\n                var classes = value.trim().split(/\\s+/g);\n                classes.forEach(function (className) { return cssSelector.addClassName(className); });\n            }\n        });\n        // Next, use the `SelectorMatcher` to get the list of directives on the node.\n        var directives = [];\n        this.matcher.match(cssSelector, function (_, directive) { return directives.push(directive); });\n        if (directives.length > 0) {\n            this.directives.set(node, directives);\n        }\n        // Resolve any references that are created on this node.\n        node.references.forEach(function (ref) {\n            var dirTarget = null;\n            // If the reference expression is empty, then it matches the \"primary\" directive on the node\n            // (if there is one). Otherwise it matches the host node itself (either an element or\n            // <ng-template> node).\n            if (ref.value.trim() === '') {\n                // This could be a reference to a component if there is one.\n                dirTarget = directives.find(function (dir) { return dir.isComponent; }) || null;\n            }\n            else {\n                // This is a reference to a directive exported via exportAs. One should exist.\n                dirTarget =\n                    directives.find(function (dir) { return dir.exportAs !== null && dir.exportAs.some(function (value) { return value === ref.value; }); }) ||\n                        null;\n                // Check if a matching directive was found, and error if it wasn't.\n                if (dirTarget === null) {\n                    // TODO(alxhub): Return an error value here that can be used for template validation.\n                    throw new Error(\"Assertion error: failed to find directive with exportAs: \" + ref.value);\n                }\n            }\n            if (dirTarget !== null) {\n                // This reference points to a directive.\n                _this.references.set(ref, { directive: dirTarget, node: node });\n            }\n            else {\n                // This reference points to the node itself.\n                _this.references.set(ref, node);\n            }\n        });\n        // Associate attributes/bindings on the node with directives or with the node itself.\n        var processAttribute = function (attribute) {\n            var dir = directives.find(function (dir) { return dir.inputs.hasOwnProperty(attribute.name); });\n            if (dir !== undefined) {\n                _this.bindings.set(attribute, dir);\n            }\n            else {\n                _this.bindings.set(attribute, node);\n            }\n        };\n        node.attributes.forEach(processAttribute);\n        node.inputs.forEach(processAttribute);\n        node.outputs.forEach(processAttribute);\n        if (node instanceof Template) {\n            node.templateAttrs.forEach(processAttribute);\n        }\n        // Recurse into the node's children.\n        node.children.forEach(function (child) { return child.visit(_this); });\n    };\n    // Unused visitors.\n    DirectiveBinder.prototype.visitContent = function (content) { };\n    DirectiveBinder.prototype.visitVariable = function (variable) { };\n    DirectiveBinder.prototype.visitReference = function (reference) { };\n    DirectiveBinder.prototype.visitTextAttribute = function (attribute) { };\n    DirectiveBinder.prototype.visitBoundAttribute = function (attribute) { };\n    DirectiveBinder.prototype.visitBoundEvent = function (attribute) { };\n    DirectiveBinder.prototype.visitBoundAttributeOrEvent = function (node) { };\n    DirectiveBinder.prototype.visitText = function (text) { };\n    DirectiveBinder.prototype.visitBoundText = function (text) { };\n    DirectiveBinder.prototype.visitIcu = function (icu) { };\n    return DirectiveBinder;\n}());\n/**\n * Processes a template and extract metadata about expressions and symbols within.\n *\n * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched\n * within the template in order to operate.\n *\n * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided\n * by overridden methods from that visitor.\n */\nvar TemplateBinder = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(TemplateBinder, _super);\n    function TemplateBinder(bindings, symbols, usedPipes, nestingLevel, scope, template, level) {\n        var _this = _super.call(this) || this;\n        _this.bindings = bindings;\n        _this.symbols = symbols;\n        _this.usedPipes = usedPipes;\n        _this.nestingLevel = nestingLevel;\n        _this.scope = scope;\n        _this.template = template;\n        _this.level = level;\n        _this.pipesUsed = [];\n        // Save a bit of processing time by constructing this closure in advance.\n        _this.visitNode = function (node) { return node.visit(_this); };\n        return _this;\n    }\n    /**\n     * Process a template and extract metadata about expressions and symbols within.\n     *\n     * @param template the nodes of the template to process\n     * @param scope the `Scope` of the template being processed.\n     * @returns three maps which contain metadata about the template: `expressions` which interprets\n     * special `AST` nodes in expressions as pointing to references or variables declared within the\n     * template, `symbols` which maps those variables and references to the nested `Template` which\n     * declares them, if any, and `nestingLevel` which associates each `Template` with a integer\n     * nesting level (how many levels deep within the template structure the `Template` is), starting\n     * at 1.\n     */\n    TemplateBinder.apply = function (template, scope) {\n        var expressions = new Map();\n        var symbols = new Map();\n        var nestingLevel = new Map();\n        var usedPipes = new Set();\n        // The top-level template has nesting level 0.\n        var binder = new TemplateBinder(expressions, symbols, usedPipes, nestingLevel, scope, template instanceof Template ? template : null, 0);\n        binder.ingest(template);\n        return { expressions: expressions, symbols: symbols, nestingLevel: nestingLevel, usedPipes: usedPipes };\n    };\n    TemplateBinder.prototype.ingest = function (template) {\n        if (template instanceof Template) {\n            // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,\n            // and references were all processed in the scope of the containing template.\n            template.variables.forEach(this.visitNode);\n            template.children.forEach(this.visitNode);\n            // Set the nesting level.\n            this.nestingLevel.set(template, this.level);\n        }\n        else {\n            // Visit each node from the top-level template.\n            template.forEach(this.visitNode);\n        }\n    };\n    TemplateBinder.prototype.visitElement = function (element) {\n        // Visit the inputs, outputs, and children of the element.\n        element.inputs.forEach(this.visitNode);\n        element.outputs.forEach(this.visitNode);\n        element.children.forEach(this.visitNode);\n    };\n    TemplateBinder.prototype.visitTemplate = function (template) {\n        // First, visit inputs, outputs and template attributes of the template node.\n        template.inputs.forEach(this.visitNode);\n        template.outputs.forEach(this.visitNode);\n        template.templateAttrs.forEach(this.visitNode);\n        // References are also evaluated in the outer context.\n        template.references.forEach(this.visitNode);\n        // Next, recurse into the template using its scope, and bumping the nesting level up by one.\n        var childScope = this.scope.getChildScope(template);\n        var binder = new TemplateBinder(this.bindings, this.symbols, this.usedPipes, this.nestingLevel, childScope, template, this.level + 1);\n        binder.ingest(template);\n    };\n    TemplateBinder.prototype.visitVariable = function (variable) {\n        // Register the `Variable` as a symbol in the current `Template`.\n        if (this.template !== null) {\n            this.symbols.set(variable, this.template);\n        }\n    };\n    TemplateBinder.prototype.visitReference = function (reference) {\n        // Register the `Reference` as a symbol in the current `Template`.\n        if (this.template !== null) {\n            this.symbols.set(reference, this.template);\n        }\n    };\n    // Unused template visitors\n    TemplateBinder.prototype.visitText = function (text) { };\n    TemplateBinder.prototype.visitContent = function (content) { };\n    TemplateBinder.prototype.visitTextAttribute = function (attribute) { };\n    TemplateBinder.prototype.visitIcu = function (icu) { };\n    // The remaining visitors are concerned with processing AST expressions within template bindings\n    TemplateBinder.prototype.visitBoundAttribute = function (attribute) { attribute.value.visit(this); };\n    TemplateBinder.prototype.visitBoundEvent = function (event) { event.handler.visit(this); };\n    TemplateBinder.prototype.visitBoundText = function (text) { text.value.visit(this); };\n    TemplateBinder.prototype.visitPipe = function (ast, context) {\n        this.usedPipes.add(ast.name);\n        return _super.prototype.visitPipe.call(this, ast, context);\n    };\n    // These five types of AST expressions can refer to expression roots, which could be variables\n    // or references in the current scope.\n    TemplateBinder.prototype.visitPropertyRead = function (ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return _super.prototype.visitPropertyRead.call(this, ast, context);\n    };\n    TemplateBinder.prototype.visitSafePropertyRead = function (ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return _super.prototype.visitSafePropertyRead.call(this, ast, context);\n    };\n    TemplateBinder.prototype.visitPropertyWrite = function (ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return _super.prototype.visitPropertyWrite.call(this, ast, context);\n    };\n    TemplateBinder.prototype.visitMethodCall = function (ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return _super.prototype.visitMethodCall.call(this, ast, context);\n    };\n    TemplateBinder.prototype.visitSafeMethodCall = function (ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return _super.prototype.visitSafeMethodCall.call(this, ast, context);\n    };\n    TemplateBinder.prototype.maybeMap = function (scope, ast, name) {\n        // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an\n        // `AST` expression that maps to a `Variable` or `Reference`.\n        if (!(ast.receiver instanceof ImplicitReceiver)) {\n            return;\n        }\n        // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is\n        // probably a property on the top-level component context.\n        var target = this.scope.lookup(name);\n        if (target !== null) {\n            this.bindings.set(ast, target);\n        }\n    };\n    return TemplateBinder;\n}(RecursiveAstVisitor$1));\n/**\n * Metadata container for a `Target` that allows queries for specific bits of metadata.\n *\n * See `BoundTarget` for documentation on the individual methods.\n */\nvar R3BoundTarget = /** @class */ (function () {\n    function R3BoundTarget(target, directives, bindings, references, exprTargets, symbols, nestingLevel, usedPipes) {\n        this.target = target;\n        this.directives = directives;\n        this.bindings = bindings;\n        this.references = references;\n        this.exprTargets = exprTargets;\n        this.symbols = symbols;\n        this.nestingLevel = nestingLevel;\n        this.usedPipes = usedPipes;\n    }\n    R3BoundTarget.prototype.getDirectivesOfNode = function (node) {\n        return this.directives.get(node) || null;\n    };\n    R3BoundTarget.prototype.getReferenceTarget = function (ref) {\n        return this.references.get(ref) || null;\n    };\n    R3BoundTarget.prototype.getConsumerOfBinding = function (binding) {\n        return this.bindings.get(binding) || null;\n    };\n    R3BoundTarget.prototype.getExpressionTarget = function (expr) {\n        return this.exprTargets.get(expr) || null;\n    };\n    R3BoundTarget.prototype.getTemplateOfSymbol = function (symbol) {\n        return this.symbols.get(symbol) || null;\n    };\n    R3BoundTarget.prototype.getNestingLevel = function (template) { return this.nestingLevel.get(template) || 0; };\n    R3BoundTarget.prototype.getUsedDirectives = function () {\n        var set = new Set();\n        this.directives.forEach(function (dirs) { return dirs.forEach(function (dir) { return set.add(dir); }); });\n        return Array.from(set.values());\n    };\n    R3BoundTarget.prototype.getUsedPipes = function () { return Array.from(this.usedPipes); };\n    return R3BoundTarget;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n// This function call has a global side effects and publishes the compiler into global namespace for\n// the late binding of the Compiler to the @angular/core for jit compilation.\npublishFacade(_global);\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n//# sourceMappingURL=compiler.js.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"../../node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL2Zlc201L2NvbXBpbGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9Vc2Vycy9qYmlhc2kvTmFtaWNzL09wZW5Tb3VyY2UvZ29uZGVsL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9mZXNtNS9jb21waWxlci5qcz84YTE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2OC4yLjE0XG4gKiAoYykgMjAxMC0yMDE5IEdvb2dsZSBMTEMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5cbmltcG9ydCB7IF9fYXNzaWduLCBfX3NwcmVhZCwgX19leHRlbmRzLCBfX3ZhbHVlcywgX19yZWFkIH0gZnJvbSAndHNsaWInO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVGFnQ29udGVudFR5cGU7XG4oZnVuY3Rpb24gKFRhZ0NvbnRlbnRUeXBlKSB7XG4gICAgVGFnQ29udGVudFR5cGVbVGFnQ29udGVudFR5cGVbXCJSQVdfVEVYVFwiXSA9IDBdID0gXCJSQVdfVEVYVFwiO1xuICAgIFRhZ0NvbnRlbnRUeXBlW1RhZ0NvbnRlbnRUeXBlW1wiRVNDQVBBQkxFX1JBV19URVhUXCJdID0gMV0gPSBcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiO1xuICAgIFRhZ0NvbnRlbnRUeXBlW1RhZ0NvbnRlbnRUeXBlW1wiUEFSU0FCTEVfREFUQVwiXSA9IDJdID0gXCJQQVJTQUJMRV9EQVRBXCI7XG59KShUYWdDb250ZW50VHlwZSB8fCAoVGFnQ29udGVudFR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gc3BsaXROc05hbWUoZWxlbWVudE5hbWUpIHtcbiAgICBpZiAoZWxlbWVudE5hbWVbMF0gIT0gJzonKSB7XG4gICAgICAgIHJldHVybiBbbnVsbCwgZWxlbWVudE5hbWVdO1xuICAgIH1cbiAgICB2YXIgY29sb25JbmRleCA9IGVsZW1lbnROYW1lLmluZGV4T2YoJzonLCAxKTtcbiAgICBpZiAoY29sb25JbmRleCA9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBmb3JtYXQgXFxcIlwiICsgZWxlbWVudE5hbWUgKyBcIlxcXCIgZXhwZWN0aW5nIFxcXCI6bmFtZXNwYWNlOm5hbWVcXFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gW2VsZW1lbnROYW1lLnNsaWNlKDEsIGNvbG9uSW5kZXgpLCBlbGVtZW50TmFtZS5zbGljZShjb2xvbkluZGV4ICsgMSldO1xufVxuLy8gYDxuZy1jb250YWluZXI+YCB0YWdzIHdvcmsgdGhlIHNhbWUgcmVnYXJkbGVzcyB0aGUgbmFtZXNwYWNlXG5mdW5jdGlvbiBpc05nQ29udGFpbmVyKHRhZ05hbWUpIHtcbiAgICByZXR1cm4gc3BsaXROc05hbWUodGFnTmFtZSlbMV0gPT09ICduZy1jb250YWluZXInO1xufVxuLy8gYDxuZy1jb250ZW50PmAgdGFncyB3b3JrIHRoZSBzYW1lIHJlZ2FyZGxlc3MgdGhlIG5hbWVzcGFjZVxuZnVuY3Rpb24gaXNOZ0NvbnRlbnQodGFnTmFtZSkge1xuICAgIHJldHVybiBzcGxpdE5zTmFtZSh0YWdOYW1lKVsxXSA9PT0gJ25nLWNvbnRlbnQnO1xufVxuLy8gYDxuZy10ZW1wbGF0ZT5gIHRhZ3Mgd29yayB0aGUgc2FtZSByZWdhcmRsZXNzIHRoZSBuYW1lc3BhY2VcbmZ1bmN0aW9uIGlzTmdUZW1wbGF0ZSh0YWdOYW1lKSB7XG4gICAgcmV0dXJuIHNwbGl0TnNOYW1lKHRhZ05hbWUpWzFdID09PSAnbmctdGVtcGxhdGUnO1xufVxuZnVuY3Rpb24gZ2V0TnNQcmVmaXgoZnVsbE5hbWUpIHtcbiAgICByZXR1cm4gZnVsbE5hbWUgPT09IG51bGwgPyBudWxsIDogc3BsaXROc05hbWUoZnVsbE5hbWUpWzBdO1xufVxuZnVuY3Rpb24gbWVyZ2VOc0FuZE5hbWUocHJlZml4LCBsb2NhbE5hbWUpIHtcbiAgICByZXR1cm4gcHJlZml4ID8gXCI6XCIgKyBwcmVmaXggKyBcIjpcIiArIGxvY2FsTmFtZSA6IGxvY2FsTmFtZTtcbn1cbi8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjbmFtZWQtY2hhcmFjdGVyLXJlZmVyZW5jZXNcbi8vIHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbnRpdGllcy5qc29uXG4vLyBUaGlzIGxpc3QgaXMgbm90IGV4aGF1c3RpdmUgdG8ga2VlcCB0aGUgY29tcGlsZXIgZm9vdHByaW50IGxvdy5cbi8vIFRoZSBgJiMxMjM7YCAvIGAmI3gxYWI7YCBzeW50YXggc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSBkb2VzIG5vdFxuLy8gZXhpc3QuXG52YXIgTkFNRURfRU5USVRJRVMgPSB7XG4gICAgJ0FhY3V0ZSc6ICdcXHUwMEMxJyxcbiAgICAnYWFjdXRlJzogJ1xcdTAwRTEnLFxuICAgICdBY2lyYyc6ICdcXHUwMEMyJyxcbiAgICAnYWNpcmMnOiAnXFx1MDBFMicsXG4gICAgJ2FjdXRlJzogJ1xcdTAwQjQnLFxuICAgICdBRWxpZyc6ICdcXHUwMEM2JyxcbiAgICAnYWVsaWcnOiAnXFx1MDBFNicsXG4gICAgJ0FncmF2ZSc6ICdcXHUwMEMwJyxcbiAgICAnYWdyYXZlJzogJ1xcdTAwRTAnLFxuICAgICdhbGVmc3ltJzogJ1xcdTIxMzUnLFxuICAgICdBbHBoYSc6ICdcXHUwMzkxJyxcbiAgICAnYWxwaGEnOiAnXFx1MDNCMScsXG4gICAgJ2FtcCc6ICcmJyxcbiAgICAnYW5kJzogJ1xcdTIyMjcnLFxuICAgICdhbmcnOiAnXFx1MjIyMCcsXG4gICAgJ2Fwb3MnOiAnXFx1MDAyNycsXG4gICAgJ0FyaW5nJzogJ1xcdTAwQzUnLFxuICAgICdhcmluZyc6ICdcXHUwMEU1JyxcbiAgICAnYXN5bXAnOiAnXFx1MjI0OCcsXG4gICAgJ0F0aWxkZSc6ICdcXHUwMEMzJyxcbiAgICAnYXRpbGRlJzogJ1xcdTAwRTMnLFxuICAgICdBdW1sJzogJ1xcdTAwQzQnLFxuICAgICdhdW1sJzogJ1xcdTAwRTQnLFxuICAgICdiZHF1byc6ICdcXHUyMDFFJyxcbiAgICAnQmV0YSc6ICdcXHUwMzkyJyxcbiAgICAnYmV0YSc6ICdcXHUwM0IyJyxcbiAgICAnYnJ2YmFyJzogJ1xcdTAwQTYnLFxuICAgICdidWxsJzogJ1xcdTIwMjInLFxuICAgICdjYXAnOiAnXFx1MjIyOScsXG4gICAgJ0NjZWRpbCc6ICdcXHUwMEM3JyxcbiAgICAnY2NlZGlsJzogJ1xcdTAwRTcnLFxuICAgICdjZWRpbCc6ICdcXHUwMEI4JyxcbiAgICAnY2VudCc6ICdcXHUwMEEyJyxcbiAgICAnQ2hpJzogJ1xcdTAzQTcnLFxuICAgICdjaGknOiAnXFx1MDNDNycsXG4gICAgJ2NpcmMnOiAnXFx1MDJDNicsXG4gICAgJ2NsdWJzJzogJ1xcdTI2NjMnLFxuICAgICdjb25nJzogJ1xcdTIyNDUnLFxuICAgICdjb3B5JzogJ1xcdTAwQTknLFxuICAgICdjcmFycic6ICdcXHUyMUI1JyxcbiAgICAnY3VwJzogJ1xcdTIyMkEnLFxuICAgICdjdXJyZW4nOiAnXFx1MDBBNCcsXG4gICAgJ2RhZ2dlcic6ICdcXHUyMDIwJyxcbiAgICAnRGFnZ2VyJzogJ1xcdTIwMjEnLFxuICAgICdkYXJyJzogJ1xcdTIxOTMnLFxuICAgICdkQXJyJzogJ1xcdTIxRDMnLFxuICAgICdkZWcnOiAnXFx1MDBCMCcsXG4gICAgJ0RlbHRhJzogJ1xcdTAzOTQnLFxuICAgICdkZWx0YSc6ICdcXHUwM0I0JyxcbiAgICAnZGlhbXMnOiAnXFx1MjY2NicsXG4gICAgJ2RpdmlkZSc6ICdcXHUwMEY3JyxcbiAgICAnRWFjdXRlJzogJ1xcdTAwQzknLFxuICAgICdlYWN1dGUnOiAnXFx1MDBFOScsXG4gICAgJ0VjaXJjJzogJ1xcdTAwQ0EnLFxuICAgICdlY2lyYyc6ICdcXHUwMEVBJyxcbiAgICAnRWdyYXZlJzogJ1xcdTAwQzgnLFxuICAgICdlZ3JhdmUnOiAnXFx1MDBFOCcsXG4gICAgJ2VtcHR5JzogJ1xcdTIyMDUnLFxuICAgICdlbXNwJzogJ1xcdTIwMDMnLFxuICAgICdlbnNwJzogJ1xcdTIwMDInLFxuICAgICdFcHNpbG9uJzogJ1xcdTAzOTUnLFxuICAgICdlcHNpbG9uJzogJ1xcdTAzQjUnLFxuICAgICdlcXVpdic6ICdcXHUyMjYxJyxcbiAgICAnRXRhJzogJ1xcdTAzOTcnLFxuICAgICdldGEnOiAnXFx1MDNCNycsXG4gICAgJ0VUSCc6ICdcXHUwMEQwJyxcbiAgICAnZXRoJzogJ1xcdTAwRjAnLFxuICAgICdFdW1sJzogJ1xcdTAwQ0InLFxuICAgICdldW1sJzogJ1xcdTAwRUInLFxuICAgICdldXJvJzogJ1xcdTIwQUMnLFxuICAgICdleGlzdCc6ICdcXHUyMjAzJyxcbiAgICAnZm5vZic6ICdcXHUwMTkyJyxcbiAgICAnZm9yYWxsJzogJ1xcdTIyMDAnLFxuICAgICdmcmFjMTInOiAnXFx1MDBCRCcsXG4gICAgJ2ZyYWMxNCc6ICdcXHUwMEJDJyxcbiAgICAnZnJhYzM0JzogJ1xcdTAwQkUnLFxuICAgICdmcmFzbCc6ICdcXHUyMDQ0JyxcbiAgICAnR2FtbWEnOiAnXFx1MDM5MycsXG4gICAgJ2dhbW1hJzogJ1xcdTAzQjMnLFxuICAgICdnZSc6ICdcXHUyMjY1JyxcbiAgICAnZ3QnOiAnPicsXG4gICAgJ2hhcnInOiAnXFx1MjE5NCcsXG4gICAgJ2hBcnInOiAnXFx1MjFENCcsXG4gICAgJ2hlYXJ0cyc6ICdcXHUyNjY1JyxcbiAgICAnaGVsbGlwJzogJ1xcdTIwMjYnLFxuICAgICdJYWN1dGUnOiAnXFx1MDBDRCcsXG4gICAgJ2lhY3V0ZSc6ICdcXHUwMEVEJyxcbiAgICAnSWNpcmMnOiAnXFx1MDBDRScsXG4gICAgJ2ljaXJjJzogJ1xcdTAwRUUnLFxuICAgICdpZXhjbCc6ICdcXHUwMEExJyxcbiAgICAnSWdyYXZlJzogJ1xcdTAwQ0MnLFxuICAgICdpZ3JhdmUnOiAnXFx1MDBFQycsXG4gICAgJ2ltYWdlJzogJ1xcdTIxMTEnLFxuICAgICdpbmZpbic6ICdcXHUyMjFFJyxcbiAgICAnaW50JzogJ1xcdTIyMkInLFxuICAgICdJb3RhJzogJ1xcdTAzOTknLFxuICAgICdpb3RhJzogJ1xcdTAzQjknLFxuICAgICdpcXVlc3QnOiAnXFx1MDBCRicsXG4gICAgJ2lzaW4nOiAnXFx1MjIwOCcsXG4gICAgJ0l1bWwnOiAnXFx1MDBDRicsXG4gICAgJ2l1bWwnOiAnXFx1MDBFRicsXG4gICAgJ0thcHBhJzogJ1xcdTAzOUEnLFxuICAgICdrYXBwYSc6ICdcXHUwM0JBJyxcbiAgICAnTGFtYmRhJzogJ1xcdTAzOUInLFxuICAgICdsYW1iZGEnOiAnXFx1MDNCQicsXG4gICAgJ2xhbmcnOiAnXFx1MjdFOCcsXG4gICAgJ2xhcXVvJzogJ1xcdTAwQUInLFxuICAgICdsYXJyJzogJ1xcdTIxOTAnLFxuICAgICdsQXJyJzogJ1xcdTIxRDAnLFxuICAgICdsY2VpbCc6ICdcXHUyMzA4JyxcbiAgICAnbGRxdW8nOiAnXFx1MjAxQycsXG4gICAgJ2xlJzogJ1xcdTIyNjQnLFxuICAgICdsZmxvb3InOiAnXFx1MjMwQScsXG4gICAgJ2xvd2FzdCc6ICdcXHUyMjE3JyxcbiAgICAnbG96JzogJ1xcdTI1Q0EnLFxuICAgICdscm0nOiAnXFx1MjAwRScsXG4gICAgJ2xzYXF1byc6ICdcXHUyMDM5JyxcbiAgICAnbHNxdW8nOiAnXFx1MjAxOCcsXG4gICAgJ2x0JzogJzwnLFxuICAgICdtYWNyJzogJ1xcdTAwQUYnLFxuICAgICdtZGFzaCc6ICdcXHUyMDE0JyxcbiAgICAnbWljcm8nOiAnXFx1MDBCNScsXG4gICAgJ21pZGRvdCc6ICdcXHUwMEI3JyxcbiAgICAnbWludXMnOiAnXFx1MjIxMicsXG4gICAgJ011JzogJ1xcdTAzOUMnLFxuICAgICdtdSc6ICdcXHUwM0JDJyxcbiAgICAnbmFibGEnOiAnXFx1MjIwNycsXG4gICAgJ25ic3AnOiAnXFx1MDBBMCcsXG4gICAgJ25kYXNoJzogJ1xcdTIwMTMnLFxuICAgICduZSc6ICdcXHUyMjYwJyxcbiAgICAnbmknOiAnXFx1MjIwQicsXG4gICAgJ25vdCc6ICdcXHUwMEFDJyxcbiAgICAnbm90aW4nOiAnXFx1MjIwOScsXG4gICAgJ25zdWInOiAnXFx1MjI4NCcsXG4gICAgJ050aWxkZSc6ICdcXHUwMEQxJyxcbiAgICAnbnRpbGRlJzogJ1xcdTAwRjEnLFxuICAgICdOdSc6ICdcXHUwMzlEJyxcbiAgICAnbnUnOiAnXFx1MDNCRCcsXG4gICAgJ09hY3V0ZSc6ICdcXHUwMEQzJyxcbiAgICAnb2FjdXRlJzogJ1xcdTAwRjMnLFxuICAgICdPY2lyYyc6ICdcXHUwMEQ0JyxcbiAgICAnb2NpcmMnOiAnXFx1MDBGNCcsXG4gICAgJ09FbGlnJzogJ1xcdTAxNTInLFxuICAgICdvZWxpZyc6ICdcXHUwMTUzJyxcbiAgICAnT2dyYXZlJzogJ1xcdTAwRDInLFxuICAgICdvZ3JhdmUnOiAnXFx1MDBGMicsXG4gICAgJ29saW5lJzogJ1xcdTIwM0UnLFxuICAgICdPbWVnYSc6ICdcXHUwM0E5JyxcbiAgICAnb21lZ2EnOiAnXFx1MDNDOScsXG4gICAgJ09taWNyb24nOiAnXFx1MDM5RicsXG4gICAgJ29taWNyb24nOiAnXFx1MDNCRicsXG4gICAgJ29wbHVzJzogJ1xcdTIyOTUnLFxuICAgICdvcic6ICdcXHUyMjI4JyxcbiAgICAnb3JkZic6ICdcXHUwMEFBJyxcbiAgICAnb3JkbSc6ICdcXHUwMEJBJyxcbiAgICAnT3NsYXNoJzogJ1xcdTAwRDgnLFxuICAgICdvc2xhc2gnOiAnXFx1MDBGOCcsXG4gICAgJ090aWxkZSc6ICdcXHUwMEQ1JyxcbiAgICAnb3RpbGRlJzogJ1xcdTAwRjUnLFxuICAgICdvdGltZXMnOiAnXFx1MjI5NycsXG4gICAgJ091bWwnOiAnXFx1MDBENicsXG4gICAgJ291bWwnOiAnXFx1MDBGNicsXG4gICAgJ3BhcmEnOiAnXFx1MDBCNicsXG4gICAgJ3Blcm1pbCc6ICdcXHUyMDMwJyxcbiAgICAncGVycCc6ICdcXHUyMkE1JyxcbiAgICAnUGhpJzogJ1xcdTAzQTYnLFxuICAgICdwaGknOiAnXFx1MDNDNicsXG4gICAgJ1BpJzogJ1xcdTAzQTAnLFxuICAgICdwaSc6ICdcXHUwM0MwJyxcbiAgICAncGl2JzogJ1xcdTAzRDYnLFxuICAgICdwbHVzbW4nOiAnXFx1MDBCMScsXG4gICAgJ3BvdW5kJzogJ1xcdTAwQTMnLFxuICAgICdwcmltZSc6ICdcXHUyMDMyJyxcbiAgICAnUHJpbWUnOiAnXFx1MjAzMycsXG4gICAgJ3Byb2QnOiAnXFx1MjIwRicsXG4gICAgJ3Byb3AnOiAnXFx1MjIxRCcsXG4gICAgJ1BzaSc6ICdcXHUwM0E4JyxcbiAgICAncHNpJzogJ1xcdTAzQzgnLFxuICAgICdxdW90JzogJ1xcdTAwMjInLFxuICAgICdyYWRpYyc6ICdcXHUyMjFBJyxcbiAgICAncmFuZyc6ICdcXHUyN0U5JyxcbiAgICAncmFxdW8nOiAnXFx1MDBCQicsXG4gICAgJ3JhcnInOiAnXFx1MjE5MicsXG4gICAgJ3JBcnInOiAnXFx1MjFEMicsXG4gICAgJ3JjZWlsJzogJ1xcdTIzMDknLFxuICAgICdyZHF1byc6ICdcXHUyMDFEJyxcbiAgICAncmVhbCc6ICdcXHUyMTFDJyxcbiAgICAncmVnJzogJ1xcdTAwQUUnLFxuICAgICdyZmxvb3InOiAnXFx1MjMwQicsXG4gICAgJ1Jobyc6ICdcXHUwM0ExJyxcbiAgICAncmhvJzogJ1xcdTAzQzEnLFxuICAgICdybG0nOiAnXFx1MjAwRicsXG4gICAgJ3JzYXF1byc6ICdcXHUyMDNBJyxcbiAgICAncnNxdW8nOiAnXFx1MjAxOScsXG4gICAgJ3NicXVvJzogJ1xcdTIwMUEnLFxuICAgICdTY2Fyb24nOiAnXFx1MDE2MCcsXG4gICAgJ3NjYXJvbic6ICdcXHUwMTYxJyxcbiAgICAnc2RvdCc6ICdcXHUyMkM1JyxcbiAgICAnc2VjdCc6ICdcXHUwMEE3JyxcbiAgICAnc2h5JzogJ1xcdTAwQUQnLFxuICAgICdTaWdtYSc6ICdcXHUwM0EzJyxcbiAgICAnc2lnbWEnOiAnXFx1MDNDMycsXG4gICAgJ3NpZ21hZic6ICdcXHUwM0MyJyxcbiAgICAnc2ltJzogJ1xcdTIyM0MnLFxuICAgICdzcGFkZXMnOiAnXFx1MjY2MCcsXG4gICAgJ3N1Yic6ICdcXHUyMjgyJyxcbiAgICAnc3ViZSc6ICdcXHUyMjg2JyxcbiAgICAnc3VtJzogJ1xcdTIyMTEnLFxuICAgICdzdXAnOiAnXFx1MjI4MycsXG4gICAgJ3N1cDEnOiAnXFx1MDBCOScsXG4gICAgJ3N1cDInOiAnXFx1MDBCMicsXG4gICAgJ3N1cDMnOiAnXFx1MDBCMycsXG4gICAgJ3N1cGUnOiAnXFx1MjI4NycsXG4gICAgJ3N6bGlnJzogJ1xcdTAwREYnLFxuICAgICdUYXUnOiAnXFx1MDNBNCcsXG4gICAgJ3RhdSc6ICdcXHUwM0M0JyxcbiAgICAndGhlcmU0JzogJ1xcdTIyMzQnLFxuICAgICdUaGV0YSc6ICdcXHUwMzk4JyxcbiAgICAndGhldGEnOiAnXFx1MDNCOCcsXG4gICAgJ3RoZXRhc3ltJzogJ1xcdTAzRDEnLFxuICAgICd0aGluc3AnOiAnXFx1MjAwOScsXG4gICAgJ1RIT1JOJzogJ1xcdTAwREUnLFxuICAgICd0aG9ybic6ICdcXHUwMEZFJyxcbiAgICAndGlsZGUnOiAnXFx1MDJEQycsXG4gICAgJ3RpbWVzJzogJ1xcdTAwRDcnLFxuICAgICd0cmFkZSc6ICdcXHUyMTIyJyxcbiAgICAnVWFjdXRlJzogJ1xcdTAwREEnLFxuICAgICd1YWN1dGUnOiAnXFx1MDBGQScsXG4gICAgJ3VhcnInOiAnXFx1MjE5MScsXG4gICAgJ3VBcnInOiAnXFx1MjFEMScsXG4gICAgJ1VjaXJjJzogJ1xcdTAwREInLFxuICAgICd1Y2lyYyc6ICdcXHUwMEZCJyxcbiAgICAnVWdyYXZlJzogJ1xcdTAwRDknLFxuICAgICd1Z3JhdmUnOiAnXFx1MDBGOScsXG4gICAgJ3VtbCc6ICdcXHUwMEE4JyxcbiAgICAndXBzaWgnOiAnXFx1MDNEMicsXG4gICAgJ1Vwc2lsb24nOiAnXFx1MDNBNScsXG4gICAgJ3Vwc2lsb24nOiAnXFx1MDNDNScsXG4gICAgJ1V1bWwnOiAnXFx1MDBEQycsXG4gICAgJ3V1bWwnOiAnXFx1MDBGQycsXG4gICAgJ3dlaWVycCc6ICdcXHUyMTE4JyxcbiAgICAnWGknOiAnXFx1MDM5RScsXG4gICAgJ3hpJzogJ1xcdTAzQkUnLFxuICAgICdZYWN1dGUnOiAnXFx1MDBERCcsXG4gICAgJ3lhY3V0ZSc6ICdcXHUwMEZEJyxcbiAgICAneWVuJzogJ1xcdTAwQTUnLFxuICAgICd5dW1sJzogJ1xcdTAwRkYnLFxuICAgICdZdW1sJzogJ1xcdTAxNzgnLFxuICAgICdaZXRhJzogJ1xcdTAzOTYnLFxuICAgICd6ZXRhJzogJ1xcdTAzQjYnLFxuICAgICd6d2onOiAnXFx1MjAwRCcsXG4gICAgJ3p3bmonOiAnXFx1MjAwQycsXG59O1xuLy8gVGhlICZuZ3NwOyBwc2V1ZG8tZW50aXR5IGlzIGRlbm90aW5nIGEgc3BhY2UuIHNlZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJ0LWxhbmcvYW5ndWxhci9ibG9iLzBiYjYxMTM4N2QyOWQ2NWI1YWY3ZjlkMjUxNWFiNTcxZmQzZmJlZTQvX3Rlc3RzL3Rlc3QvY29tcGlsZXIvcHJlc2VydmVfd2hpdGVzcGFjZV90ZXN0LmRhcnRcbnZhciBOR1NQX1VOSUNPREUgPSAnXFx1RTUwMCc7XG5OQU1FRF9FTlRJVElFU1snbmdzcCddID0gTkdTUF9VTklDT0RFO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSHRtbFRhZ0RlZmluaXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHRtbFRhZ0RlZmluaXRpb24oX2EpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGNsb3NlZEJ5Q2hpbGRyZW4gPSBfYi5jbG9zZWRCeUNoaWxkcmVuLCBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeCA9IF9iLmltcGxpY2l0TmFtZXNwYWNlUHJlZml4LCBfYyA9IF9iLmNvbnRlbnRUeXBlLCBjb250ZW50VHlwZSA9IF9jID09PSB2b2lkIDAgPyBUYWdDb250ZW50VHlwZS5QQVJTQUJMRV9EQVRBIDogX2MsIF9kID0gX2IuY2xvc2VkQnlQYXJlbnQsIGNsb3NlZEJ5UGFyZW50ID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2QsIF9lID0gX2IuaXNWb2lkLCBpc1ZvaWQgPSBfZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZSwgX2YgPSBfYi5pZ25vcmVGaXJzdExmLCBpZ25vcmVGaXJzdExmID0gX2YgPT09IHZvaWQgMCA/IGZhbHNlIDogX2Y7XG4gICAgICAgIHRoaXMuY2xvc2VkQnlDaGlsZHJlbiA9IHt9O1xuICAgICAgICB0aGlzLmNsb3NlZEJ5UGFyZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FuU2VsZkNsb3NlID0gZmFsc2U7XG4gICAgICAgIGlmIChjbG9zZWRCeUNoaWxkcmVuICYmIGNsb3NlZEJ5Q2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY2xvc2VkQnlDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uICh0YWdOYW1lKSB7IHJldHVybiBfdGhpcy5jbG9zZWRCeUNoaWxkcmVuW3RhZ05hbWVdID0gdHJ1ZTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1ZvaWQgPSBpc1ZvaWQ7XG4gICAgICAgIHRoaXMuY2xvc2VkQnlQYXJlbnQgPSBjbG9zZWRCeVBhcmVudCB8fCBpc1ZvaWQ7XG4gICAgICAgIHRoaXMuaW1wbGljaXROYW1lc3BhY2VQcmVmaXggPSBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeCB8fCBudWxsO1xuICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gY29udGVudFR5cGU7XG4gICAgICAgIHRoaXMuaWdub3JlRmlyc3RMZiA9IGlnbm9yZUZpcnN0TGY7XG4gICAgfVxuICAgIEh0bWxUYWdEZWZpbml0aW9uLnByb3RvdHlwZS5pc0Nsb3NlZEJ5Q2hpbGQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZvaWQgfHwgbmFtZS50b0xvd2VyQ2FzZSgpIGluIHRoaXMuY2xvc2VkQnlDaGlsZHJlbjtcbiAgICB9O1xuICAgIHJldHVybiBIdG1sVGFnRGVmaW5pdGlvbjtcbn0oKSk7XG52YXIgX0RFRkFVTFRfVEFHX0RFRklOSVRJT047XG4vLyBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUxL3N5bnRheC5odG1sI29wdGlvbmFsLXRhZ3Ncbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgZnVsbHkgY29uZm9ybSB0byB0aGUgSFRNTDUgc3BlYy5cbnZhciBUQUdfREVGSU5JVElPTlM7XG5mdW5jdGlvbiBnZXRIdG1sVGFnRGVmaW5pdGlvbih0YWdOYW1lKSB7XG4gICAgaWYgKCFUQUdfREVGSU5JVElPTlMpIHtcbiAgICAgICAgX0RFRkFVTFRfVEFHX0RFRklOSVRJT04gPSBuZXcgSHRtbFRhZ0RlZmluaXRpb24oKTtcbiAgICAgICAgVEFHX0RFRklOSVRJT05TID0ge1xuICAgICAgICAgICAgJ2Jhc2UnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnbWV0YSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdhcmVhJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ2VtYmVkJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ2xpbmsnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnaW1nJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ2lucHV0JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3BhcmFtJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ2hyJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ2JyJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3NvdXJjZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICd0cmFjayc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICd3YnInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAncCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7XG4gICAgICAgICAgICAgICAgY2xvc2VkQnlDaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICAnYWRkcmVzcycsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jsb2NrcXVvdGUnLCAnZGl2JywgJ2RsJywgJ2ZpZWxkc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2Zvb3RlcicsICdmb3JtJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JyxcbiAgICAgICAgICAgICAgICAgICAgJ2g2JywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnbWFpbicsICduYXYnLCAnb2wnLFxuICAgICAgICAgICAgICAgICAgICAncCcsICdwcmUnLCAnc2VjdGlvbicsICd0YWJsZScsICd1bCdcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGNsb3NlZEJ5UGFyZW50OiB0cnVlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICd0aGVhZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGJvZHknLCAndGZvb3QnXSB9KSxcbiAgICAgICAgICAgICd0Ym9keSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGJvZHknLCAndGZvb3QnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAndGZvb3QnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3Rib2R5J10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3RyJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0ciddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICd0ZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGQnLCAndGgnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAndGgnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3RkJywgJ3RoJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ2NvbCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdzdmcnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeDogJ3N2ZycgfSksXG4gICAgICAgICAgICAnbWF0aCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGltcGxpY2l0TmFtZXNwYWNlUHJlZml4OiAnbWF0aCcgfSksXG4gICAgICAgICAgICAnbGknOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ2xpJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ2R0JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydkdCcsICdkZCddIH0pLFxuICAgICAgICAgICAgJ2RkJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydkdCcsICdkZCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdyYic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3J0JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydyYicsICdydCcsICdydGMnLCAncnAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAncnRjJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydyYicsICdydGMnLCAncnAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAncnAnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0JywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdvcHRncm91cCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnb3B0Z3JvdXAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAnb3B0aW9uJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydvcHRpb24nLCAnb3B0Z3JvdXAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAncHJlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaWdub3JlRmlyc3RMZjogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdsaXN0aW5nJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaWdub3JlRmlyc3RMZjogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdzdHlsZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNvbnRlbnRUeXBlOiBUYWdDb250ZW50VHlwZS5SQVdfVEVYVCB9KSxcbiAgICAgICAgICAgICdzY3JpcHQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuUkFXX1RFWFQgfSksXG4gICAgICAgICAgICAndGl0bGUnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhUIH0pLFxuICAgICAgICAgICAgJ3RleHRhcmVhJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IFRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCwgaWdub3JlRmlyc3RMZjogdHJ1ZSB9KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIFRBR19ERUZJTklUSU9OU1t0YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8IF9ERUZBVUxUX1RBR19ERUZJTklUSU9OO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX1NFTEVDVE9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoJyhcXFxcOm5vdFxcXFwoKXwnICsgLy9cIjpub3QoXCJcbiAgICAnKFstXFxcXHddKyl8JyArIC8vIFwidGFnXCJcbiAgICAnKD86XFxcXC4oWy1cXFxcd10rKSl8JyArIC8vIFwiLmNsYXNzXCJcbiAgICAvLyBcIi1cIiBzaG91bGQgYXBwZWFyIGZpcnN0IGluIHRoZSByZWdleHAgYmVsb3cgYXMgRkYzMSBwYXJzZXMgXCJbLi1cXHddXCIgYXMgYSByYW5nZVxuICAgICcoPzpcXFxcWyhbLS5cXFxcdypdKykoPzo9KFtcXFwiXFwnXT8pKFteXFxcXF1cXFwiXFwnXSopXFxcXDUpP1xcXFxdKXwnICsgLy8gXCJbbmFtZV1cIiwgXCJbbmFtZT12YWx1ZV1cIixcbiAgICAvLyBcIltuYW1lPVwidmFsdWVcIl1cIixcbiAgICAvLyBcIltuYW1lPSd2YWx1ZSddXCJcbiAgICAnKFxcXFwpKXwnICsgLy8gXCIpXCJcbiAgICAnKFxcXFxzKixcXFxccyopJywgLy8gXCIsXCJcbidnJyk7XG4vKipcbiAqIEEgY3NzIHNlbGVjdG9yIGNvbnRhaW5zIGFuIGVsZW1lbnQgbmFtZSxcbiAqIGNzcyBjbGFzc2VzIGFuZCBhdHRyaWJ1dGUvdmFsdWUgcGFpcnMgd2l0aCB0aGUgcHVycG9zZVxuICogb2Ygc2VsZWN0aW5nIHN1YnNldHMgb3V0IG9mIHRoZW0uXG4gKi9cbnZhciBDc3NTZWxlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDc3NTZWxlY3RvcigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbGFzc05hbWVzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2VsZWN0b3JzIGFyZSBlbmNvZGVkIGluIHBhaXJzIHdoZXJlOlxuICAgICAgICAgKiAtIGV2ZW4gbG9jYXRpb25zIGFyZSBhdHRyaWJ1dGUgbmFtZXNcbiAgICAgICAgICogLSBvZGQgbG9jYXRpb25zIGFyZSBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlOlxuICAgICAgICAgKiBTZWxlY3RvcjogYFtrZXkxPXZhbHVlMV1ba2V5Ml1gIHdvdWxkIHBhcnNlIHRvOlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogWydrZXkxJywgJ3ZhbHVlMScsICdrZXkyJywgJyddXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdHRycyA9IFtdO1xuICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycyA9IFtdO1xuICAgIH1cbiAgICBDc3NTZWxlY3Rvci5wYXJzZSA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICB2YXIgX2FkZFJlc3VsdCA9IGZ1bmN0aW9uIChyZXMsIGNzc1NlbCkge1xuICAgICAgICAgICAgaWYgKGNzc1NlbC5ub3RTZWxlY3RvcnMubGVuZ3RoID4gMCAmJiAhY3NzU2VsLmVsZW1lbnQgJiYgY3NzU2VsLmNsYXNzTmFtZXMubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICBjc3NTZWwuYXR0cnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBjc3NTZWwuZWxlbWVudCA9ICcqJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5wdXNoKGNzc1NlbCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjc3NTZWxlY3RvciA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIHZhciBjdXJyZW50ID0gY3NzU2VsZWN0b3I7XG4gICAgICAgIHZhciBpbk5vdCA9IGZhbHNlO1xuICAgICAgICBfU0VMRUNUT1JfUkVHRVhQLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChtYXRjaCA9IF9TRUxFQ1RPUl9SRUdFWFAuZXhlYyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgIGlmIChpbk5vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lc3RpbmcgOm5vdCBpcyBub3QgYWxsb3dlZCBpbiBhIHNlbGVjdG9yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluTm90ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV3IENzc1NlbGVjdG9yKCk7XG4gICAgICAgICAgICAgICAgY3NzU2VsZWN0b3Iubm90U2VsZWN0b3JzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnNldEVsZW1lbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5hZGRDbGFzc05hbWUobWF0Y2hbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5hZGRBdHRyaWJ1dGUobWF0Y2hbNF0sIG1hdGNoWzZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs3XSkge1xuICAgICAgICAgICAgICAgIGluTm90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNzc1NlbGVjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzhdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluTm90KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVsdGlwbGUgc2VsZWN0b3JzIGluIDpub3QgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2FkZFJlc3VsdChyZXN1bHRzLCBjc3NTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgY3NzU2VsZWN0b3IgPSBjdXJyZW50ID0gbmV3IENzc1NlbGVjdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX2FkZFJlc3VsdChyZXN1bHRzLCBjc3NTZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmlzRWxlbWVudFNlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNFbGVtZW50U2VsZWN0b3IoKSAmJiB0aGlzLmNsYXNzTmFtZXMubGVuZ3RoID09IDAgJiYgdGhpcy5hdHRycy5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmhhc0VsZW1lbnRTZWxlY3RvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICEhdGhpcy5lbGVtZW50OyB9O1xuICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS5zZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IHZvaWQgMCkgeyBlbGVtZW50ID0gbnVsbDsgfVxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIH07XG4gICAgLyoqIEdldHMgYSB0ZW1wbGF0ZSBzdHJpbmcgZm9yIGFuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rvci4gKi9cbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuZ2V0TWF0Y2hpbmdFbGVtZW50VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0YWdOYW1lID0gdGhpcy5lbGVtZW50IHx8ICdkaXYnO1xuICAgICAgICB2YXIgY2xhc3NBdHRyID0gdGhpcy5jbGFzc05hbWVzLmxlbmd0aCA+IDAgPyBcIiBjbGFzcz1cXFwiXCIgKyB0aGlzLmNsYXNzTmFtZXMuam9pbignICcpICsgXCJcXFwiXCIgOiAnJztcbiAgICAgICAgdmFyIGF0dHJzID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hdHRycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gdGhpcy5hdHRyc1tpXTtcbiAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXSAhPT0gJycgPyBcIj1cXFwiXCIgKyB0aGlzLmF0dHJzW2kgKyAxXSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgICBhdHRycyArPSBcIiBcIiArIGF0dHJOYW1lICsgYXR0clZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRIdG1sVGFnRGVmaW5pdGlvbih0YWdOYW1lKS5pc1ZvaWQgPyBcIjxcIiArIHRhZ05hbWUgKyBjbGFzc0F0dHIgKyBhdHRycyArIFwiLz5cIiA6XG4gICAgICAgICAgICBcIjxcIiArIHRhZ05hbWUgKyBjbGFzc0F0dHIgKyBhdHRycyArIFwiPjwvXCIgKyB0YWdOYW1lICsgXCI+XCI7XG4gICAgfTtcbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuZ2V0QXR0cnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnY2xhc3MnLCB0aGlzLmNsYXNzTmFtZXMuam9pbignICcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdCh0aGlzLmF0dHJzKTtcbiAgICB9O1xuICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS5hZGRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAnJzsgfVxuICAgICAgICB0aGlzLmF0dHJzLnB1c2gobmFtZSwgdmFsdWUgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSB8fCAnJyk7XG4gICAgfTtcbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuYWRkQ2xhc3NOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5jbGFzc05hbWVzLnB1c2gobmFtZS50b0xvd2VyQ2FzZSgpKTsgfTtcbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLmVsZW1lbnQgfHwgJyc7XG4gICAgICAgIGlmICh0aGlzLmNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChrbGFzcykgeyByZXR1cm4gcmVzICs9IFwiLlwiICsga2xhc3M7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gdGhpcy5hdHRyc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICByZXMgKz0gXCJbXCIgKyBuYW1lXzEgKyAodmFsdWUgPyAnPScgKyB2YWx1ZSA6ICcnKSArIFwiXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90U2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKG5vdFNlbGVjdG9yKSB7IHJldHVybiByZXMgKz0gXCI6bm90KFwiICsgbm90U2VsZWN0b3IgKyBcIilcIjsgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gQ3NzU2VsZWN0b3I7XG59KCkpO1xuLyoqXG4gKiBSZWFkcyBhIGxpc3Qgb2YgQ3NzU2VsZWN0b3JzIGFuZCBhbGxvd3MgdG8gY2FsY3VsYXRlIHdoaWNoIG9uZXNcbiAqIGFyZSBjb250YWluZWQgaW4gYSBnaXZlbiBDc3NTZWxlY3Rvci5cbiAqL1xudmFyIFNlbGVjdG9yTWF0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3Rvck1hdGNoZXIoKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRQYXJ0aWFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jbGFzc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY2xhc3NQYXJ0aWFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9hdHRyVmFsdWVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2F0dHJWYWx1ZVBhcnRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2xpc3RDb250ZXh0cyA9IFtdO1xuICAgIH1cbiAgICBTZWxlY3Rvck1hdGNoZXIuY3JlYXRlTm90TWF0Y2hlciA9IGZ1bmN0aW9uIChub3RTZWxlY3RvcnMpIHtcbiAgICAgICAgdmFyIG5vdE1hdGNoZXIgPSBuZXcgU2VsZWN0b3JNYXRjaGVyKCk7XG4gICAgICAgIG5vdE1hdGNoZXIuYWRkU2VsZWN0YWJsZXMobm90U2VsZWN0b3JzLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIG5vdE1hdGNoZXI7XG4gICAgfTtcbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLmFkZFNlbGVjdGFibGVzID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9ycywgY2FsbGJhY2tDdHh0KSB7XG4gICAgICAgIHZhciBsaXN0Q29udGV4dCA9IG51bGw7XG4gICAgICAgIGlmIChjc3NTZWxlY3RvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGlzdENvbnRleHQgPSBuZXcgU2VsZWN0b3JMaXN0Q29udGV4dChjc3NTZWxlY3RvcnMpO1xuICAgICAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzLnB1c2gobGlzdENvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3NzU2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRTZWxlY3RhYmxlKGNzc1NlbGVjdG9yc1tpXSwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhbiBvYmplY3QgdGhhdCBjYW4gYmUgZm91bmQgbGF0ZXIgb24gYnkgY2FsbGluZyBgbWF0Y2hgLlxuICAgICAqIEBwYXJhbSBjc3NTZWxlY3RvciBBIGNzcyBzZWxlY3RvclxuICAgICAqIEBwYXJhbSBjYWxsYmFja0N0eHQgQW4gb3BhcXVlIG9iamVjdCB0aGF0IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGNhbGxiYWNrIG9mIHRoZSBgbWF0Y2hgIGZ1bmN0aW9uXG4gICAgICovXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkU2VsZWN0YWJsZSA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCkge1xuICAgICAgICB2YXIgbWF0Y2hlciA9IHRoaXM7XG4gICAgICAgIHZhciBlbGVtZW50ID0gY3NzU2VsZWN0b3IuZWxlbWVudDtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBjc3NTZWxlY3Rvci5jbGFzc05hbWVzO1xuICAgICAgICB2YXIgYXR0cnMgPSBjc3NTZWxlY3Rvci5hdHRycztcbiAgICAgICAgdmFyIHNlbGVjdGFibGUgPSBuZXcgU2VsZWN0b3JDb250ZXh0KGNzc1NlbGVjdG9yLCBjYWxsYmFja0N0eHQsIGxpc3RDb250ZXh0KTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGNsYXNzTmFtZXMubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbChtYXRjaGVyLl9lbGVtZW50TWFwLCBlbGVtZW50LCBzZWxlY3RhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdGNoZXIgPSB0aGlzLl9hZGRQYXJ0aWFsKG1hdGNoZXIuX2VsZW1lbnRQYXJ0aWFsTWFwLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzVGVybWluYWwgPSBhdHRycy5sZW5ndGggPT09IDAgJiYgaSA9PT0gY2xhc3NOYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKG1hdGNoZXIuX2NsYXNzTWFwLCBjbGFzc05hbWUsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwobWF0Y2hlci5fY2xhc3NQYXJ0aWFsTWFwLCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNUZXJtaW5hbCA9IGkgPT09IGF0dHJzLmxlbmd0aCAtIDI7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMiA9IGF0dHJzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVybWluYWxNYXAgPSBtYXRjaGVyLl9hdHRyVmFsdWVNYXA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXJtaW5hbFZhbHVlc01hcCA9IHRlcm1pbmFsTWFwLmdldChuYW1lXzIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm1pbmFsVmFsdWVzTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbFZhbHVlc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsTWFwLnNldChuYW1lXzIsIHRlcm1pbmFsVmFsdWVzTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgdmFsdWUsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxNYXAgPSBtYXRjaGVyLl9hdHRyVmFsdWVQYXJ0aWFsTWFwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbFZhbHVlc01hcCA9IHBhcnRpYWxNYXAuZ2V0KG5hbWVfMik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFydGlhbFZhbHVlc01hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFZhbHVlc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxNYXAuc2V0KG5hbWVfMiwgcGFydGlhbFZhbHVlc01hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkVGVybWluYWwgPSBmdW5jdGlvbiAobWFwLCBuYW1lLCBzZWxlY3RhYmxlKSB7XG4gICAgICAgIHZhciB0ZXJtaW5hbExpc3QgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIXRlcm1pbmFsTGlzdCkge1xuICAgICAgICAgICAgdGVybWluYWxMaXN0ID0gW107XG4gICAgICAgICAgICBtYXAuc2V0KG5hbWUsIHRlcm1pbmFsTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVybWluYWxMaXN0LnB1c2goc2VsZWN0YWJsZSk7XG4gICAgfTtcbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9hZGRQYXJ0aWFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSkge1xuICAgICAgICB2YXIgbWF0Y2hlciA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbWF0Y2hlcikge1xuICAgICAgICAgICAgbWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgICAgIG1hcC5zZXQobmFtZSwgbWF0Y2hlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHZpYSBgYWRkU2VsZWN0YWJsZWBcbiAgICAgKiB3aG9zZSBjc3Mgc2VsZWN0b3IgaXMgY29udGFpbmVkIGluIHRoZSBnaXZlbiBjc3Mgc2VsZWN0b3IuXG4gICAgICogQHBhcmFtIGNzc1NlbGVjdG9yIEEgY3NzIHNlbGVjdG9yXG4gICAgICogQHBhcmFtIG1hdGNoZWRDYWxsYmFjayBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIG9iamVjdCBoYW5kZWQgaW50byBgYWRkU2VsZWN0YWJsZWBcbiAgICAgKiBAcmV0dXJuIGJvb2xlYW4gdHJ1ZSBpZiBhIG1hdGNoIHdhcyBmb3VuZFxuICAgICovXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjc3NTZWxlY3Rvci5lbGVtZW50O1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IGNzc1NlbGVjdG9yLmNsYXNzTmFtZXM7XG4gICAgICAgIHZhciBhdHRycyA9IGNzc1NlbGVjdG9yLmF0dHJzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpc3RDb250ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzW2ldLmFscmVhZHlNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hUZXJtaW5hbCh0aGlzLl9lbGVtZW50TWFwLCBlbGVtZW50LCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoUGFydGlhbCh0aGlzLl9lbGVtZW50UGFydGlhbE1hcCwgZWxlbWVudCwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcbiAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgaWYgKGNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3NOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fY2xhc3NNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoUGFydGlhbCh0aGlzLl9jbGFzc1BhcnRpYWxNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZV8zID0gYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbaSArIDFdO1xuICAgICAgICAgICAgICAgIHZhciB0ZXJtaW5hbFZhbHVlc01hcCA9IHRoaXMuX2F0dHJWYWx1ZU1hcC5nZXQobmFtZV8zKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoVGVybWluYWwodGVybWluYWxWYWx1ZXNNYXAsICcnLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoVGVybWluYWwodGVybWluYWxWYWx1ZXNNYXAsIHZhbHVlLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxWYWx1ZXNNYXAgPSB0aGlzLl9hdHRyVmFsdWVQYXJ0aWFsTWFwLmdldChuYW1lXzMpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9tYXRjaFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgJycsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2hQYXJ0aWFsKHBhcnRpYWxWYWx1ZXNNYXAsIHZhbHVlLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9tYXRjaFRlcm1pbmFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykge1xuICAgICAgICBpZiAoIW1hcCB8fCB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZWN0YWJsZXMgPSBtYXAuZ2V0KG5hbWUpIHx8IFtdO1xuICAgICAgICB2YXIgc3RhclNlbGVjdGFibGVzID0gbWFwLmdldCgnKicpO1xuICAgICAgICBpZiAoc3RhclNlbGVjdGFibGVzKSB7XG4gICAgICAgICAgICBzZWxlY3RhYmxlcyA9IHNlbGVjdGFibGVzLmNvbmNhdChzdGFyU2VsZWN0YWJsZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3RhYmxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZWN0YWJsZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZWxlY3RhYmxlID0gc2VsZWN0YWJsZXNbaV07XG4gICAgICAgICAgICByZXN1bHQgPSBzZWxlY3RhYmxlLmZpbmFsaXplKGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX21hdGNoUGFydGlhbCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFtYXAgfHwgdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5lc3RlZFNlbGVjdG9yID0gbWFwLmdldChuYW1lKTtcbiAgICAgICAgaWYgKCFuZXN0ZWRTZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8ocGVyZik6IGdldCByaWQgb2YgcmVjdXJzaW9uIGFuZCBtZWFzdXJlIGFnYWluXG4gICAgICAgIC8vIFRPRE8ocGVyZik6IGRvbid0IHBhc3MgdGhlIHdob2xlIHNlbGVjdG9yIGludG8gdGhlIHJlY3Vyc2lvbixcbiAgICAgICAgLy8gYnV0IG9ubHkgdGhlIG5vdCBwcm9jZXNzZWQgcGFydHNcbiAgICAgICAgcmV0dXJuIG5lc3RlZFNlbGVjdG9yLm1hdGNoKGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spO1xuICAgIH07XG4gICAgcmV0dXJuIFNlbGVjdG9yTWF0Y2hlcjtcbn0oKSk7XG52YXIgU2VsZWN0b3JMaXN0Q29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3Rvckxpc3RDb250ZXh0KHNlbGVjdG9ycykge1xuICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IHNlbGVjdG9ycztcbiAgICAgICAgdGhpcy5hbHJlYWR5TWF0Y2hlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gU2VsZWN0b3JMaXN0Q29udGV4dDtcbn0oKSk7XG4vLyBTdG9yZSBjb250ZXh0IHRvIHBhc3MgYmFjayBzZWxlY3RvciBhbmQgY29udGV4dCB3aGVuIGEgc2VsZWN0b3IgaXMgbWF0Y2hlZFxudmFyIFNlbGVjdG9yQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3RvckNvbnRleHQoc2VsZWN0b3IsIGNiQ29udGV4dCwgbGlzdENvbnRleHQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNiQ29udGV4dCA9IGNiQ29udGV4dDtcbiAgICAgICAgdGhpcy5saXN0Q29udGV4dCA9IGxpc3RDb250ZXh0O1xuICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycyA9IHNlbGVjdG9yLm5vdFNlbGVjdG9ycztcbiAgICB9XG4gICAgU2VsZWN0b3JDb250ZXh0LnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm5vdFNlbGVjdG9ycy5sZW5ndGggPiAwICYmICghdGhpcy5saXN0Q29udGV4dCB8fCAhdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCkpIHtcbiAgICAgICAgICAgIHZhciBub3RNYXRjaGVyID0gU2VsZWN0b3JNYXRjaGVyLmNyZWF0ZU5vdE1hdGNoZXIodGhpcy5ub3RTZWxlY3RvcnMpO1xuICAgICAgICAgICAgcmVzdWx0ID0gIW5vdE1hdGNoZXIubWF0Y2goY3NzU2VsZWN0b3IsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQgJiYgY2FsbGJhY2sgJiYgKCF0aGlzLmxpc3RDb250ZXh0IHx8ICF0aGlzLmxpc3RDb250ZXh0LmFscmVhZHlNYXRjaGVkKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGlzdENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RDb250ZXh0LmFscmVhZHlNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuc2VsZWN0b3IsIHRoaXMuY2JDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFNlbGVjdG9yQ29udGV4dDtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBjcmVhdGVJbmplY3QgPSBtYWtlTWV0YWRhdGFGYWN0b3J5KCdJbmplY3QnLCBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuICh7IHRva2VuOiB0b2tlbiB9KTsgfSk7XG52YXIgY3JlYXRlSW5qZWN0aW9uVG9rZW4gPSBtYWtlTWV0YWRhdGFGYWN0b3J5KCdJbmplY3Rpb25Ub2tlbicsIGZ1bmN0aW9uIChkZXNjKSB7IHJldHVybiAoeyBfZGVzYzogZGVzYywgbmdJbmplY3RhYmxlRGVmOiB1bmRlZmluZWQgfSk7IH0pO1xudmFyIGNyZWF0ZUF0dHJpYnV0ZSA9IG1ha2VNZXRhZGF0YUZhY3RvcnkoJ0F0dHJpYnV0ZScsIGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7IHJldHVybiAoeyBhdHRyaWJ1dGVOYW1lOiBhdHRyaWJ1dGVOYW1lIH0pOyB9KTtcbnZhciBjcmVhdGVDb250ZW50Q2hpbGRyZW4gPSBtYWtlTWV0YWRhdGFGYWN0b3J5KCdDb250ZW50Q2hpbGRyZW4nLCBmdW5jdGlvbiAoc2VsZWN0b3IsIGRhdGEpIHtcbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7IGRhdGEgPSB7fTsgfVxuICAgIHJldHVybiAoX19hc3NpZ24oeyBzZWxlY3Rvcjogc2VsZWN0b3IsIGZpcnN0OiBmYWxzZSwgaXNWaWV3UXVlcnk6IGZhbHNlLCBkZXNjZW5kYW50czogZmFsc2UgfSwgZGF0YSkpO1xufSk7XG52YXIgY3JlYXRlQ29udGVudENoaWxkID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnQ29udGVudENoaWxkJywgZnVuY3Rpb24gKHNlbGVjdG9yLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT09IHZvaWQgMCkgeyBkYXRhID0ge307IH1cbiAgICByZXR1cm4gKF9fYXNzaWduKHsgc2VsZWN0b3I6IHNlbGVjdG9yLCBmaXJzdDogdHJ1ZSwgaXNWaWV3UXVlcnk6IGZhbHNlLCBkZXNjZW5kYW50czogdHJ1ZSB9LCBkYXRhKSk7XG59KTtcbnZhciBjcmVhdGVWaWV3Q2hpbGRyZW4gPSBtYWtlTWV0YWRhdGFGYWN0b3J5KCdWaWV3Q2hpbGRyZW4nLCBmdW5jdGlvbiAoc2VsZWN0b3IsIGRhdGEpIHtcbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7IGRhdGEgPSB7fTsgfVxuICAgIHJldHVybiAoX19hc3NpZ24oeyBzZWxlY3Rvcjogc2VsZWN0b3IsIGZpcnN0OiBmYWxzZSwgaXNWaWV3UXVlcnk6IHRydWUsIGRlc2NlbmRhbnRzOiB0cnVlIH0sIGRhdGEpKTtcbn0pO1xudmFyIGNyZWF0ZVZpZXdDaGlsZCA9IG1ha2VNZXRhZGF0YUZhY3RvcnkoJ1ZpZXdDaGlsZCcsIGZ1bmN0aW9uIChzZWxlY3RvciwgZGF0YSkge1xuICAgIHJldHVybiAoX19hc3NpZ24oeyBzZWxlY3Rvcjogc2VsZWN0b3IsIGZpcnN0OiB0cnVlLCBpc1ZpZXdRdWVyeTogdHJ1ZSwgZGVzY2VuZGFudHM6IHRydWUgfSwgZGF0YSkpO1xufSk7XG52YXIgY3JlYXRlRGlyZWN0aXZlID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnRGlyZWN0aXZlJywgZnVuY3Rpb24gKGRpcikge1xuICAgIGlmIChkaXIgPT09IHZvaWQgMCkgeyBkaXIgPSB7fTsgfVxuICAgIHJldHVybiBkaXI7XG59KTtcbnZhciBWaWV3RW5jYXBzdWxhdGlvbjtcbihmdW5jdGlvbiAoVmlld0VuY2Fwc3VsYXRpb24pIHtcbiAgICBWaWV3RW5jYXBzdWxhdGlvbltWaWV3RW5jYXBzdWxhdGlvbltcIkVtdWxhdGVkXCJdID0gMF0gPSBcIkVtdWxhdGVkXCI7XG4gICAgVmlld0VuY2Fwc3VsYXRpb25bVmlld0VuY2Fwc3VsYXRpb25bXCJOYXRpdmVcIl0gPSAxXSA9IFwiTmF0aXZlXCI7XG4gICAgVmlld0VuY2Fwc3VsYXRpb25bVmlld0VuY2Fwc3VsYXRpb25bXCJOb25lXCJdID0gMl0gPSBcIk5vbmVcIjtcbiAgICBWaWV3RW5jYXBzdWxhdGlvbltWaWV3RW5jYXBzdWxhdGlvbltcIlNoYWRvd0RvbVwiXSA9IDNdID0gXCJTaGFkb3dEb21cIjtcbn0pKFZpZXdFbmNhcHN1bGF0aW9uIHx8IChWaWV3RW5jYXBzdWxhdGlvbiA9IHt9KSk7XG52YXIgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENoYW5nZURldGVjdGlvblN0cmF0ZWd5KSB7XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbXCJPblB1c2hcIl0gPSAwXSA9IFwiT25QdXNoXCI7XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbXCJEZWZhdWx0XCJdID0gMV0gPSBcIkRlZmF1bHRcIjtcbn0pKENoYW5nZURldGVjdGlvblN0cmF0ZWd5IHx8IChDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IHt9KSk7XG52YXIgY3JlYXRlQ29tcG9uZW50ID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnQ29tcG9uZW50JywgZnVuY3Rpb24gKGMpIHtcbiAgICBpZiAoYyA9PT0gdm9pZCAwKSB7IGMgPSB7fTsgfVxuICAgIHJldHVybiAoX19hc3NpZ24oeyBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQgfSwgYykpO1xufSk7XG52YXIgY3JlYXRlUGlwZSA9IG1ha2VNZXRhZGF0YUZhY3RvcnkoJ1BpcGUnLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gKF9fYXNzaWduKHsgcHVyZTogdHJ1ZSB9LCBwKSk7IH0pO1xudmFyIGNyZWF0ZUlucHV0ID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnSW5wdXQnLCBmdW5jdGlvbiAoYmluZGluZ1Byb3BlcnR5TmFtZSkgeyByZXR1cm4gKHsgYmluZGluZ1Byb3BlcnR5TmFtZTogYmluZGluZ1Byb3BlcnR5TmFtZSB9KTsgfSk7XG52YXIgY3JlYXRlT3V0cHV0ID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnT3V0cHV0JywgZnVuY3Rpb24gKGJpbmRpbmdQcm9wZXJ0eU5hbWUpIHsgcmV0dXJuICh7IGJpbmRpbmdQcm9wZXJ0eU5hbWU6IGJpbmRpbmdQcm9wZXJ0eU5hbWUgfSk7IH0pO1xudmFyIGNyZWF0ZUhvc3RCaW5kaW5nID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnSG9zdEJpbmRpbmcnLCBmdW5jdGlvbiAoaG9zdFByb3BlcnR5TmFtZSkgeyByZXR1cm4gKHsgaG9zdFByb3BlcnR5TmFtZTogaG9zdFByb3BlcnR5TmFtZSB9KTsgfSk7XG52YXIgY3JlYXRlSG9zdExpc3RlbmVyID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnSG9zdExpc3RlbmVyJywgZnVuY3Rpb24gKGV2ZW50TmFtZSwgYXJncykgeyByZXR1cm4gKHsgZXZlbnROYW1lOiBldmVudE5hbWUsIGFyZ3M6IGFyZ3MgfSk7IH0pO1xudmFyIGNyZWF0ZU5nTW9kdWxlID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnTmdNb2R1bGUnLCBmdW5jdGlvbiAobmdNb2R1bGUpIHsgcmV0dXJuIG5nTW9kdWxlOyB9KTtcbnZhciBjcmVhdGVJbmplY3RhYmxlID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnSW5qZWN0YWJsZScsIGZ1bmN0aW9uIChpbmplY3RhYmxlKSB7XG4gICAgaWYgKGluamVjdGFibGUgPT09IHZvaWQgMCkgeyBpbmplY3RhYmxlID0ge307IH1cbiAgICByZXR1cm4gaW5qZWN0YWJsZTtcbn0pO1xudmFyIENVU1RPTV9FTEVNRU5UU19TQ0hFTUEgPSB7XG4gICAgbmFtZTogJ2N1c3RvbS1lbGVtZW50cydcbn07XG52YXIgTk9fRVJST1JTX1NDSEVNQSA9IHtcbiAgICBuYW1lOiAnbm8tZXJyb3JzLXNjaGVtYSdcbn07XG52YXIgY3JlYXRlT3B0aW9uYWwgPSBtYWtlTWV0YWRhdGFGYWN0b3J5KCdPcHRpb25hbCcpO1xudmFyIGNyZWF0ZVNlbGYgPSBtYWtlTWV0YWRhdGFGYWN0b3J5KCdTZWxmJyk7XG52YXIgY3JlYXRlU2tpcFNlbGYgPSBtYWtlTWV0YWRhdGFGYWN0b3J5KCdTa2lwU2VsZicpO1xudmFyIGNyZWF0ZUhvc3QgPSBtYWtlTWV0YWRhdGFGYWN0b3J5KCdIb3N0Jyk7XG52YXIgVHlwZSA9IEZ1bmN0aW9uO1xudmFyIFNlY3VyaXR5Q29udGV4dDtcbihmdW5jdGlvbiAoU2VjdXJpdHlDb250ZXh0KSB7XG4gICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJIVE1MXCJdID0gMV0gPSBcIkhUTUxcIjtcbiAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiU1RZTEVcIl0gPSAyXSA9IFwiU1RZTEVcIjtcbiAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiU0NSSVBUXCJdID0gM10gPSBcIlNDUklQVFwiO1xuICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJVUkxcIl0gPSA0XSA9IFwiVVJMXCI7XG4gICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIlJFU09VUkNFX1VSTFwiXSA9IDVdID0gXCJSRVNPVVJDRV9VUkxcIjtcbn0pKFNlY3VyaXR5Q29udGV4dCB8fCAoU2VjdXJpdHlDb250ZXh0ID0ge30pKTtcbnZhciBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kpIHtcbiAgICBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtcIkVycm9yXCJdID0gMF0gPSBcIkVycm9yXCI7XG4gICAgTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3lbTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3lbXCJXYXJuaW5nXCJdID0gMV0gPSBcIldhcm5pbmdcIjtcbiAgICBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtcIklnbm9yZVwiXSA9IDJdID0gXCJJZ25vcmVcIjtcbn0pKE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5IHx8IChNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9IHt9KSk7XG5mdW5jdGlvbiBtYWtlTWV0YWRhdGFGYWN0b3J5KG5hbWUsIHByb3BzKSB7XG4gICAgLy8gVGhpcyBtdXN0IGJlIGRlY2xhcmVkIGFzIGEgZnVuY3Rpb24sIG5vdCBhIGZhdCBhcnJvdywgc28gdGhhdCBFUzIwMTUgZGV2bW9kZSBwcm9kdWNlcyBjb2RlXG4gICAgLy8gdGhhdCB3b3JrcyB3aXRoIHRoZSBzdGF0aWNfcmVmbGVjdG9yLnRzIGluIHRoZSBWaWV3RW5naW5lIGNvbXBpbGVyLlxuICAgIC8vIEluIHBhcnRpY3VsYXIsIGBfcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yYCBhc3N1bWVzIHRoYXQgdGhlIHZhbHVlIHJldHVybmVkIGhlcmUgY2FuIGJlXG4gICAgLy8gbmV3J2VkLlxuICAgIGZ1bmN0aW9uIGZhY3RvcnkoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlcyA9IHByb3BzID8gcHJvcHMuYXBwbHkodm9pZCAwLCBfX3NwcmVhZChhcmdzKSkgOiB7fTtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKHsgbmdNZXRhZGF0YU5hbWU6IG5hbWUgfSwgdmFsdWVzKTtcbiAgICB9XG4gICAgZmFjdG9yeS5pc1R5cGVPZiA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmoubmdNZXRhZGF0YU5hbWUgPT09IG5hbWU7IH07XG4gICAgZmFjdG9yeS5uZ01ldGFkYXRhTmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIGZhY3Rvcnk7XG59XG5mdW5jdGlvbiBwYXJzZXJTZWxlY3RvclRvU2ltcGxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICB2YXIgY2xhc3NlcyA9IHNlbGVjdG9yLmNsYXNzTmFtZXMgJiYgc2VsZWN0b3IuY2xhc3NOYW1lcy5sZW5ndGggPyBfX3NwcmVhZChbOCAvKiBDTEFTUyAqL10sIHNlbGVjdG9yLmNsYXNzTmFtZXMpIDpcbiAgICAgICAgW107XG4gICAgdmFyIGVsZW1lbnROYW1lID0gc2VsZWN0b3IuZWxlbWVudCAmJiBzZWxlY3Rvci5lbGVtZW50ICE9PSAnKicgPyBzZWxlY3Rvci5lbGVtZW50IDogJyc7XG4gICAgcmV0dXJuIF9fc3ByZWFkKFtlbGVtZW50TmFtZV0sIHNlbGVjdG9yLmF0dHJzLCBjbGFzc2VzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlclNlbGVjdG9yVG9OZWdhdGl2ZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgdmFyIGNsYXNzZXMgPSBzZWxlY3Rvci5jbGFzc05hbWVzICYmIHNlbGVjdG9yLmNsYXNzTmFtZXMubGVuZ3RoID8gX19zcHJlYWQoWzggLyogQ0xBU1MgKi9dLCBzZWxlY3Rvci5jbGFzc05hbWVzKSA6XG4gICAgICAgIFtdO1xuICAgIGlmIChzZWxlY3Rvci5lbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBfX3NwcmVhZChbXG4gICAgICAgICAgICAxIC8qIE5PVCAqLyB8IDQgLyogRUxFTUVOVCAqLywgc2VsZWN0b3IuZWxlbWVudFxuICAgICAgICBdLCBzZWxlY3Rvci5hdHRycywgY2xhc3Nlcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbGVjdG9yLmF0dHJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gX19zcHJlYWQoWzEgLyogTk9UICovIHwgMiAvKiBBVFRSSUJVVEUgKi9dLCBzZWxlY3Rvci5hdHRycywgY2xhc3Nlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IuY2xhc3NOYW1lcyAmJiBzZWxlY3Rvci5jbGFzc05hbWVzLmxlbmd0aCA/IF9fc3ByZWFkKFsxIC8qIE5PVCAqLyB8IDggLyogQ0xBU1MgKi9dLCBzZWxlY3Rvci5jbGFzc05hbWVzKSA6XG4gICAgICAgICAgICBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZXJTZWxlY3RvclRvUjNTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHZhciBwb3NpdGl2ZSA9IHBhcnNlclNlbGVjdG9yVG9TaW1wbGVTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgdmFyIG5lZ2F0aXZlID0gc2VsZWN0b3Iubm90U2VsZWN0b3JzICYmIHNlbGVjdG9yLm5vdFNlbGVjdG9ycy5sZW5ndGggP1xuICAgICAgICBzZWxlY3Rvci5ub3RTZWxlY3RvcnMubWFwKGZ1bmN0aW9uIChub3RTZWxlY3RvcikgeyByZXR1cm4gcGFyc2VyU2VsZWN0b3JUb05lZ2F0aXZlU2VsZWN0b3Iobm90U2VsZWN0b3IpOyB9KSA6XG4gICAgICAgIFtdO1xuICAgIHJldHVybiBwb3NpdGl2ZS5jb25jYXQuYXBwbHkocG9zaXRpdmUsIF9fc3ByZWFkKG5lZ2F0aXZlKSk7XG59XG5mdW5jdGlvbiBwYXJzZVNlbGVjdG9yVG9SM1NlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yID8gQ3NzU2VsZWN0b3IucGFyc2Uoc2VsZWN0b3IpLm1hcChwYXJzZXJTZWxlY3RvclRvUjNTZWxlY3RvcikgOiBbXTtcbn1cblxudmFyIGNvcmUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgY3JlYXRlSW5qZWN0OiBjcmVhdGVJbmplY3QsXG4gICAgY3JlYXRlSW5qZWN0aW9uVG9rZW46IGNyZWF0ZUluamVjdGlvblRva2VuLFxuICAgIGNyZWF0ZUF0dHJpYnV0ZTogY3JlYXRlQXR0cmlidXRlLFxuICAgIGNyZWF0ZUNvbnRlbnRDaGlsZHJlbjogY3JlYXRlQ29udGVudENoaWxkcmVuLFxuICAgIGNyZWF0ZUNvbnRlbnRDaGlsZDogY3JlYXRlQ29udGVudENoaWxkLFxuICAgIGNyZWF0ZVZpZXdDaGlsZHJlbjogY3JlYXRlVmlld0NoaWxkcmVuLFxuICAgIGNyZWF0ZVZpZXdDaGlsZDogY3JlYXRlVmlld0NoaWxkLFxuICAgIGNyZWF0ZURpcmVjdGl2ZTogY3JlYXRlRGlyZWN0aXZlLFxuICAgIGdldCBWaWV3RW5jYXBzdWxhdGlvbiAoKSB7IHJldHVybiBWaWV3RW5jYXBzdWxhdGlvbjsgfSxcbiAgICBnZXQgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgKCkgeyByZXR1cm4gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3k7IH0sXG4gICAgY3JlYXRlQ29tcG9uZW50OiBjcmVhdGVDb21wb25lbnQsXG4gICAgY3JlYXRlUGlwZTogY3JlYXRlUGlwZSxcbiAgICBjcmVhdGVJbnB1dDogY3JlYXRlSW5wdXQsXG4gICAgY3JlYXRlT3V0cHV0OiBjcmVhdGVPdXRwdXQsXG4gICAgY3JlYXRlSG9zdEJpbmRpbmc6IGNyZWF0ZUhvc3RCaW5kaW5nLFxuICAgIGNyZWF0ZUhvc3RMaXN0ZW5lcjogY3JlYXRlSG9zdExpc3RlbmVyLFxuICAgIGNyZWF0ZU5nTW9kdWxlOiBjcmVhdGVOZ01vZHVsZSxcbiAgICBjcmVhdGVJbmplY3RhYmxlOiBjcmVhdGVJbmplY3RhYmxlLFxuICAgIENVU1RPTV9FTEVNRU5UU19TQ0hFTUE6IENVU1RPTV9FTEVNRU5UU19TQ0hFTUEsXG4gICAgTk9fRVJST1JTX1NDSEVNQTogTk9fRVJST1JTX1NDSEVNQSxcbiAgICBjcmVhdGVPcHRpb25hbDogY3JlYXRlT3B0aW9uYWwsXG4gICAgY3JlYXRlU2VsZjogY3JlYXRlU2VsZixcbiAgICBjcmVhdGVTa2lwU2VsZjogY3JlYXRlU2tpcFNlbGYsXG4gICAgY3JlYXRlSG9zdDogY3JlYXRlSG9zdCxcbiAgICBUeXBlOiBUeXBlLFxuICAgIGdldCBTZWN1cml0eUNvbnRleHQgKCkgeyByZXR1cm4gU2VjdXJpdHlDb250ZXh0OyB9LFxuICAgIGdldCBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSAoKSB7IHJldHVybiBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneTsgfSxcbiAgICBwYXJzZVNlbGVjdG9yVG9SM1NlbGVjdG9yOiBwYXJzZVNlbGVjdG9yVG9SM1NlbGVjdG9yXG59KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8vLyBUeXBlc1xudmFyIFR5cGVNb2RpZmllcjtcbihmdW5jdGlvbiAoVHlwZU1vZGlmaWVyKSB7XG4gICAgVHlwZU1vZGlmaWVyW1R5cGVNb2RpZmllcltcIkNvbnN0XCJdID0gMF0gPSBcIkNvbnN0XCI7XG59KShUeXBlTW9kaWZpZXIgfHwgKFR5cGVNb2RpZmllciA9IHt9KSk7XG52YXIgVHlwZSQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGUobW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHRoaXMubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICAgICAgICBpZiAoIW1vZGlmaWVycykge1xuICAgICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUeXBlLnByb3RvdHlwZS5oYXNNb2RpZmllciA9IGZ1bmN0aW9uIChtb2RpZmllcikgeyByZXR1cm4gdGhpcy5tb2RpZmllcnMuaW5kZXhPZihtb2RpZmllcikgIT09IC0xOyB9O1xuICAgIHJldHVybiBUeXBlO1xufSgpKTtcbnZhciBCdWlsdGluVHlwZU5hbWU7XG4oZnVuY3Rpb24gKEJ1aWx0aW5UeXBlTmFtZSkge1xuICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJEeW5hbWljXCJdID0gMF0gPSBcIkR5bmFtaWNcIjtcbiAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiQm9vbFwiXSA9IDFdID0gXCJCb29sXCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIlN0cmluZ1wiXSA9IDJdID0gXCJTdHJpbmdcIjtcbiAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiSW50XCJdID0gM10gPSBcIkludFwiO1xuICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJOdW1iZXJcIl0gPSA0XSA9IFwiTnVtYmVyXCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIkZ1bmN0aW9uXCJdID0gNV0gPSBcIkZ1bmN0aW9uXCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIkluZmVycmVkXCJdID0gNl0gPSBcIkluZmVycmVkXCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIk5vbmVcIl0gPSA3XSA9IFwiTm9uZVwiO1xufSkoQnVpbHRpblR5cGVOYW1lIHx8IChCdWlsdGluVHlwZU5hbWUgPSB7fSkpO1xudmFyIEJ1aWx0aW5UeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdWlsdGluVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWlsdGluVHlwZShuYW1lLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBCdWlsdGluVHlwZS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCdWlsdGluVHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBCdWlsdGluVHlwZTtcbn0oVHlwZSQxKSk7XG52YXIgRXhwcmVzc2lvblR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4cHJlc3Npb25UeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4cHJlc3Npb25UeXBlKHZhbHVlLCBtb2RpZmllcnMsIHR5cGVQYXJhbXMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIF90aGlzLnR5cGVQYXJhbXMgPSB0eXBlUGFyYW1zO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEV4cHJlc3Npb25UeXBlLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4cHJlc3Npb25UeXBlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEV4cHJlc3Npb25UeXBlO1xufShUeXBlJDEpKTtcbnZhciBBcnJheVR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5VHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheVR5cGUob2YsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9mID0gb2Y7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXJyYXlUeXBlLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFycmF5VHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBBcnJheVR5cGU7XG59KFR5cGUkMSkpO1xudmFyIE1hcFR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcFR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFwVHlwZSh2YWx1ZVR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlVHlwZSA9IHZhbHVlVHlwZSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1hcFR5cGUucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0TWFwVHlwZSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gTWFwVHlwZTtcbn0oVHlwZSQxKSk7XG52YXIgRFlOQU1JQ19UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5EeW5hbWljKTtcbnZhciBJTkZFUlJFRF9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5JbmZlcnJlZCk7XG52YXIgQk9PTF9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5Cb29sKTtcbnZhciBJTlRfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuSW50KTtcbnZhciBOVU1CRVJfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuTnVtYmVyKTtcbnZhciBTVFJJTkdfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuU3RyaW5nKTtcbnZhciBGVU5DVElPTl9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5GdW5jdGlvbik7XG52YXIgTk9ORV9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5Ob25lKTtcbi8vLy8vIEV4cHJlc3Npb25zXG52YXIgQmluYXJ5T3BlcmF0b3I7XG4oZnVuY3Rpb24gKEJpbmFyeU9wZXJhdG9yKSB7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJFcXVhbHNcIl0gPSAwXSA9IFwiRXF1YWxzXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJOb3RFcXVhbHNcIl0gPSAxXSA9IFwiTm90RXF1YWxzXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJJZGVudGljYWxcIl0gPSAyXSA9IFwiSWRlbnRpY2FsXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJOb3RJZGVudGljYWxcIl0gPSAzXSA9IFwiTm90SWRlbnRpY2FsXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJNaW51c1wiXSA9IDRdID0gXCJNaW51c1wiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiUGx1c1wiXSA9IDVdID0gXCJQbHVzXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJEaXZpZGVcIl0gPSA2XSA9IFwiRGl2aWRlXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJNdWx0aXBseVwiXSA9IDddID0gXCJNdWx0aXBseVwiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTW9kdWxvXCJdID0gOF0gPSBcIk1vZHVsb1wiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiQW5kXCJdID0gOV0gPSBcIkFuZFwiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiT3JcIl0gPSAxMF0gPSBcIk9yXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJCaXR3aXNlQW5kXCJdID0gMTFdID0gXCJCaXR3aXNlQW5kXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJMb3dlclwiXSA9IDEyXSA9IFwiTG93ZXJcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkxvd2VyRXF1YWxzXCJdID0gMTNdID0gXCJMb3dlckVxdWFsc1wiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiQmlnZ2VyXCJdID0gMTRdID0gXCJCaWdnZXJcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkJpZ2dlckVxdWFsc1wiXSA9IDE1XSA9IFwiQmlnZ2VyRXF1YWxzXCI7XG59KShCaW5hcnlPcGVyYXRvciB8fCAoQmluYXJ5T3BlcmF0b3IgPSB7fSkpO1xuZnVuY3Rpb24gbnVsbFNhZmVJc0VxdWl2YWxlbnQoYmFzZSwgb3RoZXIpIHtcbiAgICBpZiAoYmFzZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGJhc2UgPT0gb3RoZXI7XG4gICAgfVxuICAgIHJldHVybiBiYXNlLmlzRXF1aXZhbGVudChvdGhlcik7XG59XG5mdW5jdGlvbiBhcmVBbGxFcXVpdmFsZW50KGJhc2UsIG90aGVyKSB7XG4gICAgdmFyIGxlbiA9IGJhc2UubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFiYXNlW2ldLmlzRXF1aXZhbGVudChvdGhlcltpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbnZhciBFeHByZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4cHJlc3Npb24odHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW4gfHwgbnVsbDtcbiAgICB9XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUucHJvcCA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZFByb3BFeHByKHRoaXMsIG5hbWUsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUua2V5ID0gZnVuY3Rpb24gKGluZGV4LCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZEtleUV4cHIodGhpcywgaW5kZXgsIHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuY2FsbE1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZva2VNZXRob2RFeHByKHRoaXMsIG5hbWUsIHBhcmFtcywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jYWxsRm4gPSBmdW5jdGlvbiAocGFyYW1zLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW52b2tlRnVuY3Rpb25FeHByKHRoaXMsIHBhcmFtcywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChwYXJhbXMsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW50aWF0ZUV4cHIodGhpcywgcGFyYW1zLCB0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmNvbmRpdGlvbmFsID0gZnVuY3Rpb24gKHRydWVDYXNlLCBmYWxzZUNhc2UsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKGZhbHNlQ2FzZSA9PT0gdm9pZCAwKSB7IGZhbHNlQ2FzZSA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbEV4cHIodGhpcywgdHJ1ZUNhc2UsIGZhbHNlQ2FzZSwgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkVxdWFscywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuaWRlbnRpY2FsID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5JZGVudGljYWwsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5ub3RJZGVudGljYWwgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbCwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm1pbnVzID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5NaW51cywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLnBsdXMgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLlBsdXMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkRpdmlkZSwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5NdWx0aXBseSwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTW9kdWxvLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5BbmQsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5iaXR3aXNlQW5kID0gZnVuY3Rpb24gKHJocywgc291cmNlU3BhbiwgcGFyZW5zKSB7XG4gICAgICAgIGlmIChwYXJlbnMgPT09IHZvaWQgMCkgeyBwYXJlbnMgPSB0cnVlOyB9XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkJpdHdpc2VBbmQsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3BhbiwgcGFyZW5zKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5PciwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmxvd2VyID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Mb3dlciwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmxvd2VyRXF1YWxzID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFscywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmJpZ2dlciA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuQmlnZ2VyLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuYmlnZ2VyRXF1YWxzID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5pc0JsYW5rID0gZnVuY3Rpb24gKHNvdXJjZVNwYW4pIHtcbiAgICAgICAgLy8gTm90ZTogV2UgdXNlIGVxdWFscyBieSBwdXJwb3NlIGhlcmUgdG8gY29tcGFyZSB0byBudWxsIGFuZCB1bmRlZmluZWQgaW4gSlMuXG4gICAgICAgIC8vIFdlIHVzZSB0aGUgdHlwZWQgbnVsbCB0byBhbGxvdyBzdHJpY3ROdWxsQ2hlY2tzIHRvIG5hcnJvdyB0eXBlcy5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFRZUEVEX05VTExfRVhQUiwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24gKHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYXN0RXhwcih0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLnRvU3RtdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBFeHByZXNzaW9uU3RhdGVtZW50KHRoaXMsIG51bGwpOyB9O1xuICAgIHJldHVybiBFeHByZXNzaW9uO1xufSgpKTtcbnZhciBCdWlsdGluVmFyO1xuKGZ1bmN0aW9uIChCdWlsdGluVmFyKSB7XG4gICAgQnVpbHRpblZhcltCdWlsdGluVmFyW1wiVGhpc1wiXSA9IDBdID0gXCJUaGlzXCI7XG4gICAgQnVpbHRpblZhcltCdWlsdGluVmFyW1wiU3VwZXJcIl0gPSAxXSA9IFwiU3VwZXJcIjtcbiAgICBCdWlsdGluVmFyW0J1aWx0aW5WYXJbXCJDYXRjaEVycm9yXCJdID0gMl0gPSBcIkNhdGNoRXJyb3JcIjtcbiAgICBCdWlsdGluVmFyW0J1aWx0aW5WYXJbXCJDYXRjaFN0YWNrXCJdID0gM10gPSBcIkNhdGNoU3RhY2tcIjtcbn0pKEJ1aWx0aW5WYXIgfHwgKEJ1aWx0aW5WYXIgPSB7fSkpO1xudmFyIFJlYWRWYXJFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWFkVmFyRXhwciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWFkVmFyRXhwcihuYW1lLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgX3RoaXMuYnVpbHRpbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLmJ1aWx0aW4gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVhZFZhckV4cHIucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgUmVhZFZhckV4cHIgJiYgdGhpcy5uYW1lID09PSBlLm5hbWUgJiYgdGhpcy5idWlsdGluID09PSBlLmJ1aWx0aW47XG4gICAgfTtcbiAgICBSZWFkVmFyRXhwci5wcm90b3R5cGUuaXNDb25zdGFudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIFJlYWRWYXJFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlYWRWYXJFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVhZFZhckV4cHIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVpbHQgaW4gdmFyaWFibGUgXCIgKyB0aGlzLmJ1aWx0aW4gKyBcIiBjYW4gbm90IGJlIGFzc2lnbmVkIHRvLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFdyaXRlVmFyRXhwcih0aGlzLm5hbWUsIHZhbHVlLCBudWxsLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlYWRWYXJFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgVHlwZW9mRXhwciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHlwZW9mRXhwciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUeXBlb2ZFeHByKGV4cHIsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXhwciA9IGV4cHI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVHlwZW9mRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUeXBlb2ZFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgVHlwZW9mRXhwci5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBUeXBlb2ZFeHByICYmIGUuZXhwci5pc0VxdWl2YWxlbnQodGhpcy5leHByKTtcbiAgICB9O1xuICAgIFR5cGVvZkV4cHIucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmV4cHIuaXNDb25zdGFudCgpOyB9O1xuICAgIHJldHVybiBUeXBlb2ZFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgV3JhcHBlZE5vZGVFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXcmFwcGVkTm9kZUV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV3JhcHBlZE5vZGVFeHByKG5vZGUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgV3JhcHBlZE5vZGVFeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFdyYXBwZWROb2RlRXhwciAmJiB0aGlzLm5vZGUgPT09IGUubm9kZTtcbiAgICB9O1xuICAgIFdyYXBwZWROb2RlRXhwci5wcm90b3R5cGUuaXNDb25zdGFudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIFdyYXBwZWROb2RlRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRXcmFwcGVkTm9kZUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gV3JhcHBlZE5vZGVFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgV3JpdGVWYXJFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXcml0ZVZhckV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV3JpdGVWYXJFeHByKG5hbWUsIHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUgfHwgdmFsdWUudHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgV3JpdGVWYXJFeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFdyaXRlVmFyRXhwciAmJiB0aGlzLm5hbWUgPT09IGUubmFtZSAmJiB0aGlzLnZhbHVlLmlzRXF1aXZhbGVudChlLnZhbHVlKTtcbiAgICB9O1xuICAgIFdyaXRlVmFyRXhwci5wcm90b3R5cGUuaXNDb25zdGFudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIFdyaXRlVmFyRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRXcml0ZVZhckV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICBXcml0ZVZhckV4cHIucHJvdG90eXBlLnRvRGVjbFN0bXQgPSBmdW5jdGlvbiAodHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjbGFyZVZhclN0bXQodGhpcy5uYW1lLCB0aGlzLnZhbHVlLCB0eXBlLCBtb2RpZmllcnMsIHRoaXMuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBXcml0ZVZhckV4cHIucHJvdG90eXBlLnRvQ29uc3REZWNsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50b0RlY2xTdG10KElORkVSUkVEX1RZUEUsIFtTdG10TW9kaWZpZXIuRmluYWxdKTsgfTtcbiAgICByZXR1cm4gV3JpdGVWYXJFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgV3JpdGVLZXlFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXcml0ZUtleUV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV3JpdGVLZXlFeHByKHJlY2VpdmVyLCBpbmRleCwgdmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCB2YWx1ZS50eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFdyaXRlS2V5RXhwci5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBXcml0ZUtleUV4cHIgJiYgdGhpcy5yZWNlaXZlci5pc0VxdWl2YWxlbnQoZS5yZWNlaXZlcikgJiZcbiAgICAgICAgICAgIHRoaXMuaW5kZXguaXNFcXVpdmFsZW50KGUuaW5kZXgpICYmIHRoaXMudmFsdWUuaXNFcXVpdmFsZW50KGUudmFsdWUpO1xuICAgIH07XG4gICAgV3JpdGVLZXlFeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgV3JpdGVLZXlFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFdyaXRlS2V5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBXcml0ZUtleUV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBXcml0ZVByb3BFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXcml0ZVByb3BFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdyaXRlUHJvcEV4cHIocmVjZWl2ZXIsIG5hbWUsIHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUgfHwgdmFsdWUudHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgV3JpdGVQcm9wRXhwci5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBXcml0ZVByb3BFeHByICYmIHRoaXMucmVjZWl2ZXIuaXNFcXVpdmFsZW50KGUucmVjZWl2ZXIpICYmXG4gICAgICAgICAgICB0aGlzLm5hbWUgPT09IGUubmFtZSAmJiB0aGlzLnZhbHVlLmlzRXF1aXZhbGVudChlLnZhbHVlKTtcbiAgICB9O1xuICAgIFdyaXRlUHJvcEV4cHIucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICBXcml0ZVByb3BFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFdyaXRlUHJvcEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gV3JpdGVQcm9wRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIEJ1aWx0aW5NZXRob2Q7XG4oZnVuY3Rpb24gKEJ1aWx0aW5NZXRob2QpIHtcbiAgICBCdWlsdGluTWV0aG9kW0J1aWx0aW5NZXRob2RbXCJDb25jYXRBcnJheVwiXSA9IDBdID0gXCJDb25jYXRBcnJheVwiO1xuICAgIEJ1aWx0aW5NZXRob2RbQnVpbHRpbk1ldGhvZFtcIlN1YnNjcmliZU9ic2VydmFibGVcIl0gPSAxXSA9IFwiU3Vic2NyaWJlT2JzZXJ2YWJsZVwiO1xuICAgIEJ1aWx0aW5NZXRob2RbQnVpbHRpbk1ldGhvZFtcIkJpbmRcIl0gPSAyXSA9IFwiQmluZFwiO1xufSkoQnVpbHRpbk1ldGhvZCB8fCAoQnVpbHRpbk1ldGhvZCA9IHt9KSk7XG52YXIgSW52b2tlTWV0aG9kRXhwciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW52b2tlTWV0aG9kRXhwciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnZva2VNZXRob2RFeHByKHJlY2VpdmVyLCBtZXRob2QsIGFyZ3MsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgX3RoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgX3RoaXMubmFtZSA9IG1ldGhvZDtcbiAgICAgICAgICAgIF90aGlzLmJ1aWx0aW4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMubmFtZSA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5idWlsdGluID0gbWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW52b2tlTWV0aG9kRXhwci5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBJbnZva2VNZXRob2RFeHByICYmIHRoaXMucmVjZWl2ZXIuaXNFcXVpdmFsZW50KGUucmVjZWl2ZXIpICYmXG4gICAgICAgICAgICB0aGlzLm5hbWUgPT09IGUubmFtZSAmJiB0aGlzLmJ1aWx0aW4gPT09IGUuYnVpbHRpbiAmJiBhcmVBbGxFcXVpdmFsZW50KHRoaXMuYXJncywgZS5hcmdzKTtcbiAgICB9O1xuICAgIEludm9rZU1ldGhvZEV4cHIucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICBJbnZva2VNZXRob2RFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEludm9rZU1ldGhvZEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW52b2tlTWV0aG9kRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIEludm9rZUZ1bmN0aW9uRXhwciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW52b2tlRnVuY3Rpb25FeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludm9rZUZ1bmN0aW9uRXhwcihmbiwgYXJncywgdHlwZSwgc291cmNlU3BhbiwgcHVyZSkge1xuICAgICAgICBpZiAocHVyZSA9PT0gdm9pZCAwKSB7IHB1cmUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5mbiA9IGZuO1xuICAgICAgICBfdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgX3RoaXMucHVyZSA9IHB1cmU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW52b2tlRnVuY3Rpb25FeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEludm9rZUZ1bmN0aW9uRXhwciAmJiB0aGlzLmZuLmlzRXF1aXZhbGVudChlLmZuKSAmJlxuICAgICAgICAgICAgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmFyZ3MsIGUuYXJncykgJiYgdGhpcy5wdXJlID09PSBlLnB1cmU7XG4gICAgfTtcbiAgICBJbnZva2VGdW5jdGlvbkV4cHIucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICBJbnZva2VGdW5jdGlvbkV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEludm9rZUZ1bmN0aW9uRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIEluc3RhbnRpYXRlRXhwciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5zdGFudGlhdGVFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluc3RhbnRpYXRlRXhwcihjbGFzc0V4cHIsIGFyZ3MsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2xhc3NFeHByID0gY2xhc3NFeHByO1xuICAgICAgICBfdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbnN0YW50aWF0ZUV4cHIucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgSW5zdGFudGlhdGVFeHByICYmIHRoaXMuY2xhc3NFeHByLmlzRXF1aXZhbGVudChlLmNsYXNzRXhwcikgJiZcbiAgICAgICAgICAgIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5hcmdzLCBlLmFyZ3MpO1xuICAgIH07XG4gICAgSW5zdGFudGlhdGVFeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgSW5zdGFudGlhdGVFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEluc3RhbnRpYXRlRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBJbnN0YW50aWF0ZUV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBMaXRlcmFsRXhwciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGl0ZXJhbEV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGl0ZXJhbEV4cHIodmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMaXRlcmFsRXhwci5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBMaXRlcmFsRXhwciAmJiB0aGlzLnZhbHVlID09PSBlLnZhbHVlO1xuICAgIH07XG4gICAgTGl0ZXJhbEV4cHIucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIExpdGVyYWxFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIExpdGVyYWxFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgRXh0ZXJuYWxFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlcm5hbEV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZXJuYWxFeHByKHZhbHVlLCB0eXBlLCB0eXBlUGFyYW1zLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmICh0eXBlUGFyYW1zID09PSB2b2lkIDApIHsgdHlwZVBhcmFtcyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgX3RoaXMudHlwZVBhcmFtcyA9IHR5cGVQYXJhbXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRXh0ZXJuYWxFeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEV4dGVybmFsRXhwciAmJiB0aGlzLnZhbHVlLm5hbWUgPT09IGUudmFsdWUubmFtZSAmJlxuICAgICAgICAgICAgdGhpcy52YWx1ZS5tb2R1bGVOYW1lID09PSBlLnZhbHVlLm1vZHVsZU5hbWUgJiYgdGhpcy52YWx1ZS5ydW50aW1lID09PSBlLnZhbHVlLnJ1bnRpbWU7XG4gICAgfTtcbiAgICBFeHRlcm5hbEV4cHIucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICBFeHRlcm5hbEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXh0ZXJuYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVybmFsRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIEV4dGVybmFsUmVmZXJlbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4dGVybmFsUmVmZXJlbmNlKG1vZHVsZU5hbWUsIG5hbWUsIHJ1bnRpbWUpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVOYW1lID0gbW9kdWxlTmFtZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5ydW50aW1lID0gcnVudGltZTtcbiAgICB9XG4gICAgcmV0dXJuIEV4dGVybmFsUmVmZXJlbmNlO1xufSgpKTtcbnZhciBDb25kaXRpb25hbEV4cHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmRpdGlvbmFsRXhwciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25kaXRpb25hbEV4cHIoY29uZGl0aW9uLCB0cnVlQ2FzZSwgZmFsc2VDYXNlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChmYWxzZUNhc2UgPT09IHZvaWQgMCkgeyBmYWxzZUNhc2UgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUgfHwgdHJ1ZUNhc2UudHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICBfdGhpcy5mYWxzZUNhc2UgPSBmYWxzZUNhc2U7XG4gICAgICAgIF90aGlzLnRydWVDYXNlID0gdHJ1ZUNhc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29uZGl0aW9uYWxFeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIENvbmRpdGlvbmFsRXhwciAmJiB0aGlzLmNvbmRpdGlvbi5pc0VxdWl2YWxlbnQoZS5jb25kaXRpb24pICYmXG4gICAgICAgICAgICB0aGlzLnRydWVDYXNlLmlzRXF1aXZhbGVudChlLnRydWVDYXNlKSAmJiBudWxsU2FmZUlzRXF1aXZhbGVudCh0aGlzLmZhbHNlQ2FzZSwgZS5mYWxzZUNhc2UpO1xuICAgIH07XG4gICAgQ29uZGl0aW9uYWxFeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgQ29uZGl0aW9uYWxFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbmRpdGlvbmFsRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBDb25kaXRpb25hbEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBOb3RFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb3RFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5vdEV4cHIoY29uZGl0aW9uLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIEJPT0xfVFlQRSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE5vdEV4cHIucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgTm90RXhwciAmJiB0aGlzLmNvbmRpdGlvbi5pc0VxdWl2YWxlbnQoZS5jb25kaXRpb24pO1xuICAgIH07XG4gICAgTm90RXhwci5wcm90b3R5cGUuaXNDb25zdGFudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIE5vdEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Tm90RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBOb3RFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgQXNzZXJ0Tm90TnVsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXNzZXJ0Tm90TnVsbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3NlcnROb3ROdWxsKGNvbmRpdGlvbiwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25kaXRpb24udHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFzc2VydE5vdE51bGwucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgQXNzZXJ0Tm90TnVsbCAmJiB0aGlzLmNvbmRpdGlvbi5pc0VxdWl2YWxlbnQoZS5jb25kaXRpb24pO1xuICAgIH07XG4gICAgQXNzZXJ0Tm90TnVsbC5wcm90b3R5cGUuaXNDb25zdGFudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIEFzc2VydE5vdE51bGwucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXNzZXJ0Tm90TnVsbEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQXNzZXJ0Tm90TnVsbDtcbn0oRXhwcmVzc2lvbikpO1xudmFyIENhc3RFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYXN0RXhwciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYXN0RXhwcih2YWx1ZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENhc3RFeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIENhc3RFeHByICYmIHRoaXMudmFsdWUuaXNFcXVpdmFsZW50KGUudmFsdWUpO1xuICAgIH07XG4gICAgQ2FzdEV4cHIucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICBDYXN0RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDYXN0RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBDYXN0RXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIEZuUGFyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRm5QYXJhbShuYW1lLCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgRm5QYXJhbS5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiB0aGlzLm5hbWUgPT09IHBhcmFtLm5hbWU7IH07XG4gICAgcmV0dXJuIEZuUGFyYW07XG59KCkpO1xudmFyIEZ1bmN0aW9uRXhwciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnVuY3Rpb25FeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRXhwcihwYXJhbXMsIHN0YXRlbWVudHMsIHR5cGUsIHNvdXJjZVNwYW4sIG5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICBfdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRnVuY3Rpb25FeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEZ1bmN0aW9uRXhwciAmJiBhcmVBbGxFcXVpdmFsZW50KHRoaXMucGFyYW1zLCBlLnBhcmFtcykgJiZcbiAgICAgICAgICAgIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5zdGF0ZW1lbnRzLCBlLnN0YXRlbWVudHMpO1xuICAgIH07XG4gICAgRnVuY3Rpb25FeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgRnVuY3Rpb25FeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEZ1bmN0aW9uRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEZ1bmN0aW9uRXhwci5wcm90b3R5cGUudG9EZWNsU3RtdCA9IGZ1bmN0aW9uIChuYW1lLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBEZWNsYXJlRnVuY3Rpb25TdG10KG5hbWUsIHRoaXMucGFyYW1zLCB0aGlzLnN0YXRlbWVudHMsIHRoaXMudHlwZSwgbW9kaWZpZXJzLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIEZ1bmN0aW9uRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIEJpbmFyeU9wZXJhdG9yRXhwciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmluYXJ5T3BlcmF0b3JFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJpbmFyeU9wZXJhdG9yRXhwcihvcGVyYXRvciwgbGhzLCByaHMsIHR5cGUsIHNvdXJjZVNwYW4sIHBhcmVucykge1xuICAgICAgICBpZiAocGFyZW5zID09PSB2b2lkIDApIHsgcGFyZW5zID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlIHx8IGxocy50eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICBfdGhpcy5yaHMgPSByaHM7XG4gICAgICAgIF90aGlzLnBhcmVucyA9IHBhcmVucztcbiAgICAgICAgX3RoaXMubGhzID0gbGhzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEJpbmFyeU9wZXJhdG9yRXhwci5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBCaW5hcnlPcGVyYXRvckV4cHIgJiYgdGhpcy5vcGVyYXRvciA9PT0gZS5vcGVyYXRvciAmJlxuICAgICAgICAgICAgdGhpcy5saHMuaXNFcXVpdmFsZW50KGUubGhzKSAmJiB0aGlzLnJocy5pc0VxdWl2YWxlbnQoZS5yaHMpO1xuICAgIH07XG4gICAgQmluYXJ5T3BlcmF0b3JFeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgQmluYXJ5T3BlcmF0b3JFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJpbmFyeU9wZXJhdG9yRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBCaW5hcnlPcGVyYXRvckV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBSZWFkUHJvcEV4cHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlYWRQcm9wRXhwciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWFkUHJvcEV4cHIocmVjZWl2ZXIsIG5hbWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVhZFByb3BFeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFJlYWRQcm9wRXhwciAmJiB0aGlzLnJlY2VpdmVyLmlzRXF1aXZhbGVudChlLnJlY2VpdmVyKSAmJlxuICAgICAgICAgICAgdGhpcy5uYW1lID09PSBlLm5hbWU7XG4gICAgfTtcbiAgICBSZWFkUHJvcEV4cHIucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICBSZWFkUHJvcEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVhZFByb3BFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVhZFByb3BFeHByLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZVByb3BFeHByKHRoaXMucmVjZWl2ZXIsIHRoaXMubmFtZSwgdmFsdWUsIG51bGwsIHRoaXMuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICByZXR1cm4gUmVhZFByb3BFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgUmVhZEtleUV4cHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlYWRLZXlFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlYWRLZXlFeHByKHJlY2VpdmVyLCBpbmRleCwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlYWRLZXlFeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFJlYWRLZXlFeHByICYmIHRoaXMucmVjZWl2ZXIuaXNFcXVpdmFsZW50KGUucmVjZWl2ZXIpICYmXG4gICAgICAgICAgICB0aGlzLmluZGV4LmlzRXF1aXZhbGVudChlLmluZGV4KTtcbiAgICB9O1xuICAgIFJlYWRLZXlFeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgUmVhZEtleUV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVhZEtleUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWFkS2V5RXhwci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JpdGVLZXlFeHByKHRoaXMucmVjZWl2ZXIsIHRoaXMuaW5kZXgsIHZhbHVlLCBudWxsLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlYWRLZXlFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgTGl0ZXJhbEFycmF5RXhwciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGl0ZXJhbEFycmF5RXhwciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaXRlcmFsQXJyYXlFeHByKGVudHJpZXMsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGl0ZXJhbEFycmF5RXhwci5wcm90b3R5cGUuaXNDb25zdGFudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZW50cmllcy5ldmVyeShmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5pc0NvbnN0YW50KCk7IH0pOyB9O1xuICAgIExpdGVyYWxBcnJheUV4cHIucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgTGl0ZXJhbEFycmF5RXhwciAmJiBhcmVBbGxFcXVpdmFsZW50KHRoaXMuZW50cmllcywgZS5lbnRyaWVzKTtcbiAgICB9O1xuICAgIExpdGVyYWxBcnJheUV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbEFycmF5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBMaXRlcmFsQXJyYXlFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgTGl0ZXJhbE1hcEVudHJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpdGVyYWxNYXBFbnRyeShrZXksIHZhbHVlLCBxdW90ZWQpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5xdW90ZWQgPSBxdW90ZWQ7XG4gICAgfVxuICAgIExpdGVyYWxNYXBFbnRyeS5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5ID09PSBlLmtleSAmJiB0aGlzLnZhbHVlLmlzRXF1aXZhbGVudChlLnZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBMaXRlcmFsTWFwRW50cnk7XG59KCkpO1xudmFyIExpdGVyYWxNYXBFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaXRlcmFsTWFwRXhwciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaXRlcmFsTWFwRXhwcihlbnRyaWVzLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgICAgICBfdGhpcy52YWx1ZVR5cGUgPSBudWxsO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgX3RoaXMudmFsdWVUeXBlID0gdHlwZS52YWx1ZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMaXRlcmFsTWFwRXhwci5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBMaXRlcmFsTWFwRXhwciAmJiBhcmVBbGxFcXVpdmFsZW50KHRoaXMuZW50cmllcywgZS5lbnRyaWVzKTtcbiAgICB9O1xuICAgIExpdGVyYWxNYXBFeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmV2ZXJ5KGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnZhbHVlLmlzQ29uc3RhbnQoKTsgfSk7IH07XG4gICAgTGl0ZXJhbE1hcEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbE1hcEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbE1hcEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBDb21tYUV4cHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbW1hRXhwciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21tYUV4cHIocGFydHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0udHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGFydHMgPSBwYXJ0cztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb21tYUV4cHIucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgQ29tbWFFeHByICYmIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5wYXJ0cywgZS5wYXJ0cyk7XG4gICAgfTtcbiAgICBDb21tYUV4cHIucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICBDb21tYUV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29tbWFFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbW1hRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIFRISVNfRVhQUiA9IG5ldyBSZWFkVmFyRXhwcihCdWlsdGluVmFyLlRoaXMsIG51bGwsIG51bGwpO1xudmFyIFNVUEVSX0VYUFIgPSBuZXcgUmVhZFZhckV4cHIoQnVpbHRpblZhci5TdXBlciwgbnVsbCwgbnVsbCk7XG52YXIgQ0FUQ0hfRVJST1JfVkFSID0gbmV3IFJlYWRWYXJFeHByKEJ1aWx0aW5WYXIuQ2F0Y2hFcnJvciwgbnVsbCwgbnVsbCk7XG52YXIgQ0FUQ0hfU1RBQ0tfVkFSID0gbmV3IFJlYWRWYXJFeHByKEJ1aWx0aW5WYXIuQ2F0Y2hTdGFjaywgbnVsbCwgbnVsbCk7XG52YXIgTlVMTF9FWFBSID0gbmV3IExpdGVyYWxFeHByKG51bGwsIG51bGwsIG51bGwpO1xudmFyIFRZUEVEX05VTExfRVhQUiA9IG5ldyBMaXRlcmFsRXhwcihudWxsLCBJTkZFUlJFRF9UWVBFLCBudWxsKTtcbi8vLy8gU3RhdGVtZW50c1xudmFyIFN0bXRNb2RpZmllcjtcbihmdW5jdGlvbiAoU3RtdE1vZGlmaWVyKSB7XG4gICAgU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllcltcIkZpbmFsXCJdID0gMF0gPSBcIkZpbmFsXCI7XG4gICAgU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllcltcIlByaXZhdGVcIl0gPSAxXSA9IFwiUHJpdmF0ZVwiO1xuICAgIFN0bXRNb2RpZmllcltTdG10TW9kaWZpZXJbXCJFeHBvcnRlZFwiXSA9IDJdID0gXCJFeHBvcnRlZFwiO1xuICAgIFN0bXRNb2RpZmllcltTdG10TW9kaWZpZXJbXCJTdGF0aWNcIl0gPSAzXSA9IFwiU3RhdGljXCI7XG59KShTdG10TW9kaWZpZXIgfHwgKFN0bXRNb2RpZmllciA9IHt9KSk7XG52YXIgU3RhdGVtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlbWVudChtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgW107XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW4gfHwgbnVsbDtcbiAgICB9XG4gICAgU3RhdGVtZW50LnByb3RvdHlwZS5oYXNNb2RpZmllciA9IGZ1bmN0aW9uIChtb2RpZmllcikgeyByZXR1cm4gdGhpcy5tb2RpZmllcnMuaW5kZXhPZihtb2RpZmllcikgIT09IC0xOyB9O1xuICAgIHJldHVybiBTdGF0ZW1lbnQ7XG59KCkpO1xudmFyIERlY2xhcmVWYXJTdG10ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWNsYXJlVmFyU3RtdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWNsYXJlVmFyU3RtdChuYW1lLCB2YWx1ZSwgdHlwZSwgbW9kaWZpZXJzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycywgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIF90aGlzLnR5cGUgPSB0eXBlIHx8ICh2YWx1ZSAmJiB2YWx1ZS50eXBlKSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERlY2xhcmVWYXJTdG10LnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoc3RtdCkge1xuICAgICAgICByZXR1cm4gc3RtdCBpbnN0YW5jZW9mIERlY2xhcmVWYXJTdG10ICYmIHRoaXMubmFtZSA9PT0gc3RtdC5uYW1lICYmXG4gICAgICAgICAgICAodGhpcy52YWx1ZSA/ICEhc3RtdC52YWx1ZSAmJiB0aGlzLnZhbHVlLmlzRXF1aXZhbGVudChzdG10LnZhbHVlKSA6ICFzdG10LnZhbHVlKTtcbiAgICB9O1xuICAgIERlY2xhcmVWYXJTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyZVZhclN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVjbGFyZVZhclN0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIERlY2xhcmVGdW5jdGlvblN0bXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlY2xhcmVGdW5jdGlvblN0bXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVjbGFyZUZ1bmN0aW9uU3RtdChuYW1lLCBwYXJhbXMsIHN0YXRlbWVudHMsIHR5cGUsIG1vZGlmaWVycywgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIF90aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgICAgICBfdGhpcy50eXBlID0gdHlwZSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERlY2xhcmVGdW5jdGlvblN0bXQucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChzdG10KSB7XG4gICAgICAgIHJldHVybiBzdG10IGluc3RhbmNlb2YgRGVjbGFyZUZ1bmN0aW9uU3RtdCAmJiBhcmVBbGxFcXVpdmFsZW50KHRoaXMucGFyYW1zLCBzdG10LnBhcmFtcykgJiZcbiAgICAgICAgICAgIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5zdGF0ZW1lbnRzLCBzdG10LnN0YXRlbWVudHMpO1xuICAgIH07XG4gICAgRGVjbGFyZUZ1bmN0aW9uU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVjbGFyZUZ1bmN0aW9uU3RtdDtcbn0oU3RhdGVtZW50KSk7XG52YXIgRXhwcmVzc2lvblN0YXRlbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXhwcmVzc2lvblN0YXRlbWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbnVsbCwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXhwciA9IGV4cHI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRXhwcmVzc2lvblN0YXRlbWVudC5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQgaW5zdGFuY2VvZiBFeHByZXNzaW9uU3RhdGVtZW50ICYmIHRoaXMuZXhwci5pc0VxdWl2YWxlbnQoc3RtdC5leHByKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHByZXNzaW9uU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBFeHByZXNzaW9uU3RhdGVtZW50O1xufShTdGF0ZW1lbnQpKTtcbnZhciBSZXR1cm5TdGF0ZW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJldHVyblN0YXRlbWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXR1cm5TdGF0ZW1lbnQodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbnVsbCwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZXR1cm5TdGF0ZW1lbnQucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChzdG10KSB7XG4gICAgICAgIHJldHVybiBzdG10IGluc3RhbmNlb2YgUmV0dXJuU3RhdGVtZW50ICYmIHRoaXMudmFsdWUuaXNFcXVpdmFsZW50KHN0bXQudmFsdWUpO1xuICAgIH07XG4gICAgUmV0dXJuU3RhdGVtZW50LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmV0dXJuU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXR1cm5TdGF0ZW1lbnQ7XG59KFN0YXRlbWVudCkpO1xudmFyIEFic3RyYWN0Q2xhc3NQYXJ0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0Q2xhc3NQYXJ0KHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICB0aGlzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgICAgICAgaWYgKCFtb2RpZmllcnMpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZpZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCBudWxsO1xuICAgIH1cbiAgICBBYnN0cmFjdENsYXNzUGFydC5wcm90b3R5cGUuaGFzTW9kaWZpZXIgPSBmdW5jdGlvbiAobW9kaWZpZXIpIHsgcmV0dXJuIHRoaXMubW9kaWZpZXJzLmluZGV4T2YobW9kaWZpZXIpICE9PSAtMTsgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RDbGFzc1BhcnQ7XG59KCkpO1xudmFyIENsYXNzRmllbGQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENsYXNzRmllbGQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2xhc3NGaWVsZChuYW1lLCB0eXBlLCBtb2RpZmllcnMsIGluaXRpYWxpemVyKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIG1vZGlmaWVycykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2xhc3NGaWVsZC5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHRoaXMubmFtZSA9PT0gZi5uYW1lOyB9O1xuICAgIHJldHVybiBDbGFzc0ZpZWxkO1xufShBYnN0cmFjdENsYXNzUGFydCkpO1xudmFyIENsYXNzTWV0aG9kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDbGFzc01ldGhvZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDbGFzc01ldGhvZChuYW1lLCBwYXJhbXMsIGJvZHksIHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBtb2RpZmllcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIF90aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENsYXNzTWV0aG9kLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09PSBtLm5hbWUgJiYgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmJvZHksIG0uYm9keSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2xhc3NNZXRob2Q7XG59KEFic3RyYWN0Q2xhc3NQYXJ0KSk7XG52YXIgQ2xhc3NHZXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENsYXNzR2V0dGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENsYXNzR2V0dGVyKG5hbWUsIGJvZHksIHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBtb2RpZmllcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDbGFzc0dldHRlci5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSA9PT0gbS5uYW1lICYmIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5ib2R5LCBtLmJvZHkpO1xuICAgIH07XG4gICAgcmV0dXJuIENsYXNzR2V0dGVyO1xufShBYnN0cmFjdENsYXNzUGFydCkpO1xudmFyIENsYXNzU3RtdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2xhc3NTdG10LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENsYXNzU3RtdChuYW1lLCBwYXJlbnQsIGZpZWxkcywgZ2V0dGVycywgY29uc3RydWN0b3JNZXRob2QsIG1ldGhvZHMsIG1vZGlmaWVycywgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIF90aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgX3RoaXMuZ2V0dGVycyA9IGdldHRlcnM7XG4gICAgICAgIF90aGlzLmNvbnN0cnVjdG9yTWV0aG9kID0gY29uc3RydWN0b3JNZXRob2Q7XG4gICAgICAgIF90aGlzLm1ldGhvZHMgPSBtZXRob2RzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENsYXNzU3RtdC5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQgaW5zdGFuY2VvZiBDbGFzc1N0bXQgJiYgdGhpcy5uYW1lID09PSBzdG10Lm5hbWUgJiZcbiAgICAgICAgICAgIG51bGxTYWZlSXNFcXVpdmFsZW50KHRoaXMucGFyZW50LCBzdG10LnBhcmVudCkgJiZcbiAgICAgICAgICAgIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5maWVsZHMsIHN0bXQuZmllbGRzKSAmJlxuICAgICAgICAgICAgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmdldHRlcnMsIHN0bXQuZ2V0dGVycykgJiZcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3JNZXRob2QuaXNFcXVpdmFsZW50KHN0bXQuY29uc3RydWN0b3JNZXRob2QpICYmXG4gICAgICAgICAgICBhcmVBbGxFcXVpdmFsZW50KHRoaXMubWV0aG9kcywgc3RtdC5tZXRob2RzKTtcbiAgICB9O1xuICAgIENsYXNzU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERlY2xhcmVDbGFzc1N0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2xhc3NTdG10O1xufShTdGF0ZW1lbnQpKTtcbnZhciBJZlN0bXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElmU3RtdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJZlN0bXQoY29uZGl0aW9uLCB0cnVlQ2FzZSwgZmFsc2VDYXNlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChmYWxzZUNhc2UgPT09IHZvaWQgMCkgeyBmYWxzZUNhc2UgPSBbXTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIF90aGlzLnRydWVDYXNlID0gdHJ1ZUNhc2U7XG4gICAgICAgIF90aGlzLmZhbHNlQ2FzZSA9IGZhbHNlQ2FzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJZlN0bXQucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChzdG10KSB7XG4gICAgICAgIHJldHVybiBzdG10IGluc3RhbmNlb2YgSWZTdG10ICYmIHRoaXMuY29uZGl0aW9uLmlzRXF1aXZhbGVudChzdG10LmNvbmRpdGlvbikgJiZcbiAgICAgICAgICAgIGFyZUFsbEVxdWl2YWxlbnQodGhpcy50cnVlQ2FzZSwgc3RtdC50cnVlQ2FzZSkgJiZcbiAgICAgICAgICAgIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5mYWxzZUNhc2UsIHN0bXQuZmFsc2VDYXNlKTtcbiAgICB9O1xuICAgIElmU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdElmU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBJZlN0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIENvbW1lbnRTdG10ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21tZW50U3RtdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21tZW50U3RtdChjb21tZW50LCBtdWx0aWxpbmUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKG11bHRpbGluZSA9PT0gdm9pZCAwKSB7IG11bHRpbGluZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvbW1lbnQgPSBjb21tZW50O1xuICAgICAgICBfdGhpcy5tdWx0aWxpbmUgPSBtdWx0aWxpbmU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29tbWVudFN0bXQucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10IGluc3RhbmNlb2YgQ29tbWVudFN0bXQ7IH07XG4gICAgQ29tbWVudFN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb21tZW50U3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBDb21tZW50U3RtdDtcbn0oU3RhdGVtZW50KSk7XG52YXIgSlNEb2NDb21tZW50U3RtdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSlNEb2NDb21tZW50U3RtdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBKU0RvY0NvbW1lbnRTdG10KHRhZ3MsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKHRhZ3MgPT09IHZvaWQgMCkgeyB0YWdzID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbnVsbCwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGFncyA9IHRhZ3M7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSlNEb2NDb21tZW50U3RtdC5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQgaW5zdGFuY2VvZiBKU0RvY0NvbW1lbnRTdG10ICYmIHRoaXMudG9TdHJpbmcoKSA9PT0gc3RtdC50b1N0cmluZygpO1xuICAgIH07XG4gICAgSlNEb2NDb21tZW50U3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEpTRG9jQ29tbWVudFN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICBKU0RvY0NvbW1lbnRTdG10LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcmlhbGl6ZVRhZ3ModGhpcy50YWdzKTsgfTtcbiAgICByZXR1cm4gSlNEb2NDb21tZW50U3RtdDtcbn0oU3RhdGVtZW50KSk7XG52YXIgVHJ5Q2F0Y2hTdG10ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcnlDYXRjaFN0bXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHJ5Q2F0Y2hTdG10KGJvZHlTdG10cywgY2F0Y2hTdG10cywgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ib2R5U3RtdHMgPSBib2R5U3RtdHM7XG4gICAgICAgIF90aGlzLmNhdGNoU3RtdHMgPSBjYXRjaFN0bXRzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRyeUNhdGNoU3RtdC5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQgaW5zdGFuY2VvZiBUcnlDYXRjaFN0bXQgJiYgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmJvZHlTdG10cywgc3RtdC5ib2R5U3RtdHMpICYmXG4gICAgICAgICAgICBhcmVBbGxFcXVpdmFsZW50KHRoaXMuY2F0Y2hTdG10cywgc3RtdC5jYXRjaFN0bXRzKTtcbiAgICB9O1xuICAgIFRyeUNhdGNoU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRyeUNhdGNoU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBUcnlDYXRjaFN0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIFRocm93U3RtdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGhyb3dTdG10LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRocm93U3RtdChlcnJvciwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRocm93U3RtdC5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQgaW5zdGFuY2VvZiBUcnlDYXRjaFN0bXQgJiYgdGhpcy5lcnJvci5pc0VxdWl2YWxlbnQoc3RtdC5lcnJvcik7XG4gICAgfTtcbiAgICBUaHJvd1N0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUaHJvd1N0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gVGhyb3dTdG10O1xufShTdGF0ZW1lbnQpKTtcbnZhciBBc3RUcmFuc2Zvcm1lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3RUcmFuc2Zvcm1lcigpIHtcbiAgICB9XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkgeyByZXR1cm4gZXhwcjsgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7IHJldHVybiBzdG10OyB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKGFzdCwgY29udGV4dCk7IH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0V3JhcHBlZE5vZGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRUeXBlb2ZFeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgVHlwZW9mRXhwcihleHByLmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLnR5cGUsIGV4cHIuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0V3JpdGVWYXJFeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgV3JpdGVWYXJFeHByKGV4cHIubmFtZSwgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGV4cHIudHlwZSwgZXhwci5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRXcml0ZUtleUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBXcml0ZUtleUV4cHIoZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGV4cHIuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci50eXBlLCBleHByLnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFdyaXRlUHJvcEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBXcml0ZVByb3BFeHByKGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLm5hbWUsIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLnR5cGUsIGV4cHIuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0SW52b2tlTWV0aG9kRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IGFzdC5idWlsdGluIHx8IGFzdC5uYW1lO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBJbnZva2VNZXRob2RFeHByKGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIG1ldGhvZCwgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IEludm9rZUZ1bmN0aW9uRXhwcihhc3QuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEluc3RhbnRpYXRlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgSW5zdGFudGlhdGVFeHByKGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKGFzdCwgY29udGV4dCk7IH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IENvbmRpdGlvbmFsRXhwcihhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnRydWVDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LmZhbHNlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgTm90RXhwcihhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEFzc2VydE5vdE51bGxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBBc3NlcnROb3ROdWxsKGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IENhc3RFeHByKGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBGdW5jdGlvbkV4cHIoYXN0LnBhcmFtcywgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoYXN0LnN0YXRlbWVudHMsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgQmluYXJ5T3BlcmF0b3JFeHByKGFzdC5vcGVyYXRvciwgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgUmVhZFByb3BFeHByKGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5uYW1lLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFJlYWRLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBSZWFkS2V5RXhwcihhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IExpdGVyYWxBcnJheUV4cHIodGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjb250ZXh0KSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGVudHJpZXMgPSBhc3QuZW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBuZXcgTGl0ZXJhbE1hcEVudHJ5KGVudHJ5LmtleSwgZW50cnkudmFsdWUudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KSwgZW50cnkucXVvdGVkKTsgfSk7XG4gICAgICAgIHZhciBtYXBUeXBlID0gbmV3IE1hcFR5cGUoYXN0LnZhbHVlVHlwZSwgbnVsbCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IExpdGVyYWxNYXBFeHByKGVudHJpZXMsIG1hcFR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRDb21tYUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IENvbW1hRXhwcih0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LnBhcnRzLCBjb250ZXh0KSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEFsbEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKGV4cHJzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBleHBycy5tYXAoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0bXQudmFsdWUgJiYgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQobmV3IERlY2xhcmVWYXJTdG10KHN0bXQubmFtZSwgdmFsdWUsIHN0bXQudHlwZSwgc3RtdC5tb2RpZmllcnMsIHN0bXQuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQobmV3IERlY2xhcmVGdW5jdGlvblN0bXQoc3RtdC5uYW1lLCBzdG10LnBhcmFtcywgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5zdGF0ZW1lbnRzLCBjb250ZXh0KSwgc3RtdC50eXBlLCBzdG10Lm1vZGlmaWVycywgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQobmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQoc3RtdC5leHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRSZXR1cm5TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgUmV0dXJuU3RhdGVtZW50KHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBzdG10LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcGFyZW50ID0gc3RtdC5wYXJlbnQudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB2YXIgZ2V0dGVycyA9IHN0bXQuZ2V0dGVycy5tYXAoZnVuY3Rpb24gKGdldHRlcikgeyByZXR1cm4gbmV3IENsYXNzR2V0dGVyKGdldHRlci5uYW1lLCBfdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoZ2V0dGVyLmJvZHksIGNvbnRleHQpLCBnZXR0ZXIudHlwZSwgZ2V0dGVyLm1vZGlmaWVycyk7IH0pO1xuICAgICAgICB2YXIgY3Rvck1ldGhvZCA9IHN0bXQuY29uc3RydWN0b3JNZXRob2QgJiZcbiAgICAgICAgICAgIG5ldyBDbGFzc01ldGhvZChzdG10LmNvbnN0cnVjdG9yTWV0aG9kLm5hbWUsIHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGNvbnRleHQpLCBzdG10LmNvbnN0cnVjdG9yTWV0aG9kLnR5cGUsIHN0bXQuY29uc3RydWN0b3JNZXRob2QubW9kaWZpZXJzKTtcbiAgICAgICAgdmFyIG1ldGhvZHMgPSBzdG10Lm1ldGhvZHMubWFwKGZ1bmN0aW9uIChtZXRob2QpIHsgcmV0dXJuIG5ldyBDbGFzc01ldGhvZChtZXRob2QubmFtZSwgbWV0aG9kLnBhcmFtcywgX3RoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKG1ldGhvZC5ib2R5LCBjb250ZXh0KSwgbWV0aG9kLnR5cGUsIG1ldGhvZC5tb2RpZmllcnMpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgQ2xhc3NTdG10KHN0bXQubmFtZSwgcGFyZW50LCBzdG10LmZpZWxkcywgZ2V0dGVycywgY3Rvck1ldGhvZCwgbWV0aG9kcywgc3RtdC5tb2RpZmllcnMsIHN0bXQuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0SWZTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgSWZTdG10KHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY29udGV4dCksIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjb250ZXh0KSwgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1TdG10KG5ldyBUcnlDYXRjaFN0bXQodGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5ib2R5U3RtdHMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNhdGNoU3RtdHMsIGNvbnRleHQpLCBzdG10LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFRocm93U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQobmV3IFRocm93U3RtdChzdG10LmVycm9yLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQoc3RtdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRKU0RvY0NvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChzdG10LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RtdHMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHN0bXRzLm1hcChmdW5jdGlvbiAoc3RtdCkgeyByZXR1cm4gc3RtdC52aXNpdFN0YXRlbWVudChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFzdFRyYW5zZm9ybWVyO1xufSgpKTtcbnZhciBSZWN1cnNpdmVBc3RWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY3Vyc2l2ZUFzdFZpc2l0b3IoKSB7XG4gICAgfVxuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChhc3QudHlwZSkge1xuICAgICAgICAgICAgYXN0LnR5cGUudmlzaXRUeXBlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJ1aWx0aW5UeXBlID0gZnVuY3Rpb24gKHR5cGUsIGNvbnRleHQpIHsgcmV0dXJuIHRoaXMudmlzaXRUeXBlKHR5cGUsIGNvbnRleHQpOyB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0eXBlLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHR5cGUudHlwZVBhcmFtcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdHlwZS50eXBlUGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBfdGhpcy52aXNpdFR5cGUocGFyYW0sIGNvbnRleHQpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFR5cGUodHlwZSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFycmF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjb250ZXh0KSB7IHJldHVybiB0aGlzLnZpc2l0VHlwZSh0eXBlLCBjb250ZXh0KTsgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1hcFR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY29udGV4dCkgeyByZXR1cm4gdGhpcy52aXNpdFR5cGUodHlwZSwgY29udGV4dCk7IH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRXcmFwcGVkTm9kZUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRUeXBlb2ZFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTsgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnN0YW50aWF0ZUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChhc3QudHlwZVBhcmFtcykge1xuICAgICAgICAgICAgYXN0LnR5cGVQYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZS52aXNpdFR5cGUoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LnRydWVDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LmZhbHNlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXROb3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFzc2VydE5vdE51bGxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhhc3Quc3RhdGVtZW50cywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5saHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhc3QuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkudmFsdWUudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tYUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QucGFydHMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcnMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZXhwcnMuZm9yRWFjaChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBpZiAoc3RtdC52YWx1ZSkge1xuICAgICAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0bXQudHlwZSkge1xuICAgICAgICAgICAgc3RtdC50eXBlLnZpc2l0VHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuc3RhdGVtZW50cywgY29udGV4dCk7XG4gICAgICAgIGlmIChzdG10LnR5cGUpIHtcbiAgICAgICAgICAgIHN0bXQudHlwZS52aXNpdFR5cGUodGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgc3RtdC5leHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJldHVyblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzdG10LnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHN0bXQuZ2V0dGVycy5mb3JFYWNoKGZ1bmN0aW9uIChnZXR0ZXIpIHsgcmV0dXJuIF90aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhnZXR0ZXIuYm9keSwgY29udGV4dCk7IH0pO1xuICAgICAgICBpZiAoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZCkge1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5ib2R5LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBzdG10Lm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IHJldHVybiBfdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGNvbnRleHQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdElmU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jYXRjaFN0bXRzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRocm93U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkgeyByZXR1cm4gc3RtdDsgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEpTRG9jQ29tbWVudFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkgeyByZXR1cm4gc3RtdDsgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RtdHMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3RtdHMuZm9yRWFjaChmdW5jdGlvbiAoc3RtdCkgeyByZXR1cm4gc3RtdC52aXNpdFN0YXRlbWVudChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlY3Vyc2l2ZUFzdFZpc2l0b3I7XG59KCkpO1xuZnVuY3Rpb24gZmluZFJlYWRWYXJOYW1lcyhzdG10cykge1xuICAgIHZhciB2aXNpdG9yID0gbmV3IF9SZWFkVmFyVmlzaXRvcigpO1xuICAgIHZpc2l0b3IudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXRzLCBudWxsKTtcbiAgICByZXR1cm4gdmlzaXRvci52YXJOYW1lcztcbn1cbnZhciBfUmVhZFZhclZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9SZWFkVmFyVmlzaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBfUmVhZFZhclZpc2l0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YXJOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfUmVhZFZhclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIERvbid0IGRlc2NlbmQgaW50byBuZXN0ZWQgZnVuY3Rpb25zXG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgX1JlYWRWYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAvLyBEb24ndCBkZXNjZW5kIGludG8gbmVzdGVkIGNsYXNzZXNcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICBfUmVhZFZhclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChhc3QubmFtZSkge1xuICAgICAgICAgICAgdGhpcy52YXJOYW1lcy5hZGQoYXN0Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIF9SZWFkVmFyVmlzaXRvcjtcbn0oUmVjdXJzaXZlQXN0VmlzaXRvcikpO1xuZnVuY3Rpb24gY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlcyhzdG10cykge1xuICAgIHZhciB2aXNpdG9yID0gbmV3IF9GaW5kRXh0ZXJuYWxSZWZlcmVuY2VzVmlzaXRvcigpO1xuICAgIHZpc2l0b3IudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXRzLCBudWxsKTtcbiAgICByZXR1cm4gdmlzaXRvci5leHRlcm5hbFJlZmVyZW5jZXM7XG59XG52YXIgX0ZpbmRFeHRlcm5hbFJlZmVyZW5jZXNWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhfRmluZEV4dGVybmFsUmVmZXJlbmNlc1Zpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX0ZpbmRFeHRlcm5hbFJlZmVyZW5jZXNWaXNpdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXh0ZXJuYWxSZWZlcmVuY2VzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX0ZpbmRFeHRlcm5hbFJlZmVyZW5jZXNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxSZWZlcmVuY2VzLnB1c2goZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByLmNhbGwodGhpcywgZSwgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gX0ZpbmRFeHRlcm5hbFJlZmVyZW5jZXNWaXNpdG9yO1xufShSZWN1cnNpdmVBc3RWaXNpdG9yKSk7XG5mdW5jdGlvbiBhcHBseVNvdXJjZVNwYW5Ub1N0YXRlbWVudElmTmVlZGVkKHN0bXQsIHNvdXJjZVNwYW4pIHtcbiAgICBpZiAoIXNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfVxuICAgIHZhciB0cmFuc2Zvcm1lciA9IG5ldyBfQXBwbHlTb3VyY2VTcGFuVHJhbnNmb3JtZXIoc291cmNlU3Bhbik7XG4gICAgcmV0dXJuIHN0bXQudmlzaXRTdGF0ZW1lbnQodHJhbnNmb3JtZXIsIG51bGwpO1xufVxuZnVuY3Rpb24gYXBwbHlTb3VyY2VTcGFuVG9FeHByZXNzaW9uSWZOZWVkZWQoZXhwciwgc291cmNlU3Bhbikge1xuICAgIGlmICghc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gICAgdmFyIHRyYW5zZm9ybWVyID0gbmV3IF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lcihzb3VyY2VTcGFuKTtcbiAgICByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24odHJhbnNmb3JtZXIsIG51bGwpO1xufVxudmFyIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lcihzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lci5wcm90b3R5cGUuX2Nsb25lID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIGNsb25lID0gT2JqZWN0LmNyZWF0ZShvYmouY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoT2JqZWN0LmtleXMob2JqKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNsb25lW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH07XG4gICAgX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1FeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFleHByLnNvdXJjZVNwYW4pIHtcbiAgICAgICAgICAgIGV4cHIgPSB0aGlzLl9jbG9uZShleHByKTtcbiAgICAgICAgICAgIGV4cHIuc291cmNlU3BhbiA9IHRoaXMuc291cmNlU3BhbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuICAgIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghc3RtdC5zb3VyY2VTcGFuKSB7XG4gICAgICAgICAgICBzdG10ID0gdGhpcy5fY2xvbmUoc3RtdCk7XG4gICAgICAgICAgICBzdG10LnNvdXJjZVNwYW4gPSB0aGlzLnNvdXJjZVNwYW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyO1xufShBc3RUcmFuc2Zvcm1lcikpO1xuZnVuY3Rpb24gdmFyaWFibGUobmFtZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgUmVhZFZhckV4cHIobmFtZSwgdHlwZSwgc291cmNlU3Bhbik7XG59XG5mdW5jdGlvbiBpbXBvcnRFeHByKGlkLCB0eXBlUGFyYW1zLCBzb3VyY2VTcGFuKSB7XG4gICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgIHJldHVybiBuZXcgRXh0ZXJuYWxFeHByKGlkLCBudWxsLCB0eXBlUGFyYW1zLCBzb3VyY2VTcGFuKTtcbn1cbmZ1bmN0aW9uIGltcG9ydFR5cGUoaWQsIHR5cGVQYXJhbXMsIHR5cGVNb2RpZmllcnMpIHtcbiAgICBpZiAodHlwZVBhcmFtcyA9PT0gdm9pZCAwKSB7IHR5cGVQYXJhbXMgPSBudWxsOyB9XG4gICAgaWYgKHR5cGVNb2RpZmllcnMgPT09IHZvaWQgMCkgeyB0eXBlTW9kaWZpZXJzID0gbnVsbDsgfVxuICAgIHJldHVybiBpZCAhPSBudWxsID8gZXhwcmVzc2lvblR5cGUoaW1wb3J0RXhwcihpZCwgdHlwZVBhcmFtcywgbnVsbCksIHR5cGVNb2RpZmllcnMpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGV4cHJlc3Npb25UeXBlKGV4cHIsIHR5cGVNb2RpZmllcnMsIHR5cGVQYXJhbXMpIHtcbiAgICBpZiAodHlwZU1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IHR5cGVNb2RpZmllcnMgPSBudWxsOyB9XG4gICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvblR5cGUoZXhwciwgdHlwZU1vZGlmaWVycywgdHlwZVBhcmFtcyk7XG59XG5mdW5jdGlvbiB0eXBlb2ZFeHByKGV4cHIpIHtcbiAgICByZXR1cm4gbmV3IFR5cGVvZkV4cHIoZXhwcik7XG59XG5mdW5jdGlvbiBsaXRlcmFsQXJyKHZhbHVlcywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5RXhwcih2YWx1ZXMsIHR5cGUsIHNvdXJjZVNwYW4pO1xufVxuZnVuY3Rpb24gbGl0ZXJhbE1hcCh2YWx1ZXMsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRXhwcih2YWx1ZXMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBuZXcgTGl0ZXJhbE1hcEVudHJ5KGUua2V5LCBlLnZhbHVlLCBlLnF1b3RlZCk7IH0pLCB0eXBlLCBudWxsKTtcbn1cbmZ1bmN0aW9uIG5vdChleHByLCBzb3VyY2VTcGFuKSB7XG4gICAgcmV0dXJuIG5ldyBOb3RFeHByKGV4cHIsIHNvdXJjZVNwYW4pO1xufVxuZnVuY3Rpb24gYXNzZXJ0Tm90TnVsbChleHByLCBzb3VyY2VTcGFuKSB7XG4gICAgcmV0dXJuIG5ldyBBc3NlcnROb3ROdWxsKGV4cHIsIHNvdXJjZVNwYW4pO1xufVxuZnVuY3Rpb24gZm4ocGFyYW1zLCBib2R5LCB0eXBlLCBzb3VyY2VTcGFuLCBuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbkV4cHIocGFyYW1zLCBib2R5LCB0eXBlLCBzb3VyY2VTcGFuLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIGlmU3RtdChjb25kaXRpb24sIHRoZW5DbGF1c2UsIGVsc2VDbGF1c2UpIHtcbiAgICByZXR1cm4gbmV3IElmU3RtdChjb25kaXRpb24sIHRoZW5DbGF1c2UsIGVsc2VDbGF1c2UpO1xufVxuZnVuY3Rpb24gbGl0ZXJhbCh2YWx1ZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHIodmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pO1xufVxuZnVuY3Rpb24gaXNOdWxsKGV4cCkge1xuICAgIHJldHVybiBleHAgaW5zdGFuY2VvZiBMaXRlcmFsRXhwciAmJiBleHAudmFsdWUgPT09IG51bGw7XG59XG4vKlxuICogU2VyaWFsaXplcyBhIGBUYWdgIGludG8gYSBzdHJpbmcuXG4gKiBSZXR1cm5zIGEgc3RyaW5nIGxpa2UgXCIgQGZvbyB7YmFyfSBiYXpcIiAobm90ZSB0aGUgbGVhZGluZyB3aGl0ZXNwYWNlIGJlZm9yZSBgQGZvb2ApLlxuICovXG5mdW5jdGlvbiB0YWdUb1N0cmluZyh0YWcpIHtcbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgaWYgKHRhZy50YWdOYW1lKSB7XG4gICAgICAgIG91dCArPSBcIiBAXCIgKyB0YWcudGFnTmFtZTtcbiAgICB9XG4gICAgaWYgKHRhZy50ZXh0KSB7XG4gICAgICAgIGlmICh0YWcudGV4dC5tYXRjaCgvXFwvXFwqfFxcKlxcLy8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTRG9jIHRleHQgY2Fubm90IGNvbnRhaW4gXCIvKlwiIGFuZCBcIiovXCInKTtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJyAnICsgdGFnLnRleHQucmVwbGFjZSgvQC9nLCAnXFxcXEAnKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRhZ3ModGFncykge1xuICAgIHZhciBlXzIsIF9hO1xuICAgIGlmICh0YWdzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIHZhciBvdXQgPSAnKlxcbic7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgdGFnc18xID0gX192YWx1ZXModGFncyksIHRhZ3NfMV8xID0gdGFnc18xLm5leHQoKTsgIXRhZ3NfMV8xLmRvbmU7IHRhZ3NfMV8xID0gdGFnc18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHRhZ3NfMV8xLnZhbHVlO1xuICAgICAgICAgICAgb3V0ICs9ICcgKic7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdGFnVG9TdHJpbmcgaXMgbXVsdGktbGluZSwgaW5zZXJ0IFwiICogXCIgcHJlZml4ZXMgb24gc3Vic2VxdWVudCBsaW5lcy5cbiAgICAgICAgICAgIG91dCArPSB0YWdUb1N0cmluZyh0YWcpLnJlcGxhY2UoL1xcbi9nLCAnXFxuICogJyk7XG4gICAgICAgICAgICBvdXQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0YWdzXzFfMSAmJiAhdGFnc18xXzEuZG9uZSAmJiAoX2EgPSB0YWdzXzEucmV0dXJuKSkgX2EuY2FsbCh0YWdzXzEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICB9XG4gICAgb3V0ICs9ICcgJztcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgREFTSF9DQVNFX1JFR0VYUCA9IC8tKyhbYS16MC05XSkvZztcbmZ1bmN0aW9uIGRhc2hDYXNlVG9DYW1lbENhc2UoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZShEQVNIX0NBU0VfUkVHRVhQLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBtW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1bMV0udG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNwbGl0QXRDb2xvbihpbnB1dCwgZGVmYXVsdFZhbHVlcykge1xuICAgIHJldHVybiBfc3BsaXRBdChpbnB1dCwgJzonLCBkZWZhdWx0VmFsdWVzKTtcbn1cbmZ1bmN0aW9uIHNwbGl0QXRQZXJpb2QoaW5wdXQsIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICByZXR1cm4gX3NwbGl0QXQoaW5wdXQsICcuJywgZGVmYXVsdFZhbHVlcyk7XG59XG5mdW5jdGlvbiBfc3BsaXRBdChpbnB1dCwgY2hhcmFjdGVyLCBkZWZhdWx0VmFsdWVzKSB7XG4gICAgdmFyIGNoYXJhY3RlckluZGV4ID0gaW5wdXQuaW5kZXhPZihjaGFyYWN0ZXIpO1xuICAgIGlmIChjaGFyYWN0ZXJJbmRleCA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZXM7XG4gICAgcmV0dXJuIFtpbnB1dC5zbGljZSgwLCBjaGFyYWN0ZXJJbmRleCkudHJpbSgpLCBpbnB1dC5zbGljZShjaGFyYWN0ZXJJbmRleCArIDEpLnRyaW0oKV07XG59XG5mdW5jdGlvbiB2aXNpdFZhbHVlKHZhbHVlLCB2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXJyYXkodmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpY3RTdHJpbmdNYXAodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3RyaW5nTWFwKHZhbHVlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJpbWl0aXZlKHZhbHVlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHZpc2l0b3IudmlzaXRPdGhlcih2YWx1ZSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc0RlZmluZWQodmFsKSB7XG4gICAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIG5vVW5kZWZpbmVkKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2YWw7XG59XG52YXIgVmFsdWVUcmFuc2Zvcm1lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWYWx1ZVRyYW5zZm9ybWVyKCkge1xuICAgIH1cbiAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEFycmF5ID0gZnVuY3Rpb24gKGFyciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gYXJyLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZpc2l0VmFsdWUodmFsdWUsIF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgfTtcbiAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcCA9IGZ1bmN0aW9uIChtYXAsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXN1bHRba2V5XSA9IHZpc2l0VmFsdWUobWFwW2tleV0sIF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByaW1pdGl2ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkgeyByZXR1cm4gdmFsdWU7IH07XG4gICAgVmFsdWVUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkgeyByZXR1cm4gdmFsdWU7IH07XG4gICAgcmV0dXJuIFZhbHVlVHJhbnNmb3JtZXI7XG59KCkpO1xudmFyIFN5bmNBc3luYyA9IHtcbiAgICBhc3NlcnRTeW5jOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IHZhbHVlIGNhbm5vdCBiZSBhIHByb21pc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgdGhlbjogZnVuY3Rpb24gKHZhbHVlLCBjYikgeyByZXR1cm4gaXNQcm9taXNlKHZhbHVlKSA/IHZhbHVlLnRoZW4oY2IpIDogY2IodmFsdWUpOyB9LFxuICAgIGFsbDogZnVuY3Rpb24gKHN5bmNBc3luY1ZhbHVlcykge1xuICAgICAgICByZXR1cm4gc3luY0FzeW5jVmFsdWVzLnNvbWUoaXNQcm9taXNlKSA/IFByb21pc2UuYWxsKHN5bmNBc3luY1ZhbHVlcykgOiBzeW5jQXN5bmNWYWx1ZXM7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIEVycm9yOiBcIiArIG1zZyk7XG59XG5mdW5jdGlvbiBzeW50YXhFcnJvcihtc2csIHBhcnNlRXJyb3JzKSB7XG4gICAgdmFyIGVycm9yID0gRXJyb3IobXNnKTtcbiAgICBlcnJvcltFUlJPUl9TWU5UQVhfRVJST1JdID0gdHJ1ZTtcbiAgICBpZiAocGFyc2VFcnJvcnMpXG4gICAgICAgIGVycm9yW0VSUk9SX1BBUlNFX0VSUk9SU10gPSBwYXJzZUVycm9ycztcbiAgICByZXR1cm4gZXJyb3I7XG59XG52YXIgRVJST1JfU1lOVEFYX0VSUk9SID0gJ25nU3ludGF4RXJyb3InO1xudmFyIEVSUk9SX1BBUlNFX0VSUk9SUyA9ICduZ1BhcnNlRXJyb3JzJztcbmZ1bmN0aW9uIGlzU3ludGF4RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3JbRVJST1JfU1lOVEFYX0VSUk9SXTtcbn1cbmZ1bmN0aW9uIGdldFBhcnNlRXJyb3JzKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yW0VSUk9SX1BBUlNFX0VSUk9SU10gfHwgW107XG59XG4vLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYSBzcGVjaWFsIG1lYW5pbmcgaW4gUmVndWxhciBFeHByZXNzaW9uc1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC8oWy4qKz9ePSE6JHt9KCl8W1xcXVxcL1xcXFxdKS9nLCAnXFxcXCQxJyk7XG59XG52YXIgU1RSSU5HX01BUF9QUk9UTyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSk7XG5mdW5jdGlvbiBpc1N0cmljdFN0cmluZ01hcChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBTVFJJTkdfTUFQX1BST1RPO1xufVxuZnVuY3Rpb24gdXRmOEVuY29kZShzdHIpIHtcbiAgICB2YXIgZW5jb2RlZCA9ICcnO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBjb2RlUG9pbnQgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgIC8vIGRlY29kZSBzdXJyb2dhdGVcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgICBpZiAoY29kZVBvaW50ID49IDB4ZDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhkYmZmICYmIHN0ci5sZW5ndGggPiAoaW5kZXggKyAxKSkge1xuICAgICAgICAgICAgdmFyIGxvdyA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZiAobG93ID49IDB4ZGMwMCAmJiBsb3cgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSAoKGNvZGVQb2ludCAtIDB4ZDgwMCkgPDwgMTApICsgbG93IC0gMHhkYzAwICsgMHgxMDAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4N2YpIHtcbiAgICAgICAgICAgIGVuY29kZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8PSAweDdmZikge1xuICAgICAgICAgICAgZW5jb2RlZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweGMwLCAoY29kZVBvaW50ICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGVQb2ludCA+PiAxMikgfCAweGUwLCAoKGNvZGVQb2ludCA+PiA2KSAmIDB4M2YpIHwgMHg4MCwgKGNvZGVQb2ludCAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4MWZmZmZmKSB7XG4gICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweGYwLCAoKGNvZGVQb2ludCA+PiAxMikgJiAweDNmKSB8IDB4ODAsICgoY29kZVBvaW50ID4+IDYpICYgMHgzZikgfCAweDgwLCAoY29kZVBvaW50ICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlZDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeSh0b2tlbikge1xuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgaWYgKHRva2VuIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuICdbJyArIHRva2VuLm1hcChzdHJpbmdpZnkpLmpvaW4oJywgJykgKyAnXSc7XG4gICAgfVxuICAgIGlmICh0b2tlbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRva2VuO1xuICAgIH1cbiAgICBpZiAodG9rZW4ub3ZlcnJpZGRlbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyB0b2tlbi5vdmVycmlkZGVuTmFtZTtcbiAgICB9XG4gICAgaWYgKHRva2VuLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyB0b2tlbi5uYW1lO1xuICAgIH1cbiAgICBpZiAoIXRva2VuLnRvU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgLy8gV0FSTklORzogZG8gbm90IHRyeSB0byBgSlNPTi5zdHJpbmdpZnkodG9rZW4pYCBoZXJlXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzIzNDQwXG4gICAgdmFyIHJlcyA9IHRva2VuLnRvU3RyaW5nKCk7XG4gICAgaWYgKHJlcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJyArIHJlcztcbiAgICB9XG4gICAgdmFyIG5ld0xpbmVJbmRleCA9IHJlcy5pbmRleE9mKCdcXG4nKTtcbiAgICByZXR1cm4gbmV3TGluZUluZGV4ID09PSAtMSA/IHJlcyA6IHJlcy5zdWJzdHJpbmcoMCwgbmV3TGluZUluZGV4KTtcbn1cbi8qKlxuICogTGF6aWx5IHJldHJpZXZlcyB0aGUgcmVmZXJlbmNlIHZhbHVlIGZyb20gYSBmb3J3YXJkUmVmLlxuICovXG5mdW5jdGlvbiByZXNvbHZlRm9yd2FyZFJlZih0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGUuaGFzT3duUHJvcGVydHkoJ19fZm9yd2FyZF9yZWZfXycpKSB7XG4gICAgICAgIHJldHVybiB0eXBlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG59XG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgYXJndW1lbnQgaXMgc2hhcGVkIGxpa2UgYSBQcm9taXNlXG4gKi9cbmZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgICAvLyBhbGxvdyBhbnkgUHJvbWlzZS9BKyBjb21wbGlhbnQgdGhlbmFibGUuXG4gICAgLy8gSXQncyB1cCB0byB0aGUgY2FsbGVyIHRvIGVuc3VyZSB0aGF0IG9iai50aGVuIGNvbmZvcm1zIHRvIHRoZSBzcGVjXG4gICAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbnZhciBWZXJzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZlcnNpb24oZnVsbCkge1xuICAgICAgICB0aGlzLmZ1bGwgPSBmdWxsO1xuICAgICAgICB2YXIgc3BsaXRzID0gZnVsbC5zcGxpdCgnLicpO1xuICAgICAgICB0aGlzLm1ham9yID0gc3BsaXRzWzBdO1xuICAgICAgICB0aGlzLm1pbm9yID0gc3BsaXRzWzFdO1xuICAgICAgICB0aGlzLnBhdGNoID0gc3BsaXRzLnNsaWNlKDIpLmpvaW4oJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIFZlcnNpb247XG59KCkpO1xudmFyIF9fd2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93O1xudmFyIF9fc2VsZiA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlICYmIHNlbGY7XG52YXIgX19nbG9iYWwgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWw7XG4vLyBDaGVjayBfX2dsb2JhbCBmaXJzdCwgYmVjYXVzZSBpbiBOb2RlIHRlc3RzIGJvdGggX19nbG9iYWwgYW5kIF9fd2luZG93IG1heSBiZSBkZWZpbmVkIGFuZCBfZ2xvYmFsXG4vLyBzaG91bGQgYmUgX19nbG9iYWwgaW4gdGhhdCBjYXNlLlxudmFyIF9nbG9iYWwgPSBfX2dsb2JhbCB8fCBfX3dpbmRvdyB8fCBfX3NlbGY7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBDT05TVEFOVF9QUkVGSVggPSAnX2MnO1xuLyoqXG4gKiBDb250ZXh0IHRvIHVzZSB3aGVuIHByb2R1Y2luZyBhIGtleS5cbiAqXG4gKiBUaGlzIGVuc3VyZXMgd2Ugc2VlIHRoZSBjb25zdGFudCBub3QgdGhlIHJlZmVyZW5jZSB2YXJpYWJsZSB3aGVuIHByb2R1Y2luZ1xuICogYSBrZXkuXG4gKi9cbnZhciBLRVlfQ09OVEVYVCA9IHt9O1xuLyoqXG4gKiBBIG5vZGUgdGhhdCBpcyBhIHBsYWNlLWhvbGRlciB0aGF0IGFsbG93cyB0aGUgbm9kZSB0byBiZSByZXBsYWNlZCB3aGVuIHRoZSBhY3R1YWxcbiAqIG5vZGUgaXMga25vd24uXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIGNvbnN0YW50IHBvb2wgdG8gY2hhbmdlIGFuIGV4cHJlc3Npb24gZnJvbSBhIGRpcmVjdCByZWZlcmVuY2UgdG9cbiAqIGEgY29uc3RhbnQgdG8gYSBzaGFyZWQgY29uc3RhbnQuIEl0IHJldHVybnMgYSBmaXgtdXAgbm9kZSB0aGF0IGlzIGxhdGVyIGFsbG93ZWQgdG9cbiAqIGNoYW5nZSB0aGUgcmVmZXJlbmNlZCBleHByZXNzaW9uLlxuICovXG52YXIgRml4dXBFeHByZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaXh1cEV4cHJlc3Npb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRml4dXBFeHByZXNzaW9uKHJlc29sdmVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlc29sdmVkLnR5cGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlc29sdmVkID0gcmVzb2x2ZWQ7XG4gICAgICAgIF90aGlzLm9yaWdpbmFsID0gcmVzb2x2ZWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRml4dXBFeHByZXNzaW9uLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gS0VZX0NPTlRFWFQpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gcHJvZHVjaW5nIGEga2V5IHdlIHdhbnQgdG8gdHJhdmVyc2UgdGhlIGNvbnN0YW50IG5vdCB0aGVcbiAgICAgICAgICAgIC8vIHZhcmlhYmxlIHVzZWQgdG8gcmVmZXIgdG8gaXQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbC52aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlZC52aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZpeHVwRXhwcmVzc2lvbi5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBGaXh1cEV4cHJlc3Npb24gJiYgdGhpcy5yZXNvbHZlZC5pc0VxdWl2YWxlbnQoZS5yZXNvbHZlZCk7XG4gICAgfTtcbiAgICBGaXh1cEV4cHJlc3Npb24ucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIEZpeHVwRXhwcmVzc2lvbi5wcm90b3R5cGUuZml4dXAgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICB0aGlzLnJlc29sdmVkID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5zaGFyZWQgPSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIEZpeHVwRXhwcmVzc2lvbjtcbn0oRXhwcmVzc2lvbikpO1xuLyoqXG4gKiBBIGNvbnN0YW50IHBvb2wgYWxsb3dzIGEgY29kZSBlbWl0dGVyIHRvIHNoYXJlIGNvbnN0YW50IGluIGFuIG91dHB1dCBjb250ZXh0LlxuICpcbiAqIFRoZSBjb25zdGFudCBwb29sIGFsc28gc3VwcG9ydHMgc2hhcmluZyBhY2Nlc3MgdG8gaXZ5IGRlZmluaXRpb25zIHJlZmVyZW5jZXMuXG4gKi9cbnZhciBDb25zdGFudFBvb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uc3RhbnRQb29sKCkge1xuICAgICAgICB0aGlzLnN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5saXRlcmFscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5saXRlcmFsRmFjdG9yaWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmluamVjdG9yRGVmaW5pdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlRGVmaW5pdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50RGVmaW5pdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGlwZURlZmluaXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm5leHROYW1lSW5kZXggPSAwO1xuICAgIH1cbiAgICBDb25zdGFudFBvb2wucHJvdG90eXBlLmdldENvbnN0TGl0ZXJhbCA9IGZ1bmN0aW9uIChsaXRlcmFsLCBmb3JjZVNoYXJlZCkge1xuICAgICAgICBpZiAobGl0ZXJhbCBpbnN0YW5jZW9mIExpdGVyYWxFeHByIHx8IGxpdGVyYWwgaW5zdGFuY2VvZiBGaXh1cEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIC8vIERvIG5vIHB1dCBzaW1wbGUgbGl0ZXJhbHMgaW50byB0aGUgY29uc3RhbnQgcG9vbCBvciB0cnkgdG8gcHJvZHVjZSBhIGNvbnN0YW50IGZvciBhXG4gICAgICAgICAgICAvLyByZWZlcmVuY2UgdG8gYSBjb25zdGFudC5cbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmtleU9mKGxpdGVyYWwpO1xuICAgICAgICB2YXIgZml4dXAgPSB0aGlzLmxpdGVyYWxzLmdldChrZXkpO1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFmaXh1cCkge1xuICAgICAgICAgICAgZml4dXAgPSBuZXcgRml4dXBFeHByZXNzaW9uKGxpdGVyYWwpO1xuICAgICAgICAgICAgdGhpcy5saXRlcmFscy5zZXQoa2V5LCBmaXh1cCk7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghbmV3VmFsdWUgJiYgIWZpeHVwLnNoYXJlZCkgfHwgKG5ld1ZhbHVlICYmIGZvcmNlU2hhcmVkKSkge1xuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgZXhwcmVzc2lvbiB3aXRoIGEgdmFyaWFibGVcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0aGlzLmZyZXNoTmFtZSgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZW1lbnRzLnB1c2godmFyaWFibGUobmFtZV8xKS5zZXQobGl0ZXJhbCkudG9EZWNsU3RtdChJTkZFUlJFRF9UWVBFLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSkpO1xuICAgICAgICAgICAgZml4dXAuZml4dXAodmFyaWFibGUobmFtZV8xKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpeHVwO1xuICAgIH07XG4gICAgQ29uc3RhbnRQb29sLnByb3RvdHlwZS5nZXREZWZpbml0aW9uID0gZnVuY3Rpb24gKHR5cGUsIGtpbmQsIGN0eCwgZm9yY2VTaGFyZWQpIHtcbiAgICAgICAgaWYgKGZvcmNlU2hhcmVkID09PSB2b2lkIDApIHsgZm9yY2VTaGFyZWQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgZGVmaW5pdGlvbnMgPSB0aGlzLmRlZmluaXRpb25zT2Yoa2luZCk7XG4gICAgICAgIHZhciBmaXh1cCA9IGRlZmluaXRpb25zLmdldCh0eXBlKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIGlmICghZml4dXApIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucHJvcGVydHlOYW1lT2Yoa2luZCk7XG4gICAgICAgICAgICBmaXh1cCA9IG5ldyBGaXh1cEV4cHJlc3Npb24oY3R4LmltcG9ydEV4cHIodHlwZSkucHJvcChwcm9wZXJ0eSkpO1xuICAgICAgICAgICAgZGVmaW5pdGlvbnMuc2V0KHR5cGUsIGZpeHVwKTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCFuZXdWYWx1ZSAmJiAhZml4dXAuc2hhcmVkKSB8fCAobmV3VmFsdWUgJiYgZm9yY2VTaGFyZWQpKSB7XG4gICAgICAgICAgICB2YXIgbmFtZV8yID0gdGhpcy5mcmVzaE5hbWUoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVtZW50cy5wdXNoKHZhcmlhYmxlKG5hbWVfMikuc2V0KGZpeHVwLnJlc29sdmVkKS50b0RlY2xTdG10KElORkVSUkVEX1RZUEUsIFtTdG10TW9kaWZpZXIuRmluYWxdKSk7XG4gICAgICAgICAgICBmaXh1cC5maXh1cCh2YXJpYWJsZShuYW1lXzIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZml4dXA7XG4gICAgfTtcbiAgICBDb25zdGFudFBvb2wucHJvdG90eXBlLmdldExpdGVyYWxGYWN0b3J5ID0gZnVuY3Rpb24gKGxpdGVyYWwkMSkge1xuICAgICAgICAvLyBDcmVhdGUgYSBwdXJlIGZ1bmN0aW9uIHRoYXQgYnVpbGRzIGFuIGFycmF5IG9mIGEgbWl4IG9mIGNvbnN0YW50ICBhbmQgdmFyaWFibGUgZXhwcmVzc2lvbnNcbiAgICAgICAgaWYgKGxpdGVyYWwkMSBpbnN0YW5jZW9mIExpdGVyYWxBcnJheUV4cHIpIHtcbiAgICAgICAgICAgIHZhciBhcmd1bWVudHNGb3JLZXkgPSBsaXRlcmFsJDEuZW50cmllcy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuaXNDb25zdGFudCgpID8gZSA6IGxpdGVyYWwobnVsbCk7IH0pO1xuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMua2V5T2YobGl0ZXJhbEFycihhcmd1bWVudHNGb3JLZXkpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRMaXRlcmFsRmFjdG9yeShrZXksIGxpdGVyYWwkMS5lbnRyaWVzLCBmdW5jdGlvbiAoZW50cmllcykgeyByZXR1cm4gbGl0ZXJhbEFycihlbnRyaWVzKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbkZvcktleSA9IGxpdGVyYWxNYXAobGl0ZXJhbCQxLmVudHJpZXMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgIGtleTogZS5rZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGUudmFsdWUuaXNDb25zdGFudCgpID8gZS52YWx1ZSA6IGxpdGVyYWwobnVsbCksXG4gICAgICAgICAgICAgICAgcXVvdGVkOiBlLnF1b3RlZFxuICAgICAgICAgICAgfSk7IH0pKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmtleU9mKGV4cHJlc3Npb25Gb3JLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldExpdGVyYWxGYWN0b3J5KGtleSwgbGl0ZXJhbCQxLmVudHJpZXMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnZhbHVlOyB9KSwgZnVuY3Rpb24gKGVudHJpZXMpIHsgcmV0dXJuIGxpdGVyYWxNYXAoZW50cmllcy5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICBrZXk6IGxpdGVyYWwkMS5lbnRyaWVzW2luZGV4XS5rZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHF1b3RlZDogbGl0ZXJhbCQxLmVudHJpZXNbaW5kZXhdLnF1b3RlZFxuICAgICAgICAgICAgfSk7IH0pKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbnN0YW50UG9vbC5wcm90b3R5cGUuX2dldExpdGVyYWxGYWN0b3J5ID0gZnVuY3Rpb24gKGtleSwgdmFsdWVzLCByZXN1bHRNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxpdGVyYWxGYWN0b3J5ID0gdGhpcy5saXRlcmFsRmFjdG9yaWVzLmdldChrZXkpO1xuICAgICAgICB2YXIgbGl0ZXJhbEZhY3RvcnlBcmd1bWVudHMgPSB2YWx1ZXMuZmlsdGVyKChmdW5jdGlvbiAoZSkgeyByZXR1cm4gIWUuaXNDb25zdGFudCgpOyB9KSk7XG4gICAgICAgIGlmICghbGl0ZXJhbEZhY3RvcnkpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRFeHByZXNzaW9ucyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKGUsIGluZGV4KSB7IHJldHVybiBlLmlzQ29uc3RhbnQoKSA/IF90aGlzLmdldENvbnN0TGl0ZXJhbChlLCB0cnVlKSA6IHZhcmlhYmxlKFwiYVwiICsgaW5kZXgpOyB9KTtcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gcmVzdWx0RXhwcmVzc2lvbnMuZmlsdGVyKGlzVmFyaWFibGUpLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gbmV3IEZuUGFyYW0oZS5uYW1lLCBEWU5BTUlDX1RZUEUpOyB9KTtcbiAgICAgICAgICAgIHZhciBwdXJlRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGZuKHBhcmFtZXRlcnMsIFtuZXcgUmV0dXJuU3RhdGVtZW50KHJlc3VsdE1hcChyZXN1bHRFeHByZXNzaW9ucykpXSwgSU5GRVJSRURfVFlQRSk7XG4gICAgICAgICAgICB2YXIgbmFtZV8zID0gdGhpcy5mcmVzaE5hbWUoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVtZW50cy5wdXNoKHZhcmlhYmxlKG5hbWVfMykuc2V0KHB1cmVGdW5jdGlvbkRlY2xhcmF0aW9uKS50b0RlY2xTdG10KElORkVSUkVEX1RZUEUsIFtcbiAgICAgICAgICAgICAgICBTdG10TW9kaWZpZXIuRmluYWxcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgIGxpdGVyYWxGYWN0b3J5ID0gdmFyaWFibGUobmFtZV8zKTtcbiAgICAgICAgICAgIHRoaXMubGl0ZXJhbEZhY3Rvcmllcy5zZXQoa2V5LCBsaXRlcmFsRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbGl0ZXJhbEZhY3Rvcnk6IGxpdGVyYWxGYWN0b3J5LCBsaXRlcmFsRmFjdG9yeUFyZ3VtZW50czogbGl0ZXJhbEZhY3RvcnlBcmd1bWVudHMgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb2R1Y2UgYSB1bmlxdWUgbmFtZS5cbiAgICAgKlxuICAgICAqIFRoZSBuYW1lIG1pZ2h0IGJlIHVuaXF1ZSBhbW9uZyBkaWZmZXJlbnQgcHJlZml4ZXMgaWYgYW55IG9mIHRoZSBwcmVmaXhlcyBlbmQgaW5cbiAgICAgKiBhIGRpZ2l0IHNvIHRoZSBwcmVmaXggc2hvdWxkIGJlIGEgY29uc3RhbnQgc3RyaW5nIChub3QgYmFzZWQgb24gdXNlciBpbnB1dCkgYW5kXG4gICAgICogbXVzdCBub3QgZW5kIGluIGEgZGlnaXQuXG4gICAgICovXG4gICAgQ29uc3RhbnRQb29sLnByb3RvdHlwZS51bmlxdWVOYW1lID0gZnVuY3Rpb24gKHByZWZpeCkgeyByZXR1cm4gXCJcIiArIHByZWZpeCArIHRoaXMubmV4dE5hbWVJbmRleCsrOyB9O1xuICAgIENvbnN0YW50UG9vbC5wcm90b3R5cGUuZGVmaW5pdGlvbnNPZiA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgY2FzZSAyIC8qIENvbXBvbmVudCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnREZWZpbml0aW9ucztcbiAgICAgICAgICAgIGNhc2UgMSAvKiBEaXJlY3RpdmUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aXZlRGVmaW5pdGlvbnM7XG4gICAgICAgICAgICBjYXNlIDAgLyogSW5qZWN0b3IgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5qZWN0b3JEZWZpbml0aW9ucztcbiAgICAgICAgICAgIGNhc2UgMyAvKiBQaXBlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBpcGVEZWZpbml0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIlVua25vd24gZGVmaW5pdGlvbiBraW5kIFwiICsga2luZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudERlZmluaXRpb25zO1xuICAgIH07XG4gICAgQ29uc3RhbnRQb29sLnByb3RvdHlwZS5wcm9wZXJ0eU5hbWVPZiA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgY2FzZSAyIC8qIENvbXBvbmVudCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25nQ29tcG9uZW50RGVmJztcbiAgICAgICAgICAgIGNhc2UgMSAvKiBEaXJlY3RpdmUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICduZ0RpcmVjdGl2ZURlZic7XG4gICAgICAgICAgICBjYXNlIDAgLyogSW5qZWN0b3IgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICduZ0luamVjdG9yRGVmJztcbiAgICAgICAgICAgIGNhc2UgMyAvKiBQaXBlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbmdQaXBlRGVmJztcbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIlVua25vd24gZGVmaW5pdGlvbiBraW5kIFwiICsga2luZCk7XG4gICAgICAgIHJldHVybiAnPHVua25vd24+JztcbiAgICB9O1xuICAgIENvbnN0YW50UG9vbC5wcm90b3R5cGUuZnJlc2hOYW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy51bmlxdWVOYW1lKENPTlNUQU5UX1BSRUZJWCk7IH07XG4gICAgQ29uc3RhbnRQb29sLnByb3RvdHlwZS5rZXlPZiA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uLnZpc2l0RXhwcmVzc2lvbihuZXcgS2V5VmlzaXRvcigpLCBLRVlfQ09OVEVYVCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uc3RhbnRQb29sO1xufSgpKTtcbi8qKlxuICogVmlzaXRvciB1c2VkIHRvIGRldGVybWluZSBpZiAyIGV4cHJlc3Npb25zIGFyZSBlcXVpdmFsZW50IGFuZCBjYW4gYmUgc2hhcmVkIGluIHRoZVxuICogYENvbnN0YW50UG9vbGAuXG4gKlxuICogV2hlbiB0aGUgaWQgKHN0cmluZykgZ2VuZXJhdGVkIGJ5IHRoZSB2aXNpdG9yIGlzIGVxdWFsLCBleHByZXNzaW9ucyBhcmUgY29uc2lkZXJlZCBlcXVpdmFsZW50LlxuICovXG52YXIgS2V5VmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBLZXlWaXNpdG9yKCkge1xuICAgICAgICB0aGlzLnZpc2l0V3JhcHBlZE5vZGVFeHByID0gaW52YWxpZDtcbiAgICAgICAgdGhpcy52aXNpdFdyaXRlVmFyRXhwciA9IGludmFsaWQ7XG4gICAgICAgIHRoaXMudmlzaXRXcml0ZUtleUV4cHIgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLnZpc2l0V3JpdGVQcm9wRXhwciA9IGludmFsaWQ7XG4gICAgICAgIHRoaXMudmlzaXRJbnZva2VNZXRob2RFeHByID0gaW52YWxpZDtcbiAgICAgICAgdGhpcy52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGludmFsaWQ7XG4gICAgICAgIHRoaXMudmlzaXRJbnN0YW50aWF0ZUV4cHIgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLnZpc2l0Q29uZGl0aW9uYWxFeHByID0gaW52YWxpZDtcbiAgICAgICAgdGhpcy52aXNpdE5vdEV4cHIgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLnZpc2l0QXNzZXJ0Tm90TnVsbEV4cHIgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLnZpc2l0Q2FzdEV4cHIgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLnZpc2l0RnVuY3Rpb25FeHByID0gaW52YWxpZDtcbiAgICAgICAgdGhpcy52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGludmFsaWQ7XG4gICAgICAgIHRoaXMudmlzaXRSZWFkUHJvcEV4cHIgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLnZpc2l0UmVhZEtleUV4cHIgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLnZpc2l0Q29tbWFFeHByID0gaW52YWxpZDtcbiAgICB9XG4gICAgS2V5VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwciA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyAodHlwZW9mIGFzdC52YWx1ZSA9PT0gJ3N0cmluZycgPyAnXCInICsgYXN0LnZhbHVlICsgJ1wiJyA6IGFzdC52YWx1ZSk7XG4gICAgfTtcbiAgICBLZXlWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBcIltcIiArIGFzdC5lbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY29udGV4dCk7IH0pLmpvaW4oJywnKSArIFwiXVwiO1xuICAgIH07XG4gICAgS2V5VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1hcEtleSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgdmFyIHF1b3RlID0gZW50cnkucXVvdGVkID8gJ1wiJyA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBxdW90ZSArIGVudHJ5LmtleSArIHF1b3RlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbWFwRW50cnkgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBLZXkoZW50cnkpICsgXCI6XCIgKyBlbnRyeS52YWx1ZS52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGNvbnRleHQpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBhc3QuZW50cmllcy5tYXAobWFwRW50cnkpLmpvaW4oJywnKTtcbiAgICB9O1xuICAgIEtleVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICByZXR1cm4gYXN0LnZhbHVlLm1vZHVsZU5hbWUgPyBcIkVYOlwiICsgYXN0LnZhbHVlLm1vZHVsZU5hbWUgKyBcIjpcIiArIGFzdC52YWx1ZS5uYW1lIDpcbiAgICAgICAgICAgIFwiRVg6XCIgKyBhc3QudmFsdWUucnVudGltZS5uYW1lO1xuICAgIH07XG4gICAgS2V5VmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBcIlZBUjpcIiArIG5vZGUubmFtZTsgfTtcbiAgICBLZXlWaXNpdG9yLnByb3RvdHlwZS52aXNpdFR5cGVvZkV4cHIgPSBmdW5jdGlvbiAobm9kZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gXCJUWVBFT0Y6XCIgKyBub2RlLmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEtleVZpc2l0b3I7XG59KCkpO1xuZnVuY3Rpb24gaW52YWxpZChhcmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlOiBWaXNpdG9yIFwiICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgXCIgZG9lc24ndCBoYW5kbGUgXCIgKyBhcmcuY29uc3RydWN0b3IubmFtZSk7XG59XG5mdW5jdGlvbiBpc1ZhcmlhYmxlKGUpIHtcbiAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFJlYWRWYXJFeHByO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQ09SRSA9ICdAYW5ndWxhci9jb3JlJztcbnZhciBJZGVudGlmaWVycyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJZGVudGlmaWVycygpIHtcbiAgICB9XG4gICAgSWRlbnRpZmllcnMuQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUyA9IHtcbiAgICAgICAgbmFtZTogJ0FOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMnLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFLFxuICAgIH07XG4gICAgSWRlbnRpZmllcnMuRWxlbWVudFJlZiA9IHsgbmFtZTogJ0VsZW1lbnRSZWYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMuTmdNb2R1bGVSZWYgPSB7IG5hbWU6ICdOZ01vZHVsZVJlZicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmID0geyBuYW1lOiAnVmlld0NvbnRhaW5lclJlZicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5DaGFuZ2VEZXRlY3RvclJlZiA9IHtcbiAgICAgICAgbmFtZTogJ0NoYW5nZURldGVjdG9yUmVmJyxcbiAgICAgICAgbW9kdWxlTmFtZTogQ09SRSxcbiAgICB9O1xuICAgIElkZW50aWZpZXJzLlF1ZXJ5TGlzdCA9IHsgbmFtZTogJ1F1ZXJ5TGlzdCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5UZW1wbGF0ZVJlZiA9IHsgbmFtZTogJ1RlbXBsYXRlUmVmJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLlJlbmRlcmVyMiA9IHsgbmFtZTogJ1JlbmRlcmVyMicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5Db2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0ge1xuICAgICAgICBuYW1lOiAnybVDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyJyxcbiAgICAgICAgbW9kdWxlTmFtZTogQ09SRSxcbiAgICB9O1xuICAgIElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IHtcbiAgICAgICAgbmFtZTogJ0NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcicsXG4gICAgICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5ID0geyBuYW1lOiAnQ29tcG9uZW50RmFjdG9yeScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5Db21wb25lbnRSZWYgPSB7IG5hbWU6ICdDb21wb25lbnRSZWYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMuTmdNb2R1bGVGYWN0b3J5ID0geyBuYW1lOiAnTmdNb2R1bGVGYWN0b3J5JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLmNyZWF0ZU1vZHVsZUZhY3RvcnkgPSB7XG4gICAgICAgIG5hbWU6ICfJtWNtZicsXG4gICAgICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5tb2R1bGVEZWYgPSB7XG4gICAgICAgIG5hbWU6ICfJtW1vZCcsXG4gICAgICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5tb2R1bGVQcm92aWRlckRlZiA9IHtcbiAgICAgICAgbmFtZTogJ8m1bXBkJyxcbiAgICAgICAgbW9kdWxlTmFtZTogQ09SRSxcbiAgICB9O1xuICAgIElkZW50aWZpZXJzLlJlZ2lzdGVyTW9kdWxlRmFjdG9yeUZuID0ge1xuICAgICAgICBuYW1lOiAnybVyZWdpc3Rlck1vZHVsZUZhY3RvcnknLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFLFxuICAgIH07XG4gICAgSWRlbnRpZmllcnMuaW5qZWN0ID0geyBuYW1lOiAnybXJtWluamVjdCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5JTkpFQ1RPUiA9IHsgbmFtZTogJ0lOSkVDVE9SJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLkluamVjdG9yID0geyBuYW1lOiAnSW5qZWN0b3InLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMuybXJtWRlZmluZUluamVjdGFibGUgPSB7IG5hbWU6ICfJtcm1ZGVmaW5lSW5qZWN0YWJsZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5JbmplY3RhYmxlRGVmID0geyBuYW1lOiAnybXJtUluamVjdGFibGVEZWYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMuVmlld0VuY2Fwc3VsYXRpb24gPSB7XG4gICAgICAgIG5hbWU6ICdWaWV3RW5jYXBzdWxhdGlvbicsXG4gICAgICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IHtcbiAgICAgICAgbmFtZTogJ0NoYW5nZURldGVjdGlvblN0cmF0ZWd5JyxcbiAgICAgICAgbW9kdWxlTmFtZTogQ09SRSxcbiAgICB9O1xuICAgIElkZW50aWZpZXJzLlNlY3VyaXR5Q29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogJ1NlY3VyaXR5Q29udGV4dCcsXG4gICAgICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5MT0NBTEVfSUQgPSB7IG5hbWU6ICdMT0NBTEVfSUQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMuVFJBTlNMQVRJT05TX0ZPUk1BVCA9IHtcbiAgICAgICAgbmFtZTogJ1RSQU5TTEFUSU9OU19GT1JNQVQnLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFLFxuICAgIH07XG4gICAgSWRlbnRpZmllcnMuaW5saW5lSW50ZXJwb2xhdGUgPSB7XG4gICAgICAgIG5hbWU6ICfJtWlubGluZUludGVycG9sYXRlJyxcbiAgICAgICAgbW9kdWxlTmFtZTogQ09SRSxcbiAgICB9O1xuICAgIElkZW50aWZpZXJzLmludGVycG9sYXRlID0geyBuYW1lOiAnybVpbnRlcnBvbGF0ZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5FTVBUWV9BUlJBWSA9IHsgbmFtZTogJ8m1RU1QVFlfQVJSQVknLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMuRU1QVFlfTUFQID0geyBuYW1lOiAnybVFTVBUWV9NQVAnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMuUmVuZGVyZXIgPSB7IG5hbWU6ICdSZW5kZXJlcicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy52aWV3RGVmID0geyBuYW1lOiAnybV2aWQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMuZWxlbWVudERlZiA9IHsgbmFtZTogJ8m1ZWxkJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLmFuY2hvckRlZiA9IHsgbmFtZTogJ8m1YW5kJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLnRleHREZWYgPSB7IG5hbWU6ICfJtXRlZCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5kaXJlY3RpdmVEZWYgPSB7IG5hbWU6ICfJtWRpZCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5wcm92aWRlckRlZiA9IHsgbmFtZTogJ8m1cHJkJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLnF1ZXJ5RGVmID0geyBuYW1lOiAnybVxdWQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMucHVyZUFycmF5RGVmID0geyBuYW1lOiAnybVwYWQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMucHVyZU9iamVjdERlZiA9IHsgbmFtZTogJ8m1cG9kJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLnB1cmVQaXBlRGVmID0geyBuYW1lOiAnybVwcGQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMucGlwZURlZiA9IHsgbmFtZTogJ8m1cGlkJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLm5vZGVWYWx1ZSA9IHsgbmFtZTogJ8m1bm92JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLm5nQ29udGVudERlZiA9IHsgbmFtZTogJ8m1bmNkJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLnVud3JhcFZhbHVlID0geyBuYW1lOiAnybV1bnYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMuY3JlYXRlUmVuZGVyZXJUeXBlMiA9IHsgbmFtZTogJ8m1Y3J0JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIC8vIHR5cGUgb25seVxuICAgIElkZW50aWZpZXJzLlJlbmRlcmVyVHlwZTIgPSB7XG4gICAgICAgIG5hbWU6ICdSZW5kZXJlclR5cGUyJyxcbiAgICAgICAgbW9kdWxlTmFtZTogQ09SRSxcbiAgICB9O1xuICAgIC8vIHR5cGUgb25seVxuICAgIElkZW50aWZpZXJzLlZpZXdEZWZpbml0aW9uID0ge1xuICAgICAgICBuYW1lOiAnybVWaWV3RGVmaW5pdGlvbicsXG4gICAgICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5jcmVhdGVDb21wb25lbnRGYWN0b3J5ID0geyBuYW1lOiAnybVjY2YnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMuc2V0Q2xhc3NNZXRhZGF0YSA9IHsgbmFtZTogJ8m1c2V0Q2xhc3NNZXRhZGF0YScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICByZXR1cm4gSWRlbnRpZmllcnM7XG59KCkpO1xuZnVuY3Rpb24gY3JlYXRlVG9rZW5Gb3JSZWZlcmVuY2UocmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIHsgaWRlbnRpZmllcjogeyByZWZlcmVuY2U6IHJlZmVyZW5jZSB9IH07XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbkZvckV4dGVybmFsUmVmZXJlbmNlKHJlZmxlY3RvciwgcmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRva2VuRm9yUmVmZXJlbmNlKHJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UocmVmZXJlbmNlKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSB0b2tlbiByZXByZXNlbnRpbmcgdGhlIGEgcmVmZXJlbmNlIHRvIGEgc3RhdGljIHR5cGUuXG4gKlxuICogVGhpcyB0b2tlbiBpcyB1bmlxdWUgZm9yIGEgZmlsZVBhdGggYW5kIG5hbWUgYW5kIGNhbiBiZSB1c2VkIGFzIGEgaGFzaCB0YWJsZSBrZXkuXG4gKi9cbnZhciBTdGF0aWNTeW1ib2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljU3ltYm9sKGZpbGVQYXRoLCBuYW1lLCBtZW1iZXJzKSB7XG4gICAgICAgIHRoaXMuZmlsZVBhdGggPSBmaWxlUGF0aDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgICB9XG4gICAgU3RhdGljU3ltYm9sLnByb3RvdHlwZS5hc3NlcnROb01lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1lbWJlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBzeW1ib2wgd2l0aG91dCBtZW1iZXJzIGV4cGVjdGVkLCBidXQgZ290IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcykgKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNTeW1ib2w7XG59KCkpO1xuLyoqXG4gKiBBIGNhY2hlIG9mIHN0YXRpYyBzeW1ib2wgdXNlZCBieSB0aGUgU3RhdGljUmVmbGVjdG9yIHRvIHJldHVybiB0aGUgc2FtZSBzeW1ib2wgZm9yIHRoZVxuICogc2FtZSBzeW1ib2wgdmFsdWVzLlxuICovXG52YXIgU3RhdGljU3ltYm9sQ2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljU3ltYm9sQ2FjaGUoKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIFN0YXRpY1N5bWJvbENhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoZGVjbGFyYXRpb25GaWxlLCBuYW1lLCBtZW1iZXJzKSB7XG4gICAgICAgIG1lbWJlcnMgPSBtZW1iZXJzIHx8IFtdO1xuICAgICAgICB2YXIgbWVtYmVyU3VmZml4ID0gbWVtYmVycy5sZW5ndGggPyBcIi5cIiArIG1lbWJlcnMuam9pbignLicpIDogJyc7XG4gICAgICAgIHZhciBrZXkgPSBcIlxcXCJcIiArIGRlY2xhcmF0aW9uRmlsZSArIFwiXFxcIi5cIiArIG5hbWUgKyBtZW1iZXJTdWZmaXg7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNhY2hlLmdldChrZXkpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFN0YXRpY1N5bWJvbChkZWNsYXJhdGlvbkZpbGUsIG5hbWUsIG1lbWJlcnMpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljU3ltYm9sQ2FjaGU7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyBncm91cCAwOiBcIltwcm9wXSBvciAoZXZlbnQpIG9yIEB0cmlnZ2VyXCJcbi8vIGdyb3VwIDE6IFwicHJvcFwiIGZyb20gXCJbcHJvcF1cIlxuLy8gZ3JvdXAgMjogXCJldmVudFwiIGZyb20gXCIoZXZlbnQpXCJcbi8vIGdyb3VwIDM6IFwiQHRyaWdnZXJcIiBmcm9tIFwiQHRyaWdnZXJcIlxudmFyIEhPU1RfUkVHX0VYUCA9IC9eKD86KD86XFxbKFteXFxdXSspXFxdKXwoPzpcXCgoW15cXCldKylcXCkpKXwoXFxAWy1cXHddKykkLztcbmZ1bmN0aW9uIHNhbml0aXplSWRlbnRpZmllcihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXFxXL2csICdfJyk7XG59XG52YXIgX2Fub255bW91c1R5cGVJbmRleCA9IDA7XG5mdW5jdGlvbiBpZGVudGlmaWVyTmFtZShjb21waWxlSWRlbnRpZmllcikge1xuICAgIGlmICghY29tcGlsZUlkZW50aWZpZXIgfHwgIWNvbXBpbGVJZGVudGlmaWVyLnJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJlZiA9IGNvbXBpbGVJZGVudGlmaWVyLnJlZmVyZW5jZTtcbiAgICBpZiAocmVmIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgIHJldHVybiByZWYubmFtZTtcbiAgICB9XG4gICAgaWYgKHJlZlsnX19hbm9ueW1vdXNUeXBlJ10pIHtcbiAgICAgICAgcmV0dXJuIHJlZlsnX19hbm9ueW1vdXNUeXBlJ107XG4gICAgfVxuICAgIHZhciBpZGVudGlmaWVyID0gc3RyaW5naWZ5KHJlZik7XG4gICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignKCcpID49IDApIHtcbiAgICAgICAgLy8gY2FzZTogYW5vbnltb3VzIGZ1bmN0aW9ucyFcbiAgICAgICAgaWRlbnRpZmllciA9IFwiYW5vbnltb3VzX1wiICsgX2Fub255bW91c1R5cGVJbmRleCsrO1xuICAgICAgICByZWZbJ19fYW5vbnltb3VzVHlwZSddID0gaWRlbnRpZmllcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlkZW50aWZpZXIgPSBzYW5pdGl6ZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIHJldHVybiBpZGVudGlmaWVyO1xufVxuZnVuY3Rpb24gaWRlbnRpZmllck1vZHVsZVVybChjb21waWxlSWRlbnRpZmllcikge1xuICAgIHZhciByZWYgPSBjb21waWxlSWRlbnRpZmllci5yZWZlcmVuY2U7XG4gICAgaWYgKHJlZiBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICByZXR1cm4gcmVmLmZpbGVQYXRoO1xuICAgIH1cbiAgICAvLyBSdW50aW1lIHR5cGVcbiAgICByZXR1cm4gXCIuL1wiICsgc3RyaW5naWZ5KHJlZik7XG59XG5mdW5jdGlvbiB2aWV3Q2xhc3NOYW1lKGNvbXBUeXBlLCBlbWJlZGRlZFRlbXBsYXRlSW5kZXgpIHtcbiAgICByZXR1cm4gXCJWaWV3X1wiICsgaWRlbnRpZmllck5hbWUoeyByZWZlcmVuY2U6IGNvbXBUeXBlIH0pICsgXCJfXCIgKyBlbWJlZGRlZFRlbXBsYXRlSW5kZXg7XG59XG5mdW5jdGlvbiByZW5kZXJlclR5cGVOYW1lKGNvbXBUeXBlKSB7XG4gICAgcmV0dXJuIFwiUmVuZGVyVHlwZV9cIiArIGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiBjb21wVHlwZSB9KTtcbn1cbmZ1bmN0aW9uIGhvc3RWaWV3Q2xhc3NOYW1lKGNvbXBUeXBlKSB7XG4gICAgcmV0dXJuIFwiSG9zdFZpZXdfXCIgKyBpZGVudGlmaWVyTmFtZSh7IHJlZmVyZW5jZTogY29tcFR5cGUgfSk7XG59XG5mdW5jdGlvbiBjb21wb25lbnRGYWN0b3J5TmFtZShjb21wVHlwZSkge1xuICAgIHJldHVybiBpZGVudGlmaWVyTmFtZSh7IHJlZmVyZW5jZTogY29tcFR5cGUgfSkgKyBcIk5nRmFjdG9yeVwiO1xufVxudmFyIENvbXBpbGVTdW1tYXJ5S2luZDtcbihmdW5jdGlvbiAoQ29tcGlsZVN1bW1hcnlLaW5kKSB7XG4gICAgQ29tcGlsZVN1bW1hcnlLaW5kW0NvbXBpbGVTdW1tYXJ5S2luZFtcIlBpcGVcIl0gPSAwXSA9IFwiUGlwZVwiO1xuICAgIENvbXBpbGVTdW1tYXJ5S2luZFtDb21waWxlU3VtbWFyeUtpbmRbXCJEaXJlY3RpdmVcIl0gPSAxXSA9IFwiRGlyZWN0aXZlXCI7XG4gICAgQ29tcGlsZVN1bW1hcnlLaW5kW0NvbXBpbGVTdW1tYXJ5S2luZFtcIk5nTW9kdWxlXCJdID0gMl0gPSBcIk5nTW9kdWxlXCI7XG4gICAgQ29tcGlsZVN1bW1hcnlLaW5kW0NvbXBpbGVTdW1tYXJ5S2luZFtcIkluamVjdGFibGVcIl0gPSAzXSA9IFwiSW5qZWN0YWJsZVwiO1xufSkoQ29tcGlsZVN1bW1hcnlLaW5kIHx8IChDb21waWxlU3VtbWFyeUtpbmQgPSB7fSkpO1xuZnVuY3Rpb24gdG9rZW5OYW1lKHRva2VuKSB7XG4gICAgcmV0dXJuIHRva2VuLnZhbHVlICE9IG51bGwgPyBzYW5pdGl6ZUlkZW50aWZpZXIodG9rZW4udmFsdWUpIDogaWRlbnRpZmllck5hbWUodG9rZW4uaWRlbnRpZmllcik7XG59XG5mdW5jdGlvbiB0b2tlblJlZmVyZW5jZSh0b2tlbikge1xuICAgIGlmICh0b2tlbi5pZGVudGlmaWVyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLmlkZW50aWZpZXIucmVmZXJlbmNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLnZhbHVlO1xuICAgIH1cbn1cbi8qKlxuICogTWV0YWRhdGEgYWJvdXQgYSBzdHlsZXNoZWV0XG4gKi9cbnZhciBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG1vZHVsZVVybCA9IF9iLm1vZHVsZVVybCwgc3R5bGVzID0gX2Iuc3R5bGVzLCBzdHlsZVVybHMgPSBfYi5zdHlsZVVybHM7XG4gICAgICAgIHRoaXMubW9kdWxlVXJsID0gbW9kdWxlVXJsIHx8IG51bGw7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlcyk7XG4gICAgICAgIHRoaXMuc3R5bGVVcmxzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlVXJscyk7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhO1xufSgpKTtcbi8qKlxuICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgdGVtcGxhdGUuXG4gKi9cbnZhciBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlVGVtcGxhdGVNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgZW5jYXBzdWxhdGlvbiA9IF9hLmVuY2Fwc3VsYXRpb24sIHRlbXBsYXRlID0gX2EudGVtcGxhdGUsIHRlbXBsYXRlVXJsID0gX2EudGVtcGxhdGVVcmwsIGh0bWxBc3QgPSBfYS5odG1sQXN0LCBzdHlsZXMgPSBfYS5zdHlsZXMsIHN0eWxlVXJscyA9IF9hLnN0eWxlVXJscywgZXh0ZXJuYWxTdHlsZXNoZWV0cyA9IF9hLmV4dGVybmFsU3R5bGVzaGVldHMsIGFuaW1hdGlvbnMgPSBfYS5hbmltYXRpb25zLCBuZ0NvbnRlbnRTZWxlY3RvcnMgPSBfYS5uZ0NvbnRlbnRTZWxlY3RvcnMsIGludGVycG9sYXRpb24gPSBfYS5pbnRlcnBvbGF0aW9uLCBpc0lubGluZSA9IF9hLmlzSW5saW5lLCBwcmVzZXJ2ZVdoaXRlc3BhY2VzID0gX2EucHJlc2VydmVXaGl0ZXNwYWNlcztcbiAgICAgICAgdGhpcy5lbmNhcHN1bGF0aW9uID0gZW5jYXBzdWxhdGlvbjtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLnRlbXBsYXRlVXJsID0gdGVtcGxhdGVVcmw7XG4gICAgICAgIHRoaXMuaHRtbEFzdCA9IGh0bWxBc3Q7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlcyk7XG4gICAgICAgIHRoaXMuc3R5bGVVcmxzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlVXJscyk7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxTdHlsZXNoZWV0cyA9IF9ub3JtYWxpemVBcnJheShleHRlcm5hbFN0eWxlc2hlZXRzKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gYW5pbWF0aW9ucyA/IGZsYXR0ZW4oYW5pbWF0aW9ucykgOiBbXTtcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRTZWxlY3RvcnMgPSBuZ0NvbnRlbnRTZWxlY3RvcnMgfHwgW107XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uICYmIGludGVycG9sYXRpb24ubGVuZ3RoICE9IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidpbnRlcnBvbGF0aW9uJyBzaG91bGQgaGF2ZSBhIHN0YXJ0IGFuZCBhbiBlbmQgc3ltYm9sLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uO1xuICAgICAgICB0aGlzLmlzSW5saW5lID0gaXNJbmxpbmU7XG4gICAgICAgIHRoaXMucHJlc2VydmVXaGl0ZXNwYWNlcyA9IHByZXNlcnZlV2hpdGVzcGFjZXM7XG4gICAgfVxuICAgIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhLnByb3RvdHlwZS50b1N1bW1hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IHRoaXMubmdDb250ZW50U2VsZWN0b3JzLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogdGhpcy5lbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgc3R5bGVzOiB0aGlzLnN0eWxlcyxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHRoaXMuYW5pbWF0aW9uc1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhO1xufSgpKTtcbi8qKlxuICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgZGlyZWN0aXZlLlxuICovXG52YXIgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgaXNIb3N0ID0gX2EuaXNIb3N0LCB0eXBlID0gX2EudHlwZSwgaXNDb21wb25lbnQgPSBfYS5pc0NvbXBvbmVudCwgc2VsZWN0b3IgPSBfYS5zZWxlY3RvciwgZXhwb3J0QXMgPSBfYS5leHBvcnRBcywgY2hhbmdlRGV0ZWN0aW9uID0gX2EuY2hhbmdlRGV0ZWN0aW9uLCBpbnB1dHMgPSBfYS5pbnB1dHMsIG91dHB1dHMgPSBfYS5vdXRwdXRzLCBob3N0TGlzdGVuZXJzID0gX2EuaG9zdExpc3RlbmVycywgaG9zdFByb3BlcnRpZXMgPSBfYS5ob3N0UHJvcGVydGllcywgaG9zdEF0dHJpYnV0ZXMgPSBfYS5ob3N0QXR0cmlidXRlcywgcHJvdmlkZXJzID0gX2EucHJvdmlkZXJzLCB2aWV3UHJvdmlkZXJzID0gX2Eudmlld1Byb3ZpZGVycywgcXVlcmllcyA9IF9hLnF1ZXJpZXMsIGd1YXJkcyA9IF9hLmd1YXJkcywgdmlld1F1ZXJpZXMgPSBfYS52aWV3UXVlcmllcywgZW50cnlDb21wb25lbnRzID0gX2EuZW50cnlDb21wb25lbnRzLCB0ZW1wbGF0ZSA9IF9hLnRlbXBsYXRlLCBjb21wb25lbnRWaWV3VHlwZSA9IF9hLmNvbXBvbmVudFZpZXdUeXBlLCByZW5kZXJlclR5cGUgPSBfYS5yZW5kZXJlclR5cGUsIGNvbXBvbmVudEZhY3RvcnkgPSBfYS5jb21wb25lbnRGYWN0b3J5O1xuICAgICAgICB0aGlzLmlzSG9zdCA9ICEhaXNIb3N0O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmlzQ29tcG9uZW50ID0gaXNDb21wb25lbnQ7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5leHBvcnRBcyA9IGV4cG9ydEFzO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdGlvbiA9IGNoYW5nZURldGVjdGlvbjtcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgIHRoaXMub3V0cHV0cyA9IG91dHB1dHM7XG4gICAgICAgIHRoaXMuaG9zdExpc3RlbmVycyA9IGhvc3RMaXN0ZW5lcnM7XG4gICAgICAgIHRoaXMuaG9zdFByb3BlcnRpZXMgPSBob3N0UHJvcGVydGllcztcbiAgICAgICAgdGhpcy5ob3N0QXR0cmlidXRlcyA9IGhvc3RBdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IF9ub3JtYWxpemVBcnJheShwcm92aWRlcnMpO1xuICAgICAgICB0aGlzLnZpZXdQcm92aWRlcnMgPSBfbm9ybWFsaXplQXJyYXkodmlld1Byb3ZpZGVycyk7XG4gICAgICAgIHRoaXMucXVlcmllcyA9IF9ub3JtYWxpemVBcnJheShxdWVyaWVzKTtcbiAgICAgICAgdGhpcy5ndWFyZHMgPSBndWFyZHM7XG4gICAgICAgIHRoaXMudmlld1F1ZXJpZXMgPSBfbm9ybWFsaXplQXJyYXkodmlld1F1ZXJpZXMpO1xuICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50cyA9IF9ub3JtYWxpemVBcnJheShlbnRyeUNvbXBvbmVudHMpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuY29tcG9uZW50Vmlld1R5cGUgPSBjb21wb25lbnRWaWV3VHlwZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlclR5cGUgPSByZW5kZXJlclR5cGU7XG4gICAgICAgIHRoaXMuY29tcG9uZW50RmFjdG9yeSA9IGNvbXBvbmVudEZhY3Rvcnk7XG4gICAgfVxuICAgIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YS5jcmVhdGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGlzSG9zdCA9IF9hLmlzSG9zdCwgdHlwZSA9IF9hLnR5cGUsIGlzQ29tcG9uZW50ID0gX2EuaXNDb21wb25lbnQsIHNlbGVjdG9yID0gX2Euc2VsZWN0b3IsIGV4cG9ydEFzID0gX2EuZXhwb3J0QXMsIGNoYW5nZURldGVjdGlvbiA9IF9hLmNoYW5nZURldGVjdGlvbiwgaW5wdXRzID0gX2EuaW5wdXRzLCBvdXRwdXRzID0gX2Eub3V0cHV0cywgaG9zdCA9IF9hLmhvc3QsIHByb3ZpZGVycyA9IF9hLnByb3ZpZGVycywgdmlld1Byb3ZpZGVycyA9IF9hLnZpZXdQcm92aWRlcnMsIHF1ZXJpZXMgPSBfYS5xdWVyaWVzLCBndWFyZHMgPSBfYS5ndWFyZHMsIHZpZXdRdWVyaWVzID0gX2Eudmlld1F1ZXJpZXMsIGVudHJ5Q29tcG9uZW50cyA9IF9hLmVudHJ5Q29tcG9uZW50cywgdGVtcGxhdGUgPSBfYS50ZW1wbGF0ZSwgY29tcG9uZW50Vmlld1R5cGUgPSBfYS5jb21wb25lbnRWaWV3VHlwZSwgcmVuZGVyZXJUeXBlID0gX2EucmVuZGVyZXJUeXBlLCBjb21wb25lbnRGYWN0b3J5ID0gX2EuY29tcG9uZW50RmFjdG9yeTtcbiAgICAgICAgdmFyIGhvc3RMaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgdmFyIGhvc3RQcm9wZXJ0aWVzID0ge307XG4gICAgICAgIHZhciBob3N0QXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBpZiAoaG9zdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhob3N0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBob3N0W2tleV07XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBrZXkubWF0Y2goSE9TVF9SRUdfRVhQKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBob3N0QXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoZXNbMV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBob3N0UHJvcGVydGllc1ttYXRjaGVzWzFdXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGVzWzJdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdExpc3RlbmVyc1ttYXRjaGVzWzJdXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dHNNYXAgPSB7fTtcbiAgICAgICAgaWYgKGlucHV0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoYmluZENvbmZpZykge1xuICAgICAgICAgICAgICAgIC8vIGNhbm9uaWNhbCBzeW50YXg6IGBkaXJQcm9wOiBlbFByb3BgXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYDpgLCB1c2UgZGlyUHJvcCA9IGVsUHJvcFxuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHNwbGl0QXRDb2xvbihiaW5kQ29uZmlnLCBbYmluZENvbmZpZywgYmluZENvbmZpZ10pO1xuICAgICAgICAgICAgICAgIGlucHV0c01hcFtwYXJ0c1swXV0gPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRzTWFwID0ge307XG4gICAgICAgIGlmIChvdXRwdXRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIG91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAoYmluZENvbmZpZykge1xuICAgICAgICAgICAgICAgIC8vIGNhbm9uaWNhbCBzeW50YXg6IGBkaXJQcm9wOiBlbFByb3BgXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYDpgLCB1c2UgZGlyUHJvcCA9IGVsUHJvcFxuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHNwbGl0QXRDb2xvbihiaW5kQ29uZmlnLCBbYmluZENvbmZpZywgYmluZENvbmZpZ10pO1xuICAgICAgICAgICAgICAgIG91dHB1dHNNYXBbcGFydHNbMF1dID0gcGFydHNbMV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSh7XG4gICAgICAgICAgICBpc0hvc3Q6IGlzSG9zdCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBpc0NvbXBvbmVudDogISFpc0NvbXBvbmVudCwgc2VsZWN0b3I6IHNlbGVjdG9yLCBleHBvcnRBczogZXhwb3J0QXMsIGNoYW5nZURldGVjdGlvbjogY2hhbmdlRGV0ZWN0aW9uLFxuICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHNNYXAsXG4gICAgICAgICAgICBvdXRwdXRzOiBvdXRwdXRzTWFwLFxuICAgICAgICAgICAgaG9zdExpc3RlbmVyczogaG9zdExpc3RlbmVycyxcbiAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzOiBob3N0UHJvcGVydGllcyxcbiAgICAgICAgICAgIGhvc3RBdHRyaWJ1dGVzOiBob3N0QXR0cmlidXRlcyxcbiAgICAgICAgICAgIHByb3ZpZGVyczogcHJvdmlkZXJzLFxuICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogdmlld1Byb3ZpZGVycyxcbiAgICAgICAgICAgIHF1ZXJpZXM6IHF1ZXJpZXMsXG4gICAgICAgICAgICBndWFyZHM6IGd1YXJkcyxcbiAgICAgICAgICAgIHZpZXdRdWVyaWVzOiB2aWV3UXVlcmllcyxcbiAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogZW50cnlDb21wb25lbnRzLFxuICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgICAgICAgY29tcG9uZW50Vmlld1R5cGU6IGNvbXBvbmVudFZpZXdUeXBlLFxuICAgICAgICAgICAgcmVuZGVyZXJUeXBlOiByZW5kZXJlclR5cGUsXG4gICAgICAgICAgICBjb21wb25lbnRGYWN0b3J5OiBjb21wb25lbnRGYWN0b3J5LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YS5wcm90b3R5cGUudG9TdW1tYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VtbWFyeUtpbmQ6IENvbXBpbGVTdW1tYXJ5S2luZC5EaXJlY3RpdmUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBpc0NvbXBvbmVudDogdGhpcy5pc0NvbXBvbmVudCxcbiAgICAgICAgICAgIHNlbGVjdG9yOiB0aGlzLnNlbGVjdG9yLFxuICAgICAgICAgICAgZXhwb3J0QXM6IHRoaXMuZXhwb3J0QXMsXG4gICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLFxuICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLFxuICAgICAgICAgICAgaG9zdExpc3RlbmVyczogdGhpcy5ob3N0TGlzdGVuZXJzLFxuICAgICAgICAgICAgaG9zdFByb3BlcnRpZXM6IHRoaXMuaG9zdFByb3BlcnRpZXMsXG4gICAgICAgICAgICBob3N0QXR0cmlidXRlczogdGhpcy5ob3N0QXR0cmlidXRlcyxcbiAgICAgICAgICAgIHByb3ZpZGVyczogdGhpcy5wcm92aWRlcnMsXG4gICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiB0aGlzLnZpZXdQcm92aWRlcnMsXG4gICAgICAgICAgICBxdWVyaWVzOiB0aGlzLnF1ZXJpZXMsXG4gICAgICAgICAgICBndWFyZHM6IHRoaXMuZ3VhcmRzLFxuICAgICAgICAgICAgdmlld1F1ZXJpZXM6IHRoaXMudmlld1F1ZXJpZXMsXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IHRoaXMuZW50cnlDb21wb25lbnRzLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiB0aGlzLmNoYW5nZURldGVjdGlvbixcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlICYmIHRoaXMudGVtcGxhdGUudG9TdW1tYXJ5KCksXG4gICAgICAgICAgICBjb21wb25lbnRWaWV3VHlwZTogdGhpcy5jb21wb25lbnRWaWV3VHlwZSxcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZTogdGhpcy5yZW5kZXJlclR5cGUsXG4gICAgICAgICAgICBjb21wb25lbnRGYWN0b3J5OiB0aGlzLmNvbXBvbmVudEZhY3RvcnlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGE7XG59KCkpO1xudmFyIENvbXBpbGVQaXBlTWV0YWRhdGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGlsZVBpcGVNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGUsIG5hbWUgPSBfYS5uYW1lLCBwdXJlID0gX2EucHVyZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wdXJlID0gISFwdXJlO1xuICAgIH1cbiAgICBDb21waWxlUGlwZU1ldGFkYXRhLnByb3RvdHlwZS50b1N1bW1hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdW1tYXJ5S2luZDogQ29tcGlsZVN1bW1hcnlLaW5kLlBpcGUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBwdXJlOiB0aGlzLnB1cmVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb21waWxlUGlwZU1ldGFkYXRhO1xufSgpKTtcbnZhciBDb21waWxlU2hhbGxvd01vZHVsZU1ldGFkYXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVTaGFsbG93TW9kdWxlTWV0YWRhdGEoKSB7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlU2hhbGxvd01vZHVsZU1ldGFkYXRhO1xufSgpKTtcbi8qKlxuICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgbW9kdWxlLlxuICovXG52YXIgQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlLCBwcm92aWRlcnMgPSBfYS5wcm92aWRlcnMsIGRlY2xhcmVkRGlyZWN0aXZlcyA9IF9hLmRlY2xhcmVkRGlyZWN0aXZlcywgZXhwb3J0ZWREaXJlY3RpdmVzID0gX2EuZXhwb3J0ZWREaXJlY3RpdmVzLCBkZWNsYXJlZFBpcGVzID0gX2EuZGVjbGFyZWRQaXBlcywgZXhwb3J0ZWRQaXBlcyA9IF9hLmV4cG9ydGVkUGlwZXMsIGVudHJ5Q29tcG9uZW50cyA9IF9hLmVudHJ5Q29tcG9uZW50cywgYm9vdHN0cmFwQ29tcG9uZW50cyA9IF9hLmJvb3RzdHJhcENvbXBvbmVudHMsIGltcG9ydGVkTW9kdWxlcyA9IF9hLmltcG9ydGVkTW9kdWxlcywgZXhwb3J0ZWRNb2R1bGVzID0gX2EuZXhwb3J0ZWRNb2R1bGVzLCBzY2hlbWFzID0gX2Euc2NoZW1hcywgdHJhbnNpdGl2ZU1vZHVsZSA9IF9hLnRyYW5zaXRpdmVNb2R1bGUsIGlkID0gX2EuaWQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5kZWNsYXJlZERpcmVjdGl2ZXMgPSBfbm9ybWFsaXplQXJyYXkoZGVjbGFyZWREaXJlY3RpdmVzKTtcbiAgICAgICAgdGhpcy5leHBvcnRlZERpcmVjdGl2ZXMgPSBfbm9ybWFsaXplQXJyYXkoZXhwb3J0ZWREaXJlY3RpdmVzKTtcbiAgICAgICAgdGhpcy5kZWNsYXJlZFBpcGVzID0gX25vcm1hbGl6ZUFycmF5KGRlY2xhcmVkUGlwZXMpO1xuICAgICAgICB0aGlzLmV4cG9ydGVkUGlwZXMgPSBfbm9ybWFsaXplQXJyYXkoZXhwb3J0ZWRQaXBlcyk7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gX25vcm1hbGl6ZUFycmF5KHByb3ZpZGVycyk7XG4gICAgICAgIHRoaXMuZW50cnlDb21wb25lbnRzID0gX25vcm1hbGl6ZUFycmF5KGVudHJ5Q29tcG9uZW50cyk7XG4gICAgICAgIHRoaXMuYm9vdHN0cmFwQ29tcG9uZW50cyA9IF9ub3JtYWxpemVBcnJheShib290c3RyYXBDb21wb25lbnRzKTtcbiAgICAgICAgdGhpcy5pbXBvcnRlZE1vZHVsZXMgPSBfbm9ybWFsaXplQXJyYXkoaW1wb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgdGhpcy5leHBvcnRlZE1vZHVsZXMgPSBfbm9ybWFsaXplQXJyYXkoZXhwb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0gX25vcm1hbGl6ZUFycmF5KHNjaGVtYXMpO1xuICAgICAgICB0aGlzLmlkID0gaWQgfHwgbnVsbDtcbiAgICAgICAgdGhpcy50cmFuc2l0aXZlTW9kdWxlID0gdHJhbnNpdGl2ZU1vZHVsZSB8fCBudWxsO1xuICAgIH1cbiAgICBDb21waWxlTmdNb2R1bGVNZXRhZGF0YS5wcm90b3R5cGUudG9TdW1tYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbW9kdWxlID0gdGhpcy50cmFuc2l0aXZlTW9kdWxlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VtbWFyeUtpbmQ6IENvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogbW9kdWxlLmVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgIHByb3ZpZGVyczogbW9kdWxlLnByb3ZpZGVycyxcbiAgICAgICAgICAgIG1vZHVsZXM6IG1vZHVsZS5tb2R1bGVzLFxuICAgICAgICAgICAgZXhwb3J0ZWREaXJlY3RpdmVzOiBtb2R1bGUuZXhwb3J0ZWREaXJlY3RpdmVzLFxuICAgICAgICAgICAgZXhwb3J0ZWRQaXBlczogbW9kdWxlLmV4cG9ydGVkUGlwZXNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb21waWxlTmdNb2R1bGVNZXRhZGF0YTtcbn0oKSk7XG52YXIgVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YSgpIHtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5leHBvcnRlZERpcmVjdGl2ZXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZXhwb3J0ZWREaXJlY3RpdmVzID0gW107XG4gICAgICAgIHRoaXMucGlwZXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMucGlwZXMgPSBbXTtcbiAgICAgICAgdGhpcy5leHBvcnRlZFBpcGVzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmV4cG9ydGVkUGlwZXMgPSBbXTtcbiAgICAgICAgdGhpcy5tb2R1bGVzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLm1vZHVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5lbnRyeUNvbXBvbmVudHNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZW50cnlDb21wb25lbnRzID0gW107XG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gW107XG4gICAgfVxuICAgIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YS5wcm90b3R5cGUuYWRkUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIsIG1vZHVsZSkge1xuICAgICAgICB0aGlzLnByb3ZpZGVycy5wdXNoKHsgcHJvdmlkZXI6IHByb3ZpZGVyLCBtb2R1bGU6IG1vZHVsZSB9KTtcbiAgICB9O1xuICAgIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YS5wcm90b3R5cGUuYWRkRGlyZWN0aXZlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXJlY3RpdmVzU2V0LmhhcyhpZC5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXNTZXQuYWRkKGlkLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YS5wcm90b3R5cGUuYWRkRXhwb3J0ZWREaXJlY3RpdmUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmV4cG9ydGVkRGlyZWN0aXZlc1NldC5oYXMoaWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5leHBvcnRlZERpcmVjdGl2ZXNTZXQuYWRkKGlkLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICB0aGlzLmV4cG9ydGVkRGlyZWN0aXZlcy5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhLnByb3RvdHlwZS5hZGRQaXBlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5waXBlc1NldC5oYXMoaWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5waXBlc1NldC5hZGQoaWQucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHRoaXMucGlwZXMucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YS5wcm90b3R5cGUuYWRkRXhwb3J0ZWRQaXBlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5leHBvcnRlZFBpcGVzU2V0LmhhcyhpZC5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICB0aGlzLmV4cG9ydGVkUGlwZXNTZXQuYWRkKGlkLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICB0aGlzLmV4cG9ydGVkUGlwZXMucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YS5wcm90b3R5cGUuYWRkTW9kdWxlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2R1bGVzU2V0LmhhcyhpZC5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICB0aGlzLm1vZHVsZXNTZXQuYWRkKGlkLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICB0aGlzLm1vZHVsZXMucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YS5wcm90b3R5cGUuYWRkRW50cnlDb21wb25lbnQgPSBmdW5jdGlvbiAoZWMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVudHJ5Q29tcG9uZW50c1NldC5oYXMoZWMuY29tcG9uZW50VHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW50cnlDb21wb25lbnRzU2V0LmFkZChlYy5jb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgIHRoaXMuZW50cnlDb21wb25lbnRzLnB1c2goZWMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhO1xufSgpKTtcbmZ1bmN0aW9uIF9ub3JtYWxpemVBcnJheShvYmopIHtcbiAgICByZXR1cm4gb2JqIHx8IFtdO1xufVxudmFyIFByb3ZpZGVyTWV0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm92aWRlck1ldGEodG9rZW4sIF9hKSB7XG4gICAgICAgIHZhciB1c2VDbGFzcyA9IF9hLnVzZUNsYXNzLCB1c2VWYWx1ZSA9IF9hLnVzZVZhbHVlLCB1c2VFeGlzdGluZyA9IF9hLnVzZUV4aXN0aW5nLCB1c2VGYWN0b3J5ID0gX2EudXNlRmFjdG9yeSwgZGVwcyA9IF9hLmRlcHMsIG11bHRpID0gX2EubXVsdGk7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy51c2VDbGFzcyA9IHVzZUNsYXNzIHx8IG51bGw7XG4gICAgICAgIHRoaXMudXNlVmFsdWUgPSB1c2VWYWx1ZTtcbiAgICAgICAgdGhpcy51c2VFeGlzdGluZyA9IHVzZUV4aXN0aW5nO1xuICAgICAgICB0aGlzLnVzZUZhY3RvcnkgPSB1c2VGYWN0b3J5IHx8IG51bGw7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwcyB8fCBudWxsO1xuICAgICAgICB0aGlzLm11bHRpID0gISFtdWx0aTtcbiAgICB9XG4gICAgcmV0dXJuIFByb3ZpZGVyTWV0YTtcbn0oKSk7XG5mdW5jdGlvbiBmbGF0dGVuKGxpc3QpIHtcbiAgICByZXR1cm4gbGlzdC5yZWR1Y2UoZnVuY3Rpb24gKGZsYXQsIGl0ZW0pIHtcbiAgICAgICAgdmFyIGZsYXRJdGVtID0gQXJyYXkuaXNBcnJheShpdGVtKSA/IGZsYXR0ZW4oaXRlbSkgOiBpdGVtO1xuICAgICAgICByZXR1cm4gZmxhdC5jb25jYXQoZmxhdEl0ZW0pO1xuICAgIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIGppdFNvdXJjZVVybCh1cmwpIHtcbiAgICAvLyBOb3RlOiBXZSBuZWVkIDMgXCIvXCIgc28gdGhhdCBuZyBzaG93cyB1cCBhcyBhIHNlcGFyYXRlIGRvbWFpblxuICAgIC8vIGluIHRoZSBjaHJvbWUgZGV2IHRvb2xzLlxuICAgIHJldHVybiB1cmwucmVwbGFjZSgvKFxcdys6XFwvXFwvW1xcdzotXSspPyhcXC8rKT8vLCAnbmc6Ly8vJyk7XG59XG5mdW5jdGlvbiB0ZW1wbGF0ZVNvdXJjZVVybChuZ01vZHVsZVR5cGUsIGNvbXBNZXRhLCB0ZW1wbGF0ZU1ldGEpIHtcbiAgICB2YXIgdXJsO1xuICAgIGlmICh0ZW1wbGF0ZU1ldGEuaXNJbmxpbmUpIHtcbiAgICAgICAgaWYgKGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBhIC50cyBmaWxlIG1pZ2h0IGNvbnRhaW4gbXVsdGlwbGUgY29tcG9uZW50cyB3aXRoIGlubGluZSB0ZW1wbGF0ZXMsXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGdpdmUgdGhlbSB1bmlxdWUgdXJscywgYXMgdGhlc2Ugd2lsbCBiZSB1c2VkIGZvciBzb3VyY2VtYXBzLlxuICAgICAgICAgICAgdXJsID0gY29tcE1ldGEudHlwZS5yZWZlcmVuY2UuZmlsZVBhdGggKyBcIi5cIiArIGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlLm5hbWUgKyBcIi5odG1sXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cmwgPSBpZGVudGlmaWVyTmFtZShuZ01vZHVsZVR5cGUpICsgXCIvXCIgKyBpZGVudGlmaWVyTmFtZShjb21wTWV0YS50eXBlKSArIFwiLmh0bWxcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXJsID0gdGVtcGxhdGVNZXRhLnRlbXBsYXRlVXJsO1xuICAgIH1cbiAgICByZXR1cm4gY29tcE1ldGEudHlwZS5yZWZlcmVuY2UgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wgPyB1cmwgOiBqaXRTb3VyY2VVcmwodXJsKTtcbn1cbmZ1bmN0aW9uIHNoYXJlZFN0eWxlc2hlZXRKaXRVcmwobWV0YSwgaWQpIHtcbiAgICB2YXIgcGF0aFBhcnRzID0gbWV0YS5tb2R1bGVVcmwuc3BsaXQoL1xcL1xcXFwvZyk7XG4gICAgdmFyIGJhc2VOYW1lID0gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gaml0U291cmNlVXJsKFwiY3NzL1wiICsgaWQgKyBiYXNlTmFtZSArIFwiLm5nc3R5bGUuanNcIik7XG59XG5mdW5jdGlvbiBuZ01vZHVsZUppdFVybChtb2R1bGVNZXRhKSB7XG4gICAgcmV0dXJuIGppdFNvdXJjZVVybChpZGVudGlmaWVyTmFtZShtb2R1bGVNZXRhLnR5cGUpICsgXCIvbW9kdWxlLm5nZmFjdG9yeS5qc1wiKTtcbn1cbmZ1bmN0aW9uIHRlbXBsYXRlSml0VXJsKG5nTW9kdWxlVHlwZSwgY29tcE1ldGEpIHtcbiAgICByZXR1cm4gaml0U291cmNlVXJsKGlkZW50aWZpZXJOYW1lKG5nTW9kdWxlVHlwZSkgKyBcIi9cIiArIGlkZW50aWZpZXJOYW1lKGNvbXBNZXRhLnR5cGUpICsgXCIubmdmYWN0b3J5LmpzXCIpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQ09SRSQxID0gJ0Bhbmd1bGFyL2NvcmUnO1xudmFyIElkZW50aWZpZXJzJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSWRlbnRpZmllcnMoKSB7XG4gICAgfVxuICAgIC8qIE1ldGhvZHMgKi9cbiAgICBJZGVudGlmaWVycy5ORVdfTUVUSE9EID0gJ2ZhY3RvcnknO1xuICAgIElkZW50aWZpZXJzLlRSQU5TRk9STV9NRVRIT0QgPSAndHJhbnNmb3JtJztcbiAgICBJZGVudGlmaWVycy5QQVRDSF9ERVBTID0gJ3BhdGNoZWREZXBzJztcbiAgICAvKiBJbnN0cnVjdGlvbnMgKi9cbiAgICBJZGVudGlmaWVycy5uYW1lc3BhY2VIVE1MID0geyBuYW1lOiAnybXJtW5hbWVzcGFjZUhUTUwnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5uYW1lc3BhY2VNYXRoTUwgPSB7IG5hbWU6ICfJtcm1bmFtZXNwYWNlTWF0aE1MJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMubmFtZXNwYWNlU1ZHID0geyBuYW1lOiAnybXJtW5hbWVzcGFjZVNWRycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmVsZW1lbnQgPSB7IG5hbWU6ICfJtcm1ZWxlbWVudCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmVsZW1lbnRTdGFydCA9IHsgbmFtZTogJ8m1ybVlbGVtZW50U3RhcnQnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5lbGVtZW50RW5kID0geyBuYW1lOiAnybXJtWVsZW1lbnRFbmQnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zZWxlY3QgPSB7IG5hbWU6ICfJtcm1c2VsZWN0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMudXBkYXRlU3ludGhldGljSG9zdEJpbmRpbmcgPSB7IG5hbWU6ICfJtcm1dXBkYXRlU3ludGhldGljSG9zdEJpbmRpbmcnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5jb21wb25lbnRIb3N0U3ludGhldGljTGlzdGVuZXIgPSB7IG5hbWU6ICfJtcm1Y29tcG9uZW50SG9zdFN5bnRoZXRpY0xpc3RlbmVyJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuYXR0cmlidXRlID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlMSA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGVJbnRlcnBvbGF0ZTEnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTIgPSB7IG5hbWU6ICfJtcm1YXR0cmlidXRlSW50ZXJwb2xhdGUyJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGUzID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZUludGVycG9sYXRlMycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlNCA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGVJbnRlcnBvbGF0ZTQnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTUgPSB7IG5hbWU6ICfJtcm1YXR0cmlidXRlSW50ZXJwb2xhdGU1JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGU2ID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZUludGVycG9sYXRlNicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlNyA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGVJbnRlcnBvbGF0ZTcnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTggPSB7IG5hbWU6ICfJtcm1YXR0cmlidXRlSW50ZXJwb2xhdGU4JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGVWID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZUludGVycG9sYXRlVicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmNsYXNzUHJvcCA9IHsgbmFtZTogJ8m1ybVjbGFzc1Byb3AnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5lbGVtZW50Q29udGFpbmVyU3RhcnQgPSB7IG5hbWU6ICfJtcm1ZWxlbWVudENvbnRhaW5lclN0YXJ0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuZWxlbWVudENvbnRhaW5lckVuZCA9IHsgbmFtZTogJ8m1ybVlbGVtZW50Q29udGFpbmVyRW5kJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuZWxlbWVudENvbnRhaW5lciA9IHsgbmFtZTogJ8m1ybVlbGVtZW50Q29udGFpbmVyJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc3R5bGluZyA9IHsgbmFtZTogJ8m1ybVzdHlsaW5nJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc3R5bGVNYXAgPSB7IG5hbWU6ICfJtcm1c3R5bGVNYXAnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5jbGFzc01hcCA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGUxID0geyBuYW1lOiAnybXJtWNsYXNzTWFwSW50ZXJwb2xhdGUxJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuY2xhc3NNYXBJbnRlcnBvbGF0ZTIgPSB7IG5hbWU6ICfJtcm1Y2xhc3NNYXBJbnRlcnBvbGF0ZTInLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlMyA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlMycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGU0ID0geyBuYW1lOiAnybXJtWNsYXNzTWFwSW50ZXJwb2xhdGU0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuY2xhc3NNYXBJbnRlcnBvbGF0ZTUgPSB7IG5hbWU6ICfJtcm1Y2xhc3NNYXBJbnRlcnBvbGF0ZTUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlNiA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlNicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGU3ID0geyBuYW1lOiAnybXJtWNsYXNzTWFwSW50ZXJwb2xhdGU3JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuY2xhc3NNYXBJbnRlcnBvbGF0ZTggPSB7IG5hbWU6ICfJtcm1Y2xhc3NNYXBJbnRlcnBvbGF0ZTgnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlViA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlVicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnN0eWxlUHJvcCA9IHsgbmFtZTogJ8m1ybVzdHlsZVByb3AnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTEgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wSW50ZXJwb2xhdGUxJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGUyID0geyBuYW1lOiAnybXJtXN0eWxlUHJvcEludGVycG9sYXRlMicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlMyA9IHsgbmFtZTogJ8m1ybVzdHlsZVByb3BJbnRlcnBvbGF0ZTMnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTQgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wSW50ZXJwb2xhdGU0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGU1ID0geyBuYW1lOiAnybXJtXN0eWxlUHJvcEludGVycG9sYXRlNScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlNiA9IHsgbmFtZTogJ8m1ybVzdHlsZVByb3BJbnRlcnBvbGF0ZTYnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTcgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wSW50ZXJwb2xhdGU3JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGU4ID0geyBuYW1lOiAnybXJtXN0eWxlUHJvcEludGVycG9sYXRlOCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlViA9IHsgbmFtZTogJ8m1ybVzdHlsZVByb3BJbnRlcnBvbGF0ZVYnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zdHlsaW5nQXBwbHkgPSB7IG5hbWU6ICfJtcm1c3R5bGluZ0FwcGx5JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc3R5bGVTYW5pdGl6ZXIgPSB7IG5hbWU6ICfJtcm1c3R5bGVTYW5pdGl6ZXInLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5lbGVtZW50SG9zdEF0dHJzID0geyBuYW1lOiAnybXJtWVsZW1lbnRIb3N0QXR0cnMnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5jb250YWluZXJDcmVhdGUgPSB7IG5hbWU6ICfJtcm1Y29udGFpbmVyJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMubmV4dENvbnRleHQgPSB7IG5hbWU6ICfJtcm1bmV4dENvbnRleHQnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy50ZW1wbGF0ZUNyZWF0ZSA9IHsgbmFtZTogJ8m1ybV0ZW1wbGF0ZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnRleHQgPSB7IG5hbWU6ICfJtcm1dGV4dCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnRleHRCaW5kaW5nID0geyBuYW1lOiAnybXJtXRleHRCaW5kaW5nJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuZW5hYmxlQmluZGluZ3MgPSB7IG5hbWU6ICfJtcm1ZW5hYmxlQmluZGluZ3MnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5kaXNhYmxlQmluZGluZ3MgPSB7IG5hbWU6ICfJtcm1ZGlzYWJsZUJpbmRpbmdzJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuYWxsb2NIb3N0VmFycyA9IHsgbmFtZTogJ8m1ybVhbGxvY0hvc3RWYXJzJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuZ2V0Q3VycmVudFZpZXcgPSB7IG5hbWU6ICfJtcm1Z2V0Q3VycmVudFZpZXcnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGUgPSB7IG5hbWU6ICfJtcm1dGV4dEludGVycG9sYXRlJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlMSA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGUxJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlMiA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGUyJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlMyA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGUzJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlNCA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGU0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlNSA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGU1JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlNiA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGU2JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlNyA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGU3JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlOCA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGU4JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlViA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGVWJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucmVzdG9yZVZpZXcgPSB7IG5hbWU6ICfJtcm1cmVzdG9yZVZpZXcnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb24wID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjAnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb24xID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjEnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb24yID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjInLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb24zID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjMnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb240ID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjQnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb241ID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb242ID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjYnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb243ID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjcnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb244ID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjgnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb25WID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvblYnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5waXBlQmluZDEgPSB7IG5hbWU6ICfJtcm1cGlwZUJpbmQxJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucGlwZUJpbmQyID0geyBuYW1lOiAnybXJtXBpcGVCaW5kMicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnBpcGVCaW5kMyA9IHsgbmFtZTogJ8m1ybVwaXBlQmluZDMnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5waXBlQmluZDQgPSB7IG5hbWU6ICfJtcm1cGlwZUJpbmQ0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucGlwZUJpbmRWID0geyBuYW1lOiAnybXJtXBpcGVCaW5kVicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmhvc3RQcm9wZXJ0eSA9IHsgbmFtZTogJ8m1ybVob3N0UHJvcGVydHknLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eSA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGUgPSB7IG5hbWU6ICfJtcm1cHJvcGVydHlJbnRlcnBvbGF0ZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGUxID0geyBuYW1lOiAnybXJtXByb3BlcnR5SW50ZXJwb2xhdGUxJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHJvcGVydHlJbnRlcnBvbGF0ZTIgPSB7IG5hbWU6ICfJtcm1cHJvcGVydHlJbnRlcnBvbGF0ZTInLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlMyA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlMycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGU0ID0geyBuYW1lOiAnybXJtXByb3BlcnR5SW50ZXJwb2xhdGU0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHJvcGVydHlJbnRlcnBvbGF0ZTUgPSB7IG5hbWU6ICfJtcm1cHJvcGVydHlJbnRlcnBvbGF0ZTUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNiA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlNicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGU3ID0geyBuYW1lOiAnybXJtXByb3BlcnR5SW50ZXJwb2xhdGU3JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHJvcGVydHlJbnRlcnBvbGF0ZTggPSB7IG5hbWU6ICfJtcm1cHJvcGVydHlJbnRlcnBvbGF0ZTgnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlViA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlVicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmkxOG4gPSB7IG5hbWU6ICfJtcm1aTE4bicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmkxOG5BdHRyaWJ1dGVzID0geyBuYW1lOiAnybXJtWkxOG5BdHRyaWJ1dGVzJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuaTE4bkV4cCA9IHsgbmFtZTogJ8m1ybVpMThuRXhwJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuaTE4blN0YXJ0ID0geyBuYW1lOiAnybXJtWkxOG5TdGFydCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmkxOG5FbmQgPSB7IG5hbWU6ICfJtcm1aTE4bkVuZCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmkxOG5BcHBseSA9IHsgbmFtZTogJ8m1ybVpMThuQXBwbHknLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5pMThuUG9zdHByb2Nlc3MgPSB7IG5hbWU6ICfJtcm1aTE4blBvc3Rwcm9jZXNzJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuaTE4bkxvY2FsaXplID0geyBuYW1lOiAnybXJtWkxOG5Mb2NhbGl6ZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmxvYWQgPSB7IG5hbWU6ICfJtcm1bG9hZCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnBpcGUgPSB7IG5hbWU6ICfJtcm1cGlwZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnByb2plY3Rpb24gPSB7IG5hbWU6ICfJtcm1cHJvamVjdGlvbicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnByb2plY3Rpb25EZWYgPSB7IG5hbWU6ICfJtcm1cHJvamVjdGlvbkRlZicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnJlZmVyZW5jZSA9IHsgbmFtZTogJ8m1ybVyZWZlcmVuY2UnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5pbmplY3QgPSB7IG5hbWU6ICfJtcm1aW5qZWN0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuaW5qZWN0QXR0cmlidXRlID0geyBuYW1lOiAnybXJtWluamVjdEF0dHJpYnV0ZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmluamVjdFBpcGVDaGFuZ2VEZXRlY3RvclJlZiA9IHsgbmFtZTogJ8m1ybVpbmplY3RQaXBlQ2hhbmdlRGV0ZWN0b3JSZWYnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5kaXJlY3RpdmVJbmplY3QgPSB7IG5hbWU6ICfJtcm1ZGlyZWN0aXZlSW5qZWN0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMudGVtcGxhdGVSZWZFeHRyYWN0b3IgPSB7IG5hbWU6ICfJtcm1dGVtcGxhdGVSZWZFeHRyYWN0b3InLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5yZXNvbHZlV2luZG93ID0geyBuYW1lOiAnybXJtXJlc29sdmVXaW5kb3cnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5yZXNvbHZlRG9jdW1lbnQgPSB7IG5hbWU6ICfJtcm1cmVzb2x2ZURvY3VtZW50JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucmVzb2x2ZUJvZHkgPSB7IG5hbWU6ICfJtcm1cmVzb2x2ZUJvZHknLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5kZWZpbmVCYXNlID0geyBuYW1lOiAnybXJtWRlZmluZUJhc2UnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5CYXNlRGVmID0ge1xuICAgICAgICBuYW1lOiAnybXJtUJhc2VEZWYnLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFJDEsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5kZWZpbmVDb21wb25lbnQgPSB7IG5hbWU6ICfJtcm1ZGVmaW5lQ29tcG9uZW50JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc2V0Q29tcG9uZW50U2NvcGUgPSB7IG5hbWU6ICfJtcm1c2V0Q29tcG9uZW50U2NvcGUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5Db21wb25lbnREZWZXaXRoTWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ8m1ybVDb21wb25lbnREZWZXaXRoTWV0YScsXG4gICAgICAgIG1vZHVsZU5hbWU6IENPUkUkMSxcbiAgICB9O1xuICAgIElkZW50aWZpZXJzLmRlZmluZURpcmVjdGl2ZSA9IHtcbiAgICAgICAgbmFtZTogJ8m1ybVkZWZpbmVEaXJlY3RpdmUnLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFJDEsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5EaXJlY3RpdmVEZWZXaXRoTWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ8m1ybVEaXJlY3RpdmVEZWZXaXRoTWV0YScsXG4gICAgICAgIG1vZHVsZU5hbWU6IENPUkUkMSxcbiAgICB9O1xuICAgIElkZW50aWZpZXJzLkluamVjdG9yRGVmID0ge1xuICAgICAgICBuYW1lOiAnybXJtUluamVjdG9yRGVmJyxcbiAgICAgICAgbW9kdWxlTmFtZTogQ09SRSQxLFxuICAgIH07XG4gICAgSWRlbnRpZmllcnMuZGVmaW5lSW5qZWN0b3IgPSB7XG4gICAgICAgIG5hbWU6ICfJtcm1ZGVmaW5lSW5qZWN0b3InLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFJDEsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5OZ01vZHVsZURlZldpdGhNZXRhID0ge1xuICAgICAgICBuYW1lOiAnybXJtU5nTW9kdWxlRGVmV2l0aE1ldGEnLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFJDEsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5kZWZpbmVOZ01vZHVsZSA9IHsgbmFtZTogJ8m1ybVkZWZpbmVOZ01vZHVsZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnNldE5nTW9kdWxlU2NvcGUgPSB7IG5hbWU6ICfJtcm1c2V0TmdNb2R1bGVTY29wZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLlBpcGVEZWZXaXRoTWV0YSA9IHsgbmFtZTogJ8m1ybVQaXBlRGVmV2l0aE1ldGEnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5kZWZpbmVQaXBlID0geyBuYW1lOiAnybXJtWRlZmluZVBpcGUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5xdWVyeVJlZnJlc2ggPSB7IG5hbWU6ICfJtcm1cXVlcnlSZWZyZXNoJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMudmlld1F1ZXJ5ID0geyBuYW1lOiAnybXJtXZpZXdRdWVyeScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnN0YXRpY1ZpZXdRdWVyeSA9IHsgbmFtZTogJ8m1ybVzdGF0aWNWaWV3UXVlcnknLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zdGF0aWNDb250ZW50UXVlcnkgPSB7IG5hbWU6ICfJtcm1c3RhdGljQ29udGVudFF1ZXJ5JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMubG9hZFZpZXdRdWVyeSA9IHsgbmFtZTogJ8m1ybVsb2FkVmlld1F1ZXJ5JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuY29udGVudFF1ZXJ5ID0geyBuYW1lOiAnybXJtWNvbnRlbnRRdWVyeScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmxvYWRDb250ZW50UXVlcnkgPSB7IG5hbWU6ICfJtcm1bG9hZENvbnRlbnRRdWVyeScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLk5nT25DaGFuZ2VzRmVhdHVyZSA9IHsgbmFtZTogJ8m1ybVOZ09uQ2hhbmdlc0ZlYXR1cmUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5Jbmhlcml0RGVmaW5pdGlvbkZlYXR1cmUgPSB7IG5hbWU6ICfJtcm1SW5oZXJpdERlZmluaXRpb25GZWF0dXJlJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuUHJvdmlkZXJzRmVhdHVyZSA9IHsgbmFtZTogJ8m1ybVQcm92aWRlcnNGZWF0dXJlJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMubGlzdGVuZXIgPSB7IG5hbWU6ICfJtcm1bGlzdGVuZXInLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5nZXRGYWN0b3J5T2YgPSB7XG4gICAgICAgIG5hbWU6ICfJtcm1Z2V0RmFjdG9yeU9mJyxcbiAgICAgICAgbW9kdWxlTmFtZTogQ09SRSQxLFxuICAgIH07XG4gICAgSWRlbnRpZmllcnMuZ2V0SW5oZXJpdGVkRmFjdG9yeSA9IHtcbiAgICAgICAgbmFtZTogJ8m1ybVnZXRJbmhlcml0ZWRGYWN0b3J5JyxcbiAgICAgICAgbW9kdWxlTmFtZTogQ09SRSQxLFxuICAgIH07XG4gICAgLy8gc2FuaXRpemF0aW9uLXJlbGF0ZWQgZnVuY3Rpb25zXG4gICAgSWRlbnRpZmllcnMuc2FuaXRpemVIdG1sID0geyBuYW1lOiAnybXJtXNhbml0aXplSHRtbCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnNhbml0aXplU3R5bGUgPSB7IG5hbWU6ICfJtcm1c2FuaXRpemVTdHlsZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmRlZmF1bHRTdHlsZVNhbml0aXplciA9IHsgbmFtZTogJ8m1ybVkZWZhdWx0U3R5bGVTYW5pdGl6ZXInLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zYW5pdGl6ZVJlc291cmNlVXJsID0geyBuYW1lOiAnybXJtXNhbml0aXplUmVzb3VyY2VVcmwnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zYW5pdGl6ZVNjcmlwdCA9IHsgbmFtZTogJ8m1ybVzYW5pdGl6ZVNjcmlwdCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnNhbml0aXplVXJsID0geyBuYW1lOiAnybXJtXNhbml0aXplVXJsJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc2FuaXRpemVVcmxPclJlc291cmNlVXJsID0geyBuYW1lOiAnybXJtXNhbml0aXplVXJsT3JSZXNvdXJjZVVybCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIHJldHVybiBJZGVudGlmaWVycztcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciAkRU9GID0gMDtcbnZhciAkQlNQQUNFID0gODtcbnZhciAkVEFCID0gOTtcbnZhciAkTEYgPSAxMDtcbnZhciAkVlRBQiA9IDExO1xudmFyICRGRiA9IDEyO1xudmFyICRDUiA9IDEzO1xudmFyICRTUEFDRSA9IDMyO1xudmFyICRCQU5HID0gMzM7XG52YXIgJERRID0gMzQ7XG52YXIgJEhBU0ggPSAzNTtcbnZhciAkJCA9IDM2O1xudmFyICRQRVJDRU5UID0gMzc7XG52YXIgJEFNUEVSU0FORCA9IDM4O1xudmFyICRTUSA9IDM5O1xudmFyICRMUEFSRU4gPSA0MDtcbnZhciAkUlBBUkVOID0gNDE7XG52YXIgJFNUQVIgPSA0MjtcbnZhciAkUExVUyA9IDQzO1xudmFyICRDT01NQSA9IDQ0O1xudmFyICRNSU5VUyA9IDQ1O1xudmFyICRQRVJJT0QgPSA0NjtcbnZhciAkU0xBU0ggPSA0NztcbnZhciAkQ09MT04gPSA1ODtcbnZhciAkU0VNSUNPTE9OID0gNTk7XG52YXIgJExUID0gNjA7XG52YXIgJEVRID0gNjE7XG52YXIgJEdUID0gNjI7XG52YXIgJFFVRVNUSU9OID0gNjM7XG52YXIgJDAgPSA0ODtcbnZhciAkNyA9IDU1O1xudmFyICQ5ID0gNTc7XG52YXIgJEEgPSA2NTtcbnZhciAkRSA9IDY5O1xudmFyICRGID0gNzA7XG52YXIgJFggPSA4ODtcbnZhciAkWiA9IDkwO1xudmFyICRMQlJBQ0tFVCA9IDkxO1xudmFyICRCQUNLU0xBU0ggPSA5MjtcbnZhciAkUkJSQUNLRVQgPSA5MztcbnZhciAkQ0FSRVQgPSA5NDtcbnZhciAkXyA9IDk1O1xudmFyICRhID0gOTc7XG52YXIgJGIgPSA5ODtcbnZhciAkZSA9IDEwMTtcbnZhciAkZiA9IDEwMjtcbnZhciAkbiA9IDExMDtcbnZhciAkciA9IDExNDtcbnZhciAkdCA9IDExNjtcbnZhciAkdSA9IDExNztcbnZhciAkdiA9IDExODtcbnZhciAkeCA9IDEyMDtcbnZhciAkeiA9IDEyMjtcbnZhciAkTEJSQUNFID0gMTIzO1xudmFyICRCQVIgPSAxMjQ7XG52YXIgJFJCUkFDRSA9IDEyNTtcbnZhciAkTkJTUCA9IDE2MDtcbnZhciAkUElQRSA9IDEyNDtcbnZhciAkVElMREEgPSAxMjY7XG52YXIgJEFUID0gNjQ7XG52YXIgJEJUID0gOTY7XG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoY29kZSkge1xuICAgIHJldHVybiAoY29kZSA+PSAkVEFCICYmIGNvZGUgPD0gJFNQQUNFKSB8fCAoY29kZSA9PSAkTkJTUCk7XG59XG5mdW5jdGlvbiBpc0RpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gJDAgPD0gY29kZSAmJiBjb2RlIDw9ICQ5O1xufVxuZnVuY3Rpb24gaXNBc2NpaUxldHRlcihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gJGEgJiYgY29kZSA8PSAkeiB8fCBjb2RlID49ICRBICYmIGNvZGUgPD0gJFo7XG59XG5mdW5jdGlvbiBpc0FzY2lpSGV4RGlnaXQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJGYgfHwgY29kZSA+PSAkQSAmJiBjb2RlIDw9ICRGIHx8IGlzRGlnaXQoY29kZSk7XG59XG5mdW5jdGlvbiBpc05ld0xpbmUoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSAkTEYgfHwgY29kZSA9PT0gJENSO1xufVxuZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gJDAgPD0gY29kZSAmJiBjb2RlIDw9ICQ3O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUGFyc2VMb2NhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZUxvY2F0aW9uKGZpbGUsIG9mZnNldCwgbGluZSwgY29sKSB7XG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICB0aGlzLmNvbCA9IGNvbDtcbiAgICB9XG4gICAgUGFyc2VMb2NhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldCAhPSBudWxsID8gdGhpcy5maWxlLnVybCArIFwiQFwiICsgdGhpcy5saW5lICsgXCI6XCIgKyB0aGlzLmNvbCA6IHRoaXMuZmlsZS51cmw7XG4gICAgfTtcbiAgICBQYXJzZUxvY2F0aW9uLnByb3RvdHlwZS5tb3ZlQnkgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZmlsZS5jb250ZW50O1xuICAgICAgICB2YXIgbGVuID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMubGluZTtcbiAgICAgICAgdmFyIGNvbCA9IHRoaXMuY29sO1xuICAgICAgICB3aGlsZSAob2Zmc2V0ID4gMCAmJiBkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAgICAgZGVsdGErKztcbiAgICAgICAgICAgIHZhciBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoY2ggPT0gJExGKSB7XG4gICAgICAgICAgICAgICAgbGluZS0tO1xuICAgICAgICAgICAgICAgIHZhciBwcmlvckxpbmUgPSBzb3VyY2Uuc3Vic3RyKDAsIG9mZnNldCAtIDEpLmxhc3RJbmRleE9mKFN0cmluZy5mcm9tQ2hhckNvZGUoJExGKSk7XG4gICAgICAgICAgICAgICAgY29sID0gcHJpb3JMaW5lID4gMCA/IG9mZnNldCAtIHByaW9yTGluZSA6IG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW4gJiYgZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBkZWx0YS0tO1xuICAgICAgICAgICAgaWYgKGNoID09ICRMRikge1xuICAgICAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgICAgICBjb2wgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUxvY2F0aW9uKHRoaXMuZmlsZSwgb2Zmc2V0LCBsaW5lLCBjb2wpO1xuICAgIH07XG4gICAgLy8gUmV0dXJuIHRoZSBzb3VyY2UgYXJvdW5kIHRoZSBsb2NhdGlvblxuICAgIC8vIFVwIHRvIGBtYXhDaGFyc2Agb3IgYG1heExpbmVzYCBvbiBlYWNoIHNpZGUgb2YgdGhlIGxvY2F0aW9uXG4gICAgUGFyc2VMb2NhdGlvbi5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIChtYXhDaGFycywgbWF4TGluZXMpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmZpbGUuY29udGVudDtcbiAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmIChzdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPiBjb250ZW50Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldCA9IGNvbnRlbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlbmRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgICAgIHZhciBjdHhDaGFycyA9IDA7XG4gICAgICAgICAgICB2YXIgY3R4TGluZXMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGN0eENoYXJzIDwgbWF4Q2hhcnMgJiYgc3RhcnRPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQtLTtcbiAgICAgICAgICAgICAgICBjdHhDaGFycysrO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50W3N0YXJ0T2Zmc2V0XSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKytjdHhMaW5lcyA9PSBtYXhMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHhDaGFycyA9IDA7XG4gICAgICAgICAgICBjdHhMaW5lcyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoY3R4Q2hhcnMgPCBtYXhDaGFycyAmJiBlbmRPZmZzZXQgPCBjb250ZW50Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBlbmRPZmZzZXQrKztcbiAgICAgICAgICAgICAgICBjdHhDaGFycysrO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50W2VuZE9mZnNldF0gPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsrY3R4TGluZXMgPT0gbWF4TGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGNvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0T2Zmc2V0LCB0aGlzLm9mZnNldCksXG4gICAgICAgICAgICAgICAgYWZ0ZXI6IGNvbnRlbnQuc3Vic3RyaW5nKHRoaXMub2Zmc2V0LCBlbmRPZmZzZXQgKyAxKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyc2VMb2NhdGlvbjtcbn0oKSk7XG52YXIgUGFyc2VTb3VyY2VGaWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlU291cmNlRmlsZShjb250ZW50LCB1cmwpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgfVxuICAgIHJldHVybiBQYXJzZVNvdXJjZUZpbGU7XG59KCkpO1xudmFyIFBhcnNlU291cmNlU3BhbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZVNvdXJjZVNwYW4oc3RhcnQsIGVuZCwgZGV0YWlscykge1xuICAgICAgICBpZiAoZGV0YWlscyA9PT0gdm9pZCAwKSB7IGRldGFpbHMgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgfVxuICAgIFBhcnNlU291cmNlU3Bhbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmZpbGUuY29udGVudC5zdWJzdHJpbmcodGhpcy5zdGFydC5vZmZzZXQsIHRoaXMuZW5kLm9mZnNldCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyc2VTb3VyY2VTcGFuO1xufSgpKTtcbnZhciBFTVBUWV9QQVJTRV9MT0NBVElPTiA9IG5ldyBQYXJzZUxvY2F0aW9uKG5ldyBQYXJzZVNvdXJjZUZpbGUoJycsICcnKSwgMCwgMCwgMCk7XG52YXIgRU1QVFlfU09VUkNFX1NQQU4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKEVNUFRZX1BBUlNFX0xPQ0FUSU9OLCBFTVBUWV9QQVJTRV9MT0NBVElPTik7XG52YXIgUGFyc2VFcnJvckxldmVsO1xuKGZ1bmN0aW9uIChQYXJzZUVycm9yTGV2ZWwpIHtcbiAgICBQYXJzZUVycm9yTGV2ZWxbUGFyc2VFcnJvckxldmVsW1wiV0FSTklOR1wiXSA9IDBdID0gXCJXQVJOSU5HXCI7XG4gICAgUGFyc2VFcnJvckxldmVsW1BhcnNlRXJyb3JMZXZlbFtcIkVSUk9SXCJdID0gMV0gPSBcIkVSUk9SXCI7XG59KShQYXJzZUVycm9yTGV2ZWwgfHwgKFBhcnNlRXJyb3JMZXZlbCA9IHt9KSk7XG52YXIgUGFyc2VFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZUVycm9yKHNwYW4sIG1zZywgbGV2ZWwpIHtcbiAgICAgICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsgbGV2ZWwgPSBQYXJzZUVycm9yTGV2ZWwuRVJST1I7IH1cbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgdGhpcy5tc2cgPSBtc2c7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgUGFyc2VFcnJvci5wcm90b3R5cGUuY29udGV4dHVhbE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLnNwYW4uc3RhcnQuZ2V0Q29udGV4dCgxMDAsIDMpO1xuICAgICAgICByZXR1cm4gY3R4ID8gdGhpcy5tc2cgKyBcIiAoXFxcIlwiICsgY3R4LmJlZm9yZSArIFwiW1wiICsgUGFyc2VFcnJvckxldmVsW3RoaXMubGV2ZWxdICsgXCIgLT5dXCIgKyBjdHguYWZ0ZXIgKyBcIlxcXCIpXCIgOlxuICAgICAgICAgICAgdGhpcy5tc2c7XG4gICAgfTtcbiAgICBQYXJzZUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRldGFpbHMgPSB0aGlzLnNwYW4uZGV0YWlscyA/IFwiLCBcIiArIHRoaXMuc3Bhbi5kZXRhaWxzIDogJyc7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHR1YWxNZXNzYWdlKCkgKyBcIjogXCIgKyB0aGlzLnNwYW4uc3RhcnQgKyBkZXRhaWxzO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlRXJyb3I7XG59KCkpO1xuZnVuY3Rpb24gdHlwZVNvdXJjZVNwYW4oa2luZCwgdHlwZSkge1xuICAgIHZhciBtb2R1bGVVcmwgPSBpZGVudGlmaWVyTW9kdWxlVXJsKHR5cGUpO1xuICAgIHZhciBzb3VyY2VGaWxlTmFtZSA9IG1vZHVsZVVybCAhPSBudWxsID8gXCJpbiBcIiArIGtpbmQgKyBcIiBcIiArIGlkZW50aWZpZXJOYW1lKHR5cGUpICsgXCIgaW4gXCIgKyBtb2R1bGVVcmwgOlxuICAgICAgICBcImluIFwiICsga2luZCArIFwiIFwiICsgaWRlbnRpZmllck5hbWUodHlwZSk7XG4gICAgdmFyIHNvdXJjZUZpbGUgPSBuZXcgUGFyc2VTb3VyY2VGaWxlKCcnLCBzb3VyY2VGaWxlTmFtZSk7XG4gICAgcmV0dXJuIG5ldyBQYXJzZVNvdXJjZVNwYW4obmV3IFBhcnNlTG9jYXRpb24oc291cmNlRmlsZSwgLTEsIC0xLCAtMSksIG5ldyBQYXJzZUxvY2F0aW9uKHNvdXJjZUZpbGUsIC0xLCAtMSwgLTEpKTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIFNvdXJjZSBTcGFuIG9iamVjdCBmb3IgYSBnaXZlbiBSMyBUeXBlIGZvciBKSVQgbW9kZS5cbiAqXG4gKiBAcGFyYW0ga2luZCBDb21wb25lbnQgb3IgRGlyZWN0aXZlLlxuICogQHBhcmFtIHR5cGVOYW1lIG5hbWUgb2YgdGhlIENvbXBvbmVudCBvciBEaXJlY3RpdmUuXG4gKiBAcGFyYW0gc291cmNlVXJsIHJlZmVyZW5jZSB0byBDb21wb25lbnQgb3IgRGlyZWN0aXZlIHNvdXJjZS5cbiAqIEByZXR1cm5zIGluc3RhbmNlIG9mIFBhcnNlU291cmNlU3BhbiB0aGF0IHJlcHJlc2VudCBhIGdpdmVuIENvbXBvbmVudCBvciBEaXJlY3RpdmUuXG4gKi9cbmZ1bmN0aW9uIHIzSml0VHlwZVNvdXJjZVNwYW4oa2luZCwgdHlwZU5hbWUsIHNvdXJjZVVybCkge1xuICAgIHZhciBzb3VyY2VGaWxlTmFtZSA9IFwiaW4gXCIgKyBraW5kICsgXCIgXCIgKyB0eXBlTmFtZSArIFwiIGluIFwiICsgc291cmNlVXJsO1xuICAgIHZhciBzb3VyY2VGaWxlID0gbmV3IFBhcnNlU291cmNlRmlsZSgnJywgc291cmNlRmlsZU5hbWUpO1xuICAgIHJldHVybiBuZXcgUGFyc2VTb3VyY2VTcGFuKG5ldyBQYXJzZUxvY2F0aW9uKHNvdXJjZUZpbGUsIC0xLCAtMSwgLTEpLCBuZXcgUGFyc2VMb2NhdGlvbihzb3VyY2VGaWxlLCAtMSwgLTEsIC0xKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHQodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBUZXh0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzKTsgfTtcbiAgICByZXR1cm4gVGV4dDtcbn0oKSk7XG52YXIgQm91bmRUZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvdW5kVGV4dCh2YWx1ZSwgc291cmNlU3BhbiwgaTE4bikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuaTE4biA9IGkxOG47XG4gICAgfVxuICAgIEJvdW5kVGV4dC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdEJvdW5kVGV4dCh0aGlzKTsgfTtcbiAgICByZXR1cm4gQm91bmRUZXh0O1xufSgpKTtcbnZhciBUZXh0QXR0cmlidXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHRBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIHZhbHVlU3BhbiwgaTE4bikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTcGFuID0gdmFsdWVTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICBUZXh0QXR0cmlidXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dEF0dHJpYnV0ZSh0aGlzKTsgfTtcbiAgICByZXR1cm4gVGV4dEF0dHJpYnV0ZTtcbn0oKSk7XG52YXIgQm91bmRBdHRyaWJ1dGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQm91bmRBdHRyaWJ1dGUobmFtZSwgdHlwZSwgc2VjdXJpdHlDb250ZXh0LCB2YWx1ZSwgdW5pdCwgc291cmNlU3BhbiwgdmFsdWVTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc2VjdXJpdHlDb250ZXh0ID0gc2VjdXJpdHlDb250ZXh0O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudW5pdCA9IHVuaXQ7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTcGFuID0gdmFsdWVTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICBCb3VuZEF0dHJpYnV0ZS5mcm9tQm91bmRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcCwgaTE4bikge1xuICAgICAgICByZXR1cm4gbmV3IEJvdW5kQXR0cmlidXRlKHByb3AubmFtZSwgcHJvcC50eXBlLCBwcm9wLnNlY3VyaXR5Q29udGV4dCwgcHJvcC52YWx1ZSwgcHJvcC51bml0LCBwcm9wLnNvdXJjZVNwYW4sIHByb3AudmFsdWVTcGFuLCBpMThuKTtcbiAgICB9O1xuICAgIEJvdW5kQXR0cmlidXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0Qm91bmRBdHRyaWJ1dGUodGhpcyk7IH07XG4gICAgcmV0dXJuIEJvdW5kQXR0cmlidXRlO1xufSgpKTtcbnZhciBCb3VuZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvdW5kRXZlbnQobmFtZSwgdHlwZSwgaGFuZGxlciwgdGFyZ2V0LCBwaGFzZSwgc291cmNlU3BhbiwgaGFuZGxlclNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucGhhc2UgPSBwaGFzZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5oYW5kbGVyU3BhbiA9IGhhbmRsZXJTcGFuO1xuICAgIH1cbiAgICBCb3VuZEV2ZW50LmZyb21QYXJzZWRFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudHlwZSA9PT0gMCAvKiBSZWd1bGFyICovID8gZXZlbnQudGFyZ2V0T3JQaGFzZSA6IG51bGw7XG4gICAgICAgIHZhciBwaGFzZSA9IGV2ZW50LnR5cGUgPT09IDEgLyogQW5pbWF0aW9uICovID8gZXZlbnQudGFyZ2V0T3JQaGFzZSA6IG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRFdmVudChldmVudC5uYW1lLCBldmVudC50eXBlLCBldmVudC5oYW5kbGVyLCB0YXJnZXQsIHBoYXNlLCBldmVudC5zb3VyY2VTcGFuLCBldmVudC5oYW5kbGVyU3Bhbik7XG4gICAgfTtcbiAgICBCb3VuZEV2ZW50LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0Qm91bmRFdmVudCh0aGlzKTsgfTtcbiAgICByZXR1cm4gQm91bmRFdmVudDtcbn0oKSk7XG52YXIgRWxlbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMsIGlucHV0cywgb3V0cHV0cywgY2hpbGRyZW4sIHJlZmVyZW5jZXMsIHNvdXJjZVNwYW4sIHN0YXJ0U291cmNlU3BhbiwgZW5kU291cmNlU3BhbiwgaTE4bikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLnN0YXJ0U291cmNlU3BhbiA9IHN0YXJ0U291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5lbmRTb3VyY2VTcGFuID0gZW5kU291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgZW1wdHkgdGhlbiB0aGUgc291cmNlIHNwYW4gc2hvdWxkIGluY2x1ZGUgYW55IGNsb3NpbmcgdGFnXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgc3RhcnRTb3VyY2VTcGFuICYmIGVuZFNvdXJjZVNwYW4pIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oc291cmNlU3Bhbi5zdGFydCwgZW5kU291cmNlU3Bhbi5lbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEVsZW1lbnQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRFbGVtZW50KHRoaXMpOyB9O1xuICAgIHJldHVybiBFbGVtZW50O1xufSgpKTtcbnZhciBUZW1wbGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZSh0YWdOYW1lLCBhdHRyaWJ1dGVzLCBpbnB1dHMsIG91dHB1dHMsIHRlbXBsYXRlQXR0cnMsIGNoaWxkcmVuLCByZWZlcmVuY2VzLCB2YXJpYWJsZXMsIHNvdXJjZVNwYW4sIHN0YXJ0U291cmNlU3BhbiwgZW5kU291cmNlU3BhbiwgaTE4bikge1xuICAgICAgICB0aGlzLnRhZ05hbWUgPSB0YWdOYW1lO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUF0dHJzID0gdGVtcGxhdGVBdHRycztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5zdGFydFNvdXJjZVNwYW4gPSBzdGFydFNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuZW5kU291cmNlU3BhbiA9IGVuZFNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuaTE4biA9IGkxOG47XG4gICAgfVxuICAgIFRlbXBsYXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGVtcGxhdGUodGhpcyk7IH07XG4gICAgcmV0dXJuIFRlbXBsYXRlO1xufSgpKTtcbnZhciBDb250ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnRlbnQoc2VsZWN0b3IsIGF0dHJpYnV0ZXMsIHNvdXJjZVNwYW4sIGkxOG4pIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICBDb250ZW50LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0Q29udGVudCh0aGlzKTsgfTtcbiAgICByZXR1cm4gQ29udGVudDtcbn0oKSk7XG52YXIgVmFyaWFibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmFyaWFibGUobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIHZhbHVlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTcGFuID0gdmFsdWVTcGFuO1xuICAgIH1cbiAgICBWYXJpYWJsZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdFZhcmlhYmxlKHRoaXMpOyB9O1xuICAgIHJldHVybiBWYXJpYWJsZTtcbn0oKSk7XG52YXIgUmVmZXJlbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZmVyZW5jZShuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdmFsdWVTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgfVxuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdFJlZmVyZW5jZSh0aGlzKTsgfTtcbiAgICByZXR1cm4gUmVmZXJlbmNlO1xufSgpKTtcbnZhciBJY3UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSWN1KHZhcnMsIHBsYWNlaG9sZGVycywgc291cmNlU3BhbiwgaTE4bikge1xuICAgICAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVycyA9IHBsYWNlaG9sZGVycztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICB9XG4gICAgSWN1LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0SWN1KHRoaXMpOyB9O1xuICAgIHJldHVybiBJY3U7XG59KCkpO1xudmFyIE51bGxWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE51bGxWaXNpdG9yKCkge1xuICAgIH1cbiAgICBOdWxsVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHsgfTtcbiAgICBOdWxsVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkgeyB9O1xuICAgIE51bGxWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRlbnQgPSBmdW5jdGlvbiAoY29udGVudCkgeyB9O1xuICAgIE51bGxWaXNpdG9yLnByb3RvdHlwZS52aXNpdFZhcmlhYmxlID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7IH07XG4gICAgTnVsbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlZmVyZW5jZSkgeyB9O1xuICAgIE51bGxWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7IH07XG4gICAgTnVsbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Qm91bmRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7IH07XG4gICAgTnVsbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Qm91bmRFdmVudCA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHsgfTtcbiAgICBOdWxsVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgfTtcbiAgICBOdWxsVmlzaXRvci5wcm90b3R5cGUudmlzaXRCb3VuZFRleHQgPSBmdW5jdGlvbiAodGV4dCkgeyB9O1xuICAgIE51bGxWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UpIHsgfTtcbiAgICByZXR1cm4gTnVsbFZpc2l0b3I7XG59KCkpO1xudmFyIFJlY3Vyc2l2ZVZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjdXJzaXZlVmlzaXRvcigpIHtcbiAgICB9XG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5hdHRyaWJ1dGVzKTtcbiAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQucmVmZXJlbmNlcyk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIHRlbXBsYXRlLmF0dHJpYnV0ZXMpO1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCB0ZW1wbGF0ZS5jaGlsZHJlbik7XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIHRlbXBsYXRlLnJlZmVyZW5jZXMpO1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCB0ZW1wbGF0ZS52YXJpYWJsZXMpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHsgfTtcbiAgICBSZWN1cnNpdmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFZhcmlhYmxlID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7IH07XG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVmZXJlbmNlKSB7IH07XG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkgeyB9O1xuICAgIFJlY3Vyc2l2ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Qm91bmRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7IH07XG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRCb3VuZEV2ZW50ID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkgeyB9O1xuICAgIFJlY3Vyc2l2ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7IH07XG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRCb3VuZFRleHQgPSBmdW5jdGlvbiAodGV4dCkgeyB9O1xuICAgIFJlY3Vyc2l2ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSkgeyB9O1xuICAgIHJldHVybiBSZWN1cnNpdmVWaXNpdG9yO1xufSgpKTtcbnZhciBUcmFuc2Zvcm1WaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVZpc2l0b3IoKSB7XG4gICAgfVxuICAgIFRyYW5zZm9ybVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBuZXdBdHRyaWJ1dGVzID0gdHJhbnNmb3JtQWxsKHRoaXMsIGVsZW1lbnQuYXR0cmlidXRlcyk7XG4gICAgICAgIHZhciBuZXdJbnB1dHMgPSB0cmFuc2Zvcm1BbGwodGhpcywgZWxlbWVudC5pbnB1dHMpO1xuICAgICAgICB2YXIgbmV3T3V0cHV0cyA9IHRyYW5zZm9ybUFsbCh0aGlzLCBlbGVtZW50Lm91dHB1dHMpO1xuICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSB0cmFuc2Zvcm1BbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgIHZhciBuZXdSZWZlcmVuY2VzID0gdHJhbnNmb3JtQWxsKHRoaXMsIGVsZW1lbnQucmVmZXJlbmNlcyk7XG4gICAgICAgIGlmIChuZXdBdHRyaWJ1dGVzICE9IGVsZW1lbnQuYXR0cmlidXRlcyB8fCBuZXdJbnB1dHMgIT0gZWxlbWVudC5pbnB1dHMgfHxcbiAgICAgICAgICAgIG5ld091dHB1dHMgIT0gZWxlbWVudC5vdXRwdXRzIHx8IG5ld0NoaWxkcmVuICE9IGVsZW1lbnQuY2hpbGRyZW4gfHxcbiAgICAgICAgICAgIG5ld1JlZmVyZW5jZXMgIT0gZWxlbWVudC5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoZWxlbWVudC5uYW1lLCBuZXdBdHRyaWJ1dGVzLCBuZXdJbnB1dHMsIG5ld091dHB1dHMsIG5ld0NoaWxkcmVuLCBuZXdSZWZlcmVuY2VzLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gICAgVHJhbnNmb3JtVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgbmV3QXR0cmlidXRlcyA9IHRyYW5zZm9ybUFsbCh0aGlzLCB0ZW1wbGF0ZS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgdmFyIG5ld0lucHV0cyA9IHRyYW5zZm9ybUFsbCh0aGlzLCB0ZW1wbGF0ZS5pbnB1dHMpO1xuICAgICAgICB2YXIgbmV3T3V0cHV0cyA9IHRyYW5zZm9ybUFsbCh0aGlzLCB0ZW1wbGF0ZS5vdXRwdXRzKTtcbiAgICAgICAgdmFyIG5ld1RlbXBsYXRlQXR0cnMgPSB0cmFuc2Zvcm1BbGwodGhpcywgdGVtcGxhdGUudGVtcGxhdGVBdHRycyk7XG4gICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IHRyYW5zZm9ybUFsbCh0aGlzLCB0ZW1wbGF0ZS5jaGlsZHJlbik7XG4gICAgICAgIHZhciBuZXdSZWZlcmVuY2VzID0gdHJhbnNmb3JtQWxsKHRoaXMsIHRlbXBsYXRlLnJlZmVyZW5jZXMpO1xuICAgICAgICB2YXIgbmV3VmFyaWFibGVzID0gdHJhbnNmb3JtQWxsKHRoaXMsIHRlbXBsYXRlLnZhcmlhYmxlcyk7XG4gICAgICAgIGlmIChuZXdBdHRyaWJ1dGVzICE9IHRlbXBsYXRlLmF0dHJpYnV0ZXMgfHwgbmV3SW5wdXRzICE9IHRlbXBsYXRlLmlucHV0cyB8fFxuICAgICAgICAgICAgbmV3T3V0cHV0cyAhPSB0ZW1wbGF0ZS5vdXRwdXRzIHx8IG5ld1RlbXBsYXRlQXR0cnMgIT0gdGVtcGxhdGUudGVtcGxhdGVBdHRycyB8fFxuICAgICAgICAgICAgbmV3Q2hpbGRyZW4gIT0gdGVtcGxhdGUuY2hpbGRyZW4gfHwgbmV3UmVmZXJlbmNlcyAhPSB0ZW1wbGF0ZS5yZWZlcmVuY2VzIHx8XG4gICAgICAgICAgICBuZXdWYXJpYWJsZXMgIT0gdGVtcGxhdGUudmFyaWFibGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlKHRlbXBsYXRlLnRhZ05hbWUsIG5ld0F0dHJpYnV0ZXMsIG5ld0lucHV0cywgbmV3T3V0cHV0cywgbmV3VGVtcGxhdGVBdHRycywgbmV3Q2hpbGRyZW4sIG5ld1JlZmVyZW5jZXMsIG5ld1ZhcmlhYmxlcywgdGVtcGxhdGUuc291cmNlU3BhbiwgdGVtcGxhdGUuc3RhcnRTb3VyY2VTcGFuLCB0ZW1wbGF0ZS5lbmRTb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfTtcbiAgICBUcmFuc2Zvcm1WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRlbnQgPSBmdW5jdGlvbiAoY29udGVudCkgeyByZXR1cm4gY29udGVudDsgfTtcbiAgICBUcmFuc2Zvcm1WaXNpdG9yLnByb3RvdHlwZS52aXNpdFZhcmlhYmxlID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7IHJldHVybiB2YXJpYWJsZTsgfTtcbiAgICBUcmFuc2Zvcm1WaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChyZWZlcmVuY2UpIHsgcmV0dXJuIHJlZmVyZW5jZTsgfTtcbiAgICBUcmFuc2Zvcm1WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7IHJldHVybiBhdHRyaWJ1dGU7IH07XG4gICAgVHJhbnNmb3JtVmlzaXRvci5wcm90b3R5cGUudmlzaXRCb3VuZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHsgcmV0dXJuIGF0dHJpYnV0ZTsgfTtcbiAgICBUcmFuc2Zvcm1WaXNpdG9yLnByb3RvdHlwZS52aXNpdEJvdW5kRXZlbnQgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7IHJldHVybiBhdHRyaWJ1dGU7IH07XG4gICAgVHJhbnNmb3JtVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIHRleHQ7IH07XG4gICAgVHJhbnNmb3JtVmlzaXRvci5wcm90b3R5cGUudmlzaXRCb3VuZFRleHQgPSBmdW5jdGlvbiAodGV4dCkgeyByZXR1cm4gdGV4dDsgfTtcbiAgICBUcmFuc2Zvcm1WaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UpIHsgcmV0dXJuIGljdTsgfTtcbiAgICByZXR1cm4gVHJhbnNmb3JtVmlzaXRvcjtcbn0oKSk7XG5mdW5jdGlvbiB2aXNpdEFsbCh2aXNpdG9yLCBub2Rlcykge1xuICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBpZiAodmlzaXRvci52aXNpdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgbm9kZXNfMSA9IF9fdmFsdWVzKG5vZGVzKSwgbm9kZXNfMV8xID0gbm9kZXNfMS5uZXh0KCk7ICFub2Rlc18xXzEuZG9uZTsgbm9kZXNfMV8xID0gbm9kZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IHZpc2l0b3IudmlzaXQobm9kZSkgfHwgbm9kZS52aXNpdCh2aXNpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzXzFfMSAmJiAhbm9kZXNfMV8xLmRvbmUgJiYgKF9hID0gbm9kZXNfMS5yZXR1cm4pKSBfYS5jYWxsKG5vZGVzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgbm9kZXNfMiA9IF9fdmFsdWVzKG5vZGVzKSwgbm9kZXNfMl8xID0gbm9kZXNfMi5uZXh0KCk7ICFub2Rlc18yXzEuZG9uZTsgbm9kZXNfMl8xID0gbm9kZXNfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IG5vZGUudmlzaXQodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKG5ld05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXNfMl8xICYmICFub2Rlc18yXzEuZG9uZSAmJiAoX2IgPSBub2Rlc18yLnJldHVybikpIF9iLmNhbGwobm9kZXNfMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUFsbCh2aXNpdG9yLCBub2Rlcykge1xuICAgIHZhciBlXzMsIF9hO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIG5vZGVzXzMgPSBfX3ZhbHVlcyhub2RlcyksIG5vZGVzXzNfMSA9IG5vZGVzXzMubmV4dCgpOyAhbm9kZXNfM18xLmRvbmU7IG5vZGVzXzNfMSA9IG5vZGVzXzMubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzXzNfMS52YWx1ZTtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlID0gbm9kZS52aXNpdCh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmIChuZXdOb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBuZXdOb2RlICE9IG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChub2Rlc18zXzEgJiYgIW5vZGVzXzNfMS5kb25lICYmIChfYSA9IG5vZGVzXzMucmV0dXJuKSkgX2EuY2FsbChub2Rlc18zKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkID8gcmVzdWx0IDogbm9kZXM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBNZXNzYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBub2RlcyBtZXNzYWdlIEFTVFxuICAgICAqIEBwYXJhbSBwbGFjZWhvbGRlcnMgbWFwcyBwbGFjZWhvbGRlciBuYW1lcyB0byBzdGF0aWMgY29udGVudFxuICAgICAqIEBwYXJhbSBwbGFjZWhvbGRlclRvTWVzc2FnZSBtYXBzIHBsYWNlaG9sZGVyIG5hbWVzIHRvIG1lc3NhZ2VzICh1c2VkIGZvciBuZXN0ZWQgSUNVIG1lc3NhZ2VzKVxuICAgICAqIEBwYXJhbSBtZWFuaW5nXG4gICAgICogQHBhcmFtIGRlc2NyaXB0aW9uXG4gICAgICogQHBhcmFtIGlkXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWVzc2FnZShub2RlcywgcGxhY2Vob2xkZXJzLCBwbGFjZWhvbGRlclRvTWVzc2FnZSwgbWVhbmluZywgZGVzY3JpcHRpb24sIGlkKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlcnMgPSBwbGFjZWhvbGRlcnM7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJUb01lc3NhZ2UgPSBwbGFjZWhvbGRlclRvTWVzc2FnZTtcbiAgICAgICAgdGhpcy5tZWFuaW5nID0gbWVhbmluZztcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlcyA9IFt7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYXRoOiBub2Rlc1swXS5zb3VyY2VTcGFuLnN0YXJ0LmZpbGUudXJsLFxuICAgICAgICAgICAgICAgICAgICBzdGFydExpbmU6IG5vZGVzWzBdLnNvdXJjZVNwYW4uc3RhcnQubGluZSArIDEsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sOiBub2Rlc1swXS5zb3VyY2VTcGFuLnN0YXJ0LmNvbCArIDEsXG4gICAgICAgICAgICAgICAgICAgIGVuZExpbmU6IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLnNvdXJjZVNwYW4uZW5kLmxpbmUgKyAxLFxuICAgICAgICAgICAgICAgICAgICBlbmRDb2w6IG5vZGVzWzBdLnNvdXJjZVNwYW4uc3RhcnQuY29sICsgMVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE1lc3NhZ2U7XG59KCkpO1xudmFyIFRleHQkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0KHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgVGV4dC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFRleHQ7XG59KCkpO1xuLy8gVE9ETyh2aWNiKTogZG8gd2UgcmVhbGx5IG5lZWQgdGhpcyBub2RlICh2cyBhbiBhcnJheSkgP1xudmFyIENvbnRhaW5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb250YWluZXIoY2hpbGRyZW4sIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBDb250YWluZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRDb250YWluZXIodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIENvbnRhaW5lcjtcbn0oKSk7XG52YXIgSWN1JDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSWN1KGV4cHJlc3Npb24sIHR5cGUsIGNhc2VzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgSWN1LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0SWN1KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBJY3U7XG59KCkpO1xudmFyIFRhZ1BsYWNlaG9sZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhZ1BsYWNlaG9sZGVyKHRhZywgYXR0cnMsIHN0YXJ0TmFtZSwgY2xvc2VOYW1lLCBjaGlsZHJlbiwgaXNWb2lkLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuc3RhcnROYW1lID0gc3RhcnROYW1lO1xuICAgICAgICB0aGlzLmNsb3NlTmFtZSA9IGNsb3NlTmFtZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmlzVm9pZCA9IGlzVm9pZDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgVGFnUGxhY2Vob2xkZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUYWdQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gVGFnUGxhY2Vob2xkZXI7XG59KCkpO1xudmFyIFBsYWNlaG9sZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBsYWNlaG9sZGVyKHZhbHVlLCBuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgUGxhY2Vob2xkZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gUGxhY2Vob2xkZXI7XG59KCkpO1xudmFyIEljdVBsYWNlaG9sZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEljdVBsYWNlaG9sZGVyKHZhbHVlLCBuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgSWN1UGxhY2Vob2xkZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRJY3VQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gSWN1UGxhY2Vob2xkZXI7XG59KCkpO1xuLy8gQ2xvbmUgdGhlIEFTVFxudmFyIENsb25lVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbG9uZVZpc2l0b3IoKSB7XG4gICAgfVxuICAgIENsb25lVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIG5ldyBUZXh0JDEodGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTsgfTtcbiAgICBDbG9uZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBjb250YWluZXIuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29udGFpbmVyKGNoaWxkcmVuLCBjb250YWluZXIuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBDbG9uZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2FzZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGNhc2VzW2tleV0gPSBpY3UuY2FzZXNba2V5XS52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICB2YXIgbXNnID0gbmV3IEljdSQxKGljdS5leHByZXNzaW9uLCBpY3UudHlwZSwgY2FzZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgbXNnLmV4cHJlc3Npb25QbGFjZWhvbGRlciA9IGljdS5leHByZXNzaW9uUGxhY2Vob2xkZXI7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfTtcbiAgICBDbG9uZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gcGguY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgVGFnUGxhY2Vob2xkZXIocGgudGFnLCBwaC5hdHRycywgcGguc3RhcnROYW1lLCBwaC5jbG9zZU5hbWUsIGNoaWxkcmVuLCBwaC5pc1ZvaWQsIHBoLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUGxhY2Vob2xkZXIocGgudmFsdWUsIHBoLm5hbWUsIHBoLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgSWN1UGxhY2Vob2xkZXIocGgudmFsdWUsIHBoLm5hbWUsIHBoLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIENsb25lVmlzaXRvcjtcbn0oKSk7XG4vLyBWaXNpdCBhbGwgdGhlIG5vZGVzIHJlY3Vyc2l2ZWx5XG52YXIgUmVjdXJzZVZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjdXJzZVZpc2l0b3IoKSB7XG4gICAgfVxuICAgIFJlY3Vyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyB9O1xuICAgIFJlY3Vyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC52aXNpdChfdGhpcyk7IH0pO1xuICAgIH07XG4gICAgUmVjdXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgaWN1LmNhc2VzW2tdLnZpc2l0KF90aGlzKTsgfSk7XG4gICAgfTtcbiAgICBSZWN1cnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBwaC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMpOyB9KTtcbiAgICB9O1xuICAgIFJlY3Vyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7IH07XG4gICAgUmVjdXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHsgfTtcbiAgICByZXR1cm4gUmVjdXJzZVZpc2l0b3I7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBkaWdlc3QobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmlkIHx8IHNoYTEoc2VyaWFsaXplTm9kZXMobWVzc2FnZS5ub2Rlcykuam9pbignJykgKyAoXCJbXCIgKyBtZXNzYWdlLm1lYW5pbmcgKyBcIl1cIikpO1xufVxuZnVuY3Rpb24gZGVjaW1hbERpZ2VzdChtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UuaWQpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UuaWQ7XG4gICAgfVxuICAgIHZhciB2aXNpdG9yID0gbmV3IF9TZXJpYWxpemVySWdub3JlSWN1RXhwVmlzaXRvcigpO1xuICAgIHZhciBwYXJ0cyA9IG1lc3NhZ2Uubm9kZXMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnZpc2l0KHZpc2l0b3IsIG51bGwpOyB9KTtcbiAgICByZXR1cm4gY29tcHV0ZU1zZ0lkKHBhcnRzLmpvaW4oJycpLCBtZXNzYWdlLm1lYW5pbmcpO1xufVxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGkxOG4gYXN0IHRvIHNvbWV0aGluZyB4bWwtbGlrZSBpbiBvcmRlciB0byBnZW5lcmF0ZSBhbiBVSUQuXG4gKlxuICogVGhlIHZpc2l0b3IgaXMgYWxzbyB1c2VkIGluIHRoZSBpMThuIHBhcnNlciB0ZXN0c1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgX1NlcmlhbGl6ZXJWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9TZXJpYWxpemVyVmlzaXRvcigpIHtcbiAgICB9XG4gICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gdGV4dC52YWx1ZTsgfTtcbiAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gXCJbXCIgKyBjb250YWluZXIuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMpOyB9KS5qb2luKCcsICcpICsgXCJdXCI7XG4gICAgfTtcbiAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3RyQ2FzZXMgPSBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gayArIFwiIHtcIiArIGljdS5jYXNlc1trXS52aXNpdChfdGhpcykgKyBcIn1cIjsgfSk7XG4gICAgICAgIHJldHVybiBcIntcIiArIGljdS5leHByZXNzaW9uICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIgKyBzdHJDYXNlcy5qb2luKCcsICcpICsgXCJ9XCI7XG4gICAgfTtcbiAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHBoLmlzVm9pZCA/XG4gICAgICAgICAgICBcIjxwaCB0YWcgbmFtZT1cXFwiXCIgKyBwaC5zdGFydE5hbWUgKyBcIlxcXCIvPlwiIDpcbiAgICAgICAgICAgIFwiPHBoIHRhZyBuYW1lPVxcXCJcIiArIHBoLnN0YXJ0TmFtZSArIFwiXFxcIj5cIiArIHBoLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnZpc2l0KF90aGlzKTsgfSkuam9pbignLCAnKSArIFwiPC9waCBuYW1lPVxcXCJcIiArIHBoLmNsb3NlTmFtZSArIFwiXFxcIj5cIjtcbiAgICB9O1xuICAgIF9TZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcGgudmFsdWUgPyBcIjxwaCBuYW1lPVxcXCJcIiArIHBoLm5hbWUgKyBcIlxcXCI+XCIgKyBwaC52YWx1ZSArIFwiPC9waD5cIiA6IFwiPHBoIG5hbWU9XFxcIlwiICsgcGgubmFtZSArIFwiXFxcIi8+XCI7XG4gICAgfTtcbiAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFwiPHBoIGljdSBuYW1lPVxcXCJcIiArIHBoLm5hbWUgKyBcIlxcXCI+XCIgKyBwaC52YWx1ZS52aXNpdCh0aGlzKSArIFwiPC9waD5cIjtcbiAgICB9O1xuICAgIHJldHVybiBfU2VyaWFsaXplclZpc2l0b3I7XG59KCkpO1xudmFyIHNlcmlhbGl6ZXJWaXNpdG9yID0gbmV3IF9TZXJpYWxpemVyVmlzaXRvcigpO1xuZnVuY3Rpb24gc2VyaWFsaXplTm9kZXMobm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnZpc2l0KHNlcmlhbGl6ZXJWaXNpdG9yLCBudWxsKTsgfSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgaTE4biBhc3QgdG8gc29tZXRoaW5nIHhtbC1saWtlIGluIG9yZGVyIHRvIGdlbmVyYXRlIGFuIFVJRC5cbiAqXG4gKiBJZ25vcmUgdGhlIElDVSBleHByZXNzaW9ucyBzbyB0aGF0IG1lc3NhZ2UgSURzIHN0YXlzIGlkZW50aWNhbCBpZiBvbmx5IHRoZSBleHByZXNzaW9uIGNoYW5nZXMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBfU2VyaWFsaXplcklnbm9yZUljdUV4cFZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9TZXJpYWxpemVySWdub3JlSWN1RXhwVmlzaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBfU2VyaWFsaXplcklnbm9yZUljdUV4cFZpc2l0b3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgX1NlcmlhbGl6ZXJJZ25vcmVJY3VFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN0ckNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGsgKyBcIiB7XCIgKyBpY3UuY2FzZXNba10udmlzaXQoX3RoaXMpICsgXCJ9XCI7IH0pO1xuICAgICAgICAvLyBEbyBub3QgdGFrZSB0aGUgZXhwcmVzc2lvbiBpbnRvIGFjY291bnRcbiAgICAgICAgcmV0dXJuIFwie1wiICsgaWN1LnR5cGUgKyBcIiwgXCIgKyBzdHJDYXNlcy5qb2luKCcsICcpICsgXCJ9XCI7XG4gICAgfTtcbiAgICByZXR1cm4gX1NlcmlhbGl6ZXJJZ25vcmVJY3VFeHBWaXNpdG9yO1xufShfU2VyaWFsaXplclZpc2l0b3IpKTtcbi8qKlxuICogQ29tcHV0ZSB0aGUgU0hBMSBvZiB0aGUgZ2l2ZW4gc3RyaW5nXG4gKlxuICogc2VlIGh0dHA6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9maXBzL2ZpcHMxODAtNC9maXBzLTE4MC00LnBkZlxuICpcbiAqIFdBUk5JTkc6IHRoaXMgZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGRlc2lnbmVkIG5vdCB0ZXN0ZWQgd2l0aCBzZWN1cml0eSBpbiBtaW5kLlxuICogICAgICAgICAgRE8gTk9UIFVTRSBJVCBJTiBBIFNFQ1VSSVRZIFNFTlNJVElWRSBDT05URVhULlxuICovXG5mdW5jdGlvbiBzaGExKHN0cikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdmFyIHV0ZjggPSB1dGY4RW5jb2RlKHN0cik7XG4gICAgdmFyIHdvcmRzMzIgPSBzdHJpbmdUb1dvcmRzMzIodXRmOCwgRW5kaWFuLkJpZyk7XG4gICAgdmFyIGxlbiA9IHV0ZjgubGVuZ3RoICogODtcbiAgICB2YXIgdyA9IG5ldyBBcnJheSg4MCk7XG4gICAgdmFyIF9jID0gX19yZWFkKFsweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwXSwgNSksIGEgPSBfY1swXSwgYiA9IF9jWzFdLCBjID0gX2NbMl0sIGQgPSBfY1szXSwgZSA9IF9jWzRdO1xuICAgIHdvcmRzMzJbbGVuID4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbGVuICUgMzIpO1xuICAgIHdvcmRzMzJbKChsZW4gKyA2NCA+PiA5KSA8PCA0KSArIDE1XSA9IGxlbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzMzIubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgIHZhciBfZCA9IF9fcmVhZChbYSwgYiwgYywgZCwgZV0sIDUpLCBoMCA9IF9kWzBdLCBoMSA9IF9kWzFdLCBoMiA9IF9kWzJdLCBoMyA9IF9kWzNdLCBoNCA9IF9kWzRdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChqIDwgMTYpIHtcbiAgICAgICAgICAgICAgICB3W2pdID0gd29yZHMzMltpICsgal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3W2pdID0gcm9sMzIod1tqIC0gM10gXiB3W2ogLSA4XSBeIHdbaiAtIDE0XSBeIHdbaiAtIDE2XSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2UgPSBfX3JlYWQoZmsoaiwgYiwgYywgZCksIDIpLCBmID0gX2VbMF0sIGsgPSBfZVsxXTtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gW3JvbDMyKGEsIDUpLCBmLCBlLCBrLCB3W2pdXS5yZWR1Y2UoYWRkMzIpO1xuICAgICAgICAgICAgX2EgPSBfX3JlYWQoW2QsIGMsIHJvbDMyKGIsIDMwKSwgYSwgdGVtcF0sIDUpLCBlID0gX2FbMF0sIGQgPSBfYVsxXSwgYyA9IF9hWzJdLCBiID0gX2FbM10sIGEgPSBfYVs0XTtcbiAgICAgICAgfVxuICAgICAgICBfYiA9IF9fcmVhZChbYWRkMzIoYSwgaDApLCBhZGQzMihiLCBoMSksIGFkZDMyKGMsIGgyKSwgYWRkMzIoZCwgaDMpLCBhZGQzMihlLCBoNCldLCA1KSwgYSA9IF9iWzBdLCBiID0gX2JbMV0sIGMgPSBfYlsyXSwgZCA9IF9iWzNdLCBlID0gX2JbNF07XG4gICAgfVxuICAgIHJldHVybiBieXRlU3RyaW5nVG9IZXhTdHJpbmcod29yZHMzMlRvQnl0ZVN0cmluZyhbYSwgYiwgYywgZCwgZV0pKTtcbn1cbmZ1bmN0aW9uIGZrKGluZGV4LCBiLCBjLCBkKSB7XG4gICAgaWYgKGluZGV4IDwgMjApIHtcbiAgICAgICAgcmV0dXJuIFsoYiAmIGMpIHwgKH5iICYgZCksIDB4NWE4Mjc5OTldO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCA0MCkge1xuICAgICAgICByZXR1cm4gW2IgXiBjIF4gZCwgMHg2ZWQ5ZWJhMV07XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDYwKSB7XG4gICAgICAgIHJldHVybiBbKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpLCAweDhmMWJiY2RjXTtcbiAgICB9XG4gICAgcmV0dXJuIFtiIF4gYyBeIGQsIDB4Y2E2MmMxZDZdO1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBmaW5nZXJwcmludCBvZiB0aGUgZ2l2ZW4gc3RyaW5nXG4gKlxuICogVGhlIG91dHB1dCBpcyA2NCBiaXQgbnVtYmVyIGVuY29kZWQgYXMgYSBkZWNpbWFsIHN0cmluZ1xuICpcbiAqIGJhc2VkIG9uOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2Jsb2IvbWFzdGVyL3NyYy9jb20vZ29vZ2xlL2phdmFzY3JpcHQvanNjb21wL0dvb2dsZUpzTWVzc2FnZUlkR2VuZXJhdG9yLmphdmFcbiAqL1xuZnVuY3Rpb24gZmluZ2VycHJpbnQoc3RyKSB7XG4gICAgdmFyIHV0ZjggPSB1dGY4RW5jb2RlKHN0cik7XG4gICAgdmFyIF9hID0gX19yZWFkKFtoYXNoMzIodXRmOCwgMCksIGhhc2gzMih1dGY4LCAxMDIwNzIpXSwgMiksIGhpID0gX2FbMF0sIGxvID0gX2FbMV07XG4gICAgaWYgKGhpID09IDAgJiYgKGxvID09IDAgfHwgbG8gPT0gMSkpIHtcbiAgICAgICAgaGkgPSBoaSBeIDB4MTMwZjliZWY7XG4gICAgICAgIGxvID0gbG8gXiAtMHg2YjVmNTZkODtcbiAgICB9XG4gICAgcmV0dXJuIFtoaSwgbG9dO1xufVxuZnVuY3Rpb24gY29tcHV0ZU1zZ0lkKG1zZywgbWVhbmluZykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgX2IgPSBfX3JlYWQoZmluZ2VycHJpbnQobXNnKSwgMiksIGhpID0gX2JbMF0sIGxvID0gX2JbMV07XG4gICAgaWYgKG1lYW5pbmcpIHtcbiAgICAgICAgdmFyIF9jID0gX19yZWFkKGZpbmdlcnByaW50KG1lYW5pbmcpLCAyKSwgaGltID0gX2NbMF0sIGxvbSA9IF9jWzFdO1xuICAgICAgICBfYSA9IF9fcmVhZChhZGQ2NChyb2w2NChbaGksIGxvXSwgMSksIFtoaW0sIGxvbV0pLCAyKSwgaGkgPSBfYVswXSwgbG8gPSBfYVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVTdHJpbmdUb0RlY1N0cmluZyh3b3JkczMyVG9CeXRlU3RyaW5nKFtoaSAmIDB4N2ZmZmZmZmYsIGxvXSkpO1xufVxuZnVuY3Rpb24gaGFzaDMyKHN0ciwgYykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgX2IgPSBfX3JlYWQoWzB4OWUzNzc5YjksIDB4OWUzNzc5YjldLCAyKSwgYSA9IF9iWzBdLCBiID0gX2JbMV07XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSArIDEyIDw9IGxlbjsgaSArPSAxMikge1xuICAgICAgICBhID0gYWRkMzIoYSwgd29yZEF0KHN0ciwgaSwgRW5kaWFuLkxpdHRsZSkpO1xuICAgICAgICBiID0gYWRkMzIoYiwgd29yZEF0KHN0ciwgaSArIDQsIEVuZGlhbi5MaXR0bGUpKTtcbiAgICAgICAgYyA9IGFkZDMyKGMsIHdvcmRBdChzdHIsIGkgKyA4LCBFbmRpYW4uTGl0dGxlKSk7XG4gICAgICAgIF9hID0gX19yZWFkKG1peChbYSwgYiwgY10pLCAzKSwgYSA9IF9hWzBdLCBiID0gX2FbMV0sIGMgPSBfYVsyXTtcbiAgICB9XG4gICAgYSA9IGFkZDMyKGEsIHdvcmRBdChzdHIsIGksIEVuZGlhbi5MaXR0bGUpKTtcbiAgICBiID0gYWRkMzIoYiwgd29yZEF0KHN0ciwgaSArIDQsIEVuZGlhbi5MaXR0bGUpKTtcbiAgICAvLyB0aGUgZmlyc3QgYnl0ZSBvZiBjIGlzIHJlc2VydmVkIGZvciB0aGUgbGVuZ3RoXG4gICAgYyA9IGFkZDMyKGMsIGxlbik7XG4gICAgYyA9IGFkZDMyKGMsIHdvcmRBdChzdHIsIGkgKyA4LCBFbmRpYW4uTGl0dGxlKSA8PCA4KTtcbiAgICByZXR1cm4gbWl4KFthLCBiLCBjXSlbMl07XG59XG4vLyBjbGFuZy1mb3JtYXQgb2ZmXG5mdW5jdGlvbiBtaXgoX2EpIHtcbiAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDMpLCBhID0gX2JbMF0sIGIgPSBfYlsxXSwgYyA9IF9iWzJdO1xuICAgIGEgPSBzdWIzMihhLCBiKTtcbiAgICBhID0gc3ViMzIoYSwgYyk7XG4gICAgYSBePSBjID4+PiAxMztcbiAgICBiID0gc3ViMzIoYiwgYyk7XG4gICAgYiA9IHN1YjMyKGIsIGEpO1xuICAgIGIgXj0gYSA8PCA4O1xuICAgIGMgPSBzdWIzMihjLCBhKTtcbiAgICBjID0gc3ViMzIoYywgYik7XG4gICAgYyBePSBiID4+PiAxMztcbiAgICBhID0gc3ViMzIoYSwgYik7XG4gICAgYSA9IHN1YjMyKGEsIGMpO1xuICAgIGEgXj0gYyA+Pj4gMTI7XG4gICAgYiA9IHN1YjMyKGIsIGMpO1xuICAgIGIgPSBzdWIzMihiLCBhKTtcbiAgICBiIF49IGEgPDwgMTY7XG4gICAgYyA9IHN1YjMyKGMsIGEpO1xuICAgIGMgPSBzdWIzMihjLCBiKTtcbiAgICBjIF49IGIgPj4+IDU7XG4gICAgYSA9IHN1YjMyKGEsIGIpO1xuICAgIGEgPSBzdWIzMihhLCBjKTtcbiAgICBhIF49IGMgPj4+IDM7XG4gICAgYiA9IHN1YjMyKGIsIGMpO1xuICAgIGIgPSBzdWIzMihiLCBhKTtcbiAgICBiIF49IGEgPDwgMTA7XG4gICAgYyA9IHN1YjMyKGMsIGEpO1xuICAgIGMgPSBzdWIzMihjLCBiKTtcbiAgICBjIF49IGIgPj4+IDE1O1xuICAgIHJldHVybiBbYSwgYiwgY107XG59XG4vLyBjbGFuZy1mb3JtYXQgb25cbi8vIFV0aWxzXG52YXIgRW5kaWFuO1xuKGZ1bmN0aW9uIChFbmRpYW4pIHtcbiAgICBFbmRpYW5bRW5kaWFuW1wiTGl0dGxlXCJdID0gMF0gPSBcIkxpdHRsZVwiO1xuICAgIEVuZGlhbltFbmRpYW5bXCJCaWdcIl0gPSAxXSA9IFwiQmlnXCI7XG59KShFbmRpYW4gfHwgKEVuZGlhbiA9IHt9KSk7XG5mdW5jdGlvbiBhZGQzMihhLCBiKSB7XG4gICAgcmV0dXJuIGFkZDMydG82NChhLCBiKVsxXTtcbn1cbmZ1bmN0aW9uIGFkZDMydG82NChhLCBiKSB7XG4gICAgdmFyIGxvdyA9IChhICYgMHhmZmZmKSArIChiICYgMHhmZmZmKTtcbiAgICB2YXIgaGlnaCA9IChhID4+PiAxNikgKyAoYiA+Pj4gMTYpICsgKGxvdyA+Pj4gMTYpO1xuICAgIHJldHVybiBbaGlnaCA+Pj4gMTYsIChoaWdoIDw8IDE2KSB8IChsb3cgJiAweGZmZmYpXTtcbn1cbmZ1bmN0aW9uIGFkZDY0KF9hLCBfYikge1xuICAgIHZhciBfYyA9IF9fcmVhZChfYSwgMiksIGFoID0gX2NbMF0sIGFsID0gX2NbMV07XG4gICAgdmFyIF9kID0gX19yZWFkKF9iLCAyKSwgYmggPSBfZFswXSwgYmwgPSBfZFsxXTtcbiAgICB2YXIgX2UgPSBfX3JlYWQoYWRkMzJ0bzY0KGFsLCBibCksIDIpLCBjYXJyeSA9IF9lWzBdLCBsID0gX2VbMV07XG4gICAgdmFyIGggPSBhZGQzMihhZGQzMihhaCwgYmgpLCBjYXJyeSk7XG4gICAgcmV0dXJuIFtoLCBsXTtcbn1cbmZ1bmN0aW9uIHN1YjMyKGEsIGIpIHtcbiAgICB2YXIgbG93ID0gKGEgJiAweGZmZmYpIC0gKGIgJiAweGZmZmYpO1xuICAgIHZhciBoaWdoID0gKGEgPj4gMTYpIC0gKGIgPj4gMTYpICsgKGxvdyA+PiAxNik7XG4gICAgcmV0dXJuIChoaWdoIDw8IDE2KSB8IChsb3cgJiAweGZmZmYpO1xufVxuLy8gUm90YXRlIGEgMzJiIG51bWJlciBsZWZ0IGBjb3VudGAgcG9zaXRpb25cbmZ1bmN0aW9uIHJvbDMyKGEsIGNvdW50KSB7XG4gICAgcmV0dXJuIChhIDw8IGNvdW50KSB8IChhID4+PiAoMzIgLSBjb3VudCkpO1xufVxuLy8gUm90YXRlIGEgNjRiIG51bWJlciBsZWZ0IGBjb3VudGAgcG9zaXRpb25cbmZ1bmN0aW9uIHJvbDY0KF9hLCBjb3VudCkge1xuICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIGhpID0gX2JbMF0sIGxvID0gX2JbMV07XG4gICAgdmFyIGggPSAoaGkgPDwgY291bnQpIHwgKGxvID4+PiAoMzIgLSBjb3VudCkpO1xuICAgIHZhciBsID0gKGxvIDw8IGNvdW50KSB8IChoaSA+Pj4gKDMyIC0gY291bnQpKTtcbiAgICByZXR1cm4gW2gsIGxdO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9Xb3JkczMyKHN0ciwgZW5kaWFuKSB7XG4gICAgdmFyIHdvcmRzMzIgPSBBcnJheSgoc3RyLmxlbmd0aCArIDMpID4+PiAyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzMzIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd29yZHMzMltpXSA9IHdvcmRBdChzdHIsIGkgKiA0LCBlbmRpYW4pO1xuICAgIH1cbiAgICByZXR1cm4gd29yZHMzMjtcbn1cbmZ1bmN0aW9uIGJ5dGVBdChzdHIsIGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID49IHN0ci5sZW5ndGggPyAwIDogc3RyLmNoYXJDb2RlQXQoaW5kZXgpICYgMHhmZjtcbn1cbmZ1bmN0aW9uIHdvcmRBdChzdHIsIGluZGV4LCBlbmRpYW4pIHtcbiAgICB2YXIgd29yZCA9IDA7XG4gICAgaWYgKGVuZGlhbiA9PT0gRW5kaWFuLkJpZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgd29yZCArPSBieXRlQXQoc3RyLCBpbmRleCArIGkpIDw8ICgyNCAtIDggKiBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHdvcmQgKz0gYnl0ZUF0KHN0ciwgaW5kZXggKyBpKSA8PCA4ICogaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd29yZDtcbn1cbmZ1bmN0aW9uIHdvcmRzMzJUb0J5dGVTdHJpbmcod29yZHMzMikge1xuICAgIHJldHVybiB3b3JkczMyLnJlZHVjZShmdW5jdGlvbiAoc3RyLCB3b3JkKSB7IHJldHVybiBzdHIgKyB3b3JkMzJUb0J5dGVTdHJpbmcod29yZCk7IH0sICcnKTtcbn1cbmZ1bmN0aW9uIHdvcmQzMlRvQnl0ZVN0cmluZyh3b3JkKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCh3b3JkID4+PiA4ICogKDMgLSBpKSkgJiAweGZmKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGJ5dGVTdHJpbmdUb0hleFN0cmluZyhzdHIpIHtcbiAgICB2YXIgaGV4ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGIgPSBieXRlQXQoc3RyLCBpKTtcbiAgICAgICAgaGV4ICs9IChiID4+PiA0KS50b1N0cmluZygxNikgKyAoYiAmIDB4MGYpLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIGhleC50b0xvd2VyQ2FzZSgpO1xufVxuLy8gYmFzZWQgb24gaHR0cDovL3d3dy5kYW52ay5vcmcvaGV4MmRlYy5odG1sIChKUyBjYW4gbm90IGhhbmRsZSBtb3JlIHRoYW4gNTZiKVxuZnVuY3Rpb24gYnl0ZVN0cmluZ1RvRGVjU3RyaW5nKHN0cikge1xuICAgIHZhciBkZWNpbWFsID0gJyc7XG4gICAgdmFyIHRvVGhlUG93ZXIgPSAnMSc7XG4gICAgZm9yICh2YXIgaSA9IHN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBkZWNpbWFsID0gYWRkQmlnSW50KGRlY2ltYWwsIG51bWJlclRpbWVzQmlnSW50KGJ5dGVBdChzdHIsIGkpLCB0b1RoZVBvd2VyKSk7XG4gICAgICAgIHRvVGhlUG93ZXIgPSBudW1iZXJUaW1lc0JpZ0ludCgyNTYsIHRvVGhlUG93ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjaW1hbC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xufVxuLy8geCBhbmQgeSBkZWNpbWFsLCBsb3dlc3Qgc2lnbmlmaWNhbnQgZGlnaXQgZmlyc3RcbmZ1bmN0aW9uIGFkZEJpZ0ludCh4LCB5KSB7XG4gICAgdmFyIHN1bSA9ICcnO1xuICAgIHZhciBsZW4gPSBNYXRoLm1heCh4Lmxlbmd0aCwgeS5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBjYXJyeSA9IDA7IGkgPCBsZW4gfHwgY2Fycnk7IGkrKykge1xuICAgICAgICB2YXIgdG1wU3VtID0gY2FycnkgKyArKHhbaV0gfHwgMCkgKyArKHlbaV0gfHwgMCk7XG4gICAgICAgIGlmICh0bXBTdW0gPj0gMTApIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gMTtcbiAgICAgICAgICAgIHN1bSArPSB0bXBTdW0gLSAxMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgICAgIHN1bSArPSB0bXBTdW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cbmZ1bmN0aW9uIG51bWJlclRpbWVzQmlnSW50KG51bSwgYikge1xuICAgIHZhciBwcm9kdWN0ID0gJyc7XG4gICAgdmFyIGJUb1RoZVBvd2VyID0gYjtcbiAgICBmb3IgKDsgbnVtICE9PSAwOyBudW0gPSBudW0gPj4+IDEpIHtcbiAgICAgICAgaWYgKG51bSAmIDEpXG4gICAgICAgICAgICBwcm9kdWN0ID0gYWRkQmlnSW50KHByb2R1Y3QsIGJUb1RoZVBvd2VyKTtcbiAgICAgICAgYlRvVGhlUG93ZXIgPSBhZGRCaWdJbnQoYlRvVGhlUG93ZXIsIGJUb1RoZVBvd2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2R1Y3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBTZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcmlhbGl6ZXIoKSB7XG4gICAgfVxuICAgIC8vIENyZWF0ZXMgYSBuYW1lIG1hcHBlciwgc2VlIGBQbGFjZWhvbGRlck1hcHBlcmBcbiAgICAvLyBSZXR1cm5pbmcgYG51bGxgIG1lYW5zIHRoYXQgbm8gbmFtZSBtYXBwaW5nIGlzIHVzZWQuXG4gICAgU2VyaWFsaXplci5wcm90b3R5cGUuY3JlYXRlTmFtZU1hcHBlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBudWxsOyB9O1xuICAgIHJldHVybiBTZXJpYWxpemVyO1xufSgpKTtcbi8qKlxuICogQSBzaW1wbGUgbWFwcGVyIHRoYXQgdGFrZSBhIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBhbiBpbnRlcm5hbCBuYW1lIHRvIGEgcHVibGljIG5hbWVcbiAqL1xudmFyIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaW1wbGVQbGFjZWhvbGRlck1hcHBlciwgX3N1cGVyKTtcbiAgICAvLyBjcmVhdGUgYSBtYXBwaW5nIGZyb20gdGhlIG1lc3NhZ2VcbiAgICBmdW5jdGlvbiBTaW1wbGVQbGFjZWhvbGRlck1hcHBlcihtZXNzYWdlLCBtYXBOYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1hcE5hbWUgPSBtYXBOYW1lO1xuICAgICAgICBfdGhpcy5pbnRlcm5hbFRvUHVibGljID0ge307XG4gICAgICAgIF90aGlzLnB1YmxpY1RvTmV4dElkID0ge307XG4gICAgICAgIF90aGlzLnB1YmxpY1RvSW50ZXJuYWwgPSB7fTtcbiAgICAgICAgbWVzc2FnZS5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIucHJvdG90eXBlLnRvUHVibGljTmFtZSA9IGZ1bmN0aW9uIChpbnRlcm5hbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxUb1B1YmxpYy5oYXNPd25Qcm9wZXJ0eShpbnRlcm5hbE5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxUb1B1YmxpY1tpbnRlcm5hbE5hbWVdIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfTtcbiAgICBTaW1wbGVQbGFjZWhvbGRlck1hcHBlci5wcm90b3R5cGUudG9JbnRlcm5hbE5hbWUgPSBmdW5jdGlvbiAocHVibGljTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNUb0ludGVybmFsLmhhc093blByb3BlcnR5KHB1YmxpY05hbWUpID8gdGhpcy5wdWJsaWNUb0ludGVybmFsW3B1YmxpY05hbWVdIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfTtcbiAgICBTaW1wbGVQbGFjZWhvbGRlck1hcHBlci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdFBsYWNlaG9sZGVyTmFtZShwaC5zdGFydE5hbWUpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIuY2FsbCh0aGlzLCBwaCwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRQbGFjZWhvbGRlck5hbWUocGguY2xvc2VOYW1lKTtcbiAgICB9O1xuICAgIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7IHRoaXMudmlzaXRQbGFjZWhvbGRlck5hbWUocGgubmFtZSk7IH07XG4gICAgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdFBsYWNlaG9sZGVyTmFtZShwaC5uYW1lKTtcbiAgICB9O1xuICAgIC8vIFhNQiBwbGFjZWhvbGRlcnMgY291bGQgb25seSBjb250YWlucyBBLVosIDAtOSBhbmQgX1xuICAgIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyTmFtZSA9IGZ1bmN0aW9uIChpbnRlcm5hbE5hbWUpIHtcbiAgICAgICAgaWYgKCFpbnRlcm5hbE5hbWUgfHwgdGhpcy5pbnRlcm5hbFRvUHVibGljLmhhc093blByb3BlcnR5KGludGVybmFsTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHVibGljTmFtZSA9IHRoaXMubWFwTmFtZShpbnRlcm5hbE5hbWUpO1xuICAgICAgICBpZiAodGhpcy5wdWJsaWNUb0ludGVybmFsLmhhc093blByb3BlcnR5KHB1YmxpY05hbWUpKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgWE1CIHdoZW4gaXQgaGFzIGFscmVhZHkgYmVlbiB1c2VkXG4gICAgICAgICAgICB2YXIgbmV4dElkID0gdGhpcy5wdWJsaWNUb05leHRJZFtwdWJsaWNOYW1lXTtcbiAgICAgICAgICAgIHRoaXMucHVibGljVG9OZXh0SWRbcHVibGljTmFtZV0gPSBuZXh0SWQgKyAxO1xuICAgICAgICAgICAgcHVibGljTmFtZSA9IHB1YmxpY05hbWUgKyBcIl9cIiArIG5leHRJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHVibGljVG9OZXh0SWRbcHVibGljTmFtZV0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJuYWxUb1B1YmxpY1tpbnRlcm5hbE5hbWVdID0gcHVibGljTmFtZTtcbiAgICAgICAgdGhpcy5wdWJsaWNUb0ludGVybmFsW3B1YmxpY05hbWVdID0gaW50ZXJuYWxOYW1lO1xuICAgIH07XG4gICAgcmV0dXJuIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyO1xufShSZWN1cnNlVmlzaXRvcikpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX1Zpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX1Zpc2l0b3IoKSB7XG4gICAgfVxuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN0ckF0dHJzID0gdGhpcy5fc2VyaWFsaXplQXR0cmlidXRlcyh0YWcuYXR0cnMpO1xuICAgICAgICBpZiAodGFnLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCI8XCIgKyB0YWcubmFtZSArIHN0ckF0dHJzICsgXCIvPlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJDaGlsZHJlbiA9IHRhZy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KTtcbiAgICAgICAgcmV0dXJuIFwiPFwiICsgdGFnLm5hbWUgKyBzdHJBdHRycyArIFwiPlwiICsgc3RyQ2hpbGRyZW4uam9pbignJykgKyBcIjwvXCIgKyB0YWcubmFtZSArIFwiPlwiO1xuICAgIH07XG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiB0ZXh0LnZhbHVlOyB9O1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGRlY2wpIHtcbiAgICAgICAgcmV0dXJuIFwiPD94bWxcIiArIHRoaXMuX3NlcmlhbGl6ZUF0dHJpYnV0ZXMoZGVjbC5hdHRycykgKyBcIiA/PlwiO1xuICAgIH07XG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl9zZXJpYWxpemVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJzKSB7XG4gICAgICAgIHZhciBzdHJBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWUgKyBcIj1cXFwiXCIgKyBhdHRyc1tuYW1lXSArIFwiXFxcIlwiOyB9KS5qb2luKCcgJyk7XG4gICAgICAgIHJldHVybiBzdHJBdHRycy5sZW5ndGggPiAwID8gJyAnICsgc3RyQXR0cnMgOiAnJztcbiAgICB9O1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdERvY3R5cGUgPSBmdW5jdGlvbiAoZG9jdHlwZSkge1xuICAgICAgICByZXR1cm4gXCI8IURPQ1RZUEUgXCIgKyBkb2N0eXBlLnJvb3RUYWcgKyBcIiBbXFxuXCIgKyBkb2N0eXBlLmR0ZCArIFwiXFxuXT5cIjtcbiAgICB9O1xuICAgIHJldHVybiBfVmlzaXRvcjtcbn0oKSk7XG52YXIgX3Zpc2l0b3IgPSBuZXcgX1Zpc2l0b3IoKTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZShub2Rlcykge1xuICAgIHJldHVybiBub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3Zpc2l0b3IpOyB9KS5qb2luKCcnKTtcbn1cbnZhciBEZWNsYXJhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWNsYXJhdGlvbih1bmVzY2FwZWRBdHRycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHVuZXNjYXBlZEF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBfdGhpcy5hdHRyc1trXSA9IGVzY2FwZVhtbCh1bmVzY2FwZWRBdHRyc1trXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBEZWNsYXJhdGlvbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdERlY2xhcmF0aW9uKHRoaXMpOyB9O1xuICAgIHJldHVybiBEZWNsYXJhdGlvbjtcbn0oKSk7XG52YXIgRG9jdHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb2N0eXBlKHJvb3RUYWcsIGR0ZCkge1xuICAgICAgICB0aGlzLnJvb3RUYWcgPSByb290VGFnO1xuICAgICAgICB0aGlzLmR0ZCA9IGR0ZDtcbiAgICB9XG4gICAgRG9jdHlwZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdERvY3R5cGUodGhpcyk7IH07XG4gICAgcmV0dXJuIERvY3R5cGU7XG59KCkpO1xudmFyIFRhZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWcobmFtZSwgdW5lc2NhcGVkQXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh1bmVzY2FwZWRBdHRycyA9PT0gdm9pZCAwKSB7IHVuZXNjYXBlZEF0dHJzID0ge307IH1cbiAgICAgICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHsgY2hpbGRyZW4gPSBbXTsgfVxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuYXR0cnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModW5lc2NhcGVkQXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIF90aGlzLmF0dHJzW2tdID0gZXNjYXBlWG1sKHVuZXNjYXBlZEF0dHJzW2tdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFRhZy5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdFRhZyh0aGlzKTsgfTtcbiAgICByZXR1cm4gVGFnO1xufSgpKTtcbnZhciBUZXh0JDIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGV4dCh1bmVzY2FwZWRWYWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gZXNjYXBlWG1sKHVuZXNjYXBlZFZhbHVlKTtcbiAgICB9XG4gICAgVGV4dC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcyk7IH07XG4gICAgcmV0dXJuIFRleHQ7XG59KCkpO1xudmFyIENSID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDUiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDUih3cykge1xuICAgICAgICBpZiAod3MgPT09IHZvaWQgMCkgeyB3cyA9IDA7IH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiXFxuXCIgKyBuZXcgQXJyYXkod3MgKyAxKS5qb2luKCcgJykpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDUjtcbn0oVGV4dCQyKSk7XG52YXIgX0VTQ0FQRURfQ0hBUlMgPSBbXG4gICAgWy8mL2csICcmYW1wOyddLFxuICAgIFsvXCIvZywgJyZxdW90OyddLFxuICAgIFsvJy9nLCAnJmFwb3M7J10sXG4gICAgWy88L2csICcmbHQ7J10sXG4gICAgWy8+L2csICcmZ3Q7J10sXG5dO1xuLy8gRXNjYXBlIGBfRVNDQVBFRF9DSEFSU2AgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gdGV4dCB3aXRoIGVuY29kZWQgZW50aXRpZXNcbmZ1bmN0aW9uIGVzY2FwZVhtbCh0ZXh0KSB7XG4gICAgcmV0dXJuIF9FU0NBUEVEX0NIQVJTLnJlZHVjZShmdW5jdGlvbiAodGV4dCwgZW50cnkpIHsgcmV0dXJuIHRleHQucmVwbGFjZShlbnRyeVswXSwgZW50cnlbMV0pOyB9LCB0ZXh0KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9NRVNTQUdFU19UQUcgPSAnbWVzc2FnZWJ1bmRsZSc7XG52YXIgX01FU1NBR0VfVEFHID0gJ21zZyc7XG52YXIgX1BMQUNFSE9MREVSX1RBRyA9ICdwaCc7XG52YXIgX0VYQU1QTEVfVEFHID0gJ2V4JztcbnZhciBfU09VUkNFX1RBRyA9ICdzb3VyY2UnO1xudmFyIF9ET0NUWVBFID0gXCI8IUVMRU1FTlQgbWVzc2FnZWJ1bmRsZSAobXNnKSo+XFxuPCFBVFRMSVNUIG1lc3NhZ2VidW5kbGUgY2xhc3MgQ0RBVEEgI0lNUExJRUQ+XFxuXFxuPCFFTEVNRU5UIG1zZyAoI1BDREFUQXxwaHxzb3VyY2UpKj5cXG48IUFUVExJU1QgbXNnIGlkIENEQVRBICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgc2VxIENEQVRBICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgbmFtZSBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIGRlc2MgQ0RBVEEgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyBtZWFuaW5nIENEQVRBICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgb2Jzb2xldGUgKG9ic29sZXRlKSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIHhtbDpzcGFjZSAoZGVmYXVsdHxwcmVzZXJ2ZSkgXFxcImRlZmF1bHRcXFwiPlxcbjwhQVRUTElTVCBtc2cgaXNfaGlkZGVuIENEQVRBICNJTVBMSUVEPlxcblxcbjwhRUxFTUVOVCBzb3VyY2UgKCNQQ0RBVEEpPlxcblxcbjwhRUxFTUVOVCBwaCAoI1BDREFUQXxleCkqPlxcbjwhQVRUTElTVCBwaCBuYW1lIENEQVRBICNSRVFVSVJFRD5cXG5cXG48IUVMRU1FTlQgZXggKCNQQ0RBVEEpPlwiO1xudmFyIFhtYiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWG1iLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFhtYigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBYbWIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGV4YW1wbGVWaXNpdG9yID0gbmV3IEV4YW1wbGVWaXNpdG9yKCk7XG4gICAgICAgIHZhciB2aXNpdG9yID0gbmV3IF9WaXNpdG9yJDEoKTtcbiAgICAgICAgdmFyIHJvb3ROb2RlID0gbmV3IFRhZyhfTUVTU0FHRVNfVEFHKTtcbiAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIGF0dHJzID0geyBpZDogbWVzc2FnZS5pZCB9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBhdHRyc1snZGVzYyddID0gbWVzc2FnZS5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICBhdHRyc1snbWVhbmluZyddID0gbWVzc2FnZS5tZWFuaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNvdXJjZVRhZ3MgPSBbXTtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VUYWdzLnB1c2gobmV3IFRhZyhfU09VUkNFX1RBRywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFRleHQkMihzb3VyY2UuZmlsZVBhdGggKyBcIjpcIiArIHNvdXJjZS5zdGFydExpbmUgKyAoc291cmNlLmVuZExpbmUgIT09IHNvdXJjZS5zdGFydExpbmUgPyAnLCcgKyBzb3VyY2UuZW5kTGluZSA6ICcnKSlcbiAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJvb3ROb2RlLmNoaWxkcmVuLnB1c2gobmV3IENSKDIpLCBuZXcgVGFnKF9NRVNTQUdFX1RBRywgYXR0cnMsIF9fc3ByZWFkKHNvdXJjZVRhZ3MsIHZpc2l0b3Iuc2VyaWFsaXplKG1lc3NhZ2Uubm9kZXMpKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcm9vdE5vZGUuY2hpbGRyZW4ucHVzaChuZXcgQ1IoKSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemUoW1xuICAgICAgICAgICAgbmV3IERlY2xhcmF0aW9uKHsgdmVyc2lvbjogJzEuMCcsIGVuY29kaW5nOiAnVVRGLTgnIH0pLFxuICAgICAgICAgICAgbmV3IENSKCksXG4gICAgICAgICAgICBuZXcgRG9jdHlwZShfTUVTU0FHRVNfVEFHLCBfRE9DVFlQRSksXG4gICAgICAgICAgICBuZXcgQ1IoKSxcbiAgICAgICAgICAgIGV4YW1wbGVWaXNpdG9yLmFkZERlZmF1bHRFeGFtcGxlcyhyb290Tm9kZSksXG4gICAgICAgICAgICBuZXcgQ1IoKSxcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICBYbWIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY29udGVudCwgdXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQnKTtcbiAgICB9O1xuICAgIFhtYi5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIGRpZ2VzdCQxKG1lc3NhZ2UpOyB9O1xuICAgIFhtYi5wcm90b3R5cGUuY3JlYXRlTmFtZU1hcHBlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIobWVzc2FnZSwgdG9QdWJsaWNOYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBYbWI7XG59KFNlcmlhbGl6ZXIpKTtcbnZhciBfVmlzaXRvciQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9WaXNpdG9yKCkge1xuICAgIH1cbiAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIFtuZXcgVGV4dCQyKHRleHQudmFsdWUpXTsgfTtcbiAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICBjb250YWluZXIuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZXMucHVzaC5hcHBseShub2RlcywgX19zcHJlYWQobm9kZS52aXNpdChfdGhpcykpKTsgfSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9O1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5vZGVzID0gW25ldyBUZXh0JDIoXCJ7XCIgKyBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIpXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBfX3NwcmVhZChbbmV3IFRleHQkMihjICsgXCIge1wiKV0sIGljdS5jYXNlc1tjXS52aXNpdChfdGhpcyksIFtuZXcgVGV4dCQyKFwifSBcIildKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDIoXCJ9XCIpKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHN0YXJ0VGFnQXNUZXh0ID0gbmV3IFRleHQkMihcIjxcIiArIHBoLnRhZyArIFwiPlwiKTtcbiAgICAgICAgdmFyIHN0YXJ0RXggPSBuZXcgVGFnKF9FWEFNUExFX1RBRywge30sIFtzdGFydFRhZ0FzVGV4dF0pO1xuICAgICAgICAvLyBUQyByZXF1aXJlcyBQSCB0byBoYXZlIGEgbm9uIGVtcHR5IEVYLCBhbmQgdXNlcyB0aGUgdGV4dCBub2RlIHRvIHNob3cgdGhlIFwib3JpZ2luYWxcIiB2YWx1ZS5cbiAgICAgICAgdmFyIHN0YXJ0VGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUcsIHsgbmFtZTogcGguc3RhcnROYW1lIH0sIFtzdGFydEV4LCBzdGFydFRhZ0FzVGV4dF0pO1xuICAgICAgICBpZiAocGguaXNWb2lkKSB7XG4gICAgICAgICAgICAvLyB2b2lkIHRhZ3MgaGF2ZSBubyBjaGlsZHJlbiBub3IgY2xvc2luZyB0YWdzXG4gICAgICAgICAgICByZXR1cm4gW3N0YXJ0VGFnUGhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbG9zZVRhZ0FzVGV4dCA9IG5ldyBUZXh0JDIoXCI8L1wiICsgcGgudGFnICsgXCI+XCIpO1xuICAgICAgICB2YXIgY2xvc2VFeCA9IG5ldyBUYWcoX0VYQU1QTEVfVEFHLCB7fSwgW2Nsb3NlVGFnQXNUZXh0XSk7XG4gICAgICAgIC8vIFRDIHJlcXVpcmVzIFBIIHRvIGhhdmUgYSBub24gZW1wdHkgRVgsIGFuZCB1c2VzIHRoZSB0ZXh0IG5vZGUgdG8gc2hvdyB0aGUgXCJvcmlnaW5hbFwiIHZhbHVlLlxuICAgICAgICB2YXIgY2xvc2VUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRywgeyBuYW1lOiBwaC5jbG9zZU5hbWUgfSwgW2Nsb3NlRXgsIGNsb3NlVGFnQXNUZXh0XSk7XG4gICAgICAgIHJldHVybiBfX3NwcmVhZChbc3RhcnRUYWdQaF0sIHRoaXMuc2VyaWFsaXplKHBoLmNoaWxkcmVuKSwgW2Nsb3NlVGFnUGhdKTtcbiAgICB9O1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpbnRlcnBvbGF0aW9uQXNUZXh0ID0gbmV3IFRleHQkMihcInt7XCIgKyBwaC52YWx1ZSArIFwifX1cIik7XG4gICAgICAgIC8vIEV4YW1wbGUgdGFnIG5lZWRzIHRvIGJlIG5vdC1lbXB0eSBmb3IgVEMuXG4gICAgICAgIHZhciBleFRhZyA9IG5ldyBUYWcoX0VYQU1QTEVfVEFHLCB7fSwgW2ludGVycG9sYXRpb25Bc1RleHRdKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC8vIFRDIHJlcXVpcmVzIFBIIHRvIGhhdmUgYSBub24gZW1wdHkgRVgsIGFuZCB1c2VzIHRoZSB0ZXh0IG5vZGUgdG8gc2hvdyB0aGUgXCJvcmlnaW5hbFwiIHZhbHVlLlxuICAgICAgICAgICAgbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHLCB7IG5hbWU6IHBoLm5hbWUgfSwgW2V4VGFnLCBpbnRlcnBvbGF0aW9uQXNUZXh0XSlcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpY3VFeHByZXNzaW9uID0gcGgudmFsdWUuZXhwcmVzc2lvbjtcbiAgICAgICAgdmFyIGljdVR5cGUgPSBwaC52YWx1ZS50eXBlO1xuICAgICAgICB2YXIgaWN1Q2FzZXMgPSBPYmplY3Qua2V5cyhwaC52YWx1ZS5jYXNlcykubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgKyAnIHsuLi59JzsgfSkuam9pbignICcpO1xuICAgICAgICB2YXIgaWN1QXNUZXh0ID0gbmV3IFRleHQkMihcIntcIiArIGljdUV4cHJlc3Npb24gKyBcIiwgXCIgKyBpY3VUeXBlICsgXCIsIFwiICsgaWN1Q2FzZXMgKyBcIn1cIik7XG4gICAgICAgIHZhciBleFRhZyA9IG5ldyBUYWcoX0VYQU1QTEVfVEFHLCB7fSwgW2ljdUFzVGV4dF0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLy8gVEMgcmVxdWlyZXMgUEggdG8gaGF2ZSBhIG5vbiBlbXB0eSBFWCwgYW5kIHVzZXMgdGhlIHRleHQgbm9kZSB0byBzaG93IHRoZSBcIm9yaWdpbmFsXCIgdmFsdWUuXG4gICAgICAgICAgICBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUcsIHsgbmFtZTogcGgubmFtZSB9LCBbZXhUYWcsIGljdUFzVGV4dF0pXG4gICAgICAgIF07XG4gICAgfTtcbiAgICBfVmlzaXRvci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIF9fc3ByZWFkKG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pKSk7XG4gICAgfTtcbiAgICByZXR1cm4gX1Zpc2l0b3I7XG59KCkpO1xuZnVuY3Rpb24gZGlnZXN0JDEobWVzc2FnZSkge1xuICAgIHJldHVybiBkZWNpbWFsRGlnZXN0KG1lc3NhZ2UpO1xufVxuLy8gVEMgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIG5vbi1lbXB0eSBleGFtcGxlIG9uIHBsYWNlaG9sZGVyc1xudmFyIEV4YW1wbGVWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4YW1wbGVWaXNpdG9yKCkge1xuICAgIH1cbiAgICBFeGFtcGxlVmlzaXRvci5wcm90b3R5cGUuYWRkRGVmYXVsdEV4YW1wbGVzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZS52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBFeGFtcGxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0YWcubmFtZSA9PT0gX1BMQUNFSE9MREVSX1RBRykge1xuICAgICAgICAgICAgaWYgKCF0YWcuY2hpbGRyZW4gfHwgdGFnLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4VGV4dCA9IG5ldyBUZXh0JDIodGFnLmF0dHJzWyduYW1lJ10gfHwgJy4uLicpO1xuICAgICAgICAgICAgICAgIHRhZy5jaGlsZHJlbiA9IFtuZXcgVGFnKF9FWEFNUExFX1RBRywge30sIFtleFRleHRdKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFnLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0YWcuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFeGFtcGxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgfTtcbiAgICBFeGFtcGxlVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChkZWNsKSB7IH07XG4gICAgRXhhbXBsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RG9jdHlwZSA9IGZ1bmN0aW9uIChkb2N0eXBlKSB7IH07XG4gICAgcmV0dXJuIEV4YW1wbGVWaXNpdG9yO1xufSgpKTtcbi8vIFhNQi9YVEIgcGxhY2Vob2xkZXJzIGNhbiBvbmx5IGNvbnRhaW4gQS1aLCAwLTkgYW5kIF9cbmZ1bmN0aW9uIHRvUHVibGljTmFtZShpbnRlcm5hbE5hbWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxOYW1lLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvW15BLVowLTlfXS9nLCAnXycpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBtYXBFbnRyeShrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSwgcXVvdGVkOiBmYWxzZSB9O1xufVxuZnVuY3Rpb24gbWFwTGl0ZXJhbChvYmosIHF1b3RlZCkge1xuICAgIGlmIChxdW90ZWQgPT09IHZvaWQgMCkgeyBxdW90ZWQgPSBmYWxzZTsgfVxuICAgIHJldHVybiBsaXRlcmFsTWFwKE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBxdW90ZWQ6IHF1b3RlZCxcbiAgICAgICAgdmFsdWU6IG9ialtrZXldLFxuICAgIH0pOyB9KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qIENsb3N1cmUgdmFyaWFibGVzIGhvbGRpbmcgbWVzc2FnZXMgbXVzdCBiZSBuYW1lZCBgTVNHX1tBLVowLTldK2AgKi9cbnZhciBDTE9TVVJFX1RSQU5TTEFUSU9OX1BSRUZJWCA9ICdNU0dfJztcbi8qIFByZWZpeCBmb3Igbm9uLWBnb29nLmdldE1zZ2AgaTE4bi1yZWxhdGVkIHZhcnMgKi9cbnZhciBUUkFOU0xBVElPTl9QUkVGSVggPSAnSTE4Tl8nO1xuLyoqIENsb3N1cmUgdXNlcyBgZ29vZy5nZXRNc2cobWVzc2FnZSlgIHRvIGxvb2t1cCB0cmFuc2xhdGlvbnMgKi9cbnZhciBHT09HX0dFVF9NU0cgPSAnZ29vZy5nZXRNc2cnO1xuLyoqIE5hbWUgb2YgdGhlIGdsb2JhbCB2YXJpYWJsZSB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHdlIHVzZSBDbG9zdXJlIHRyYW5zbGF0aW9ucyBvciBub3QgKi9cbnZhciBOR19JMThOX0NMT1NVUkVfTU9ERSA9ICduZ0kxOG5DbG9zdXJlTW9kZSc7XG4vKiogSTE4biBzZXBhcmF0b3JzIGZvciBtZXRhZGF0YSAqKi9cbnZhciBJMThOX01FQU5JTkdfU0VQQVJBVE9SID0gJ3wnO1xudmFyIEkxOE5fSURfU0VQQVJBVE9SID0gJ0BAJztcbi8qKiBOYW1lIG9mIHRoZSBpMThuIGF0dHJpYnV0ZXMgKiovXG52YXIgSTE4Tl9BVFRSID0gJ2kxOG4nO1xudmFyIEkxOE5fQVRUUl9QUkVGSVggPSAnaTE4bi0nO1xuLyoqIFByZWZpeCBvZiB2YXIgZXhwcmVzc2lvbnMgdXNlZCBpbiBJQ1VzICovXG52YXIgSTE4Tl9JQ1VfVkFSX1BSRUZJWCA9ICdWQVJfJztcbi8qKiBQcmVmaXggb2YgSUNVIGV4cHJlc3Npb25zIGZvciBwb3N0IHByb2Nlc3NpbmcgKi9cbnZhciBJMThOX0lDVV9NQVBQSU5HX1BSRUZJWCA9ICdJMThOX0VYUF8nO1xuLyoqIFBsYWNlaG9sZGVyIHdyYXBwZXIgZm9yIGkxOG4gZXhwcmVzc2lvbnMgKiovXG52YXIgSTE4Tl9QTEFDRUhPTERFUl9TWU1CT0wgPSAn77+9JztcbmZ1bmN0aW9uIGkxOG5UcmFuc2xhdGlvblRvRGVjbFN0bXQodmFyaWFibGUkMSwgY2xvc3VyZVZhciwgbWVzc2FnZSwgbWV0YSwgcGFyYW1zKSB7XG4gICAgdmFyIHN0YXRlbWVudHMgPSBbXTtcbiAgICAvLyB2YXIgSTE4Tl9YO1xuICAgIHN0YXRlbWVudHMucHVzaChuZXcgRGVjbGFyZVZhclN0bXQodmFyaWFibGUkMS5uYW1lLCB1bmRlZmluZWQsIElORkVSUkVEX1RZUEUsIG51bGwsIHZhcmlhYmxlJDEuc291cmNlU3BhbikpO1xuICAgIHZhciBhcmdzID0gW2xpdGVyYWwobWVzc2FnZSldO1xuICAgIGlmIChwYXJhbXMgJiYgT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGgpIHtcbiAgICAgICAgYXJncy5wdXNoKG1hcExpdGVyYWwocGFyYW1zLCB0cnVlKSk7XG4gICAgfVxuICAgIC8vIENsb3N1cmUgSlNEb2MgY29tbWVudHNcbiAgICB2YXIgZG9jU3RhdGVtZW50cyA9IGkxOG5NZXRhVG9Eb2NTdG10KG1ldGEpO1xuICAgIHZhciB0aGVuU3RhdGVtZW50cyA9IGRvY1N0YXRlbWVudHMgPyBbZG9jU3RhdGVtZW50c10gOiBbXTtcbiAgICB2YXIgZ29vZ0ZuQ2FsbCA9IHZhcmlhYmxlKEdPT0dfR0VUX01TRykuY2FsbEZuKGFyZ3MpO1xuICAgIC8vIGNvbnN0IE1TR18uLi4gPSBnb29nLmdldE1zZyguLik7XG4gICAgdGhlblN0YXRlbWVudHMucHVzaChjbG9zdXJlVmFyLnNldChnb29nRm5DYWxsKS50b0NvbnN0RGVjbCgpKTtcbiAgICAvLyBJMThOX1ggPSBNU0dfLi4uO1xuICAgIHRoZW5TdGF0ZW1lbnRzLnB1c2gobmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQodmFyaWFibGUkMS5zZXQoY2xvc3VyZVZhcikpKTtcbiAgICB2YXIgbG9jYWxpemVGbkNhbGwgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuaTE4bkxvY2FsaXplKS5jYWxsRm4oYXJncyk7XG4gICAgLy8gSTE4Tl9YID0gaTE4bkxvY2FsaXplKC4uLik7XG4gICAgdmFyIGVsc2VTdGF0ZW1lbnRzID0gW25ldyBFeHByZXNzaW9uU3RhdGVtZW50KHZhcmlhYmxlJDEuc2V0KGxvY2FsaXplRm5DYWxsKSldO1xuICAgIC8vIGlmKG5nSTE4bkNsb3N1cmVNb2RlKSB7IC4uLiB9IGVsc2UgeyAuLi4gfVxuICAgIHN0YXRlbWVudHMucHVzaChpZlN0bXQodmFyaWFibGUoTkdfSTE4Tl9DTE9TVVJFX01PREUpLCB0aGVuU3RhdGVtZW50cywgZWxzZVN0YXRlbWVudHMpKTtcbiAgICByZXR1cm4gc3RhdGVtZW50cztcbn1cbi8vIENvbnZlcnRzIGkxOG4gbWV0YSBpbmZvcm1hdGlvbiBmb3IgYSBtZXNzYWdlIChpZCwgZGVzY3JpcHRpb24sIG1lYW5pbmcpXG4vLyB0byBhIEpzRG9jIHN0YXRlbWVudCBmb3JtYXR0ZWQgYXMgZXhwZWN0ZWQgYnkgdGhlIENsb3N1cmUgY29tcGlsZXIuXG5mdW5jdGlvbiBpMThuTWV0YVRvRG9jU3RtdChtZXRhKSB7XG4gICAgdmFyIHRhZ3MgPSBbXTtcbiAgICBpZiAobWV0YS5kZXNjcmlwdGlvbikge1xuICAgICAgICB0YWdzLnB1c2goeyB0YWdOYW1lOiBcImRlc2NcIiAvKiBEZXNjICovLCB0ZXh0OiBtZXRhLmRlc2NyaXB0aW9uIH0pO1xuICAgIH1cbiAgICBpZiAobWV0YS5tZWFuaW5nKSB7XG4gICAgICAgIHRhZ3MucHVzaCh7IHRhZ05hbWU6IFwibWVhbmluZ1wiIC8qIE1lYW5pbmcgKi8sIHRleHQ6IG1ldGEubWVhbmluZyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ3MubGVuZ3RoID09IDAgPyBudWxsIDogbmV3IEpTRG9jQ29tbWVudFN0bXQodGFncyk7XG59XG5mdW5jdGlvbiBpc0kxOG5BdHRyaWJ1dGUobmFtZSkge1xuICAgIHJldHVybiBuYW1lID09PSBJMThOX0FUVFIgfHwgbmFtZS5zdGFydHNXaXRoKEkxOE5fQVRUUl9QUkVGSVgpO1xufVxuZnVuY3Rpb24gaXNJMThuUm9vdE5vZGUobWV0YSkge1xuICAgIHJldHVybiBtZXRhIGluc3RhbmNlb2YgTWVzc2FnZTtcbn1cbmZ1bmN0aW9uIGlzU2luZ2xlSTE4bkljdShtZXRhKSB7XG4gICAgcmV0dXJuIGlzSTE4blJvb3ROb2RlKG1ldGEpICYmIG1ldGEubm9kZXMubGVuZ3RoID09PSAxICYmIG1ldGEubm9kZXNbMF0gaW5zdGFuY2VvZiBJY3UkMTtcbn1cbmZ1bmN0aW9uIGhhc0kxOG5BdHRycyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuYXR0cnMuc29tZShmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gaXNJMThuQXR0cmlidXRlKGF0dHIubmFtZSk7IH0pO1xufVxuZnVuY3Rpb24gbWV0YUZyb21JMThuTWVzc2FnZShtZXNzYWdlLCBpZCkge1xuICAgIGlmIChpZCA9PT0gdm9pZCAwKSB7IGlkID0gbnVsbDsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gaWQgOiBtZXNzYWdlLmlkIHx8ICcnLFxuICAgICAgICBtZWFuaW5nOiBtZXNzYWdlLm1lYW5pbmcgfHwgJycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBtZXNzYWdlLmRlc2NyaXB0aW9uIHx8ICcnXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGljdUZyb21JMThuTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2Uubm9kZXNbMF07XG59XG5mdW5jdGlvbiB3cmFwSTE4blBsYWNlaG9sZGVyKGNvbnRlbnQsIGNvbnRleHRJZCkge1xuICAgIGlmIChjb250ZXh0SWQgPT09IHZvaWQgMCkgeyBjb250ZXh0SWQgPSAwOyB9XG4gICAgdmFyIGJsb2NrSWQgPSBjb250ZXh0SWQgPiAwID8gXCI6XCIgKyBjb250ZXh0SWQgOiAnJztcbiAgICByZXR1cm4gXCJcIiArIEkxOE5fUExBQ0VIT0xERVJfU1lNQk9MICsgY29udGVudCArIGJsb2NrSWQgKyBJMThOX1BMQUNFSE9MREVSX1NZTUJPTDtcbn1cbmZ1bmN0aW9uIGFzc2VtYmxlSTE4bkJvdW5kU3RyaW5nKHN0cmluZ3MsIGJpbmRpbmdTdGFydEluZGV4LCBjb250ZXh0SWQpIHtcbiAgICBpZiAoYmluZGluZ1N0YXJ0SW5kZXggPT09IHZvaWQgMCkgeyBiaW5kaW5nU3RhcnRJbmRleCA9IDA7IH1cbiAgICBpZiAoY29udGV4dElkID09PSB2b2lkIDApIHsgY29udGV4dElkID0gMDsgfVxuICAgIGlmICghc3RyaW5ncy5sZW5ndGgpXG4gICAgICAgIHJldHVybiAnJztcbiAgICB2YXIgYWNjID0gJyc7XG4gICAgdmFyIGxhc3RJZHggPSBzdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWR4OyBpKyspIHtcbiAgICAgICAgYWNjICs9IFwiXCIgKyBzdHJpbmdzW2ldICsgd3JhcEkxOG5QbGFjZWhvbGRlcihiaW5kaW5nU3RhcnRJbmRleCArIGksIGNvbnRleHRJZCk7XG4gICAgfVxuICAgIGFjYyArPSBzdHJpbmdzW2xhc3RJZHhdO1xuICAgIHJldHVybiBhY2M7XG59XG5mdW5jdGlvbiBnZXRTZXFOdW1iZXJHZW5lcmF0b3Ioc3RhcnRzQXQpIHtcbiAgICBpZiAoc3RhcnRzQXQgPT09IHZvaWQgMCkgeyBzdGFydHNBdCA9IDA7IH1cbiAgICB2YXIgY3VycmVudCA9IHN0YXJ0c0F0O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBjdXJyZW50Kys7IH07XG59XG5mdW5jdGlvbiBwbGFjZWhvbGRlcnNUb1BhcmFtcyhwbGFjZWhvbGRlcnMpIHtcbiAgICB2YXIgcGFyYW1zID0ge307XG4gICAgcGxhY2Vob2xkZXJzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlcywga2V5KSB7XG4gICAgICAgIHBhcmFtc1trZXldID0gbGl0ZXJhbCh2YWx1ZXMubGVuZ3RoID4gMSA/IFwiW1wiICsgdmFsdWVzLmpvaW4oJ3wnKSArIFwiXVwiIDogdmFsdWVzWzBdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFyYW1zO1xufVxuZnVuY3Rpb24gdXBkYXRlUGxhY2Vob2xkZXJNYXAobWFwLCBuYW1lKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhbHVlc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnQgPSBtYXAuZ2V0KG5hbWUpIHx8IFtdO1xuICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBfX3NwcmVhZCh2YWx1ZXMpKTtcbiAgICBtYXAuc2V0KG5hbWUsIGN1cnJlbnQpO1xufVxuZnVuY3Rpb24gYXNzZW1ibGVCb3VuZFRleHRQbGFjZWhvbGRlcnMobWV0YSwgYmluZGluZ1N0YXJ0SW5kZXgsIGNvbnRleHRJZCkge1xuICAgIGlmIChiaW5kaW5nU3RhcnRJbmRleCA9PT0gdm9pZCAwKSB7IGJpbmRpbmdTdGFydEluZGV4ID0gMDsgfVxuICAgIGlmIChjb250ZXh0SWQgPT09IHZvaWQgMCkgeyBjb250ZXh0SWQgPSAwOyB9XG4gICAgdmFyIHN0YXJ0SWR4ID0gYmluZGluZ1N0YXJ0SW5kZXg7XG4gICAgdmFyIHBsYWNlaG9sZGVycyA9IG5ldyBNYXAoKTtcbiAgICB2YXIgbm9kZSA9IG1ldGEgaW5zdGFuY2VvZiBNZXNzYWdlID8gbWV0YS5ub2Rlcy5maW5kKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlIGluc3RhbmNlb2YgQ29udGFpbmVyOyB9KSA6IG1ldGE7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgbm9kZVxuICAgICAgICAgICAgLmNoaWxkcmVuXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQgaW5zdGFuY2VvZiBQbGFjZWhvbGRlcjsgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHdyYXBJMThuUGxhY2Vob2xkZXIoc3RhcnRJZHggKyBpZHgsIGNvbnRleHRJZCk7XG4gICAgICAgICAgICB1cGRhdGVQbGFjZWhvbGRlck1hcChwbGFjZWhvbGRlcnMsIGNoaWxkLm5hbWUsIGNvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBsYWNlaG9sZGVycztcbn1cbmZ1bmN0aW9uIGZpbmRJbmRleChpdGVtcywgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhpdGVtc1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8qKlxuICogUGFyc2VzIGkxOG4gbWV0YXMgbGlrZTpcbiAqICAtIFwiQEBpZFwiLFxuICogIC0gXCJkZXNjcmlwdGlvbltAQGlkXVwiLFxuICogIC0gXCJtZWFuaW5nfGRlc2NyaXB0aW9uW0BAaWRdXCJcbiAqIGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHBhcnNlZCBvdXRwdXQuXG4gKlxuICogQHBhcmFtIG1ldGEgU3RyaW5nIHRoYXQgcmVwcmVzZW50cyBpMThuIG1ldGFcbiAqIEByZXR1cm5zIE9iamVjdCB3aXRoIGlkLCBtZWFuaW5nIGFuZCBkZXNjcmlwdGlvbiBmaWVsZHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VJMThuTWV0YShtZXRhKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgaWQ7XG4gICAgdmFyIG1lYW5pbmc7XG4gICAgdmFyIGRlc2NyaXB0aW9uO1xuICAgIGlmIChtZXRhKSB7XG4gICAgICAgIHZhciBpZEluZGV4ID0gbWV0YS5pbmRleE9mKEkxOE5fSURfU0VQQVJBVE9SKTtcbiAgICAgICAgdmFyIGRlc2NJbmRleCA9IG1ldGEuaW5kZXhPZihJMThOX01FQU5JTkdfU0VQQVJBVE9SKTtcbiAgICAgICAgdmFyIG1lYW5pbmdBbmREZXNjID0gdm9pZCAwO1xuICAgICAgICBfYSA9IF9fcmVhZCgoaWRJbmRleCA+IC0xKSA/IFttZXRhLnNsaWNlKDAsIGlkSW5kZXgpLCBtZXRhLnNsaWNlKGlkSW5kZXggKyAyKV0gOiBbbWV0YSwgJyddLCAyKSwgbWVhbmluZ0FuZERlc2MgPSBfYVswXSwgaWQgPSBfYVsxXTtcbiAgICAgICAgX2IgPSBfX3JlYWQoKGRlc2NJbmRleCA+IC0xKSA/XG4gICAgICAgICAgICBbbWVhbmluZ0FuZERlc2Muc2xpY2UoMCwgZGVzY0luZGV4KSwgbWVhbmluZ0FuZERlc2Muc2xpY2UoZGVzY0luZGV4ICsgMSldIDpcbiAgICAgICAgICAgIFsnJywgbWVhbmluZ0FuZERlc2NdLCAyKSwgbWVhbmluZyA9IF9iWzBdLCBkZXNjcmlwdGlvbiA9IF9iWzFdO1xuICAgIH1cbiAgICByZXR1cm4geyBpZDogaWQsIG1lYW5pbmc6IG1lYW5pbmcsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBpbnRlcm5hbCBwbGFjZWhvbGRlciBuYW1lcyB0byBwdWJsaWMtZmFjaW5nIGZvcm1hdFxuICogKGZvciBleGFtcGxlIHRvIHVzZSBpbiBnb29nLmdldE1zZyBjYWxsKS5cbiAqIEV4YW1wbGU6IGBTVEFSVF9UQUdfRElWXzFgIGlzIGNvbnZlcnRlZCB0byBgc3RhcnRUYWdEaXZfMWAuXG4gKlxuICogQHBhcmFtIG5hbWUgVGhlIHBsYWNlaG9sZGVyIG5hbWUgdGhhdCBzaG91bGQgYmUgZm9ybWF0dGVkXG4gKiBAcmV0dXJucyBGb3JtYXR0ZWQgcGxhY2Vob2xkZXIgbmFtZVxuICovXG5mdW5jdGlvbiBmb3JtYXRJMThuUGxhY2Vob2xkZXJOYW1lKG5hbWUsIHVzZUNhbWVsQ2FzZSkge1xuICAgIGlmICh1c2VDYW1lbENhc2UgPT09IHZvaWQgMCkgeyB1c2VDYW1lbENhc2UgPSB0cnVlOyB9XG4gICAgdmFyIHB1YmxpY05hbWUgPSB0b1B1YmxpY05hbWUobmFtZSk7XG4gICAgaWYgKCF1c2VDYW1lbENhc2UpIHtcbiAgICAgICAgcmV0dXJuIHB1YmxpY05hbWU7XG4gICAgfVxuICAgIHZhciBjaHVua3MgPSBwdWJsaWNOYW1lLnNwbGl0KCdfJyk7XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gaWYgbm8gXCJfXCIgZm91bmQgLSBqdXN0IGxvd2VyY2FzZSB0aGUgdmFsdWVcbiAgICAgICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgdmFyIHBvc3RmaXg7XG4gICAgLy8gZWplY3QgbGFzdCBlbGVtZW50IGlmIGl0J3MgYSBudW1iZXJcbiAgICBpZiAoL15cXGQrJC8udGVzdChjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICBwb3N0Zml4ID0gY2h1bmtzLnBvcCgpO1xuICAgIH1cbiAgICB2YXIgcmF3ID0gY2h1bmtzLnNoaWZ0KCkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICByYXcgKz0gY2h1bmtzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGMuc2xpY2UoMSkudG9Mb3dlckNhc2UoKTsgfSkuam9pbignJyk7XG4gICAgfVxuICAgIHJldHVybiBwb3N0Zml4ID8gcmF3ICsgXCJfXCIgKyBwb3N0Zml4IDogcmF3O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwcmVmaXggZm9yIHRyYW5zbGF0aW9uIGNvbnN0IG5hbWUuXG4gKlxuICogQHBhcmFtIGV4dHJhIEFkZGl0aW9uYWwgbG9jYWwgcHJlZml4IHRoYXQgc2hvdWxkIGJlIGluamVjdGVkIGludG8gdHJhbnNsYXRpb24gdmFyIG5hbWVcbiAqIEByZXR1cm5zIENvbXBsZXRlIHRyYW5zbGF0aW9uIGNvbnN0IHByZWZpeFxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGlvbkNvbnN0UHJlZml4KGV4dHJhKSB7XG4gICAgcmV0dXJuIChcIlwiICsgQ0xPU1VSRV9UUkFOU0xBVElPTl9QUkVGSVggKyBleHRyYSkudG9VcHBlckNhc2UoKTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIHRyYW5zbGF0aW9uIGRlY2xhcmF0aW9uIHN0YXRlbWVudHMuXG4gKlxuICogQHBhcmFtIHZhcmlhYmxlIFRyYW5zbGF0aW9uIHZhbHVlIHJlZmVyZW5jZVxuICogQHBhcmFtIGNsb3N1cmVWYXIgVmFyaWFibGUgZm9yIENsb3N1cmUgYGdvb2cuZ2V0TXNnYCBjYWxsc1xuICogQHBhcmFtIG1lc3NhZ2UgVGV4dCBtZXNzYWdlIHRvIGJlIHRyYW5zbGF0ZWRcbiAqIEBwYXJhbSBtZXRhIE9iamVjdCB0aGF0IGNvbnRhaW5zIG1ldGEgaW5mb3JtYXRpb24gKGlkLCBtZWFuaW5nIGFuZCBkZXNjcmlwdGlvbilcbiAqIEBwYXJhbSBwYXJhbXMgT2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGtleS12YWx1ZSBwYWlyc1xuICogQHBhcmFtIHRyYW5zZm9ybUZuIE9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIChwb3N0IHByb2Nlc3NpbmcpIGZ1bmN0aW9uIHJlZmVyZW5jZVxuICogQHJldHVybnMgQXJyYXkgb2YgU3RhdGVtZW50cyB0aGF0IHJlcHJlc2VudCBhIGdpdmVuIHRyYW5zbGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uRGVjbFN0bXRzKHZhcmlhYmxlLCBjbG9zdXJlVmFyLCBtZXNzYWdlLCBtZXRhLCBwYXJhbXMsIHRyYW5zZm9ybUZuKSB7XG4gICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XG4gICAgdmFyIHN0YXRlbWVudHMgPSBbXTtcbiAgICBzdGF0ZW1lbnRzLnB1c2guYXBwbHkoc3RhdGVtZW50cywgX19zcHJlYWQoaTE4blRyYW5zbGF0aW9uVG9EZWNsU3RtdCh2YXJpYWJsZSwgY2xvc3VyZVZhciwgbWVzc2FnZSwgbWV0YSwgcGFyYW1zKSkpO1xuICAgIGlmICh0cmFuc2Zvcm1Gbikge1xuICAgICAgICBzdGF0ZW1lbnRzLnB1c2gobmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQodmFyaWFibGUuc2V0KHRyYW5zZm9ybUZuKHZhcmlhYmxlKSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlbWVudHM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGtleSBjb250YWlucyBwb3RlbnRpYWxseSB1bnNhZmUgY2hhcnMsIHRodXMgdGhlIGtleSBzaG91bGQgYmUgd3JhcHBlZCBpblxuICogcXVvdGVzLiBOb3RlOiB3ZSBkbyBub3Qgd3JhcCBhbGwga2V5cyBpbnRvIHF1b3RlcywgYXMgaXQgbWF5IGhhdmUgaW1wYWN0IG9uIG1pbmlmaWNhdGlvbiBhbmQgbWF5XG4gKiBib3Qgd29yayBpbiBzb21lIGNhc2VzIHdoZW4gb2JqZWN0IGtleXMgYXJlIG1hbmdsZWQgYnkgbWluaWZpZXIuXG4gKlxuICogVE9ETyhGVy0xMTM2KTogdGhpcyBpcyBhIHRlbXBvcmFyeSBzb2x1dGlvbiwgd2UgbmVlZCB0byBjb21lIHVwIHdpdGggYSBiZXR0ZXIgd2F5IG9mIHdvcmtpbmcgd2l0aFxuICogaW5wdXRzIHRoYXQgY29udGFpbiBwb3RlbnRpYWxseSB1bnNhZmUgY2hhcnMuXG4gKi9cbnZhciBVTlNBRkVfT0JKRUNUX0tFWV9OQU1FX1JFR0VYUCA9IC9bLS5dLztcbi8qKiBOYW1lIG9mIHRoZSB0ZW1wb3JhcnkgdG8gdXNlIGR1cmluZyBkYXRhIGJpbmRpbmcgKi9cbnZhciBURU1QT1JBUllfTkFNRSA9ICdfdCc7XG4vKiogTmFtZSBvZiB0aGUgY29udGV4dCBwYXJhbWV0ZXIgcGFzc2VkIGludG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiAqL1xudmFyIENPTlRFWFRfTkFNRSA9ICdjdHgnO1xuLyoqIE5hbWUgb2YgdGhlIFJlbmRlckZsYWcgcGFzc2VkIGludG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiAqL1xudmFyIFJFTkRFUl9GTEFHUyA9ICdyZic7XG4vKiogVGhlIHByZWZpeCByZWZlcmVuY2UgdmFyaWFibGVzICovXG52YXIgUkVGRVJFTkNFX1BSRUZJWCA9ICdfcic7XG4vKiogVGhlIG5hbWUgb2YgdGhlIGltcGxpY2l0IGNvbnRleHQgcmVmZXJlbmNlICovXG52YXIgSU1QTElDSVRfUkVGRVJFTkNFID0gJyRpbXBsaWNpdCc7XG4vKiogTm9uIGJpbmRhYmxlIGF0dHJpYnV0ZSBuYW1lICoqL1xudmFyIE5PTl9CSU5EQUJMRV9BVFRSID0gJ25nTm9uQmluZGFibGUnO1xuLyoqXG4gKiBDcmVhdGVzIGFuIGFsbG9jYXRvciBmb3IgYSB0ZW1wb3JhcnkgdmFyaWFibGUuXG4gKlxuICogQSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBpcyBhZGRlZCB0byB0aGUgc3RhdGVtZW50cyB0aGUgZmlyc3QgdGltZSB0aGUgYWxsb2NhdG9yIGlzIGludm9rZWQuXG4gKi9cbmZ1bmN0aW9uIHRlbXBvcmFyeUFsbG9jYXRvcihzdGF0ZW1lbnRzLCBuYW1lKSB7XG4gICAgdmFyIHRlbXAgPSBudWxsO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGVtcCkge1xuICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKG5ldyBEZWNsYXJlVmFyU3RtdChURU1QT1JBUllfTkFNRSwgdW5kZWZpbmVkLCBEWU5BTUlDX1RZUEUpKTtcbiAgICAgICAgICAgIHRlbXAgPSB2YXJpYWJsZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVtcDtcbiAgICB9O1xufVxuZnVuY3Rpb24gdW5zdXBwb3J0ZWQoZmVhdHVyZSkge1xuICAgIGlmICh0aGlzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1aWxkZXIgXCIgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyBcIiBkb2Vzbid0IHN1cHBvcnQgXCIgKyBmZWF0dXJlICsgXCIgeWV0XCIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGZWF0dXJlIFwiICsgZmVhdHVyZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgeWV0XCIpO1xufVxuZnVuY3Rpb24gaW52YWxpZCQxKGFyZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGU6IFZpc2l0b3IgXCIgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyBcIiBkb2Vzbid0IGhhbmRsZSBcIiArIGFyZy5jb25zdHJ1Y3Rvci5uYW1lKTtcbn1cbmZ1bmN0aW9uIGFzTGl0ZXJhbCh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbEFycih2YWx1ZS5tYXAoYXNMaXRlcmFsKSk7XG4gICAgfVxuICAgIHJldHVybiBsaXRlcmFsKHZhbHVlLCBJTkZFUlJFRF9UWVBFKTtcbn1cbmZ1bmN0aW9uIGNvbmRpdGlvbmFsbHlDcmVhdGVNYXBPYmplY3RMaXRlcmFsKGtleXMsIGtlZXBEZWNsYXJlZCkge1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhrZXlzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBtYXBUb0V4cHJlc3Npb24oa2V5cywga2VlcERlY2xhcmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtYXBUb0V4cHJlc3Npb24obWFwLCBrZWVwRGVjbGFyZWQpIHtcbiAgICByZXR1cm4gbGl0ZXJhbE1hcChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtYXApLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIC8vIGNhbm9uaWNhbCBzeW50YXg6IGBkaXJQcm9wOiBwdWJsaWNQcm9wYFxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBgOmAsIHVzZSBkaXJQcm9wID0gZWxQcm9wXG4gICAgICAgIHZhciB2YWx1ZSA9IG1hcFtrZXldO1xuICAgICAgICB2YXIgZGVjbGFyZWROYW1lO1xuICAgICAgICB2YXIgcHVibGljTmFtZTtcbiAgICAgICAgdmFyIG1pbmlmaWVkTmFtZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBfYSA9IF9fcmVhZCh2YWx1ZSwgMiksIHB1YmxpY05hbWUgPSBfYVswXSwgZGVjbGFyZWROYW1lID0gX2FbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfYiA9IF9fcmVhZChzcGxpdEF0Q29sb24oa2V5LCBba2V5LCB2YWx1ZV0pLCAyKSwgZGVjbGFyZWROYW1lID0gX2JbMF0sIHB1YmxpY05hbWUgPSBfYlsxXTtcbiAgICAgICAgfVxuICAgICAgICBtaW5pZmllZE5hbWUgPSBkZWNsYXJlZE5hbWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IG1pbmlmaWVkTmFtZSxcbiAgICAgICAgICAgIC8vIHB1dCBxdW90ZXMgYXJvdW5kIGtleXMgdGhhdCBjb250YWluIHBvdGVudGlhbGx5IHVuc2FmZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICBxdW90ZWQ6IFVOU0FGRV9PQkpFQ1RfS0VZX05BTUVfUkVHRVhQLnRlc3QobWluaWZpZWROYW1lKSxcbiAgICAgICAgICAgIHZhbHVlOiAoa2VlcERlY2xhcmVkICYmIHB1YmxpY05hbWUgIT09IGRlY2xhcmVkTmFtZSkgP1xuICAgICAgICAgICAgICAgIGxpdGVyYWxBcnIoW2FzTGl0ZXJhbChwdWJsaWNOYW1lKSwgYXNMaXRlcmFsKGRlY2xhcmVkTmFtZSldKSA6XG4gICAgICAgICAgICAgICAgYXNMaXRlcmFsKHB1YmxpY05hbWUpXG4gICAgICAgIH07XG4gICAgfSkpO1xufVxuLyoqXG4gKiAgUmVtb3ZlIHRyYWlsaW5nIG51bGwgbm9kZXMgYXMgdGhleSBhcmUgaW1wbGllZC5cbiAqL1xuZnVuY3Rpb24gdHJpbVRyYWlsaW5nTnVsbHMocGFyYW1ldGVycykge1xuICAgIHdoaWxlIChpc051bGwocGFyYW1ldGVyc1twYXJhbWV0ZXJzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICBwYXJhbWV0ZXJzLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1ldGVycztcbn1cbmZ1bmN0aW9uIGdldFF1ZXJ5UHJlZGljYXRlKHF1ZXJ5LCBjb25zdGFudFBvb2wpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShxdWVyeS5wcmVkaWNhdGUpKSB7XG4gICAgICAgIHZhciBwcmVkaWNhdGVfMSA9IFtdO1xuICAgICAgICBxdWVyeS5wcmVkaWNhdGUuZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIC8vIEVhY2ggaXRlbSBpbiBwcmVkaWNhdGVzIGFycmF5IG1heSBjb250YWluIHN0cmluZ3Mgd2l0aCBjb21tYS1zZXBhcmF0ZWQgcmVmc1xuICAgICAgICAgICAgLy8gKGZvciBleC4gJ3JlZiwgcmVmMSwgLi4uLCByZWZOJyksIHRodXMgd2UgZXh0cmFjdCBpbmRpdmlkdWFsIHJlZnMgYW5kIHN0b3JlIHRoZW1cbiAgICAgICAgICAgIC8vIGFzIHNlcGFyYXRlIGFycmF5IGVudGl0aWVzXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JzID0gc2VsZWN0b3Iuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiBsaXRlcmFsKHRva2VuLnRyaW0oKSk7IH0pO1xuICAgICAgICAgICAgcHJlZGljYXRlXzEucHVzaC5hcHBseShwcmVkaWNhdGVfMSwgX19zcHJlYWQoc2VsZWN0b3JzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29uc3RhbnRQb29sLmdldENvbnN0TGl0ZXJhbChsaXRlcmFsQXJyKHByZWRpY2F0ZV8xKSwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcXVlcnkucHJlZGljYXRlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbnZhciBEZWZpbml0aW9uTWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlZmluaXRpb25NYXAoKSB7XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgfVxuICAgIERlZmluaXRpb25NYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh7IGtleToga2V5LCB2YWx1ZTogdmFsdWUsIHF1b3RlZDogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmluaXRpb25NYXAucHJvdG90eXBlLnRvTGl0ZXJhbE1hcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpdGVyYWxNYXAodGhpcy52YWx1ZXMpOyB9O1xuICAgIHJldHVybiBEZWZpbml0aW9uTWFwO1xufSgpKTtcbi8qKlxuICogRXh0cmFjdCBhIG1hcCBvZiBwcm9wZXJ0aWVzIHRvIHZhbHVlcyBmb3IgYSBnaXZlbiBlbGVtZW50IG9yIHRlbXBsYXRlIG5vZGUsIHdoaWNoIGNhbiBiZSB1c2VkXG4gKiBieSB0aGUgZGlyZWN0aXZlIG1hdGNoaW5nIG1hY2hpbmVyeS5cbiAqXG4gKiBAcGFyYW0gZWxPclRwbCB0aGUgZWxlbWVudCBvciB0ZW1wbGF0ZSBpbiBxdWVzdGlvblxuICogQHJldHVybiBhbiBvYmplY3Qgc2V0IHVwIGZvciBkaXJlY3RpdmUgbWF0Y2hpbmcuIEZvciBhdHRyaWJ1dGVzIG9uIHRoZSBlbGVtZW50L3RlbXBsYXRlLCB0aGlzXG4gKiBvYmplY3QgbWFwcyBhIHByb3BlcnR5IG5hbWUgdG8gaXRzIChzdGF0aWMpIHZhbHVlLiBGb3IgYW55IGJpbmRpbmdzLCB0aGlzIG1hcCBzaW1wbHkgbWFwcyB0aGVcbiAqIHByb3BlcnR5IG5hbWUgdG8gYW4gZW1wdHkgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBnZXRBdHRyc0ZvckRpcmVjdGl2ZU1hdGNoaW5nKGVsT3JUcGwpIHtcbiAgICB2YXIgYXR0cmlidXRlc01hcCA9IHt9O1xuICAgIGlmIChlbE9yVHBsIGluc3RhbmNlb2YgVGVtcGxhdGUgJiYgZWxPclRwbC50YWdOYW1lICE9PSAnbmctdGVtcGxhdGUnKSB7XG4gICAgICAgIGVsT3JUcGwudGVtcGxhdGVBdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhdHRyaWJ1dGVzTWFwW2EubmFtZV0gPSAnJzsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbE9yVHBsLmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgaWYgKCFpc0kxOG5BdHRyaWJ1dGUoYS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNNYXBbYS5uYW1lXSA9IGEudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbE9yVHBsLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7IGF0dHJpYnV0ZXNNYXBbaS5uYW1lXSA9ICcnOyB9KTtcbiAgICAgICAgZWxPclRwbC5vdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKG8pIHsgYXR0cmlidXRlc01hcFtvLm5hbWVdID0gJyc7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlc01hcDtcbn1cbi8qKiBSZXR1cm5zIGEgY2FsbCBleHByZXNzaW9uIHRvIGEgY2hhaW5lZCBpbnN0cnVjdGlvbiwgZS5nLiBgcHJvcGVydHkocGFyYW1zWzBdKShwYXJhbXNbMV0pYC4gKi9cbmZ1bmN0aW9uIGNoYWluZWRJbnN0cnVjdGlvbihyZWZlcmVuY2UsIGNhbGxzLCBzcGFuKSB7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKHJlZmVyZW5jZSwgbnVsbCwgc3Bhbik7XG4gICAgaWYgKGNhbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uY2FsbEZuKGNhbGxzW2ldLCBzcGFuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQWRkIGEgYmxhbmsgaW52b2NhdGlvbiwgaW4gY2FzZSB0aGUgYGNhbGxzYCBhcnJheSBpcyBlbXB0eS5cbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uY2FsbEZuKFtdLCBzcGFuKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHJlc3Npb247XG59XG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgZXhwZWN0ZWQgdG8gYmUgcGFzc2VkIHRvIGEgZ2VuZXJhdGVkIGluc3RydWN0aW9uIGluIHRoZSBjYXNlIG9mXG4gKiBpbnRlcnBvbGF0aW9uIGluc3RydWN0aW9ucy5cbiAqIEBwYXJhbSBpbnRlcnBvbGF0aW9uIEFuIGludGVycG9sYXRpb24gYXN0XG4gKi9cbmZ1bmN0aW9uIGdldEludGVycG9sYXRpb25BcmdzTGVuZ3RoKGludGVycG9sYXRpb24pIHtcbiAgICB2YXIgZXhwcmVzc2lvbnMgPSBpbnRlcnBvbGF0aW9uLmV4cHJlc3Npb25zLCBzdHJpbmdzID0gaW50ZXJwb2xhdGlvbi5zdHJpbmdzO1xuICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDEgJiYgc3RyaW5ncy5sZW5ndGggPT09IDIgJiYgc3RyaW5nc1swXSA9PT0gJycgJiYgc3RyaW5nc1sxXSA9PT0gJycpIHtcbiAgICAgICAgLy8gSWYgdGhlIGludGVycG9sYXRpb24gaGFzIG9uZSBpbnRlcnBvbGF0ZWQgdmFsdWUsIGJ1dCB0aGUgcHJlZml4IGFuZCBzdWZmaXggYXJlIGJvdGggZW1wdHlcbiAgICAgICAgLy8gc3RyaW5ncywgd2Ugb25seSBwYXNzIG9uZSBhcmd1bWVudCwgdG8gYSBzcGVjaWFsIGluc3RydWN0aW9uIGxpa2UgYHByb3BlcnR5SW50ZXJwb2xhdGVgIG9yXG4gICAgICAgIC8vIGB0ZXh0SW50ZXJwb2xhdGVgLlxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9ucy5sZW5ndGggKyBzdHJpbmdzLmxlbmd0aDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGU7XG4oZnVuY3Rpb24gKFIzRmFjdG9yeURlbGVnYXRlVHlwZSkge1xuICAgIFIzRmFjdG9yeURlbGVnYXRlVHlwZVtSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGVbXCJDbGFzc1wiXSA9IDBdID0gXCJDbGFzc1wiO1xuICAgIFIzRmFjdG9yeURlbGVnYXRlVHlwZVtSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGVbXCJGdW5jdGlvblwiXSA9IDFdID0gXCJGdW5jdGlvblwiO1xuICAgIFIzRmFjdG9yeURlbGVnYXRlVHlwZVtSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGVbXCJGYWN0b3J5XCJdID0gMl0gPSBcIkZhY3RvcnlcIjtcbn0pKFIzRmFjdG9yeURlbGVnYXRlVHlwZSB8fCAoUjNGYWN0b3J5RGVsZWdhdGVUeXBlID0ge30pKTtcbi8qKlxuICogUmVzb2x2ZWQgdHlwZSBvZiBhIGRlcGVuZGVuY3kuXG4gKlxuICogT2NjYXNpb25hbGx5LCBkZXBlbmRlbmNpZXMgd2lsbCBoYXZlIHNwZWNpYWwgc2lnbmlmaWNhbmNlIHdoaWNoIGlzIGtub3duIHN0YXRpY2FsbHkuIEluIHRoYXRcbiAqIGNhc2UgdGhlIGBSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGVgIGluZm9ybXMgdGhlIGZhY3RvcnkgZ2VuZXJhdG9yIHRoYXQgYSBwYXJ0aWN1bGFyIGRlcGVuZGVuY3lcbiAqIHNob3VsZCBiZSBnZW5lcmF0ZWQgc3BlY2lhbGx5ICh1c3VhbGx5IGJ5IGNhbGxpbmcgYSBzcGVjaWFsIGluamVjdGlvbiBmdW5jdGlvbiBpbnN0ZWFkIG9mIHRoZVxuICogc3RhbmRhcmQgb25lKS5cbiAqL1xudmFyIFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZTtcbihmdW5jdGlvbiAoUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlKSB7XG4gICAgLyoqXG4gICAgICogQSBub3JtYWwgdG9rZW4gZGVwZW5kZW5jeS5cbiAgICAgKi9cbiAgICBSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGVbUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlW1wiVG9rZW5cIl0gPSAwXSA9IFwiVG9rZW5cIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVwZW5kZW5jeSBpcyBmb3IgYW4gYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogVGhlIHRva2VuIGV4cHJlc3Npb24gaXMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICAgKi9cbiAgICBSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGVbUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlW1wiQXR0cmlidXRlXCJdID0gMV0gPSBcIkF0dHJpYnV0ZVwiO1xuICAgIC8qKlxuICAgICAqIEluamVjdGluZyB0aGUgYENoYW5nZURldGVjdG9yUmVmYCB0b2tlbi4gTmVlZHMgc3BlY2lhbCBoYW5kbGluZyB3aGVuIGluamVjdGVkIGludG8gYSBwaXBlLlxuICAgICAqL1xuICAgIFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZVtSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGVbXCJDaGFuZ2VEZXRlY3RvclJlZlwiXSA9IDJdID0gXCJDaGFuZ2VEZXRlY3RvclJlZlwiO1xufSkoUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlIHx8IChSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGUgPSB7fSkpO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYSBmYWN0b3J5IGZ1bmN0aW9uIGV4cHJlc3Npb24gZm9yIHRoZSBnaXZlbiBgUjNGYWN0b3J5TWV0YWRhdGFgLlxuICovXG5mdW5jdGlvbiBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKG1ldGEsIGlzUGlwZSkge1xuICAgIGlmIChpc1BpcGUgPT09IHZvaWQgMCkgeyBpc1BpcGUgPSBmYWxzZTsgfVxuICAgIHZhciB0ID0gdmFyaWFibGUoJ3QnKTtcbiAgICB2YXIgc3RhdGVtZW50cyA9IFtdO1xuICAgIC8vIFRoZSB0eXBlIHRvIGluc3RhbnRpYXRlIHZpYSBjb25zdHJ1Y3RvciBpbnZvY2F0aW9uLiBJZiB0aGVyZSBpcyBubyBkZWxlZ2F0ZWQgZmFjdG9yeSwgbWVhbmluZ1xuICAgIC8vIHRoaXMgdHlwZSBpcyBhbHdheXMgY3JlYXRlZCBieSBjb25zdHJ1Y3RvciBpbnZvY2F0aW9uLCB0aGVuIHRoaXMgaXMgdGhlIHR5cGUtdG8tY3JlYXRlXG4gICAgLy8gcGFyYW1ldGVyIHByb3ZpZGVkIGJ5IHRoZSB1c2VyICh0KSBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjdXJyZW50IHR5cGUgaWYgbm90LiBJZiB0aGVyZSBpcyBhXG4gICAgLy8gZGVsZWdhdGVkIGZhY3RvcnkgKHdoaWNoIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBjdXJyZW50IHR5cGUpIHRoZW4gdGhpcyBpcyBvbmx5IHRoZSB0eXBlLXRvLVxuICAgIC8vIGNyZWF0ZSBwYXJhbWV0ZXIgKHQpLlxuICAgIHZhciB0eXBlRm9yQ3RvciA9ICFpc0RlbGVnYXRlZE1ldGFkYXRhKG1ldGEpID8gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5PciwgdCwgbWV0YS50eXBlKSA6IHQ7XG4gICAgdmFyIGN0b3JFeHByID0gbnVsbDtcbiAgICBpZiAobWV0YS5kZXBzICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIGEgY29uc3RydWN0b3IgKGVpdGhlciBleHBsaWNpdGx5IG9yIGltcGxpY2l0bHkgZGVmaW5lZCkuXG4gICAgICAgIGlmIChtZXRhLmRlcHMgIT09ICdpbnZhbGlkJykge1xuICAgICAgICAgICAgY3RvckV4cHIgPVxuICAgICAgICAgICAgICAgIG5ldyBJbnN0YW50aWF0ZUV4cHIodHlwZUZvckN0b3IsIGluamVjdERlcGVuZGVuY2llcyhtZXRhLmRlcHMsIG1ldGEuaW5qZWN0Rm4sIGlzUGlwZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgYmFzZUZhY3RvcnkgPSB2YXJpYWJsZShcIlxcdTAyNzVcIiArIG1ldGEubmFtZSArIFwiX0Jhc2VGYWN0b3J5XCIpO1xuICAgICAgICB2YXIgZ2V0SW5oZXJpdGVkRmFjdG9yeSA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5nZXRJbmhlcml0ZWRGYWN0b3J5KTtcbiAgICAgICAgdmFyIGJhc2VGYWN0b3J5U3RtdCA9IGJhc2VGYWN0b3J5LnNldChnZXRJbmhlcml0ZWRGYWN0b3J5LmNhbGxGbihbbWV0YS50eXBlXSkpLnRvRGVjbFN0bXQoSU5GRVJSRURfVFlQRSwgW1xuICAgICAgICAgICAgU3RtdE1vZGlmaWVyLkV4cG9ydGVkLCBTdG10TW9kaWZpZXIuRmluYWxcbiAgICAgICAgXSk7XG4gICAgICAgIHN0YXRlbWVudHMucHVzaChiYXNlRmFjdG9yeVN0bXQpO1xuICAgICAgICAvLyBUaGVyZSBpcyBubyBjb25zdHJ1Y3RvciwgdXNlIHRoZSBiYXNlIGNsYXNzJyBmYWN0b3J5IHRvIGNvbnN0cnVjdCB0eXBlRm9yQ3Rvci5cbiAgICAgICAgY3RvckV4cHIgPSBiYXNlRmFjdG9yeS5jYWxsRm4oW3R5cGVGb3JDdG9yXSk7XG4gICAgfVxuICAgIHZhciBjdG9yRXhwckZpbmFsID0gY3RvckV4cHI7XG4gICAgdmFyIGJvZHkgPSBbXTtcbiAgICB2YXIgcmV0RXhwciA9IG51bGw7XG4gICAgZnVuY3Rpb24gbWFrZUNvbmRpdGlvbmFsRmFjdG9yeShub25DdG9yRXhwcikge1xuICAgICAgICB2YXIgciA9IHZhcmlhYmxlKCdyJyk7XG4gICAgICAgIGJvZHkucHVzaChyLnNldChOVUxMX0VYUFIpLnRvRGVjbFN0bXQoKSk7XG4gICAgICAgIHZhciBjdG9yU3RtdCA9IG51bGw7XG4gICAgICAgIGlmIChjdG9yRXhwckZpbmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjdG9yU3RtdCA9IHIuc2V0KGN0b3JFeHByRmluYWwpLnRvU3RtdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3RvclN0bXQgPSBtYWtlRXJyb3JTdG10KG1ldGEubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgYm9keS5wdXNoKGlmU3RtdCh0LCBbY3RvclN0bXRdLCBbci5zZXQobm9uQ3RvckV4cHIpLnRvU3RtdCgpXSkpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgaWYgKGlzRGVsZWdhdGVkTWV0YWRhdGEobWV0YSkgJiYgbWV0YS5kZWxlZ2F0ZVR5cGUgPT09IFIzRmFjdG9yeURlbGVnYXRlVHlwZS5GYWN0b3J5KSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZUZhY3RvcnkgPSB2YXJpYWJsZShcIlxcdTAyNzVcIiArIG1ldGEubmFtZSArIFwiX0Jhc2VGYWN0b3J5XCIpO1xuICAgICAgICB2YXIgZ2V0RmFjdG9yeU9mID0gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmdldEZhY3RvcnlPZik7XG4gICAgICAgIGlmIChtZXRhLmRlbGVnYXRlLmlzRXF1aXZhbGVudChtZXRhLnR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBjb21waWxpbmcgZmFjdG9yeSB0aGF0IGRlbGVnYXRlcyB0byBpdHNlbGZcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGVnYXRlRmFjdG9yeVN0bXQgPSBkZWxlZ2F0ZUZhY3Rvcnkuc2V0KGdldEZhY3RvcnlPZi5jYWxsRm4oW21ldGEuZGVsZWdhdGVdKSkudG9EZWNsU3RtdChJTkZFUlJFRF9UWVBFLCBbXG4gICAgICAgICAgICBTdG10TW9kaWZpZXIuRXhwb3J0ZWQsIFN0bXRNb2RpZmllci5GaW5hbFxuICAgICAgICBdKTtcbiAgICAgICAgc3RhdGVtZW50cy5wdXNoKGRlbGVnYXRlRmFjdG9yeVN0bXQpO1xuICAgICAgICByZXRFeHByID0gbWFrZUNvbmRpdGlvbmFsRmFjdG9yeShkZWxlZ2F0ZUZhY3RvcnkuY2FsbEZuKFtdKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVsZWdhdGVkTWV0YWRhdGEobWV0YSkpIHtcbiAgICAgICAgLy8gVGhpcyB0eXBlIGlzIGNyZWF0ZWQgd2l0aCBhIGRlbGVnYXRlZCBmYWN0b3J5LiBJZiBhIHR5cGUgcGFyYW1ldGVyIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGxcbiAgICAgICAgLy8gdGhlIGZhY3RvcnkgaW5zdGVhZC5cbiAgICAgICAgdmFyIGRlbGVnYXRlQXJncyA9IGluamVjdERlcGVuZGVuY2llcyhtZXRhLmRlbGVnYXRlRGVwcywgbWV0YS5pbmplY3RGbiwgaXNQaXBlKTtcbiAgICAgICAgLy8gRWl0aGVyIGNhbGwgYG5ldyBkZWxlZ2F0ZSguLi4pYCBvciBgZGVsZWdhdGUoLi4uKWAgZGVwZW5kaW5nIG9uIG1ldGEudXNlTmV3Rm9yRGVsZWdhdGUuXG4gICAgICAgIHZhciBmYWN0b3J5RXhwciA9IG5ldyAobWV0YS5kZWxlZ2F0ZVR5cGUgPT09IFIzRmFjdG9yeURlbGVnYXRlVHlwZS5DbGFzcyA/XG4gICAgICAgICAgICBJbnN0YW50aWF0ZUV4cHIgOlxuICAgICAgICAgICAgSW52b2tlRnVuY3Rpb25FeHByKShtZXRhLmRlbGVnYXRlLCBkZWxlZ2F0ZUFyZ3MpO1xuICAgICAgICByZXRFeHByID0gbWFrZUNvbmRpdGlvbmFsRmFjdG9yeShmYWN0b3J5RXhwcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRXhwcmVzc2lvbkZhY3RvcnlNZXRhZGF0YShtZXRhKSkge1xuICAgICAgICAvLyBUT0RPKGFseGh1Yik6IGRlY2lkZSB3aGV0aGVyIHRvIGxvd2VyIHRoZSB2YWx1ZSBoZXJlIG9yIGluIHRoZSBjYWxsZXJcbiAgICAgICAgcmV0RXhwciA9IG1ha2VDb25kaXRpb25hbEZhY3RvcnkobWV0YS5leHByZXNzaW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldEV4cHIgPSBjdG9yRXhwcjtcbiAgICB9XG4gICAgaWYgKHJldEV4cHIgIT09IG51bGwpIHtcbiAgICAgICAgYm9keS5wdXNoKG5ldyBSZXR1cm5TdGF0ZW1lbnQocmV0RXhwcikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYm9keS5wdXNoKG1ha2VFcnJvclN0bXQobWV0YS5uYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGZhY3Rvcnk6IGZuKFtuZXcgRm5QYXJhbSgndCcsIERZTkFNSUNfVFlQRSldLCBib2R5LCBJTkZFUlJFRF9UWVBFLCB1bmRlZmluZWQsIG1ldGEubmFtZSArIFwiX0ZhY3RvcnlcIiksXG4gICAgICAgIHN0YXRlbWVudHM6IHN0YXRlbWVudHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluamVjdERlcGVuZGVuY2llcyhkZXBzLCBpbmplY3RGbiwgaXNQaXBlKSB7XG4gICAgcmV0dXJuIGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIGNvbXBpbGVJbmplY3REZXBlbmRlbmN5KGRlcCwgaW5qZWN0Rm4sIGlzUGlwZSk7IH0pO1xufVxuZnVuY3Rpb24gY29tcGlsZUluamVjdERlcGVuZGVuY3koZGVwLCBpbmplY3RGbiwgaXNQaXBlKSB7XG4gICAgLy8gSW50ZXJwcmV0IHRoZSBkZXBlbmRlbmN5IGFjY29yZGluZyB0byBpdHMgcmVzb2x2ZWQgdHlwZS5cbiAgICBzd2l0Y2ggKGRlcC5yZXNvbHZlZCkge1xuICAgICAgICBjYXNlIFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZS5Ub2tlbjpcbiAgICAgICAgY2FzZSBSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGUuQ2hhbmdlRGV0ZWN0b3JSZWY6XG4gICAgICAgICAgICAvLyBCdWlsZCB1cCB0aGUgaW5qZWN0aW9uIGZsYWdzIGFjY29yZGluZyB0byB0aGUgbWV0YWRhdGEuXG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSAwIC8qIERlZmF1bHQgKi8gfCAoZGVwLnNlbGYgPyAyIC8qIFNlbGYgKi8gOiAwKSB8XG4gICAgICAgICAgICAgICAgKGRlcC5za2lwU2VsZiA/IDQgLyogU2tpcFNlbGYgKi8gOiAwKSB8IChkZXAuaG9zdCA/IDEgLyogSG9zdCAqLyA6IDApIHxcbiAgICAgICAgICAgICAgICAoZGVwLm9wdGlvbmFsID8gOCAvKiBPcHRpb25hbCAqLyA6IDApO1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBkZXBlbmRlbmN5IGlzIG9wdGlvbmFsIG9yIG90aGVyd2lzZSBoYXMgbm9uLWRlZmF1bHQgZmxhZ3MsIHRoZW4gYWRkaXRpb25hbFxuICAgICAgICAgICAgLy8gcGFyYW1ldGVycyBkZXNjcmliaW5nIGhvdyB0byBpbmplY3QgdGhlIGRlcGVuZGVuY3kgbXVzdCBiZSBwYXNzZWQgdG8gdGhlIGluamVjdCBmdW5jdGlvblxuICAgICAgICAgICAgLy8gdGhhdCdzIGJlaW5nIHVzZWQuXG4gICAgICAgICAgICB2YXIgZmxhZ3NQYXJhbSA9IChmbGFncyAhPT0gMCAvKiBEZWZhdWx0ICovIHx8IGRlcC5vcHRpb25hbCkgPyBsaXRlcmFsKGZsYWdzKSA6IG51bGw7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGEgc2VwYXJhdGUgaW5zdHJ1Y3Rpb24gZm9yIGluamVjdGluZyBDaGFuZ2VEZXRlY3RvclJlZiBpbnRvIGEgcGlwZS5cbiAgICAgICAgICAgIGlmIChpc1BpcGUgJiYgZGVwLnJlc29sdmVkID09PSBSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGUuQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmluamVjdFBpcGVDaGFuZ2VEZXRlY3RvclJlZikuY2FsbEZuKGZsYWdzUGFyYW0gPyBbZmxhZ3NQYXJhbV0gOiBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWlsZCB1cCB0aGUgYXJndW1lbnRzIHRvIHRoZSBpbmplY3RGbiBjYWxsLlxuICAgICAgICAgICAgdmFyIGluamVjdEFyZ3MgPSBbZGVwLnRva2VuXTtcbiAgICAgICAgICAgIGlmIChmbGFnc1BhcmFtKSB7XG4gICAgICAgICAgICAgICAgaW5qZWN0QXJncy5wdXNoKGZsYWdzUGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoaW5qZWN0Rm4pLmNhbGxGbihpbmplY3RBcmdzKTtcbiAgICAgICAgY2FzZSBSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGUuQXR0cmlidXRlOlxuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYXR0cmlidXRlcywgdGhlIGF0dHJpYnV0ZSBuYW1lIGluIHF1ZXN0aW9uIGlzIGdpdmVuIGFzIHRoZSB0b2tlbi5cbiAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuaW5qZWN0QXR0cmlidXRlKS5jYWxsRm4oW2RlcC50b2tlbl0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHVuc3VwcG9ydGVkKFwiVW5rbm93biBSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGU6IFwiICsgUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlW2RlcC5yZXNvbHZlZF0pO1xuICAgIH1cbn1cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdXNlZnVsIGZvciBleHRyYWN0aW5nIGBSM0RlcGVuZGVuY3lNZXRhZGF0YWAgZnJvbSBhIFJlbmRlcjJcbiAqIGBDb21waWxlVHlwZU1ldGFkYXRhYCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kZW5jaWVzRnJvbUdsb2JhbE1ldGFkYXRhKHR5cGUsIG91dHB1dEN0eCwgcmVmbGVjdG9yKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgLy8gVXNlIHRoZSBgQ29tcGlsZVJlZmxlY3RvcmAgdG8gbG9vayB1cCByZWZlcmVuY2VzIHRvIHNvbWUgd2VsbC1rbm93biBBbmd1bGFyIHR5cGVzLiBUaGVzZSB3aWxsXG4gICAgLy8gYmUgY29tcGFyZWQgd2l0aCB0aGUgdG9rZW4gdG8gc3RhdGljYWxseSBkZXRlcm1pbmUgd2hldGhlciB0aGUgdG9rZW4gaGFzIHNpZ25pZmljYW5jZSB0b1xuICAgIC8vIEFuZ3VsYXIsIGFuZCBzZXQgdGhlIGNvcnJlY3QgYFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZWAgYXMgYSByZXN1bHQuXG4gICAgdmFyIGluamVjdG9yUmVmID0gcmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShJZGVudGlmaWVycy5JbmplY3Rvcik7XG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSB0eXBlJ3MgREkgZGVwZW5kZW5jaWVzIGFuZCBwcm9kdWNlIGBSM0RlcGVuZGVuY3lNZXRhZGF0YWAgZm9yIGVhY2ggb2YgdGhlbS5cbiAgICB2YXIgZGVwcyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModHlwZS5kaURlcHMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgZGVwZW5kZW5jeSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3kudG9rZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5SZWYgPSB0b2tlblJlZmVyZW5jZShkZXBlbmRlbmN5LnRva2VuKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZWQgPSBkZXBlbmRlbmN5LmlzQXR0cmlidXRlID9cbiAgICAgICAgICAgICAgICAgICAgUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlLkF0dHJpYnV0ZSA6XG4gICAgICAgICAgICAgICAgICAgIFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZS5Ub2tlbjtcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBtb3N0IGRlcGVuZGVuY2llcywgdGhlIHRva2VuIHdpbGwgYmUgYSByZWZlcmVuY2UgdG8gYSB0eXBlLiBTb21ldGltZXMsXG4gICAgICAgICAgICAgICAgLy8gaG93ZXZlciwgaXQgY2FuIGJlIGEgc3RyaW5nLCBpbiB0aGUgY2FzZSBvZiBvbGRlciBBbmd1bGFyIGNvZGUgb3IgQEF0dHJpYnV0ZSBpbmplY3Rpb24uXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5SZWYgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wgPyBvdXRwdXRDdHguaW1wb3J0RXhwcih0b2tlblJlZikgOiBsaXRlcmFsKHRva2VuUmVmKTtcbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIGRlcGVuZGVuY3kuXG4gICAgICAgICAgICAgICAgZGVwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZDogcmVzb2x2ZWQsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6ICEhZGVwZW5kZW5jeS5pc0hvc3QsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiAhIWRlcGVuZGVuY3kuaXNPcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZjogISFkZXBlbmRlbmN5LmlzU2VsZixcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNlbGY6ICEhZGVwZW5kZW5jeS5pc1NraXBTZWxmLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQoJ2RlcGVuZGVuY3kgd2l0aG91dCBhIHRva2VuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBkZXBzO1xufVxuZnVuY3Rpb24gbWFrZUVycm9yU3RtdChuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBUaHJvd1N0bXQobmV3IEluc3RhbnRpYXRlRXhwcihuZXcgUmVhZFZhckV4cHIoJ0Vycm9yJyksIFtcbiAgICAgICAgbGl0ZXJhbChuYW1lICsgXCIgaGFzIGEgY29uc3RydWN0b3Igd2hpY2ggaXMgbm90IGNvbXBhdGlibGUgd2l0aCBEZXBlbmRlbmN5IEluamVjdGlvbi4gSXQgc2hvdWxkIHByb2JhYmx5IG5vdCBiZSBASW5qZWN0YWJsZSgpLlwiKVxuICAgIF0pKTtcbn1cbmZ1bmN0aW9uIGlzRGVsZWdhdGVkTWV0YWRhdGEobWV0YSkge1xuICAgIHJldHVybiBtZXRhLmRlbGVnYXRlVHlwZSAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNFeHByZXNzaW9uRmFjdG9yeU1ldGFkYXRhKG1ldGEpIHtcbiAgICByZXR1cm4gbWV0YS5leHByZXNzaW9uICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3QgbWFwIHdpdGggYEV4cHJlc3Npb25gIHZhbHVlcyBpbnRvIGEgYExpdGVyYWxNYXBFeHByYC5cbiAqL1xuZnVuY3Rpb24gbWFwVG9NYXBFeHByZXNzaW9uKG1hcCkge1xuICAgIHZhciByZXN1bHQgPSBPYmplY3Qua2V5cyhtYXApLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAoeyBrZXk6IGtleSwgdmFsdWU6IG1hcFtrZXldLCBxdW90ZWQ6IGZhbHNlIH0pOyB9KTtcbiAgICByZXR1cm4gbGl0ZXJhbE1hcChyZXN1bHQpO1xufVxuLyoqXG4gKiBDb252ZXJ0IG1ldGFkYXRhIGludG8gYW4gYEV4cHJlc3Npb25gIGluIHRoZSBnaXZlbiBgT3V0cHV0Q29udGV4dGAuXG4gKlxuICogVGhpcyBvcGVyYXRpb24gd2lsbCBoYW5kbGUgYXJyYXlzLCByZWZlcmVuY2VzIHRvIHN5bWJvbHMsIG9yIGxpdGVyYWwgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0TWV0YVRvT3V0cHV0KG1ldGEsIGN0eCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1ldGEpKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsQXJyKG1ldGEubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gY29udmVydE1ldGFUb091dHB1dChlbnRyeSwgY3R4KTsgfSkpO1xuICAgIH1cbiAgICBpZiAobWV0YSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICByZXR1cm4gY3R4LmltcG9ydEV4cHIobWV0YSk7XG4gICAgfVxuICAgIGlmIChtZXRhID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxpdGVyYWwobWV0YSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yOiBVbnN1cHBvcnRlZCBvciB1bmtub3duIG1ldGFkYXRhOiBcIiArIG1ldGEpO1xufVxuZnVuY3Rpb24gdHlwZVdpdGhQYXJhbWV0ZXJzKHR5cGUsIG51bVBhcmFtcykge1xuICAgIHZhciBwYXJhbXMgPSBudWxsO1xuICAgIGlmIChudW1QYXJhbXMgPiAwKSB7XG4gICAgICAgIHBhcmFtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBhcmFtczsgaSsrKSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChEWU5BTUlDX1RZUEUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHByZXNzaW9uVHlwZSh0eXBlLCBudWxsLCBwYXJhbXMpO1xufVxudmFyIEFOSU1BVEVfU1lNQk9MX1BSRUZJWCA9ICdAJztcbmZ1bmN0aW9uIHByZXBhcmVTeW50aGV0aWNQcm9wZXJ0eU5hbWUobmFtZSkge1xuICAgIHJldHVybiBcIlwiICsgQU5JTUFURV9TWU1CT0xfUFJFRklYICsgbmFtZTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVTeW50aGV0aWNMaXN0ZW5lck5hbWUobmFtZSwgcGhhc2UpIHtcbiAgICByZXR1cm4gXCJcIiArIEFOSU1BVEVfU1lNQk9MX1BSRUZJWCArIG5hbWUgKyBcIi5cIiArIHBoYXNlO1xufVxuZnVuY3Rpb24gaXNTeW50aGV0aWNQcm9wZXJ0eU9yTGlzdGVuZXIobmFtZSkge1xuICAgIHJldHVybiBuYW1lLmNoYXJBdCgwKSA9PSBBTklNQVRFX1NZTUJPTF9QUkVGSVg7XG59XG5mdW5jdGlvbiBnZXRTeW50aGV0aWNQcm9wZXJ0eU5hbWUobmFtZSkge1xuICAgIC8vIHRoaXMgd2lsbCBzdHJpcCBvdXQgbGlzdGVuZXIgcGhhc2UgdmFsdWVzLi4uXG4gICAgLy8gQGZvby5zdGFydCA9PiBAZm9vXG4gICAgdmFyIGkgPSBuYW1lLmluZGV4T2YoJy4nKTtcbiAgICBuYW1lID0gaSA+IDAgPyBuYW1lLnN1YnN0cmluZygwLCBpKSA6IG5hbWU7XG4gICAgaWYgKG5hbWUuY2hhckF0KDApICE9PSBBTklNQVRFX1NZTUJPTF9QUkVGSVgpIHtcbiAgICAgICAgbmFtZSA9IEFOSU1BVEVfU1lNQk9MX1BSRUZJWCArIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gcHJlcGFyZVN5bnRoZXRpY0xpc3RlbmVyRnVuY3Rpb25OYW1lKG5hbWUsIHBoYXNlKSB7XG4gICAgcmV0dXJuIFwiYW5pbWF0aW9uX1wiICsgbmFtZSArIFwiX1wiICsgcGhhc2U7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVJbmplY3RhYmxlKG1ldGEpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICB2YXIgZmFjdG9yeU1ldGEgPSB7XG4gICAgICAgIG5hbWU6IG1ldGEubmFtZSxcbiAgICAgICAgdHlwZTogbWV0YS50eXBlLFxuICAgICAgICBkZXBzOiBtZXRhLmN0b3JEZXBzLFxuICAgICAgICBpbmplY3RGbjogSWRlbnRpZmllcnMuaW5qZWN0LFxuICAgIH07XG4gICAgaWYgKG1ldGEudXNlQ2xhc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBtZXRhLnVzZUNsYXNzIGhhcyB0d28gbW9kZXMgb2Ygb3BlcmF0aW9uLiBFaXRoZXIgZGVwcyBhcmUgc3BlY2lmaWVkLCBpbiB3aGljaCBjYXNlIGBuZXdgIGlzXG4gICAgICAgIC8vIHVzZWQgdG8gaW5zdGFudGlhdGUgdGhlIGNsYXNzIHdpdGggZGVwZW5kZW5jaWVzIGluamVjdGVkLCBvciBkZXBzIGFyZSBub3Qgc3BlY2lmaWVkIGFuZFxuICAgICAgICAvLyB0aGUgZmFjdG9yeSBvZiB0aGUgY2xhc3MgaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBpdC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQSBzcGVjaWFsIGNhc2UgZXhpc3RzIGZvciB1c2VDbGFzczogVHlwZSB3aGVyZSBUeXBlIGlzIHRoZSBpbmplY3RhYmxlIHR5cGUgaXRzZWxmIGFuZCBub1xuICAgICAgICAvLyBkZXBzIGFyZSBzcGVjaWZpZWQsIGluIHdoaWNoIGNhc2UgJ3VzZUNsYXNzJyBpcyBlZmZlY3RpdmVseSBpZ25vcmVkLlxuICAgICAgICB2YXIgdXNlQ2xhc3NPblNlbGYgPSBtZXRhLnVzZUNsYXNzLmlzRXF1aXZhbGVudChtZXRhLnR5cGUpO1xuICAgICAgICB2YXIgZGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1ldGEudXNlckRlcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVwcyA9IG1ldGEudXNlckRlcHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZmFjdG9yeTogKCkgPT4gbmV3IG1ldGEudXNlQ2xhc3MoLi4uZGVwcylcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbXBpbGVGYWN0b3J5RnVuY3Rpb24oX19hc3NpZ24oe30sIGZhY3RvcnlNZXRhLCB7IGRlbGVnYXRlOiBtZXRhLnVzZUNsYXNzLCBkZWxlZ2F0ZURlcHM6IGRlcHMsIGRlbGVnYXRlVHlwZTogUjNGYWN0b3J5RGVsZWdhdGVUeXBlLkNsYXNzIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1c2VDbGFzc09uU2VsZikge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29tcGlsZUZhY3RvcnlGdW5jdGlvbihmYWN0b3J5TWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKF9fYXNzaWduKHt9LCBmYWN0b3J5TWV0YSwgeyBkZWxlZ2F0ZTogbWV0YS51c2VDbGFzcywgZGVsZWdhdGVUeXBlOiBSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGUuRmFjdG9yeSB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobWV0YS51c2VGYWN0b3J5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gY29tcGlsZUZhY3RvcnlGdW5jdGlvbihfX2Fzc2lnbih7fSwgZmFjdG9yeU1ldGEsIHsgZGVsZWdhdGU6IG1ldGEudXNlRmFjdG9yeSwgZGVsZWdhdGVEZXBzOiBtZXRhLnVzZXJEZXBzIHx8IFtdLCBkZWxlZ2F0ZVR5cGU6IFIzRmFjdG9yeURlbGVnYXRlVHlwZS5GdW5jdGlvbiB9KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGEudXNlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBOb3RlOiBpdCdzIHNhZmUgdG8gdXNlIGBtZXRhLnVzZVZhbHVlYCBpbnN0ZWFkIG9mIHRoZSBgVVNFX1ZBTFVFIGluIG1ldGFgIGNoZWNrIHVzZWQgZm9yXG4gICAgICAgIC8vIGNsaWVudCBjb2RlIGJlY2F1c2UgbWV0YS51c2VWYWx1ZSBpcyBhbiBFeHByZXNzaW9uIHdoaWNoIHdpbGwgYmUgZGVmaW5lZCBldmVuIGlmIHRoZSBhY3R1YWxcbiAgICAgICAgLy8gdmFsdWUgaXMgdW5kZWZpbmVkLlxuICAgICAgICByZXN1bHQgPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKF9fYXNzaWduKHt9LCBmYWN0b3J5TWV0YSwgeyBleHByZXNzaW9uOiBtZXRhLnVzZVZhbHVlIH0pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWV0YS51c2VFeGlzdGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVzZUV4aXN0aW5nIGlzIGFuIGBpbmplY3RgIGNhbGwgb24gdGhlIGV4aXN0aW5nIHRva2VuLlxuICAgICAgICByZXN1bHQgPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKF9fYXNzaWduKHt9LCBmYWN0b3J5TWV0YSwgeyBleHByZXNzaW9uOiBpbXBvcnRFeHByKElkZW50aWZpZXJzLmluamVjdCkuY2FsbEZuKFttZXRhLnVzZUV4aXN0aW5nXSkgfSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY29tcGlsZUZhY3RvcnlGdW5jdGlvbihmYWN0b3J5TWV0YSk7XG4gICAgfVxuICAgIHZhciB0b2tlbiA9IG1ldGEudHlwZTtcbiAgICB2YXIgcHJvdmlkZWRJbiA9IG1ldGEucHJvdmlkZWRJbjtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuybXJtWRlZmluZUluamVjdGFibGUpLmNhbGxGbihbbWFwVG9NYXBFeHByZXNzaW9uKHsgdG9rZW46IHRva2VuLCBmYWN0b3J5OiByZXN1bHQuZmFjdG9yeSwgcHJvdmlkZWRJbjogcHJvdmlkZWRJbiB9KV0pO1xuICAgIHZhciB0eXBlID0gbmV3IEV4cHJlc3Npb25UeXBlKGltcG9ydEV4cHIoSWRlbnRpZmllcnMuSW5qZWN0YWJsZURlZiwgW3R5cGVXaXRoUGFyYW1ldGVycyhtZXRhLnR5cGUsIG1ldGEudHlwZUFyZ3VtZW50Q291bnQpXSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHN0YXRlbWVudHM6IHJlc3VsdC5zdGF0ZW1lbnRzLFxuICAgIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEFycmF5T2ZTdHJpbmdzKGlkZW50aWZpZXIsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkZW50aWZpZXIgKyBcIicgdG8gYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cIik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkZW50aWZpZXIgKyBcIicgdG8gYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cIik7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgVU5VU0FCTEVfSU5URVJQT0xBVElPTl9SRUdFWFBTID0gW1xuICAgIC9eXFxzKiQvLFxuICAgIC9bPD5dLyxcbiAgICAvXlt7fV0kLyxcbiAgICAvJigjfFthLXpdKS9pLFxuICAgIC9eXFwvXFwvLyxcbl07XG5mdW5jdGlvbiBhc3NlcnRJbnRlcnBvbGF0aW9uU3ltYm9scyhpZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICEoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09IDIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkZW50aWZpZXIgKyBcIicgdG8gYmUgYW4gYXJyYXksIFtzdGFydCwgZW5kXS5cIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHN0YXJ0XzEgPSB2YWx1ZVswXTtcbiAgICAgICAgdmFyIGVuZF8xID0gdmFsdWVbMV07XG4gICAgICAgIC8vIENoZWNrIGZvciB1bnVzYWJsZSBpbnRlcnBvbGF0aW9uIHN5bWJvbHNcbiAgICAgICAgVU5VU0FCTEVfSU5URVJQT0xBVElPTl9SRUdFWFBTLmZvckVhY2goZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgICAgICAgICAgaWYgKHJlZ2V4cC50ZXN0KHN0YXJ0XzEpIHx8IHJlZ2V4cC50ZXN0KGVuZF8xKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlsnXCIgKyBzdGFydF8xICsgXCInLCAnXCIgKyBlbmRfMSArIFwiJ10gY29udGFpbnMgdW51c2FibGUgaW50ZXJwb2xhdGlvbiBzeW1ib2wuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBJbnRlcnBvbGF0aW9uQ29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEludGVycG9sYXRpb25Db25maWcoc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIH1cbiAgICBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheSA9IGZ1bmN0aW9uIChtYXJrZXJzKSB7XG4gICAgICAgIGlmICghbWFya2Vycykge1xuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0SW50ZXJwb2xhdGlvblN5bWJvbHMoJ2ludGVycG9sYXRpb24nLCBtYXJrZXJzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGF0aW9uQ29uZmlnKG1hcmtlcnNbMF0sIG1hcmtlcnNbMV0pO1xuICAgIH07XG4gICAgcmV0dXJuIEludGVycG9sYXRpb25Db25maWc7XG59KCkpO1xudmFyIERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcgPSBuZXcgSW50ZXJwb2xhdGlvbkNvbmZpZygne3snLCAnfX0nKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0XG52YXIgVkVSU0lPTiA9IDM7XG52YXIgSlNfQjY0X1BSRUZJWCA9ICcjIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnO1xudmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoZmlsZSkge1xuICAgICAgICBpZiAoZmlsZSA9PT0gdm9pZCAwKSB7IGZpbGUgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIHRoaXMuc291cmNlc0NvbnRlbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5sYXN0Q29sMCA9IDA7XG4gICAgICAgIHRoaXMuaGFzTWFwcGluZ3MgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gVGhlIGNvbnRlbnQgaXMgYG51bGxgIHdoZW4gdGhlIGNvbnRlbnQgaXMgZXhwZWN0ZWQgdG8gYmUgbG9hZGVkIHVzaW5nIHRoZSBVUkxcbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZFNvdXJjZSA9IGZ1bmN0aW9uICh1cmwsIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09IHZvaWQgMCkgeyBjb250ZW50ID0gbnVsbDsgfVxuICAgICAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQuaGFzKHVybCkpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlc0NvbnRlbnQuc2V0KHVybCwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGluZXMucHVzaChbXSk7XG4gICAgICAgIHRoaXMubGFzdENvbDAgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTWFwcGluZyA9IGZ1bmN0aW9uIChjb2wwLCBzb3VyY2VVcmwsIHNvdXJjZUxpbmUwLCBzb3VyY2VDb2wwKSB7XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50TGluZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBsaW5lIG11c3QgYmUgYWRkZWQgYmVmb3JlIG1hcHBpbmdzIGNhbiBiZSBhZGRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlVXJsICE9IG51bGwgJiYgIXRoaXMuc291cmNlc0NvbnRlbnQuaGFzKHNvdXJjZVVybCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gc291cmNlIGZpbGUgXFxcIlwiICsgc291cmNlVXJsICsgXCJcXFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2wwID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjb2x1bW4gaW4gdGhlIGdlbmVyYXRlZCBjb2RlIG11c3QgYmUgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbDAgPCB0aGlzLmxhc3RDb2wwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYXBwaW5nIHNob3VsZCBiZSBhZGRlZCBpbiBvdXRwdXQgb3JkZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVVybCAmJiAoc291cmNlTGluZTAgPT0gbnVsbCB8fCBzb3VyY2VDb2wwID09IG51bGwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc291cmNlIGxvY2F0aW9uIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBhIHNvdXJjZSB1cmwgaXMgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNNYXBwaW5ncyA9IHRydWU7XG4gICAgICAgIHRoaXMubGFzdENvbDAgPSBjb2wwO1xuICAgICAgICB0aGlzLmN1cnJlbnRMaW5lLnB1c2goeyBjb2wwOiBjb2wwLCBzb3VyY2VVcmw6IHNvdXJjZVVybCwgc291cmNlTGluZTA6IHNvdXJjZUxpbmUwLCBzb3VyY2VDb2wwOiBzb3VyY2VDb2wwIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLCBcImN1cnJlbnRMaW5lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmxpbmVzLnNsaWNlKC0xKVswXTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5oYXNNYXBwaW5ncykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZXNJbmRleCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgdmFyIHNvdXJjZXNDb250ZW50ID0gW107XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5zb3VyY2VzQ29udGVudC5rZXlzKCkpLmZvckVhY2goZnVuY3Rpb24gKHVybCwgaSkge1xuICAgICAgICAgICAgc291cmNlc0luZGV4LnNldCh1cmwsIGkpO1xuICAgICAgICAgICAgc291cmNlcy5wdXNoKHVybCk7XG4gICAgICAgICAgICBzb3VyY2VzQ29udGVudC5wdXNoKF90aGlzLnNvdXJjZXNDb250ZW50LmdldCh1cmwpIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1hcHBpbmdzID0gJyc7XG4gICAgICAgIHZhciBsYXN0Q29sMCA9IDA7XG4gICAgICAgIHZhciBsYXN0U291cmNlSW5kZXggPSAwO1xuICAgICAgICB2YXIgbGFzdFNvdXJjZUxpbmUwID0gMDtcbiAgICAgICAgdmFyIGxhc3RTb3VyY2VDb2wwID0gMDtcbiAgICAgICAgdGhpcy5saW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50cykge1xuICAgICAgICAgICAgbGFzdENvbDAgPSAwO1xuICAgICAgICAgICAgbWFwcGluZ3MgKz0gc2VnbWVudHNcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gemVyby1iYXNlZCBzdGFydGluZyBjb2x1bW4gb2YgdGhlIGxpbmUgaW4gdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgICAgICAgICAgICAgdmFyIHNlZ0FzU3RyID0gdG9CYXNlNjRWTFEoc2VnbWVudC5jb2wwIC0gbGFzdENvbDApO1xuICAgICAgICAgICAgICAgIGxhc3RDb2wwID0gc2VnbWVudC5jb2wwO1xuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50LnNvdXJjZVVybCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHplcm8tYmFzZWQgaW5kZXggaW50byB0aGUg4oCcc291cmNlc+KAnSBsaXN0XG4gICAgICAgICAgICAgICAgICAgIHNlZ0FzU3RyICs9XG4gICAgICAgICAgICAgICAgICAgICAgICB0b0Jhc2U2NFZMUShzb3VyY2VzSW5kZXguZ2V0KHNlZ21lbnQuc291cmNlVXJsKSAtIGxhc3RTb3VyY2VJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTb3VyY2VJbmRleCA9IHNvdXJjZXNJbmRleC5nZXQoc2VnbWVudC5zb3VyY2VVcmwpO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgemVyby1iYXNlZCBzdGFydGluZyBsaW5lIGluIHRoZSBvcmlnaW5hbCBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgc2VnQXNTdHIgKz0gdG9CYXNlNjRWTFEoc2VnbWVudC5zb3VyY2VMaW5lMCAtIGxhc3RTb3VyY2VMaW5lMCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTb3VyY2VMaW5lMCA9IHNlZ21lbnQuc291cmNlTGluZTA7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB6ZXJvLWJhc2VkIHN0YXJ0aW5nIGNvbHVtbiBpbiB0aGUgb3JpZ2luYWwgc291cmNlXG4gICAgICAgICAgICAgICAgICAgIHNlZ0FzU3RyICs9IHRvQmFzZTY0VkxRKHNlZ21lbnQuc291cmNlQ29sMCAtIGxhc3RTb3VyY2VDb2wwKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNvdXJjZUNvbDAgPSBzZWdtZW50LnNvdXJjZUNvbDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWdBc1N0cjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJywnKTtcbiAgICAgICAgICAgIG1hcHBpbmdzICs9ICc7JztcbiAgICAgICAgfSk7XG4gICAgICAgIG1hcHBpbmdzID0gbWFwcGluZ3Muc2xpY2UoMCwgLTEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2ZpbGUnOiB0aGlzLmZpbGUgfHwgJycsXG4gICAgICAgICAgICAndmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAgICAgICAnc291cmNlUm9vdCc6ICcnLFxuICAgICAgICAgICAgJ3NvdXJjZXMnOiBzb3VyY2VzLFxuICAgICAgICAgICAgJ3NvdXJjZXNDb250ZW50Jzogc291cmNlc0NvbnRlbnQsXG4gICAgICAgICAgICAnbWFwcGluZ3MnOiBtYXBwaW5ncyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9Kc0NvbW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc01hcHBpbmdzID8gJy8vJyArIEpTX0I2NF9QUkVGSVggKyB0b0Jhc2U2NFN0cmluZyhKU09OLnN0cmluZ2lmeSh0aGlzLCBudWxsLCAwKSkgOlxuICAgICAgICAgICAgJyc7XG4gICAgfTtcbiAgICByZXR1cm4gU291cmNlTWFwR2VuZXJhdG9yO1xufSgpKTtcbmZ1bmN0aW9uIHRvQmFzZTY0U3RyaW5nKHZhbHVlKSB7XG4gICAgdmFyIGI2NCA9ICcnO1xuICAgIHZhbHVlID0gdXRmOEVuY29kZSh2YWx1ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7KSB7XG4gICAgICAgIHZhciBpMSA9IHZhbHVlLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgdmFyIGkyID0gdmFsdWUuY2hhckNvZGVBdChpKyspO1xuICAgICAgICB2YXIgaTMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGI2NCArPSB0b0Jhc2U2NERpZ2l0KGkxID4+IDIpO1xuICAgICAgICBiNjQgKz0gdG9CYXNlNjREaWdpdCgoKGkxICYgMykgPDwgNCkgfCAoaXNOYU4oaTIpID8gMCA6IGkyID4+IDQpKTtcbiAgICAgICAgYjY0ICs9IGlzTmFOKGkyKSA/ICc9JyA6IHRvQmFzZTY0RGlnaXQoKChpMiAmIDE1KSA8PCAyKSB8IChpMyA+PiA2KSk7XG4gICAgICAgIGI2NCArPSBpc05hTihpMikgfHwgaXNOYU4oaTMpID8gJz0nIDogdG9CYXNlNjREaWdpdChpMyAmIDYzKTtcbiAgICB9XG4gICAgcmV0dXJuIGI2NDtcbn1cbmZ1bmN0aW9uIHRvQmFzZTY0VkxRKHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSA8IDAgPyAoKC12YWx1ZSkgPDwgMSkgKyAxIDogdmFsdWUgPDwgMTtcbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgZG8ge1xuICAgICAgICB2YXIgZGlnaXQgPSB2YWx1ZSAmIDMxO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDU7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgIGRpZ2l0ID0gZGlnaXQgfCAzMjtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gdG9CYXNlNjREaWdpdChkaWdpdCk7XG4gICAgfSB3aGlsZSAodmFsdWUgPiAwKTtcbiAgICByZXR1cm4gb3V0O1xufVxudmFyIEI2NF9ESUdJVFMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5mdW5jdGlvbiB0b0Jhc2U2NERpZ2l0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gb25seSBlbmNvZGUgdmFsdWUgaW4gdGhlIHJhbmdlIFswLCA2M11cIik7XG4gICAgfVxuICAgIHJldHVybiBCNjRfRElHSVRTW3ZhbHVlXTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9TSU5HTEVfUVVPVEVfRVNDQVBFX1NUUklOR19SRSA9IC8nfFxcXFx8XFxufFxccnxcXCQvZztcbnZhciBfTEVHQUxfSURFTlRJRklFUl9SRSA9IC9eWyRBLVpfXVswLTlBLVpfJF0qJC9pO1xudmFyIF9JTkRFTlRfV0lUSCA9ICcgICc7XG52YXIgQ0FUQ0hfRVJST1JfVkFSJDEgPSB2YXJpYWJsZSgnZXJyb3InLCBudWxsLCBudWxsKTtcbnZhciBDQVRDSF9TVEFDS19WQVIkMSA9IHZhcmlhYmxlKCdzdGFjaycsIG51bGwsIG51bGwpO1xudmFyIF9FbWl0dGVkTGluZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfRW1pdHRlZExpbmUoaW5kZW50KSB7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gaW5kZW50O1xuICAgICAgICB0aGlzLnBhcnRzTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLnNyY1NwYW5zID0gW107XG4gICAgfVxuICAgIHJldHVybiBfRW1pdHRlZExpbmU7XG59KCkpO1xudmFyIEVtaXR0ZXJWaXNpdG9yQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbWl0dGVyVmlzaXRvckNvbnRleHQoX2luZGVudCkge1xuICAgICAgICB0aGlzLl9pbmRlbnQgPSBfaW5kZW50O1xuICAgICAgICB0aGlzLl9jbGFzc2VzID0gW107XG4gICAgICAgIHRoaXMuX3ByZWFtYmxlTGluZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fbGluZXMgPSBbbmV3IF9FbWl0dGVkTGluZShfaW5kZW50KV07XG4gICAgfVxuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEVtaXR0ZXJWaXNpdG9yQ29udGV4dCgwKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZSwgXCJfY3VycmVudExpbmVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xpbmVzW3RoaXMuX2xpbmVzLmxlbmd0aCAtIDFdOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnByaW50bG4gPSBmdW5jdGlvbiAoZnJvbSwgbGFzdFBhcnQpIHtcbiAgICAgICAgaWYgKGxhc3RQYXJ0ID09PSB2b2lkIDApIHsgbGFzdFBhcnQgPSAnJzsgfVxuICAgICAgICB0aGlzLnByaW50KGZyb20gfHwgbnVsbCwgbGFzdFBhcnQsIHRydWUpO1xuICAgIH07XG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5saW5lSXNFbXB0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2N1cnJlbnRMaW5lLnBhcnRzLmxlbmd0aCA9PT0gMDsgfTtcbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmxpbmVMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50TGluZS5pbmRlbnQgKiBfSU5ERU5UX1dJVEgubGVuZ3RoICsgdGhpcy5fY3VycmVudExpbmUucGFydHNMZW5ndGg7XG4gICAgfTtcbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gKGZyb20sIHBhcnQsIG5ld0xpbmUpIHtcbiAgICAgICAgaWYgKG5ld0xpbmUgPT09IHZvaWQgMCkgeyBuZXdMaW5lID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHBhcnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudExpbmUucGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLnBhcnRzTGVuZ3RoICs9IHBhcnQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudExpbmUuc3JjU3BhbnMucHVzaChmcm9tICYmIGZyb20uc291cmNlU3BhbiB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3TGluZSkge1xuICAgICAgICAgICAgdGhpcy5fbGluZXMucHVzaChuZXcgX0VtaXR0ZWRMaW5lKHRoaXMuX2luZGVudCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnJlbW92ZUVtcHR5TGFzdExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVJc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmluY0luZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5kZW50Kys7XG4gICAgICAgIGlmICh0aGlzLmxpbmVJc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLmluZGVudCA9IHRoaXMuX2luZGVudDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5kZWNJbmRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2luZGVudC0tO1xuICAgICAgICBpZiAodGhpcy5saW5lSXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5pbmRlbnQgPSB0aGlzLl9pbmRlbnQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucHVzaENsYXNzID0gZnVuY3Rpb24gKGNsYXp6KSB7IHRoaXMuX2NsYXNzZXMucHVzaChjbGF6eik7IH07XG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5wb3BDbGFzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NsYXNzZXMucG9wKCk7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUsIFwiY3VycmVudENsYXNzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xhc3Nlcy5sZW5ndGggPiAwID8gdGhpcy5fY2xhc3Nlc1t0aGlzLl9jbGFzc2VzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS50b1NvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlTGluZXNcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwucGFydHMubGVuZ3RoID4gMCA/IF9jcmVhdGVJbmRlbnQobC5pbmRlbnQpICsgbC5wYXJ0cy5qb2luKCcnKSA6ICcnOyB9KVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIH07XG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS50b1NvdXJjZU1hcEdlbmVyYXRvciA9IGZ1bmN0aW9uIChnZW5GaWxlUGF0aCwgc3RhcnRzQXRMaW5lKSB7XG4gICAgICAgIGlmIChzdGFydHNBdExpbmUgPT09IHZvaWQgMCkgeyBzdGFydHNBdExpbmUgPSAwOyB9XG4gICAgICAgIHZhciBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGdlbkZpbGVQYXRoKTtcbiAgICAgICAgdmFyIGZpcnN0T2Zmc2V0TWFwcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBtYXBGaXJzdE9mZnNldElmTmVlZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFmaXJzdE9mZnNldE1hcHBlZCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIHNpbmdsZSBzcGFjZSBzbyB0aGF0IHRvb2xzIHdvbid0IHRyeSB0byBsb2FkIHRoZSBmaWxlIGZyb20gZGlzay5cbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBXZSBhcmUgdXNpbmcgdmlydHVhbCB1cmxzIGxpa2UgYG5nOi8vL2AsIHNvIHdlIGhhdmUgdG9cbiAgICAgICAgICAgICAgICAvLyBwcm92aWRlIGEgY29udGVudCBoZXJlLlxuICAgICAgICAgICAgICAgIG1hcC5hZGRTb3VyY2UoZ2VuRmlsZVBhdGgsICcgJykuYWRkTWFwcGluZygwLCBnZW5GaWxlUGF0aCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgZmlyc3RPZmZzZXRNYXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXJ0c0F0TGluZTsgaSsrKSB7XG4gICAgICAgICAgICBtYXAuYWRkTGluZSgpO1xuICAgICAgICAgICAgbWFwRmlyc3RPZmZzZXRJZk5lZWRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc291cmNlTGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSwgbGluZUlkeCkge1xuICAgICAgICAgICAgbWFwLmFkZExpbmUoKTtcbiAgICAgICAgICAgIHZhciBzcGFucyA9IGxpbmUuc3JjU3BhbnM7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBsaW5lLnBhcnRzO1xuICAgICAgICAgICAgdmFyIGNvbDAgPSBsaW5lLmluZGVudCAqIF9JTkRFTlRfV0lUSC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgc3BhbklkeCA9IDA7XG4gICAgICAgICAgICAvLyBza2lwIGxlYWRpbmcgcGFydHMgd2l0aG91dCBzb3VyY2Ugc3BhbnNcbiAgICAgICAgICAgIHdoaWxlIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoICYmICFzcGFuc1tzcGFuSWR4XSkge1xuICAgICAgICAgICAgICAgIGNvbDAgKz0gcGFydHNbc3BhbklkeF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHNwYW5JZHgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoICYmIGxpbmVJZHggPT09IDAgJiYgY29sMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZpcnN0T2Zmc2V0TWFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hcEZpcnN0T2Zmc2V0SWZOZWVkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwYW4gPSBzcGFuc1tzcGFuSWR4XTtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gc3Bhbi5zdGFydC5maWxlO1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VMaW5lID0gc3Bhbi5zdGFydC5saW5lO1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VDb2wgPSBzcGFuLnN0YXJ0LmNvbDtcbiAgICAgICAgICAgICAgICBtYXAuYWRkU291cmNlKHNvdXJjZS51cmwsIHNvdXJjZS5jb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAuYWRkTWFwcGluZyhjb2wwLCBzb3VyY2UudXJsLCBzb3VyY2VMaW5lLCBzb3VyY2VDb2wpO1xuICAgICAgICAgICAgICAgIGNvbDAgKz0gcGFydHNbc3BhbklkeF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHNwYW5JZHgrKztcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ24gcGFydHMgd2l0aG91dCBzcGFuIG9yIHRoZSBzYW1lIHNwYW4gdG8gdGhlIHByZXZpb3VzIHNlZ21lbnRcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3BhbklkeCA8IHNwYW5zLmxlbmd0aCAmJiAoc3BhbiA9PT0gc3BhbnNbc3BhbklkeF0gfHwgIXNwYW5zW3NwYW5JZHhdKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2wwICs9IHBhcnRzW3NwYW5JZHhdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgc3BhbklkeCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfTtcbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnNldFByZWFtYmxlTGluZUNvdW50ID0gZnVuY3Rpb24gKGNvdW50KSB7IHJldHVybiB0aGlzLl9wcmVhbWJsZUxpbmVDb3VudCA9IGNvdW50OyB9O1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUuc3Bhbk9mID0gZnVuY3Rpb24gKGxpbmUsIGNvbHVtbikge1xuICAgICAgICB2YXIgZW1pdHRlZExpbmUgPSB0aGlzLl9saW5lc1tsaW5lIC0gdGhpcy5fcHJlYW1ibGVMaW5lQ291bnRdO1xuICAgICAgICBpZiAoZW1pdHRlZExpbmUpIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW5zTGVmdCA9IGNvbHVtbiAtIF9jcmVhdGVJbmRlbnQoZW1pdHRlZExpbmUuaW5kZW50KS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBwYXJ0SW5kZXggPSAwOyBwYXJ0SW5kZXggPCBlbWl0dGVkTGluZS5wYXJ0cy5sZW5ndGg7IHBhcnRJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBlbWl0dGVkTGluZS5wYXJ0c1twYXJ0SW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA+IGNvbHVtbnNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbWl0dGVkTGluZS5zcmNTcGFuc1twYXJ0SW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zTGVmdCAtPSBwYXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLCBcInNvdXJjZUxpbmVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZXMubGVuZ3RoICYmIHRoaXMuX2xpbmVzW3RoaXMuX2xpbmVzLmxlbmd0aCAtIDFdLnBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lcy5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGluZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBFbWl0dGVyVmlzaXRvckNvbnRleHQ7XG59KCkpO1xudmFyIEFic3RyYWN0RW1pdHRlclZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RFbWl0dGVyVmlzaXRvcihfZXNjYXBlRG9sbGFySW5TdHJpbmdzKSB7XG4gICAgICAgIHRoaXMuX2VzY2FwZURvbGxhckluU3RyaW5ncyA9IF9lc2NhcGVEb2xsYXJJblN0cmluZ3M7XG4gICAgfVxuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgJzsnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJldHVyblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcInJldHVybiBcIik7XG4gICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsICc7Jyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJZlN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcImlmIChcIik7XG4gICAgICAgIHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCIpIHtcIik7XG4gICAgICAgIHZhciBoYXNFbHNlQ2FzZSA9IHN0bXQuZmFsc2VDYXNlICE9IG51bGwgJiYgc3RtdC5mYWxzZUNhc2UubGVuZ3RoID4gMDtcbiAgICAgICAgaWYgKHN0bXQudHJ1ZUNhc2UubGVuZ3RoIDw9IDEgJiYgIWhhc0Vsc2VDYXNlKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCIgXCIpO1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY3R4KTtcbiAgICAgICAgICAgIGN0eC5yZW1vdmVFbXB0eUxhc3RMaW5lKCk7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnByaW50bG4oKTtcbiAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICBpZiAoaGFzRWxzZUNhc2UpIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn0gZWxzZSB7XCIpO1xuICAgICAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmZhbHNlQ2FzZSwgY3R4KTtcbiAgICAgICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGhyb3dTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJ0aHJvdyBcIik7XG4gICAgICAgIHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiO1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoc3RtdC5tdWx0aWxpbmUpIHtcbiAgICAgICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiLyogXCIgKyBzdG10LmNvbW1lbnQgKyBcIiAqL1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0bXQuY29tbWVudC5zcGxpdCgnXFxuJykuZm9yRWFjaChmdW5jdGlvbiAobGluZSkgeyBjdHgucHJpbnRsbihzdG10LCBcIi8vIFwiICsgbGluZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRKU0RvY0NvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIi8qXCIgKyBzdG10LnRvU3RyaW5nKCkgKyBcIiovXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVWYXJFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICB2YXIgbGluZVdhc0VtcHR5ID0gY3R4LmxpbmVJc0VtcHR5KCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJygnKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoZXhwciwgZXhwci5uYW1lICsgXCIgPSBcIik7XG4gICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJyknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVLZXlFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICB2YXIgbGluZVdhc0VtcHR5ID0gY3R4LmxpbmVJc0VtcHR5KCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJygnKTtcbiAgICAgICAgfVxuICAgICAgICBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgXCJbXCIpO1xuICAgICAgICBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgXCJdID0gXCIpO1xuICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlUHJvcEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciBsaW5lV2FzRW1wdHkgPSBjdHgubGluZUlzRW1wdHkoKTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKCcpO1xuICAgICAgICB9XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChleHByLCBcIi5cIiArIGV4cHIubmFtZSArIFwiID0gXCIpO1xuICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHZhciBuYW1lID0gZXhwci5uYW1lO1xuICAgICAgICBpZiAoZXhwci5idWlsdGluICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLmdldEJ1aWx0aW5NZXRob2ROYW1lKGV4cHIuYnVpbHRpbik7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gc29tZSBidWlsdGlucyBqdXN0IG1lYW4gdG8gc2tpcCB0aGUgY2FsbC5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIuXCIgKyBuYW1lICsgXCIoXCIpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoZXhwci5hcmdzLCBjdHgsIFwiLFwiKTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgZXhwci5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiKFwiKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4LCAnLCcpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JhcHBlZE5vZGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWJzdHJhY3QgZW1pdHRlciBjYW5ub3QgdmlzaXQgV3JhcHBlZE5vZGVFeHByLicpO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUeXBlb2ZFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgJ3R5cGVvZiAnKTtcbiAgICAgICAgZXhwci5leHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgdmFyTmFtZSA9IGFzdC5uYW1lO1xuICAgICAgICBpZiAoYXN0LmJ1aWx0aW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoIChhc3QuYnVpbHRpbikge1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5TdXBlcjpcbiAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9ICdzdXBlcic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5UaGlzOlxuICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gJ3RoaXMnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuQ2F0Y2hFcnJvcjpcbiAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9IENBVENIX0VSUk9SX1ZBUiQxLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaFN0YWNrOlxuICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gQ0FUQ0hfU1RBQ0tfVkFSJDEubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBidWlsdGluIHZhcmlhYmxlIFwiICsgYXN0LmJ1aWx0aW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChhc3QsIHZhck5hbWUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwibmV3IFwiKTtcbiAgICAgICAgYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIoXCIpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXN0LnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgZXNjYXBlSWRlbnRpZmllcih2YWx1ZSwgdGhpcy5fZXNjYXBlRG9sbGFySW5TdHJpbmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIoXCIpO1xuICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCAnPyAnKTtcbiAgICAgICAgYXN0LnRydWVDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCAnOiAnKTtcbiAgICAgICAgYXN0LmZhbHNlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCAnIScpO1xuICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXNzZXJ0Tm90TnVsbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgb3BTdHI7XG4gICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc9PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc9PT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnIT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnIT09JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQW5kOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyYmJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQml0d2lzZUFuZDpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICcmJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuT3I6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnfHwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5QbHVzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJysnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NaW51czpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICctJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRGl2aWRlOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJy8nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NdWx0aXBseTpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICcqJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTW9kdWxvOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlcjpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc8JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnPD0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXI6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnPic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc+PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3IgXCIgKyBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhc3QucGFyZW5zKVxuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgXCIoXCIpO1xuICAgICAgICBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIiBcIiArIG9wU3RyICsgXCIgXCIpO1xuICAgICAgICBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoYXN0LnBhcmVucylcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiLlwiKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYXN0Lm5hbWUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZEtleUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIltcIik7XG4gICAgICAgIGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCJdXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIltcIik7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuZW50cmllcywgY3R4LCAnLCcpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIl1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIntcIik7XG4gICAgICAgIHRoaXMudmlzaXRBbGxPYmplY3RzKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgZXNjYXBlSWRlbnRpZmllcihlbnRyeS5rZXksIF90aGlzLl9lc2NhcGVEb2xsYXJJblN0cmluZ3MsIGVudHJ5LnF1b3RlZCkgKyBcIjpcIik7XG4gICAgICAgICAgICBlbnRyeS52YWx1ZS52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7XG4gICAgICAgIH0sIGFzdC5lbnRyaWVzLCBjdHgsICcsJyk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1hRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCAnKCcpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LnBhcnRzLCBjdHgsICcsJyk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICcpJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9LCBleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IpO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxPYmplY3RzID0gZnVuY3Rpb24gKGhhbmRsZXIsIGV4cHJlc3Npb25zLCBjdHgsIHNlcGFyYXRvcikge1xuICAgICAgICB2YXIgaW5jcmVtZW50ZWRJbmRlbnQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5saW5lTGVuZ3RoKCkgPiA4MCkge1xuICAgICAgICAgICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgc2VwYXJhdG9yLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbmNyZW1lbnRlZEluZGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWF0aW9uIGFyZSBtYXJrZWQgd2l0aCBkb3VibGUgaW5kZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50ZWRJbmRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgc2VwYXJhdG9yLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlcihleHByZXNzaW9uc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY3JlbWVudGVkSW5kZW50KSB7XG4gICAgICAgICAgICAvLyBjb250aW51YXRpb24gYXJlIG1hcmtlZCB3aXRoIGRvdWJsZSBpbmRlbnQuXG4gICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsU3RhdGVtZW50cyA9IGZ1bmN0aW9uIChzdGF0ZW1lbnRzLCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3RhdGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10LnZpc2l0U3RhdGVtZW50KF90aGlzLCBjdHgpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yO1xufSgpKTtcbmZ1bmN0aW9uIGVzY2FwZUlkZW50aWZpZXIoaW5wdXQsIGVzY2FwZURvbGxhciwgYWx3YXlzUXVvdGUpIHtcbiAgICBpZiAoYWx3YXlzUXVvdGUgPT09IHZvaWQgMCkgeyBhbHdheXNRdW90ZSA9IHRydWU7IH1cbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGJvZHkgPSBpbnB1dC5yZXBsYWNlKF9TSU5HTEVfUVVPVEVfRVNDQVBFX1NUUklOR19SRSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG1hdGNoW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoWzBdID09ICckJykge1xuICAgICAgICAgICAgcmV0dXJuIGVzY2FwZURvbGxhciA/ICdcXFxcJCcgOiAnJCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbMF0gPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdID09ICdcXHInKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxyJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFxcIiArIG1hdGNoWzBdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHJlcXVpcmVzUXVvdGVzID0gYWx3YXlzUXVvdGUgfHwgIV9MRUdBTF9JREVOVElGSUVSX1JFLnRlc3QoYm9keSk7XG4gICAgcmV0dXJuIHJlcXVpcmVzUXVvdGVzID8gXCInXCIgKyBib2R5ICsgXCInXCIgOiBib2R5O1xufVxuZnVuY3Rpb24gX2NyZWF0ZUluZGVudChjb3VudCkge1xuICAgIHZhciByZXMgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgcmVzICs9IF9JTkRFTlRfV0lUSDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGZhbHNlKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY3R4LnB1c2hDbGFzcyhzdG10KTtcbiAgICAgICAgdGhpcy5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yKHN0bXQsIGN0eCk7XG4gICAgICAgIGlmIChzdG10LnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgc3RtdC5uYW1lICsgXCIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShcIik7XG4gICAgICAgICAgICBzdG10LnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiLnByb3RvdHlwZSk7XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN0bXQuZ2V0dGVycy5mb3JFYWNoKGZ1bmN0aW9uIChnZXR0ZXIpIHsgcmV0dXJuIF90aGlzLl92aXNpdENsYXNzR2V0dGVyKHN0bXQsIGdldHRlciwgY3R4KTsgfSk7XG4gICAgICAgIHN0bXQubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgcmV0dXJuIF90aGlzLl92aXNpdENsYXNzTWV0aG9kKHN0bXQsIG1ldGhvZCwgY3R4KTsgfSk7XG4gICAgICAgIGN0eC5wb3BDbGFzcygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiZnVuY3Rpb24gXCIgKyBzdG10Lm5hbWUgKyBcIihcIik7XG4gICAgICAgIGlmIChzdG10LmNvbnN0cnVjdG9yTWV0aG9kICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIGlmIChzdG10LmNvbnN0cnVjdG9yTWV0aG9kICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn1cIik7XG4gICAgfTtcbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzR2V0dGVyID0gZnVuY3Rpb24gKHN0bXQsIGdldHRlciwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KFwiICsgc3RtdC5uYW1lICsgXCIucHJvdG90eXBlLCAnXCIgKyBnZXR0ZXIubmFtZSArIFwiJywgeyBnZXQ6IGZ1bmN0aW9uKCkge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICBpZiAoZ2V0dGVyLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ2YXIgc2VsZiA9IHRoaXM7XCIpO1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoZ2V0dGVyLmJvZHksIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn19KTtcIik7XG4gICAgfTtcbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzTWV0aG9kID0gZnVuY3Rpb24gKHN0bXQsIG1ldGhvZCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBzdG10Lm5hbWUgKyBcIi5wcm90b3R5cGUuXCIgKyBtZXRob2QubmFtZSArIFwiID0gZnVuY3Rpb24oXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhtZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICBpZiAobWV0aG9kLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ2YXIgc2VsZiA9IHRoaXM7XCIpO1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn07XCIpO1xuICAgIH07XG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyYXBwZWROb2RlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbWl0IGEgV3JhcHBlZE5vZGVFeHByIGluIEphdmFzY3JpcHQuJyk7XG4gICAgfTtcbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgaWYgKGFzdC5idWlsdGluID09PSBCdWlsdGluVmFyLlRoaXMpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsICdzZWxmJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXN0LmJ1aWx0aW4gPT09IEJ1aWx0aW5WYXIuU3VwZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidzdXBlcicgbmVlZHMgdG8gYmUgaGFuZGxlZCBhdCBhIHBhcmVudCBhc3Qgbm9kZSwgbm90IGF0IHRoZSB2YXJpYWJsZSBsZXZlbCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIuY2FsbCh0aGlzLCBhc3QsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcInZhciBcIiArIHN0bXQubmFtZSk7XG4gICAgICAgIGlmIChzdG10LnZhbHVlKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgJyA9ICcpO1xuICAgICAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIjtcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICB2YXIgZm5FeHByID0gZXhwci5mbjtcbiAgICAgICAgaWYgKGZuRXhwciBpbnN0YW5jZW9mIFJlYWRWYXJFeHByICYmIGZuRXhwci5idWlsdGluID09PSBCdWlsdGluVmFyLlN1cGVyKSB7XG4gICAgICAgICAgICBjdHguY3VycmVudENsYXNzLnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCBcIi5jYWxsKHRoaXNcIik7XG4gICAgICAgICAgICBpZiAoZXhwci5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIsIFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoZXhwci5hcmdzLCBjdHgsICcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwci5jYWxsKHRoaXMsIGV4cHIsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiZnVuY3Rpb25cIiArIChhc3QubmFtZSA/ICcgJyArIGFzdC5uYW1lIDogJycpICsgXCIoXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhhc3QucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihhc3QsIFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGFzdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiZnVuY3Rpb24gXCIgKyBzdG10Lm5hbWUgKyBcIihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnN0YXRlbWVudHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwidHJ5IHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5ib2R5U3RtdHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9IGNhdGNoIChcIiArIENBVENIX0VSUk9SX1ZBUiQxLm5hbWUgKyBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB2YXIgY2F0Y2hTdG10cyA9IFtDQVRDSF9TVEFDS19WQVIkMS5zZXQoQ0FUQ0hfRVJST1JfVkFSJDEucHJvcCgnc3RhY2snKSkudG9EZWNsU3RtdChudWxsLCBbXG4gICAgICAgICAgICAgICAgU3RtdE1vZGlmaWVyLkZpbmFsXG4gICAgICAgICAgICBdKV0uY29uY2F0KHN0bXQuY2F0Y2hTdG10cyk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGNhdGNoU3RtdHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0UGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcywgY3R4KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxPYmplY3RzKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gY3R4LnByaW50KG51bGwsIHBhcmFtLm5hbWUpOyB9LCBwYXJhbXMsIGN0eCwgJywnKTtcbiAgICB9O1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuZ2V0QnVpbHRpbk1ldGhvZE5hbWUgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHZhciBuYW1lO1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5OlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnY29uY2F0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5TdWJzY3JpYmVPYnNlcnZhYmxlOlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnc3Vic2NyaWJlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5CaW5kOlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnYmluZCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiBtZXRob2Q6IFwiICsgbWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIHJldHVybiBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3I7XG59KEFic3RyYWN0RW1pdHRlclZpc2l0b3IpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBIGhlbHBlciBjbGFzcyB0byBtYW5hZ2UgdGhlIGV2YWx1YXRpb24gb2YgSklUIGdlbmVyYXRlZCBjb2RlLlxuICovXG52YXIgSml0RXZhbHVhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEppdEV2YWx1YXRvcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc291cmNlVXJsIFRoZSBVUkwgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLlxuICAgICAqIEBwYXJhbSBzdGF0ZW1lbnRzIEFuIGFycmF5IG9mIEFuZ3VsYXIgc3RhdGVtZW50IEFTVCBub2RlcyB0byBiZSBldmFsdWF0ZWQuXG4gICAgICogQHBhcmFtIHJlZmxlY3RvciBBIGhlbHBlciB1c2VkIHdoZW4gY29udmVydGluZyB0aGUgc3RhdGVtZW50cyB0byBleGVjdXRhYmxlIGNvZGUuXG4gICAgICogQHBhcmFtIGNyZWF0ZVNvdXJjZU1hcHMgSWYgdHJ1ZSB0aGVuIGNyZWF0ZSBhIHNvdXJjZS1tYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZSBhbmQgaW5jbHVkZSBpdFxuICAgICAqIGlubGluZSBhcyBhIHNvdXJjZS1tYXAgY29tbWVudC5cbiAgICAgKiBAcmV0dXJucyBBIG1hcCBvZiBhbGwgdGhlIHZhcmlhYmxlcyBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4gICAgICovXG4gICAgSml0RXZhbHVhdG9yLnByb3RvdHlwZS5ldmFsdWF0ZVN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc291cmNlVXJsLCBzdGF0ZW1lbnRzLCByZWZsZWN0b3IsIGNyZWF0ZVNvdXJjZU1hcHMpIHtcbiAgICAgICAgdmFyIGNvbnZlcnRlciA9IG5ldyBKaXRFbWl0dGVyVmlzaXRvcihyZWZsZWN0b3IpO1xuICAgICAgICB2YXIgY3R4ID0gRW1pdHRlclZpc2l0b3JDb250ZXh0LmNyZWF0ZVJvb3QoKTtcbiAgICAgICAgLy8gRW5zdXJlIGdlbmVyYXRlZCBjb2RlIGlzIGluIHN0cmljdCBtb2RlXG4gICAgICAgIGlmIChzdGF0ZW1lbnRzLmxlbmd0aCA+IDAgJiYgIWlzVXNlU3RyaWN0U3RhdGVtZW50KHN0YXRlbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzID0gX19zcHJlYWQoW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoJ3VzZSBzdHJpY3QnKS50b1N0bXQoKVxuICAgICAgICAgICAgXSwgc3RhdGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udmVydGVyLnZpc2l0QWxsU3RhdGVtZW50cyhzdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjb252ZXJ0ZXIuY3JlYXRlUmV0dXJuU3RtdChjdHgpO1xuICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0ZUNvZGUoc291cmNlVXJsLCBjdHgsIGNvbnZlcnRlci5nZXRBcmdzKCksIGNyZWF0ZVNvdXJjZU1hcHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYSBwaWVjZSBvZiBKSVQgZ2VuZXJhdGVkIGNvZGUuXG4gICAgICogQHBhcmFtIHNvdXJjZVVybCBUaGUgVVJMIG9mIHRoaXMgZ2VuZXJhdGVkIGNvZGUuXG4gICAgICogQHBhcmFtIGN0eCBBIGNvbnRleHQgb2JqZWN0IHRoYXQgY29udGFpbnMgYW4gQVNUIG9mIHRoZSBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICAgKiBAcGFyYW0gdmFycyBBIG1hcCBjb250YWluaW5nIHRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIHZhcmlhYmxlcyB0aGF0IHRoZSBldmFsdWF0ZWQgY29kZSBtaWdodFxuICAgICAqIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0gY3JlYXRlU291cmNlTWFwIElmIHRydWUgdGhlbiBjcmVhdGUgYSBzb3VyY2UtbWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGUgYW5kIGluY2x1ZGUgaXRcbiAgICAgKiBpbmxpbmUgYXMgYSBzb3VyY2UtbWFwIGNvbW1lbnQuXG4gICAgICogQHJldHVybnMgVGhlIHJlc3VsdCBvZiBldmFsdWF0aW5nIHRoZSBjb2RlLlxuICAgICAqL1xuICAgIEppdEV2YWx1YXRvci5wcm90b3R5cGUuZXZhbHVhdGVDb2RlID0gZnVuY3Rpb24gKHNvdXJjZVVybCwgY3R4LCB2YXJzLCBjcmVhdGVTb3VyY2VNYXApIHtcbiAgICAgICAgdmFyIGZuQm9keSA9IFwiXFxcInVzZSBzdHJpY3RcXFwiO1wiICsgY3R4LnRvU291cmNlKCkgKyBcIlxcbi8vIyBzb3VyY2VVUkw9XCIgKyBzb3VyY2VVcmw7XG4gICAgICAgIHZhciBmbkFyZ05hbWVzID0gW107XG4gICAgICAgIHZhciBmbkFyZ1ZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBhcmdOYW1lIGluIHZhcnMpIHtcbiAgICAgICAgICAgIGZuQXJnVmFsdWVzLnB1c2godmFyc1thcmdOYW1lXSk7XG4gICAgICAgICAgICBmbkFyZ05hbWVzLnB1c2goYXJnTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNyZWF0ZVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgLy8gdXNpbmcgYG5ldyBGdW5jdGlvbiguLi4pYCBnZW5lcmF0ZXMgYSBoZWFkZXIsIDEgbGluZSBvZiBubyBhcmd1bWVudHMsIDIgbGluZXMgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBFLmcuIGBgYFxuICAgICAgICAgICAgLy8gZnVuY3Rpb24gYW5vbnltb3VzKGEsYixjXG4gICAgICAgICAgICAvLyAvKiovKSB7IC4uLiB9YGBgXG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGhhcmQgY29kZSB0aGlzIGZhY3QsIHNvIHdlIGF1dG8gZGV0ZWN0IGl0IHZpYSBhbiBlbXB0eSBmdW5jdGlvbiBmaXJzdC5cbiAgICAgICAgICAgIHZhciBlbXB0eUZuID0gbmV3IChGdW5jdGlvbi5iaW5kLmFwcGx5KEZ1bmN0aW9uLCBfX3NwcmVhZChbdm9pZCAwXSwgZm5BcmdOYW1lcy5jb25jYXQoJ3JldHVybiBudWxsOycpKSkpKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHZhciBoZWFkZXJMaW5lcyA9IGVtcHR5Rm4uc2xpY2UoMCwgZW1wdHlGbi5pbmRleE9mKCdyZXR1cm4gbnVsbDsnKSkuc3BsaXQoJ1xcbicpLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBmbkJvZHkgKz0gXCJcXG5cIiArIGN0eC50b1NvdXJjZU1hcEdlbmVyYXRvcihzb3VyY2VVcmwsIGhlYWRlckxpbmVzKS50b0pzQ29tbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbiA9IG5ldyAoRnVuY3Rpb24uYmluZC5hcHBseShGdW5jdGlvbiwgX19zcHJlYWQoW3ZvaWQgMF0sIGZuQXJnTmFtZXMuY29uY2F0KGZuQm9keSkpKSkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZUZ1bmN0aW9uKGZuLCBmbkFyZ1ZhbHVlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGEgSklUIGdlbmVyYXRlZCBmdW5jdGlvbiBieSBjYWxsaW5nIGl0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gaW4gdGVzdHMgdG8gY2FwdHVyZSB0aGUgZnVuY3Rpb25zIHRoYXQgYXJlIGdlbmVyYXRlZFxuICAgICAqIGJ5IHRoaXMgYEppdEV2YWx1YXRvcmAgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gQSBmdW5jdGlvbiB0byBleGVjdXRlLlxuICAgICAqIEBwYXJhbSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24gYmVpbmcgZXhlY3V0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZXhlY3V0ZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgSml0RXZhbHVhdG9yLnByb3RvdHlwZS5leGVjdXRlRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4sIGFyZ3MpIHsgcmV0dXJuIGZuLmFwcGx5KHZvaWQgMCwgX19zcHJlYWQoYXJncykpOyB9O1xuICAgIHJldHVybiBKaXRFdmFsdWF0b3I7XG59KCkpO1xuLyoqXG4gKiBBbiBBbmd1bGFyIEFTVCB2aXNpdG9yIHRoYXQgY29udmVydHMgQVNUIG5vZGVzIGludG8gZXhlY3V0YWJsZSBKYXZhU2NyaXB0IGNvZGUuXG4gKi9cbnZhciBKaXRFbWl0dGVyVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSml0RW1pdHRlclZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSml0RW1pdHRlclZpc2l0b3IocmVmbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZmxlY3RvciA9IHJlZmxlY3RvcjtcbiAgICAgICAgX3RoaXMuX2V2YWxBcmdOYW1lcyA9IFtdO1xuICAgICAgICBfdGhpcy5fZXZhbEFyZ1ZhbHVlcyA9IFtdO1xuICAgICAgICBfdGhpcy5fZXZhbEV4cG9ydGVkVmFycyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5jcmVhdGVSZXR1cm5TdG10ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgc3RtdCA9IG5ldyBSZXR1cm5TdGF0ZW1lbnQobmV3IExpdGVyYWxNYXBFeHByKHRoaXMuX2V2YWxFeHBvcnRlZFZhcnMubWFwKGZ1bmN0aW9uIChyZXN1bHRWYXIpIHsgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRW50cnkocmVzdWx0VmFyLCB2YXJpYWJsZShyZXN1bHRWYXIpLCBmYWxzZSk7IH0pKSk7XG4gICAgICAgIHN0bXQudmlzaXRTdGF0ZW1lbnQodGhpcywgY3R4KTtcbiAgICB9O1xuICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5nZXRBcmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZhbEFyZ05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbdGhpcy5fZXZhbEFyZ05hbWVzW2ldXSA9IHRoaXMuX2V2YWxBcmdWYWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB0aGlzLl9lbWl0UmVmZXJlbmNlVG9FeHRlcm5hbChhc3QsIHRoaXMucmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShhc3QudmFsdWUpLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyYXBwZWROb2RlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB0aGlzLl9lbWl0UmVmZXJlbmNlVG9FeHRlcm5hbChhc3QsIGFzdC5ub2RlLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRXhwb3J0ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmFsRXhwb3J0ZWRWYXJzLnB1c2goc3RtdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10LmNhbGwodGhpcywgc3RtdCwgY3R4KTtcbiAgICB9O1xuICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGlmIChzdG10Lmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5FeHBvcnRlZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2YWxFeHBvcnRlZFZhcnMucHVzaChzdG10Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdC5jYWxsKHRoaXMsIHN0bXQsIGN0eCk7XG4gICAgfTtcbiAgICBKaXRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRXhwb3J0ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmFsRXhwb3J0ZWRWYXJzLnB1c2goc3RtdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQuY2FsbCh0aGlzLCBzdG10LCBjdHgpO1xuICAgIH07XG4gICAgSml0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl9lbWl0UmVmZXJlbmNlVG9FeHRlcm5hbCA9IGZ1bmN0aW9uIChhc3QsIHZhbHVlLCBjdHgpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5fZXZhbEFyZ1ZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgaWYgKGlkID09PSAtMSkge1xuICAgICAgICAgICAgaWQgPSB0aGlzLl9ldmFsQXJnVmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX2V2YWxBcmdWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gaWRlbnRpZmllck5hbWUoeyByZWZlcmVuY2U6IHZhbHVlIH0pIHx8ICd2YWwnO1xuICAgICAgICAgICAgdGhpcy5fZXZhbEFyZ05hbWVzLnB1c2goXCJqaXRfXCIgKyBuYW1lXzEgKyBcIl9cIiArIGlkKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoYXN0LCB0aGlzLl9ldmFsQXJnTmFtZXNbaWRdKTtcbiAgICB9O1xuICAgIHJldHVybiBKaXRFbWl0dGVyVmlzaXRvcjtcbn0oQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yKSk7XG5mdW5jdGlvbiBpc1VzZVN0cmljdFN0YXRlbWVudChzdGF0ZW1lbnQpIHtcbiAgICByZXR1cm4gc3RhdGVtZW50LmlzRXF1aXZhbGVudChsaXRlcmFsKCd1c2Ugc3RyaWN0JykudG9TdG10KCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIGBDb21waWxlUmVmbGVjdG9yYCB3aGljaCByZXNvbHZlcyByZWZlcmVuY2VzIHRvIEBhbmd1bGFyL2NvcmVcbiAqIHN5bWJvbHMgYXQgcnVudGltZSwgYWNjb3JkaW5nIHRvIGEgY29uc3VtZXItcHJvdmlkZWQgbWFwcGluZy5cbiAqXG4gKiBPbmx5IHN1cHBvcnRzIGByZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2VgLCBhbGwgb3RoZXIgbWV0aG9kcyB0aHJvdy5cbiAqL1xudmFyIFIzSml0UmVmbGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFIzSml0UmVmbGVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgUjNKaXRSZWZsZWN0b3IucHJvdG90eXBlLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgLy8gVGhpcyByZWZsZWN0b3Igb25seSBoYW5kbGVzIEBhbmd1bGFyL2NvcmUgaW1wb3J0cy5cbiAgICAgICAgaWYgKHJlZi5tb2R1bGVOYW1lICE9PSAnQGFuZ3VsYXIvY29yZScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGV4dGVybmFsIHJlZmVyZW5jZSB0byBcIiArIHJlZi5tb2R1bGVOYW1lICsgXCIsIG9ubHkgcmVmZXJlbmNlcyB0byBAYW5ndWxhci9jb3JlIGFyZSBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0Lmhhc093blByb3BlcnR5KHJlZi5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsdWUgcHJvdmlkZWQgZm9yIEBhbmd1bGFyL2NvcmUgc3ltYm9sICdcIiArIHJlZi5uYW1lICsgXCInLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0W3JlZi5uYW1lXTtcbiAgICB9O1xuICAgIFIzSml0UmVmbGVjdG9yLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuJyk7IH07XG4gICAgUjNKaXRSZWZsZWN0b3IucHJvdG90eXBlLmFubm90YXRpb25zID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuJyk7IH07XG4gICAgUjNKaXRSZWZsZWN0b3IucHJvdG90eXBlLnNoYWxsb3dBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7IHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLicpOyB9O1xuICAgIFIzSml0UmVmbGVjdG9yLnByb3RvdHlwZS50cnlBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7IHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLicpOyB9O1xuICAgIFIzSml0UmVmbGVjdG9yLnByb3RvdHlwZS5wcm9wTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykgeyB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4nKTsgfTtcbiAgICBSM0ppdFJlZmxlY3Rvci5wcm90b3R5cGUuaGFzTGlmZWN5Y2xlSG9vayA9IGZ1bmN0aW9uICh0eXBlLCBsY1Byb3BlcnR5KSB7IHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLicpOyB9O1xuICAgIFIzSml0UmVmbGVjdG9yLnByb3RvdHlwZS5ndWFyZHMgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykgeyB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4nKTsgfTtcbiAgICBSM0ppdFJlZmxlY3Rvci5wcm90b3R5cGUuY29tcG9uZW50TW9kdWxlVXJsID0gZnVuY3Rpb24gKHR5cGUsIGNtcE1ldGFkYXRhKSB7IHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLicpOyB9O1xuICAgIHJldHVybiBSM0ppdFJlZmxlY3Rvcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ29uc3RydWN0IGFuIGBSM05nTW9kdWxlRGVmYCBmb3IgdGhlIGdpdmVuIGBSM05nTW9kdWxlTWV0YWRhdGFgLlxuICovXG5mdW5jdGlvbiBjb21waWxlTmdNb2R1bGUobWV0YSkge1xuICAgIHZhciBtb2R1bGVUeXBlID0gbWV0YS50eXBlLCBib290c3RyYXAgPSBtZXRhLmJvb3RzdHJhcCwgZGVjbGFyYXRpb25zID0gbWV0YS5kZWNsYXJhdGlvbnMsIGltcG9ydHMgPSBtZXRhLmltcG9ydHMsIGV4cG9ydHMgPSBtZXRhLmV4cG9ydHMsIHNjaGVtYXMgPSBtZXRhLnNjaGVtYXMsIGNvbnRhaW5zRm9yd2FyZERlY2xzID0gbWV0YS5jb250YWluc0ZvcndhcmREZWNscywgZW1pdElubGluZSA9IG1ldGEuZW1pdElubGluZSwgaWQgPSBtZXRhLmlkO1xuICAgIHZhciBhZGRpdGlvbmFsU3RhdGVtZW50cyA9IFtdO1xuICAgIHZhciBkZWZpbml0aW9uTWFwID0ge1xuICAgICAgICB0eXBlOiBtb2R1bGVUeXBlXG4gICAgfTtcbiAgICAvLyBPbmx5IGdlbmVyYXRlIHRoZSBrZXlzIGluIHRoZSBtZXRhZGF0YSBpZiB0aGUgYXJyYXlzIGhhdmUgdmFsdWVzLlxuICAgIGlmIChib290c3RyYXAubGVuZ3RoKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuYm9vdHN0cmFwID0gcmVmc1RvQXJyYXkoYm9vdHN0cmFwLCBjb250YWluc0ZvcndhcmREZWNscyk7XG4gICAgfVxuICAgIC8vIElmIHJlcXVlc3RlZCB0byBlbWl0IHNjb3BlIGluZm9ybWF0aW9uIGlubGluZSwgcGFzcyB0aGUgZGVjbGFyYXRpb25zLCBpbXBvcnRzIGFuZCBleHBvcnRzIHRvXG4gICAgLy8gdGhlIGDJtcm1ZGVmaW5lTmdNb2R1bGVgIGNhbGwuIFRoZSBKSVQgY29tcGlsYXRpb24gdXNlcyB0aGlzLlxuICAgIGlmIChlbWl0SW5saW5lKSB7XG4gICAgICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uTWFwLmRlY2xhcmF0aW9ucyA9IHJlZnNUb0FycmF5KGRlY2xhcmF0aW9ucywgY29udGFpbnNGb3J3YXJkRGVjbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbXBvcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbk1hcC5pbXBvcnRzID0gcmVmc1RvQXJyYXkoaW1wb3J0cywgY29udGFpbnNGb3J3YXJkRGVjbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbk1hcC5leHBvcnRzID0gcmVmc1RvQXJyYXkoZXhwb3J0cywgY29udGFpbnNGb3J3YXJkRGVjbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIG5vdCBlbWl0dGluZyBpbmxpbmUsIHRoZSBzY29wZSBpbmZvcm1hdGlvbiBpcyBub3QgcGFzc2VkIGludG8gYMm1ybVkZWZpbmVOZ01vZHVsZWAgYXMgaXQgd291bGRcbiAgICAvLyBwcmV2ZW50IHRyZWUtc2hha2luZyBvZiB0aGUgZGVjbGFyYXRpb25zLCBpbXBvcnRzIGFuZCBleHBvcnRzIHJlZmVyZW5jZXMuXG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBzZXROZ01vZHVsZVNjb3BlQ2FsbCA9IGdlbmVyYXRlU2V0TmdNb2R1bGVTY29wZUNhbGwobWV0YSk7XG4gICAgICAgIGlmIChzZXROZ01vZHVsZVNjb3BlQ2FsbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYWRkaXRpb25hbFN0YXRlbWVudHMucHVzaChzZXROZ01vZHVsZVNjb3BlQ2FsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNjaGVtYXMgJiYgc2NoZW1hcy5sZW5ndGgpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zY2hlbWFzID0gbGl0ZXJhbEFycihzY2hlbWFzLm1hcChmdW5jdGlvbiAocmVmKSB7IHJldHVybiByZWYudmFsdWU7IH0pKTtcbiAgICB9XG4gICAgaWYgKGlkKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuaWQgPSBpZDtcbiAgICB9XG4gICAgdmFyIGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuZGVmaW5lTmdNb2R1bGUpLmNhbGxGbihbbWFwVG9NYXBFeHByZXNzaW9uKGRlZmluaXRpb25NYXApXSk7XG4gICAgdmFyIHR5cGUgPSBuZXcgRXhwcmVzc2lvblR5cGUoaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLk5nTW9kdWxlRGVmV2l0aE1ldGEsIFtcbiAgICAgICAgbmV3IEV4cHJlc3Npb25UeXBlKG1vZHVsZVR5cGUpLCB0dXBsZVR5cGVPZihkZWNsYXJhdGlvbnMpLCB0dXBsZVR5cGVPZihpbXBvcnRzKSxcbiAgICAgICAgdHVwbGVUeXBlT2YoZXhwb3J0cylcbiAgICBdKSk7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbjogZXhwcmVzc2lvbiwgdHlwZTogdHlwZSwgYWRkaXRpb25hbFN0YXRlbWVudHM6IGFkZGl0aW9uYWxTdGF0ZW1lbnRzIH07XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGNhbGwgdG8gYMm1ybVzZXROZ01vZHVsZVNjb3BlYCB3aXRoIGFsbCBuZWNlc3NhcnkgaW5mb3JtYXRpb24gc28gdGhhdCB0aGVcbiAqIHRyYW5zaXRpdmUgbW9kdWxlIHNjb3BlIGNhbiBiZSBjb21wdXRlZCBkdXJpbmcgcnVudGltZSBpbiBKSVQgbW9kZS4gVGhpcyBjYWxsIGlzIG1hcmtlZCBwdXJlXG4gKiBzdWNoIHRoYXQgdGhlIHJlZmVyZW5jZXMgdG8gZGVjbGFyYXRpb25zLCBpbXBvcnRzIGFuZCBleHBvcnRzIG1heSBiZSBlbGlkZWQgY2F1c2luZyB0aGVzZVxuICogc3ltYm9scyB0byBiZWNvbWUgdHJlZS1zaGFrZWFibGUuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlU2V0TmdNb2R1bGVTY29wZUNhbGwobWV0YSkge1xuICAgIHZhciBtb2R1bGVUeXBlID0gbWV0YS50eXBlLCBkZWNsYXJhdGlvbnMgPSBtZXRhLmRlY2xhcmF0aW9ucywgaW1wb3J0cyA9IG1ldGEuaW1wb3J0cywgZXhwb3J0cyA9IG1ldGEuZXhwb3J0cywgY29udGFpbnNGb3J3YXJkRGVjbHMgPSBtZXRhLmNvbnRhaW5zRm9yd2FyZERlY2xzO1xuICAgIHZhciBzY29wZU1hcCA9IHt9O1xuICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHNjb3BlTWFwLmRlY2xhcmF0aW9ucyA9IHJlZnNUb0FycmF5KGRlY2xhcmF0aW9ucywgY29udGFpbnNGb3J3YXJkRGVjbHMpO1xuICAgIH1cbiAgICBpZiAoaW1wb3J0cy5sZW5ndGgpIHtcbiAgICAgICAgc2NvcGVNYXAuaW1wb3J0cyA9IHJlZnNUb0FycmF5KGltcG9ydHMsIGNvbnRhaW5zRm9yd2FyZERlY2xzKTtcbiAgICB9XG4gICAgaWYgKGV4cG9ydHMubGVuZ3RoKSB7XG4gICAgICAgIHNjb3BlTWFwLmV4cG9ydHMgPSByZWZzVG9BcnJheShleHBvcnRzLCBjb250YWluc0ZvcndhcmREZWNscyk7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhzY29wZU1hcCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZm5DYWxsID0gbmV3IEludm9rZUZ1bmN0aW9uRXhwcihcbiAgICAvKiBmbiAqLyBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuc2V0TmdNb2R1bGVTY29wZSksIFxuICAgIC8qIGFyZ3MgKi8gW21vZHVsZVR5cGUsIG1hcFRvTWFwRXhwcmVzc2lvbihzY29wZU1hcCldLCBcbiAgICAvKiB0eXBlICovIHVuZGVmaW5lZCwgXG4gICAgLyogc291cmNlU3BhbiAqLyB1bmRlZmluZWQsIFxuICAgIC8qIHB1cmUgKi8gdHJ1ZSk7XG4gICAgcmV0dXJuIGZuQ2FsbC50b1N0bXQoKTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVJbmplY3RvcihtZXRhKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBpbGVGYWN0b3J5RnVuY3Rpb24oe1xuICAgICAgICBuYW1lOiBtZXRhLm5hbWUsXG4gICAgICAgIHR5cGU6IG1ldGEudHlwZSxcbiAgICAgICAgZGVwczogbWV0YS5kZXBzLFxuICAgICAgICBpbmplY3RGbjogSWRlbnRpZmllcnMkMS5pbmplY3QsXG4gICAgfSk7XG4gICAgdmFyIGRlZmluaXRpb25NYXAgPSB7XG4gICAgICAgIGZhY3Rvcnk6IHJlc3VsdC5mYWN0b3J5LFxuICAgIH07XG4gICAgaWYgKG1ldGEucHJvdmlkZXJzICE9PSBudWxsKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAucHJvdmlkZXJzID0gbWV0YS5wcm92aWRlcnM7XG4gICAgfVxuICAgIGlmIChtZXRhLmltcG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLmltcG9ydHMgPSBsaXRlcmFsQXJyKG1ldGEuaW1wb3J0cyk7XG4gICAgfVxuICAgIHZhciBleHByZXNzaW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmRlZmluZUluamVjdG9yKS5jYWxsRm4oW21hcFRvTWFwRXhwcmVzc2lvbihkZWZpbml0aW9uTWFwKV0pO1xuICAgIHZhciB0eXBlID0gbmV3IEV4cHJlc3Npb25UeXBlKGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5JbmplY3RvckRlZiwgW25ldyBFeHByZXNzaW9uVHlwZShtZXRhLnR5cGUpXSkpO1xuICAgIHJldHVybiB7IGV4cHJlc3Npb246IGV4cHJlc3Npb24sIHR5cGU6IHR5cGUsIHN0YXRlbWVudHM6IHJlc3VsdC5zdGF0ZW1lbnRzIH07XG59XG4vLyBUT0RPKGFseGh1Yik6IGludGVncmF0ZSB0aGlzIHdpdGggYGNvbXBpbGVOZ01vZHVsZWAuIEN1cnJlbnRseSB0aGUgdHdvIGFyZSBzZXBhcmF0ZSBvcGVyYXRpb25zLlxuZnVuY3Rpb24gY29tcGlsZU5nTW9kdWxlRnJvbVJlbmRlcjIoY3R4LCBuZ01vZHVsZSwgaW5qZWN0YWJsZUNvbXBpbGVyKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IGlkZW50aWZpZXJOYW1lKG5nTW9kdWxlLnR5cGUpO1xuICAgIHZhciByYXdJbXBvcnRzID0gbmdNb2R1bGUucmF3SW1wb3J0cyA/IFtuZ01vZHVsZS5yYXdJbXBvcnRzXSA6IFtdO1xuICAgIHZhciByYXdFeHBvcnRzID0gbmdNb2R1bGUucmF3RXhwb3J0cyA/IFtuZ01vZHVsZS5yYXdFeHBvcnRzXSA6IFtdO1xuICAgIHZhciBpbmplY3RvckRlZkFyZyA9IG1hcExpdGVyYWwoe1xuICAgICAgICAnZmFjdG9yeSc6IGluamVjdGFibGVDb21waWxlci5mYWN0b3J5Rm9yKHsgdHlwZTogbmdNb2R1bGUudHlwZSwgc3ltYm9sOiBuZ01vZHVsZS50eXBlLnJlZmVyZW5jZSB9LCBjdHgpLFxuICAgICAgICAncHJvdmlkZXJzJzogY29udmVydE1ldGFUb091dHB1dChuZ01vZHVsZS5yYXdQcm92aWRlcnMsIGN0eCksXG4gICAgICAgICdpbXBvcnRzJzogY29udmVydE1ldGFUb091dHB1dChfX3NwcmVhZChyYXdJbXBvcnRzLCByYXdFeHBvcnRzKSwgY3R4KSxcbiAgICB9KTtcbiAgICB2YXIgaW5qZWN0b3JEZWYgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuZGVmaW5lSW5qZWN0b3IpLmNhbGxGbihbaW5qZWN0b3JEZWZBcmddKTtcbiAgICBjdHguc3RhdGVtZW50cy5wdXNoKG5ldyBDbGFzc1N0bXQoXG4gICAgLyogbmFtZSAqLyBjbGFzc05hbWUsIFxuICAgIC8qIHBhcmVudCAqLyBudWxsLCBcbiAgICAvKiBmaWVsZHMgKi8gW25ldyBDbGFzc0ZpZWxkKFxuICAgICAgICAvKiBuYW1lICovICduZ0luamVjdG9yRGVmJywgXG4gICAgICAgIC8qIHR5cGUgKi8gSU5GRVJSRURfVFlQRSwgXG4gICAgICAgIC8qIG1vZGlmaWVycyAqLyBbU3RtdE1vZGlmaWVyLlN0YXRpY10sIFxuICAgICAgICAvKiBpbml0aWFsaXplciAqLyBpbmplY3RvckRlZildLCBcbiAgICAvKiBnZXR0ZXJzICovIFtdLCBcbiAgICAvKiBjb25zdHJ1Y3Rvck1ldGhvZCAqLyBuZXcgQ2xhc3NNZXRob2QobnVsbCwgW10sIFtdKSwgXG4gICAgLyogbWV0aG9kcyAqLyBbXSkpO1xufVxuZnVuY3Rpb24gYWNjZXNzRXhwb3J0U2NvcGUobW9kdWxlKSB7XG4gICAgdmFyIHNlbGVjdG9yU2NvcGUgPSBuZXcgUmVhZFByb3BFeHByKG1vZHVsZSwgJ25nTW9kdWxlRGVmJyk7XG4gICAgcmV0dXJuIG5ldyBSZWFkUHJvcEV4cHIoc2VsZWN0b3JTY29wZSwgJ2V4cG9ydGVkJyk7XG59XG5mdW5jdGlvbiB0dXBsZVR5cGVPZihleHApIHtcbiAgICB2YXIgdHlwZXMgPSBleHAubWFwKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIHR5cGVvZkV4cHIocmVmLnR5cGUpOyB9KTtcbiAgICByZXR1cm4gZXhwLmxlbmd0aCA+IDAgPyBleHByZXNzaW9uVHlwZShsaXRlcmFsQXJyKHR5cGVzKSkgOiBOT05FX1RZUEU7XG59XG5mdW5jdGlvbiByZWZzVG9BcnJheShyZWZzLCBzaG91bGRGb3J3YXJkRGVjbGFyZSkge1xuICAgIHZhciB2YWx1ZXMgPSBsaXRlcmFsQXJyKHJlZnMubWFwKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIHJlZi52YWx1ZTsgfSkpO1xuICAgIHJldHVybiBzaG91bGRGb3J3YXJkRGVjbGFyZSA/IGZuKFtdLCBbbmV3IFJldHVyblN0YXRlbWVudCh2YWx1ZXMpXSkgOiB2YWx1ZXM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVQaXBlRnJvbU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgdmFyIGRlZmluaXRpb25NYXBWYWx1ZXMgPSBbXTtcbiAgICAvLyBlLmcuIGBuYW1lOiAnbXlQaXBlJ2BcbiAgICBkZWZpbml0aW9uTWFwVmFsdWVzLnB1c2goeyBrZXk6ICduYW1lJywgdmFsdWU6IGxpdGVyYWwobWV0YWRhdGEucGlwZU5hbWUpLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgIC8vIGUuZy4gYHR5cGU6IE15UGlwZWBcbiAgICBkZWZpbml0aW9uTWFwVmFsdWVzLnB1c2goeyBrZXk6ICd0eXBlJywgdmFsdWU6IG1ldGFkYXRhLnR5cGUsIHF1b3RlZDogZmFsc2UgfSk7XG4gICAgdmFyIHRlbXBsYXRlRmFjdG9yeSA9IGNvbXBpbGVGYWN0b3J5RnVuY3Rpb24oe1xuICAgICAgICBuYW1lOiBtZXRhZGF0YS5uYW1lLFxuICAgICAgICB0eXBlOiBtZXRhZGF0YS50eXBlLFxuICAgICAgICBkZXBzOiBtZXRhZGF0YS5kZXBzLFxuICAgICAgICBpbmplY3RGbjogSWRlbnRpZmllcnMkMS5kaXJlY3RpdmVJbmplY3QsXG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5pdGlvbk1hcFZhbHVlcy5wdXNoKHsga2V5OiAnZmFjdG9yeScsIHZhbHVlOiB0ZW1wbGF0ZUZhY3RvcnkuZmFjdG9yeSwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICAvLyBlLmcuIGBwdXJlOiB0cnVlYFxuICAgIGRlZmluaXRpb25NYXBWYWx1ZXMucHVzaCh7IGtleTogJ3B1cmUnLCB2YWx1ZTogbGl0ZXJhbChtZXRhZGF0YS5wdXJlKSwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5kZWZpbmVQaXBlKS5jYWxsRm4oW2xpdGVyYWxNYXAoZGVmaW5pdGlvbk1hcFZhbHVlcyldKTtcbiAgICB2YXIgdHlwZSA9IG5ldyBFeHByZXNzaW9uVHlwZShpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuUGlwZURlZldpdGhNZXRhLCBbXG4gICAgICAgIHR5cGVXaXRoUGFyYW1ldGVycyhtZXRhZGF0YS50eXBlLCBtZXRhZGF0YS50eXBlQXJndW1lbnRDb3VudCksXG4gICAgICAgIG5ldyBFeHByZXNzaW9uVHlwZShuZXcgTGl0ZXJhbEV4cHIobWV0YWRhdGEucGlwZU5hbWUpKSxcbiAgICBdKSk7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbjogZXhwcmVzc2lvbiwgdHlwZTogdHlwZSwgc3RhdGVtZW50czogdGVtcGxhdGVGYWN0b3J5LnN0YXRlbWVudHMgfTtcbn1cbi8qKlxuICogV3JpdGUgYSBwaXBlIGRlZmluaXRpb24gdG8gdGhlIG91dHB1dCBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBjb21waWxlUGlwZUZyb21SZW5kZXIyKG91dHB1dEN0eCwgcGlwZSwgcmVmbGVjdG9yKSB7XG4gICAgdmFyIGRlZmluaXRpb25NYXBWYWx1ZXMgPSBbXTtcbiAgICB2YXIgbmFtZSA9IGlkZW50aWZpZXJOYW1lKHBpcGUudHlwZSk7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihcIkNhbm5vdCByZXNvbHZlIHRoZSBuYW1lIG9mIFwiICsgcGlwZS50eXBlKTtcbiAgICB9XG4gICAgdmFyIG1ldGFkYXRhID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBwaXBlTmFtZTogcGlwZS5uYW1lLFxuICAgICAgICB0eXBlOiBvdXRwdXRDdHguaW1wb3J0RXhwcihwaXBlLnR5cGUucmVmZXJlbmNlKSxcbiAgICAgICAgdHlwZUFyZ3VtZW50Q291bnQ6IDAsXG4gICAgICAgIGRlcHM6IGRlcGVuZGVuY2llc0Zyb21HbG9iYWxNZXRhZGF0YShwaXBlLnR5cGUsIG91dHB1dEN0eCwgcmVmbGVjdG9yKSxcbiAgICAgICAgcHVyZTogcGlwZS5wdXJlLFxuICAgIH07XG4gICAgdmFyIHJlcyA9IGNvbXBpbGVQaXBlRnJvbU1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICB2YXIgZGVmaW5pdGlvbkZpZWxkID0gb3V0cHV0Q3R4LmNvbnN0YW50UG9vbC5wcm9wZXJ0eU5hbWVPZigzIC8qIFBpcGUgKi8pO1xuICAgIG91dHB1dEN0eC5zdGF0ZW1lbnRzLnB1c2gobmV3IENsYXNzU3RtdChcbiAgICAvKiBuYW1lICovIG5hbWUsIFxuICAgIC8qIHBhcmVudCAqLyBudWxsLCBcbiAgICAvKiBmaWVsZHMgKi8gW25ldyBDbGFzc0ZpZWxkKFxuICAgICAgICAvKiBuYW1lICovIGRlZmluaXRpb25GaWVsZCwgXG4gICAgICAgIC8qIHR5cGUgKi8gSU5GRVJSRURfVFlQRSwgXG4gICAgICAgIC8qIG1vZGlmaWVycyAqLyBbU3RtdE1vZGlmaWVyLlN0YXRpY10sIFxuICAgICAgICAvKiBpbml0aWFsaXplciAqLyByZXMuZXhwcmVzc2lvbildLCBcbiAgICAvKiBnZXR0ZXJzICovIFtdLCBcbiAgICAvKiBjb25zdHJ1Y3Rvck1ldGhvZCAqLyBuZXcgQ2xhc3NNZXRob2QobnVsbCwgW10sIFtdKSwgXG4gICAgLyogbWV0aG9kcyAqLyBbXSkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUGFyc2VyRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VyRXJyb3IobWVzc2FnZSwgaW5wdXQsIGVyckxvY2F0aW9uLCBjdHhMb2NhdGlvbikge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZXJyTG9jYXRpb24gPSBlcnJMb2NhdGlvbjtcbiAgICAgICAgdGhpcy5jdHhMb2NhdGlvbiA9IGN0eExvY2F0aW9uO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIlBhcnNlciBFcnJvcjogXCIgKyBtZXNzYWdlICsgXCIgXCIgKyBlcnJMb2NhdGlvbiArIFwiIFtcIiArIGlucHV0ICsgXCJdIGluIFwiICsgY3R4TG9jYXRpb247XG4gICAgfVxuICAgIHJldHVybiBQYXJzZXJFcnJvcjtcbn0oKSk7XG52YXIgUGFyc2VTcGFuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlU3BhbihzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgfVxuICAgIHJldHVybiBQYXJzZVNwYW47XG59KCkpO1xudmFyIEFTVCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBU1Qoc3Bhbikge1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgIH1cbiAgICBBU1QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFTVC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnQVNUJzsgfTtcbiAgICByZXR1cm4gQVNUO1xufSgpKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHF1b3RlZCBleHByZXNzaW9uIG9mIHRoZSBmb3JtOlxuICpcbiAqIHF1b3RlID0gcHJlZml4IGA6YCB1bmludGVycHJldGVkRXhwcmVzc2lvblxuICogcHJlZml4ID0gaWRlbnRpZmllclxuICogdW5pbnRlcnByZXRlZEV4cHJlc3Npb24gPSBhcmJpdHJhcnkgc3RyaW5nXG4gKlxuICogQSBxdW90ZWQgZXhwcmVzc2lvbiBpcyBtZWFudCB0byBiZSBwcmUtcHJvY2Vzc2VkIGJ5IGFuIEFTVCB0cmFuc2Zvcm1lciB0aGF0XG4gKiBjb252ZXJ0cyBpdCBpbnRvIGFub3RoZXIgQVNUIHRoYXQgbm8gbG9uZ2VyIGNvbnRhaW5zIHF1b3RlZCBleHByZXNzaW9ucy5cbiAqIEl0IGlzIG1lYW50IHRvIGFsbG93IHRoaXJkLXBhcnR5IGRldmVsb3BlcnMgdG8gZXh0ZW5kIEFuZ3VsYXIgdGVtcGxhdGVcbiAqIGV4cHJlc3Npb24gbGFuZ3VhZ2UuIFRoZSBgdW5pbnRlcnByZXRlZEV4cHJlc3Npb25gIHBhcnQgb2YgdGhlIHF1b3RlIGlzXG4gKiB0aGVyZWZvcmUgbm90IGludGVycHJldGVkIGJ5IHRoZSBBbmd1bGFyJ3Mgb3duIGV4cHJlc3Npb24gcGFyc2VyLlxuICovXG52YXIgUXVvdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFF1b3RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFF1b3RlKHNwYW4sIHByZWZpeCwgdW5pbnRlcnByZXRlZEV4cHJlc3Npb24sIGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgX3RoaXMudW5pbnRlcnByZXRlZEV4cHJlc3Npb24gPSB1bmludGVycHJldGVkRXhwcmVzc2lvbjtcbiAgICAgICAgX3RoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBRdW90ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UXVvdGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICBRdW90ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnUXVvdGUnOyB9O1xuICAgIHJldHVybiBRdW90ZTtcbn0oQVNUKSk7XG52YXIgRW1wdHlFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbXB0eUV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1wdHlFeHByKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEVtcHR5RXhwci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9O1xuICAgIHJldHVybiBFbXB0eUV4cHI7XG59KEFTVCkpO1xudmFyIEltcGxpY2l0UmVjZWl2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEltcGxpY2l0UmVjZWl2ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW1wbGljaXRSZWNlaXZlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBJbXBsaWNpdFJlY2VpdmVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbXBsaWNpdFJlY2VpdmVyKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEltcGxpY2l0UmVjZWl2ZXI7XG59KEFTVCkpO1xuLyoqXG4gKiBNdWx0aXBsZSBleHByZXNzaW9ucyBzZXBhcmF0ZWQgYnkgYSBzZW1pY29sb24uXG4gKi9cbnZhciBDaGFpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hhaW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hhaW4oc3BhbiwgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDaGFpbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hhaW4odGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhaW47XG59KEFTVCkpO1xudmFyIENvbmRpdGlvbmFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25kaXRpb25hbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25kaXRpb25hbChzcGFuLCBjb25kaXRpb24sIHRydWVFeHAsIGZhbHNlRXhwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgX3RoaXMudHJ1ZUV4cCA9IHRydWVFeHA7XG4gICAgICAgIF90aGlzLmZhbHNlRXhwID0gZmFsc2VFeHA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29uZGl0aW9uYWwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbmRpdGlvbmFsKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbmRpdGlvbmFsO1xufShBU1QpKTtcbnZhciBQcm9wZXJ0eVJlYWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb3BlcnR5UmVhZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcm9wZXJ0eVJlYWQoc3BhbiwgcmVjZWl2ZXIsIG5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUHJvcGVydHlSZWFkLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcm9wZXJ0eVJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvcGVydHlSZWFkO1xufShBU1QpKTtcbnZhciBQcm9wZXJ0eVdyaXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcm9wZXJ0eVdyaXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByb3BlcnR5V3JpdGUoc3BhbiwgcmVjZWl2ZXIsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFByb3BlcnR5V3JpdGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByb3BlcnR5V3JpdGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvcGVydHlXcml0ZTtcbn0oQVNUKSk7XG52YXIgU2FmZVByb3BlcnR5UmVhZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZVByb3BlcnR5UmVhZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTYWZlUHJvcGVydHlSZWFkKHNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNhZmVQcm9wZXJ0eVJlYWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFNhZmVQcm9wZXJ0eVJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2FmZVByb3BlcnR5UmVhZDtcbn0oQVNUKSk7XG52YXIgS2V5ZWRSZWFkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhLZXllZFJlYWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gS2V5ZWRSZWFkKHNwYW4sIG9iaiwga2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9iaiA9IG9iajtcbiAgICAgICAgX3RoaXMua2V5ID0ga2V5O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEtleWVkUmVhZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0S2V5ZWRSZWFkKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEtleWVkUmVhZDtcbn0oQVNUKSk7XG52YXIgS2V5ZWRXcml0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS2V5ZWRXcml0ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBLZXllZFdyaXRlKHNwYW4sIG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vYmogPSBvYmo7XG4gICAgICAgIF90aGlzLmtleSA9IGtleTtcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBLZXllZFdyaXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXllZFdyaXRlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEtleWVkV3JpdGU7XG59KEFTVCkpO1xudmFyIEJpbmRpbmdQaXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaW5kaW5nUGlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCaW5kaW5nUGlwZShzcGFuLCBleHAsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXhwID0gZXhwO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQmluZGluZ1BpcGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFBpcGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQmluZGluZ1BpcGU7XG59KEFTVCkpO1xudmFyIExpdGVyYWxQcmltaXRpdmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxQcmltaXRpdmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGl0ZXJhbFByaW1pdGl2ZShzcGFuLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExpdGVyYWxQcmltaXRpdmUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxQcmltaXRpdmUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbFByaW1pdGl2ZTtcbn0oQVNUKSk7XG52YXIgTGl0ZXJhbEFycmF5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaXRlcmFsQXJyYXksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGl0ZXJhbEFycmF5KHNwYW4sIGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGl0ZXJhbEFycmF5LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsQXJyYXkodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbEFycmF5O1xufShBU1QpKTtcbnZhciBMaXRlcmFsTWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaXRlcmFsTWFwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpdGVyYWxNYXAoc3Bhbiwga2V5cywgdmFsdWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmtleXMgPSBrZXlzO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGl0ZXJhbE1hcC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbE1hcCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBMaXRlcmFsTWFwO1xufShBU1QpKTtcbnZhciBJbnRlcnBvbGF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnRlcnBvbGF0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludGVycG9sYXRpb24oc3Bhbiwgc3RyaW5ncywgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgIF90aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW50ZXJwb2xhdGlvbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW50ZXJwb2xhdGlvbih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBJbnRlcnBvbGF0aW9uO1xufShBU1QpKTtcbnZhciBCaW5hcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJpbmFyeSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCaW5hcnkoc3Bhbiwgb3BlcmF0aW9uLCBsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIF90aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICBfdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEJpbmFyeS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmluYXJ5KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEJpbmFyeTtcbn0oQVNUKSk7XG52YXIgUHJlZml4Tm90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcmVmaXhOb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJlZml4Tm90KHNwYW4sIGV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUHJlZml4Tm90LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcmVmaXhOb3QodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gUHJlZml4Tm90O1xufShBU1QpKTtcbnZhciBOb25OdWxsQXNzZXJ0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb25OdWxsQXNzZXJ0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5vbk51bGxBc3NlcnQoc3BhbiwgZXhwcmVzc2lvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBOb25OdWxsQXNzZXJ0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXROb25OdWxsQXNzZXJ0KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vbk51bGxBc3NlcnQ7XG59KEFTVCkpO1xudmFyIE1ldGhvZENhbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ldGhvZENhbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWV0aG9kQ2FsbChzcGFuLCByZWNlaXZlciwgbmFtZSwgYXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWV0aG9kQ2FsbC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TWV0aG9kQ2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBNZXRob2RDYWxsO1xufShBU1QpKTtcbnZhciBTYWZlTWV0aG9kQ2FsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZU1ldGhvZENhbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FmZU1ldGhvZENhbGwoc3BhbiwgcmVjZWl2ZXIsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNhZmVNZXRob2RDYWxsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTYWZlTWV0aG9kQ2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBTYWZlTWV0aG9kQ2FsbDtcbn0oQVNUKSk7XG52YXIgRnVuY3Rpb25DYWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGdW5jdGlvbkNhbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnVuY3Rpb25DYWxsKHNwYW4sIHRhcmdldCwgYXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25DYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEZ1bmN0aW9uQ2FsbDtcbn0oQVNUKSk7XG4vKipcbiAqIFJlY29yZHMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIGEgdGV4dCBzcGFuIGluIGEgc291cmNlIGZpbGUsIHdoZXJlIGBzdGFydGAgYW5kIGBlbmRgIGFyZSB0aGVcbiAqIHN0YXJ0aW5nIGFuZCBlbmRpbmcgYnl0ZSBvZmZzZXRzLCByZXNwZWN0aXZlbHksIG9mIHRoZSB0ZXh0IHNwYW4gaW4gYSBzb3VyY2UgZmlsZS5cbiAqL1xudmFyIEFic29sdXRlU291cmNlU3BhbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnNvbHV0ZVNvdXJjZVNwYW4oc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIH1cbiAgICByZXR1cm4gQWJzb2x1dGVTb3VyY2VTcGFuO1xufSgpKTtcbnZhciBBU1RXaXRoU291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBU1RXaXRoU291cmNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFTVFdpdGhTb3VyY2UoYXN0LCBzb3VyY2UsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgZXJyb3JzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5ldyBQYXJzZVNwYW4oMCwgc291cmNlID09IG51bGwgPyAwIDogc291cmNlLmxlbmd0aCkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFzdCA9IGFzdDtcbiAgICAgICAgX3RoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICBfdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICBfdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIF90aGlzLnNvdXJjZVNwYW4gPSBuZXcgQWJzb2x1dGVTb3VyY2VTcGFuKGFic29sdXRlT2Zmc2V0LCBhYnNvbHV0ZU9mZnNldCArIF90aGlzLnNwYW4uZW5kKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBU1RXaXRoU291cmNlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgaWYgKHZpc2l0b3IudmlzaXRBU1RXaXRoU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFTVFdpdGhTb3VyY2UodGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xuICAgIH07XG4gICAgQVNUV2l0aFNvdXJjZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNvdXJjZSArIFwiIGluIFwiICsgdGhpcy5sb2NhdGlvbjsgfTtcbiAgICByZXR1cm4gQVNUV2l0aFNvdXJjZTtcbn0oQVNUKSk7XG52YXIgVGVtcGxhdGVCaW5kaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlQmluZGluZyhzcGFuLCBrZXksIGtleUlzVmFyLCBuYW1lLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmtleUlzVmFyID0ga2V5SXNWYXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIHJldHVybiBUZW1wbGF0ZUJpbmRpbmc7XG59KCkpO1xudmFyIE51bGxBc3RWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE51bGxBc3RWaXNpdG9yKCkge1xuICAgIH1cbiAgICBOdWxsQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2hhaW4gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIE51bGxBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBOdWxsQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBOdWxsQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBOdWxsQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIE51bGxBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBOdWxsQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Tm9uTnVsbEFzc2VydCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBOdWxsQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJvcGVydHlXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBOdWxsQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBOdWxsQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRTYWZlTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBOdWxsQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIHJldHVybiBOdWxsQXN0VmlzaXRvcjtcbn0oKSk7XG52YXIgUmVjdXJzaXZlQXN0VmlzaXRvciQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY3Vyc2l2ZUFzdFZpc2l0b3IoKSB7XG4gICAgfVxuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0QmluYXJ5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QubGVmdC52aXNpdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LnJpZ2h0LnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2hhaW4gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7IH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LnRydWVFeHAudmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgICAgIGFzdC5mYWxzZUV4cC52aXNpdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5leHAudmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QudGFyZ2V0LnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3Qub2JqLnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3Qua2V5LnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0Lm9iai52aXNpdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LmtleS52aXNpdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LnZhbHVlLnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QudmFsdWVzLCBjb250ZXh0KTsgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmV4cHJlc3Npb24udmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXROb25OdWxsQXNzZXJ0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJvcGVydHlXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QudmFsdWUudmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRTYWZlTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGFzdHMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBhc3QudmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFF1b3RlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICByZXR1cm4gUmVjdXJzaXZlQXN0VmlzaXRvcjtcbn0oKSk7XG52YXIgQXN0VHJhbnNmb3JtZXIkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3RUcmFuc2Zvcm1lcigpIHtcbiAgICB9XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0SW1wbGljaXRSZWNlaXZlciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEludGVycG9sYXRpb24oYXN0LnNwYW4sIGFzdC5zdHJpbmdzLCB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucykpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKGFzdC5zcGFuLCBhc3QudmFsdWUpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5UmVhZChhc3Quc3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3QubmFtZSk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5V3JpdGUoYXN0LnNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUsIGFzdC52YWx1ZS52aXNpdCh0aGlzKSk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFNhZmVQcm9wZXJ0eVJlYWQoYXN0LnNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXRob2RDYWxsKGFzdC5zcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lLCB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKSk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRTYWZlTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTYWZlTWV0aG9kQ2FsbChhc3Quc3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3QubmFtZSwgdGhpcy52aXNpdEFsbChhc3QuYXJncykpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQ2FsbChhc3Quc3BhbiwgYXN0LnRhcmdldC52aXNpdCh0aGlzKSwgdGhpcy52aXNpdEFsbChhc3QuYXJncykpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheShhc3Quc3BhbiwgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcChhc3Quc3BhbiwgYXN0LmtleXMsIHRoaXMudmlzaXRBbGwoYXN0LnZhbHVlcykpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeShhc3Quc3BhbiwgYXN0Lm9wZXJhdGlvbiwgYXN0LmxlZnQudmlzaXQodGhpcyksIGFzdC5yaWdodC52aXNpdCh0aGlzKSk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJlZml4Tm90KGFzdC5zcGFuLCBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKSk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXROb25OdWxsQXNzZXJ0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE5vbk51bGxBc3NlcnQoYXN0LnNwYW4sIGFzdC5leHByZXNzaW9uLnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsKGFzdC5zcGFuLCBhc3QuY29uZGl0aW9uLnZpc2l0KHRoaXMpLCBhc3QudHJ1ZUV4cC52aXNpdCh0aGlzKSwgYXN0LmZhbHNlRXhwLnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1BpcGUoYXN0LnNwYW4sIGFzdC5leHAudmlzaXQodGhpcyksIGFzdC5uYW1lLCB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKSk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgS2V5ZWRSZWFkKGFzdC5zcGFuLCBhc3Qub2JqLnZpc2l0KHRoaXMpLCBhc3Qua2V5LnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgS2V5ZWRXcml0ZShhc3Quc3BhbiwgYXN0Lm9iai52aXNpdCh0aGlzKSwgYXN0LmtleS52aXNpdCh0aGlzKSwgYXN0LnZhbHVlLnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkoYXN0cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IGFzdHNbaV0udmlzaXQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYWluKGFzdC5zcGFuLCB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucykpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UXVvdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVvdGUoYXN0LnNwYW4sIGFzdC5wcmVmaXgsIGFzdC51bmludGVycHJldGVkRXhwcmVzc2lvbiwgYXN0LmxvY2F0aW9uKTtcbiAgICB9O1xuICAgIHJldHVybiBBc3RUcmFuc2Zvcm1lcjtcbn0oKSk7XG4vLyBBIHRyYW5zZm9ybWVyIHRoYXQgb25seSBjcmVhdGVzIG5ldyBub2RlcyBpZiB0aGUgdHJhbnNmb3JtZXIgbWFrZXMgYSBjaGFuZ2Ugb3Jcbi8vIGEgY2hhbmdlIGlzIG1hZGUgYSBjaGlsZCBub2RlLlxudmFyIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyKCkge1xuICAgIH1cbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBleHByZXNzaW9ucyA9IHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zICE9PSBhc3QuZXhwcmVzc2lvbnMpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVycG9sYXRpb24oYXN0LnNwYW4sIGFzdC5zdHJpbmdzLCBleHByZXNzaW9ucyk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAocmVjZWl2ZXIgIT09IGFzdC5yZWNlaXZlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVJlYWQoYXN0LnNwYW4sIHJlY2VpdmVyLCBhc3QubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXN0LnZhbHVlLnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAocmVjZWl2ZXIgIT09IGFzdC5yZWNlaXZlciB8fCB2YWx1ZSAhPT0gYXN0LnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5V3JpdGUoYXN0LnNwYW4sIHJlY2VpdmVyLCBhc3QubmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gYXN0LnJlY2VpdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNhZmVQcm9wZXJ0eVJlYWQoYXN0LnNwYW4sIHJlY2VpdmVyLCBhc3QubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKTtcbiAgICAgICAgaWYgKHJlY2VpdmVyICE9PSBhc3QucmVjZWl2ZXIgfHwgYXJncyAhPT0gYXN0LmFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWV0aG9kQ2FsbChhc3Quc3BhbiwgcmVjZWl2ZXIsIGFzdC5uYW1lLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgQXN0TWVtb3J5RWZmaWNpZW50VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0U2FmZU1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKTtcbiAgICAgICAgaWYgKHJlY2VpdmVyICE9PSBhc3QucmVjZWl2ZXIgfHwgYXJncyAhPT0gYXN0LmFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2FmZU1ldGhvZENhbGwoYXN0LnNwYW4sIHJlY2VpdmVyLCBhc3QubmFtZSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGFzdC50YXJnZXQgJiYgYXN0LnRhcmdldC52aXNpdCh0aGlzKTtcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKTtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gYXN0LnRhcmdldCB8fCBhcmdzICE9PSBhc3QuYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkNhbGwoYXN0LnNwYW4sIHRhcmdldCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbnMgIT09IGFzdC5leHByZXNzaW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsQXJyYXkoYXN0LnNwYW4sIGV4cHJlc3Npb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgQXN0TWVtb3J5RWZmaWNpZW50VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmlzaXRBbGwoYXN0LnZhbHVlcyk7XG4gICAgICAgIGlmICh2YWx1ZXMgIT09IGFzdC52YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcChhc3Quc3BhbiwgYXN0LmtleXMsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBhc3QubGVmdC52aXNpdCh0aGlzKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gYXN0LnJpZ2h0LnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAobGVmdCAhPT0gYXN0LmxlZnQgfHwgcmlnaHQgIT09IGFzdC5yaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnkoYXN0LnNwYW4sIGFzdC5vcGVyYXRpb24sIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgQXN0TWVtb3J5RWZmaWNpZW50VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJlZml4Tm90ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGFzdC5leHByZXNzaW9uLnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbiAhPT0gYXN0LmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJlZml4Tm90KGFzdC5zcGFuLCBleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgQXN0TWVtb3J5RWZmaWNpZW50VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Tm9uTnVsbEFzc2VydCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24gIT09IGFzdC5leHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vbk51bGxBc3NlcnQoYXN0LnNwYW4sIGV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IGFzdC5jb25kaXRpb24udmlzaXQodGhpcyk7XG4gICAgICAgIHZhciB0cnVlRXhwID0gYXN0LnRydWVFeHAudmlzaXQodGhpcyk7XG4gICAgICAgIHZhciBmYWxzZUV4cCA9IGFzdC5mYWxzZUV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKGNvbmRpdGlvbiAhPT0gYXN0LmNvbmRpdGlvbiB8fCB0cnVlRXhwICE9PSBhc3QudHJ1ZUV4cCB8fCBmYWxzZUV4cCAhPT0gYXN0LmZhbHNlRXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsKGFzdC5zcGFuLCBjb25kaXRpb24sIHRydWVFeHAsIGZhbHNlRXhwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgQXN0TWVtb3J5RWZmaWNpZW50VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGV4cCA9IGFzdC5leHAudmlzaXQodGhpcyk7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncyk7XG4gICAgICAgIGlmIChleHAgIT09IGFzdC5leHAgfHwgYXJncyAhPT0gYXN0LmFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluZGluZ1BpcGUoYXN0LnNwYW4sIGV4cCwgYXN0Lm5hbWUsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBvYmogPSBhc3Qub2JqLnZpc2l0KHRoaXMpO1xuICAgICAgICB2YXIga2V5ID0gYXN0LmtleS52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKG9iaiAhPT0gYXN0Lm9iaiB8fCBrZXkgIT09IGFzdC5rZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgS2V5ZWRSZWFkKGFzdC5zcGFuLCBvYmosIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBvYmogPSBhc3Qub2JqLnZpc2l0KHRoaXMpO1xuICAgICAgICB2YXIga2V5ID0gYXN0LmtleS52aXNpdCh0aGlzKTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXN0LnZhbHVlLnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAob2JqICE9PSBhc3Qub2JqIHx8IGtleSAhPT0gYXN0LmtleSB8fCB2YWx1ZSAhPT0gYXN0LnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEtleWVkV3JpdGUoYXN0LnNwYW4sIG9iaiwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkoYXN0cy5sZW5ndGgpO1xuICAgICAgICB2YXIgbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBhc3RzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb3JpZ2luYWwudmlzaXQodGhpcyk7XG4gICAgICAgICAgICByZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIG1vZGlmaWVkID0gbW9kaWZpZWQgfHwgdmFsdWUgIT09IG9yaWdpbmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2RpZmllZCA/IHJlcyA6IGFzdHM7XG4gICAgfTtcbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbnMgIT09IGFzdC5leHByZXNzaW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFpbihhc3Quc3BhbiwgZXhwcmVzc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICByZXR1cm4gQXN0TWVtb3J5RWZmaWNpZW50VHJhbnNmb3JtZXI7XG59KCkpO1xuZnVuY3Rpb24gdmlzaXRBc3RDaGlsZHJlbihhc3QsIHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICBmdW5jdGlvbiB2aXNpdChhc3QpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdCAmJiB2aXNpdG9yLnZpc2l0KGFzdCwgY29udGV4dCkgfHwgYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2aXNpdEFsbChhc3RzKSB7IGFzdHMuZm9yRWFjaCh2aXNpdCk7IH1cbiAgICBhc3QudmlzaXQoe1xuICAgICAgICB2aXNpdEJpbmFyeTogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgdmlzaXQoYXN0LmxlZnQpO1xuICAgICAgICAgICAgdmlzaXQoYXN0LnJpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaXRDaGFpbjogZnVuY3Rpb24gKGFzdCkgeyB2aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpOyB9LFxuICAgICAgICB2aXNpdENvbmRpdGlvbmFsOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICB2aXNpdChhc3QuY29uZGl0aW9uKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC50cnVlRXhwKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5mYWxzZUV4cCk7XG4gICAgICAgIH0sXG4gICAgICAgIHZpc2l0RnVuY3Rpb25DYWxsOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICBpZiAoYXN0LnRhcmdldCkge1xuICAgICAgICAgICAgICAgIHZpc2l0KGFzdC50YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlzaXRBbGwoYXN0LmFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXI6IGZ1bmN0aW9uIChhc3QpIHsgfSxcbiAgICAgICAgdmlzaXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoYXN0KSB7IHZpc2l0QWxsKGFzdC5leHByZXNzaW9ucyk7IH0sXG4gICAgICAgIHZpc2l0S2V5ZWRSZWFkOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICB2aXNpdChhc3Qub2JqKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5rZXkpO1xuICAgICAgICB9LFxuICAgICAgICB2aXNpdEtleWVkV3JpdGU6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5vYmopO1xuICAgICAgICAgICAgdmlzaXQoYXN0LmtleSk7XG4gICAgICAgICAgICB2aXNpdChhc3Qub2JqKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaXRMaXRlcmFsQXJyYXk6IGZ1bmN0aW9uIChhc3QpIHsgdmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKTsgfSxcbiAgICAgICAgdmlzaXRMaXRlcmFsTWFwOiBmdW5jdGlvbiAoYXN0KSB7IH0sXG4gICAgICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZTogZnVuY3Rpb24gKGFzdCkgeyB9LFxuICAgICAgICB2aXNpdE1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5yZWNlaXZlcik7XG4gICAgICAgICAgICB2aXNpdEFsbChhc3QuYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIHZpc2l0UGlwZTogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgdmlzaXQoYXN0LmV4cCk7XG4gICAgICAgICAgICB2aXNpdEFsbChhc3QuYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIHZpc2l0UHJlZml4Tm90OiBmdW5jdGlvbiAoYXN0KSB7IHZpc2l0KGFzdC5leHByZXNzaW9uKTsgfSxcbiAgICAgICAgdmlzaXROb25OdWxsQXNzZXJ0OiBmdW5jdGlvbiAoYXN0KSB7IHZpc2l0KGFzdC5leHByZXNzaW9uKTsgfSxcbiAgICAgICAgdmlzaXRQcm9wZXJ0eVJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgdmlzaXQoYXN0LnJlY2VpdmVyKTsgfSxcbiAgICAgICAgdmlzaXRQcm9wZXJ0eVdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICB2aXNpdChhc3QucmVjZWl2ZXIpO1xuICAgICAgICAgICAgdmlzaXQoYXN0LnZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaXRRdW90ZTogZnVuY3Rpb24gKGFzdCkgeyB9LFxuICAgICAgICB2aXNpdFNhZmVNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICB2aXNpdChhc3QucmVjZWl2ZXIpO1xuICAgICAgICAgICAgdmlzaXRBbGwoYXN0LmFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICB2aXNpdFNhZmVQcm9wZXJ0eVJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgdmlzaXQoYXN0LnJlY2VpdmVyKTsgfSxcbiAgICB9KTtcbn1cbi8vIEJpbmRpbmdzXG52YXIgUGFyc2VkUHJvcGVydHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VkUHJvcGVydHkobmFtZSwgZXhwcmVzc2lvbiwgdHlwZSwgc291cmNlU3BhbiwgdmFsdWVTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTcGFuID0gdmFsdWVTcGFuO1xuICAgICAgICB0aGlzLmlzTGl0ZXJhbCA9IHRoaXMudHlwZSA9PT0gUGFyc2VkUHJvcGVydHlUeXBlLkxJVEVSQUxfQVRUUjtcbiAgICAgICAgdGhpcy5pc0FuaW1hdGlvbiA9IHRoaXMudHlwZSA9PT0gUGFyc2VkUHJvcGVydHlUeXBlLkFOSU1BVElPTjtcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlZFByb3BlcnR5O1xufSgpKTtcbnZhciBQYXJzZWRQcm9wZXJ0eVR5cGU7XG4oZnVuY3Rpb24gKFBhcnNlZFByb3BlcnR5VHlwZSkge1xuICAgIFBhcnNlZFByb3BlcnR5VHlwZVtQYXJzZWRQcm9wZXJ0eVR5cGVbXCJERUZBVUxUXCJdID0gMF0gPSBcIkRFRkFVTFRcIjtcbiAgICBQYXJzZWRQcm9wZXJ0eVR5cGVbUGFyc2VkUHJvcGVydHlUeXBlW1wiTElURVJBTF9BVFRSXCJdID0gMV0gPSBcIkxJVEVSQUxfQVRUUlwiO1xuICAgIFBhcnNlZFByb3BlcnR5VHlwZVtQYXJzZWRQcm9wZXJ0eVR5cGVbXCJBTklNQVRJT05cIl0gPSAyXSA9IFwiQU5JTUFUSU9OXCI7XG59KShQYXJzZWRQcm9wZXJ0eVR5cGUgfHwgKFBhcnNlZFByb3BlcnR5VHlwZSA9IHt9KSk7XG52YXIgUGFyc2VkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmVndWxhciBldmVudHMgaGF2ZSBhIHRhcmdldFxuICAgIC8vIEFuaW1hdGlvbiBldmVudHMgaGF2ZSBhIHBoYXNlXG4gICAgZnVuY3Rpb24gUGFyc2VkRXZlbnQobmFtZSwgdGFyZ2V0T3JQaGFzZSwgdHlwZSwgaGFuZGxlciwgc291cmNlU3BhbiwgaGFuZGxlclNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50YXJnZXRPclBoYXNlID0gdGFyZ2V0T3JQaGFzZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5oYW5kbGVyU3BhbiA9IGhhbmRsZXJTcGFuO1xuICAgIH1cbiAgICByZXR1cm4gUGFyc2VkRXZlbnQ7XG59KCkpO1xudmFyIFBhcnNlZFZhcmlhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlZFZhcmlhYmxlKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlZFZhcmlhYmxlO1xufSgpKTtcbnZhciBCb3VuZEVsZW1lbnRQcm9wZXJ0eSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCb3VuZEVsZW1lbnRQcm9wZXJ0eShuYW1lLCB0eXBlLCBzZWN1cml0eUNvbnRleHQsIHZhbHVlLCB1bml0LCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zZWN1cml0eUNvbnRleHQgPSBzZWN1cml0eUNvbnRleHQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51bml0ID0gdW5pdDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgfVxuICAgIHJldHVybiBCb3VuZEVsZW1lbnRQcm9wZXJ0eTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBFdmVudEhhbmRsZXJWYXJzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50SGFuZGxlclZhcnMoKSB7XG4gICAgfVxuICAgIEV2ZW50SGFuZGxlclZhcnMuZXZlbnQgPSB2YXJpYWJsZSgnJGV2ZW50Jyk7XG4gICAgcmV0dXJuIEV2ZW50SGFuZGxlclZhcnM7XG59KCkpO1xudmFyIENvbnZlcnRBY3Rpb25CaW5kaW5nUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnZlcnRBY3Rpb25CaW5kaW5nUmVzdWx0KFxuICAgIC8qKlxuICAgICAqIFJlbmRlcjIgY29tcGF0aWJsZSBzdGF0ZW1lbnRzLFxuICAgICAqL1xuICAgIHN0bXRzLCBcbiAgICAvKipcbiAgICAgKiBWYXJpYWJsZSBuYW1lIHVzZWQgd2l0aCByZW5kZXIyIGNvbXBhdGlibGUgc3RhdGVtZW50cy5cbiAgICAgKi9cbiAgICBhbGxvd0RlZmF1bHQpIHtcbiAgICAgICAgdGhpcy5zdG10cyA9IHN0bXRzO1xuICAgICAgICB0aGlzLmFsbG93RGVmYXVsdCA9IGFsbG93RGVmYXVsdDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgYml0IG9mIGEgaGFjay4gSXQgY29udmVydHMgc3RhdGVtZW50cyB3aGljaCByZW5kZXIyIGV4cGVjdHMgdG8gc3RhdGVtZW50cyB3aGljaCBhcmVcbiAgICAgICAgICogZXhwZWN0ZWQgYnkgcmVuZGVyMy5cbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZTogYDxkaXYgY2xpY2s9XCJkb1NvbWV0aGluZygkZXZlbnQpXCI+YCB3aWxsIGdlbmVyYXRlOlxuICAgICAgICAgKlxuICAgICAgICAgKiBSZW5kZXIzOlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogY29uc3QgcGRfYjphbnkgPSAoKDxhbnk+Y3R4LmRvU29tZXRoaW5nKCRldmVudCkpICE9PSBmYWxzZSk7XG4gICAgICAgICAqIHJldHVybiBwZF9iO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogYnV0IHJlbmRlcjIgZXhwZWN0czpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIHJldHVybiBjdHguZG9Tb21ldGhpbmcoJGV2ZW50KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPKG1pc2tvKTogcmVtb3ZlIHRoaXMgaGFjayBvbmNlIHdlIG5vIGxvbmdlciBzdXBwb3J0IFZpZXdFbmdpbmUuXG4gICAgICAgIHRoaXMucmVuZGVyM1N0bXRzID0gc3RtdHMubWFwKGZ1bmN0aW9uIChzdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZW1lbnQgaW5zdGFuY2VvZiBEZWNsYXJlVmFyU3RtdCAmJiBzdGF0ZW1lbnQubmFtZSA9PSBhbGxvd0RlZmF1bHQubmFtZSAmJlxuICAgICAgICAgICAgICAgIHN0YXRlbWVudC52YWx1ZSBpbnN0YW5jZW9mIEJpbmFyeU9wZXJhdG9yRXhwcikge1xuICAgICAgICAgICAgICAgIHZhciBsaHMgPSBzdGF0ZW1lbnQudmFsdWUubGhzO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmV0dXJuU3RhdGVtZW50KGxocy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIENvbnZlcnRBY3Rpb25CaW5kaW5nUmVzdWx0O1xufSgpKTtcbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGV4cHJlc3Npb24gQVNUIGludG8gYW4gZXhlY3V0YWJsZSBvdXRwdXQgQVNULCBhc3N1bWluZyB0aGUgZXhwcmVzc2lvbiBpc1xuICogdXNlZCBpbiBhbiBhY3Rpb24gYmluZGluZyAoZS5nLiBhbiBldmVudCBoYW5kbGVyKS5cbiAqL1xuZnVuY3Rpb24gY29udmVydEFjdGlvbkJpbmRpbmcobG9jYWxSZXNvbHZlciwgaW1wbGljaXRSZWNlaXZlciwgYWN0aW9uLCBiaW5kaW5nSWQsIGludGVycG9sYXRpb25GdW5jdGlvbiwgYmFzZVNvdXJjZVNwYW4pIHtcbiAgICBpZiAoIWxvY2FsUmVzb2x2ZXIpIHtcbiAgICAgICAgbG9jYWxSZXNvbHZlciA9IG5ldyBEZWZhdWx0TG9jYWxSZXNvbHZlcigpO1xuICAgIH1cbiAgICB2YXIgYWN0aW9uV2l0aG91dEJ1aWx0aW5zID0gY29udmVydFByb3BlcnR5QmluZGluZ0J1aWx0aW5zKHtcbiAgICAgICAgY3JlYXRlTGl0ZXJhbEFycmF5Q29udmVydGVyOiBmdW5jdGlvbiAoYXJnQ291bnQpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IG5vIGNhY2hpbmcgZm9yIGxpdGVyYWwgYXJyYXlzIGluIGFjdGlvbnMuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGxpdGVyYWxBcnIoYXJncyk7IH07XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUxpdGVyYWxNYXBDb252ZXJ0ZXI6IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBubyBjYWNoaW5nIGZvciBsaXRlcmFsIG1hcHMgaW4gYWN0aW9ucy5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBrZXlzLm1hcChmdW5jdGlvbiAoaywgaSkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrLmtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgcXVvdGVkOiBrLnF1b3RlZCxcbiAgICAgICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxNYXAoZW50cmllcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVQaXBlQ29udmVydGVyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBTdGF0ZTogQWN0aW9ucyBhcmUgbm90IGFsbG93ZWQgdG8gY29udGFpbiBwaXBlcy4gUGlwZTogXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgIH0sIGFjdGlvbik7XG4gICAgdmFyIHZpc2l0b3IgPSBuZXcgX0FzdFRvSXJWaXNpdG9yKGxvY2FsUmVzb2x2ZXIsIGltcGxpY2l0UmVjZWl2ZXIsIGJpbmRpbmdJZCwgaW50ZXJwb2xhdGlvbkZ1bmN0aW9uLCBiYXNlU291cmNlU3Bhbik7XG4gICAgdmFyIGFjdGlvblN0bXRzID0gW107XG4gICAgZmxhdHRlblN0YXRlbWVudHMoYWN0aW9uV2l0aG91dEJ1aWx0aW5zLnZpc2l0KHZpc2l0b3IsIF9Nb2RlLlN0YXRlbWVudCksIGFjdGlvblN0bXRzKTtcbiAgICBwcmVwZW5kVGVtcG9yYXJ5RGVjbHModmlzaXRvci50ZW1wb3JhcnlDb3VudCwgYmluZGluZ0lkLCBhY3Rpb25TdG10cyk7XG4gICAgaWYgKHZpc2l0b3IudXNlc0ltcGxpY2l0UmVjZWl2ZXIpIHtcbiAgICAgICAgbG9jYWxSZXNvbHZlci5ub3RpZnlJbXBsaWNpdFJlY2VpdmVyVXNlKCk7XG4gICAgfVxuICAgIHZhciBsYXN0SW5kZXggPSBhY3Rpb25TdG10cy5sZW5ndGggLSAxO1xuICAgIHZhciBwcmV2ZW50RGVmYXVsdFZhciA9IG51bGw7XG4gICAgaWYgKGxhc3RJbmRleCA+PSAwKSB7XG4gICAgICAgIHZhciBsYXN0U3RhdGVtZW50ID0gYWN0aW9uU3RtdHNbbGFzdEluZGV4XTtcbiAgICAgICAgdmFyIHJldHVybkV4cHIgPSBjb252ZXJ0U3RtdEludG9FeHByZXNzaW9uKGxhc3RTdGF0ZW1lbnQpO1xuICAgICAgICBpZiAocmV0dXJuRXhwcikge1xuICAgICAgICAgICAgLy8gTm90ZTogV2UgbmVlZCB0byBjYXN0IHRoZSByZXN1bHQgb2YgdGhlIG1ldGhvZCBjYWxsIHRvIGR5bmFtaWMsXG4gICAgICAgICAgICAvLyBhcyBpdCBtaWdodCBiZSBhIHZvaWQgbWV0aG9kIVxuICAgICAgICAgICAgcHJldmVudERlZmF1bHRWYXIgPSBjcmVhdGVQcmV2ZW50RGVmYXVsdFZhcihiaW5kaW5nSWQpO1xuICAgICAgICAgICAgYWN0aW9uU3RtdHNbbGFzdEluZGV4XSA9XG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRWYXIuc2V0KHJldHVybkV4cHIuY2FzdChEWU5BTUlDX1RZUEUpLm5vdElkZW50aWNhbChsaXRlcmFsKGZhbHNlKSkpXG4gICAgICAgICAgICAgICAgICAgIC50b0RlY2xTdG10KG51bGwsIFtTdG10TW9kaWZpZXIuRmluYWxdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbnZlcnRBY3Rpb25CaW5kaW5nUmVzdWx0KGFjdGlvblN0bXRzLCBwcmV2ZW50RGVmYXVsdFZhcik7XG59XG5mdW5jdGlvbiBjb252ZXJ0UHJvcGVydHlCaW5kaW5nQnVpbHRpbnMoY29udmVydGVyRmFjdG9yeSwgYXN0KSB7XG4gICAgcmV0dXJuIGNvbnZlcnRCdWlsdGlucyhjb252ZXJ0ZXJGYWN0b3J5LCBhc3QpO1xufVxudmFyIENvbnZlcnRQcm9wZXJ0eUJpbmRpbmdSZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udmVydFByb3BlcnR5QmluZGluZ1Jlc3VsdChzdG10cywgY3VyclZhbEV4cHIpIHtcbiAgICAgICAgdGhpcy5zdG10cyA9IHN0bXRzO1xuICAgICAgICB0aGlzLmN1cnJWYWxFeHByID0gY3VyclZhbEV4cHI7XG4gICAgfVxuICAgIHJldHVybiBDb252ZXJ0UHJvcGVydHlCaW5kaW5nUmVzdWx0O1xufSgpKTtcbnZhciBCaW5kaW5nRm9ybTtcbihmdW5jdGlvbiAoQmluZGluZ0Zvcm0pIHtcbiAgICAvLyBUaGUgZ2VuZXJhbCBmb3JtIG9mIGJpbmRpbmcgZXhwcmVzc2lvbiwgc3VwcG9ydHMgYWxsIGV4cHJlc3Npb25zLlxuICAgIEJpbmRpbmdGb3JtW0JpbmRpbmdGb3JtW1wiR2VuZXJhbFwiXSA9IDBdID0gXCJHZW5lcmFsXCI7XG4gICAgLy8gVHJ5IHRvIGdlbmVyYXRlIGEgc2ltcGxlIGJpbmRpbmcgKG5vIHRlbXBvcmFyaWVzIG9yIHN0YXRlbWVudHMpXG4gICAgLy8gb3RoZXJ3aXNlIGdlbmVyYXRlIGEgZ2VuZXJhbCBiaW5kaW5nXG4gICAgQmluZGluZ0Zvcm1bQmluZGluZ0Zvcm1bXCJUcnlTaW1wbGVcIl0gPSAxXSA9IFwiVHJ5U2ltcGxlXCI7XG59KShCaW5kaW5nRm9ybSB8fCAoQmluZGluZ0Zvcm0gPSB7fSkpO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBBU1QgaW50byBhbiBleGVjdXRhYmxlIG91dHB1dCBBU1QsIGFzc3VtaW5nIHRoZSBleHByZXNzaW9uXG4gKiBpcyB1c2VkIGluIHByb3BlcnR5IGJpbmRpbmcuIFRoZSBleHByZXNzaW9uIGhhcyB0byBiZSBwcmVwcm9jZXNzZWQgdmlhXG4gKiBgY29udmVydFByb3BlcnR5QmluZGluZ0J1aWx0aW5zYC5cbiAqL1xuZnVuY3Rpb24gY29udmVydFByb3BlcnR5QmluZGluZyhsb2NhbFJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBleHByZXNzaW9uV2l0aG91dEJ1aWx0aW5zLCBiaW5kaW5nSWQsIGZvcm0sIGludGVycG9sYXRpb25GdW5jdGlvbikge1xuICAgIGlmICghbG9jYWxSZXNvbHZlcikge1xuICAgICAgICBsb2NhbFJlc29sdmVyID0gbmV3IERlZmF1bHRMb2NhbFJlc29sdmVyKCk7XG4gICAgfVxuICAgIHZhciBjdXJyVmFsRXhwciA9IGNyZWF0ZUN1cnJWYWx1ZUV4cHIoYmluZGluZ0lkKTtcbiAgICB2YXIgdmlzaXRvciA9IG5ldyBfQXN0VG9JclZpc2l0b3IobG9jYWxSZXNvbHZlciwgaW1wbGljaXRSZWNlaXZlciwgYmluZGluZ0lkLCBpbnRlcnBvbGF0aW9uRnVuY3Rpb24pO1xuICAgIHZhciBvdXRwdXRFeHByID0gZXhwcmVzc2lvbldpdGhvdXRCdWlsdGlucy52aXNpdCh2aXNpdG9yLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICB2YXIgc3RtdHMgPSBnZXRTdGF0ZW1lbnRzRnJvbVZpc2l0b3IodmlzaXRvciwgYmluZGluZ0lkKTtcbiAgICBpZiAodmlzaXRvci51c2VzSW1wbGljaXRSZWNlaXZlcikge1xuICAgICAgICBsb2NhbFJlc29sdmVyLm5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UoKTtcbiAgICB9XG4gICAgaWYgKHZpc2l0b3IudGVtcG9yYXJ5Q291bnQgPT09IDAgJiYgZm9ybSA9PSBCaW5kaW5nRm9ybS5UcnlTaW1wbGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb252ZXJ0UHJvcGVydHlCaW5kaW5nUmVzdWx0KFtdLCBvdXRwdXRFeHByKTtcbiAgICB9XG4gICAgc3RtdHMucHVzaChjdXJyVmFsRXhwci5zZXQob3V0cHV0RXhwcikudG9EZWNsU3RtdChEWU5BTUlDX1RZUEUsIFtTdG10TW9kaWZpZXIuRmluYWxdKSk7XG4gICAgcmV0dXJuIG5ldyBDb252ZXJ0UHJvcGVydHlCaW5kaW5nUmVzdWx0KHN0bXRzLCBjdXJyVmFsRXhwcik7XG59XG4vKipcbiAqIEdpdmVuIHNvbWUgZXhwcmVzc2lvbiwgc3VjaCBhcyBhIGJpbmRpbmcgb3IgaW50ZXJwb2xhdGlvbiBleHByZXNzaW9uLCBhbmQgYSBjb250ZXh0IGV4cHJlc3Npb24gdG9cbiAqIGxvb2sgdmFsdWVzIHVwIG9uLCB2aXNpdCBlYWNoIGZhY2V0IG9mIHRoZSBnaXZlbiBleHByZXNzaW9uIHJlc29sdmluZyB2YWx1ZXMgZnJvbSB0aGUgY29udGV4dFxuICogZXhwcmVzc2lvbiBzdWNoIHRoYXQgYSBsaXN0IG9mIGFyZ3VtZW50cyBjYW4gYmUgZGVyaXZlZCBmcm9tIHRoZSBmb3VuZCB2YWx1ZXMgdGhhdCBjYW4gYmUgdXNlZCBhc1xuICogYXJndW1lbnRzIHRvIGFuIGV4dGVybmFsIHVwZGF0ZSBpbnN0cnVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gbG9jYWxSZXNvbHZlciBUaGUgcmVzb2x2ZXIgdG8gdXNlIHRvIGxvb2sgdXAgZXhwcmVzc2lvbnMgYnkgbmFtZSBhcHByb3ByaWF0ZWx5XG4gKiBAcGFyYW0gY29udGV4dFZhcmlhYmxlRXhwcmVzc2lvbiBUaGUgZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgdGhlIGNvbnRleHQgdmFyaWFibGUgdXNlZCB0byBjcmVhdGVcbiAqIHRoZSBmaW5hbCBhcmd1bWVudCBleHByZXNzaW9uc1xuICogQHBhcmFtIGV4cHJlc3Npb25XaXRoQXJndW1lbnRzVG9FeHRyYWN0IFRoZSBleHByZXNzaW9uIHRvIHZpc2l0IHRvIGZpZ3VyZSBvdXQgd2hhdCB2YWx1ZXMgbmVlZCB0b1xuICogYmUgcmVzb2x2ZWQgYW5kIHdoYXQgYXJndW1lbnRzIGxpc3QgdG8gYnVpbGQuXG4gKiBAcGFyYW0gYmluZGluZ0lkIEEgbmFtZSBwcmVmaXggdXNlZCB0byBjcmVhdGUgdGVtcG9yYXJ5IHZhcmlhYmxlIG5hbWVzIGlmIHRoZXkncmUgbmVlZGVkIGZvciB0aGVcbiAqIGFyZ3VtZW50cyBnZW5lcmF0ZWRcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGV4cHJlc3Npb25zIHRoYXQgY2FuIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMgdG8gaW5zdHJ1Y3Rpb24gZXhwcmVzc2lvbnMgbGlrZVxuICogYG8uaW1wb3J0RXhwcihSMy5wcm9wZXJ0eUludGVycG9sYXRlKS5jYWxsRm4ocmVzdWx0KWBcbiAqL1xuZnVuY3Rpb24gY29udmVydFVwZGF0ZUFyZ3VtZW50cyhsb2NhbFJlc29sdmVyLCBjb250ZXh0VmFyaWFibGVFeHByZXNzaW9uLCBleHByZXNzaW9uV2l0aEFyZ3VtZW50c1RvRXh0cmFjdCwgYmluZGluZ0lkKSB7XG4gICAgdmFyIHZpc2l0b3IgPSBuZXcgX0FzdFRvSXJWaXNpdG9yKGxvY2FsUmVzb2x2ZXIsIGNvbnRleHRWYXJpYWJsZUV4cHJlc3Npb24sIGJpbmRpbmdJZCwgdW5kZWZpbmVkKTtcbiAgICB2YXIgb3V0cHV0RXhwciA9IGV4cHJlc3Npb25XaXRoQXJndW1lbnRzVG9FeHRyYWN0LnZpc2l0KHZpc2l0b3IsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgIGlmICh2aXNpdG9yLnVzZXNJbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgIGxvY2FsUmVzb2x2ZXIubm90aWZ5SW1wbGljaXRSZWNlaXZlclVzZSgpO1xuICAgIH1cbiAgICB2YXIgc3RtdHMgPSBnZXRTdGF0ZW1lbnRzRnJvbVZpc2l0b3IodmlzaXRvciwgYmluZGluZ0lkKTtcbiAgICAvLyBSZW1vdmluZyB0aGUgZmlyc3QgYXJndW1lbnQsIGJlY2F1c2UgaXQgd2FzIGEgbGVuZ3RoIGZvciBWaWV3RW5naW5lLCBub3QgSXZ5LlxuICAgIHZhciBhcmdzID0gb3V0cHV0RXhwci5hcmdzLnNsaWNlKDEpO1xuICAgIGlmIChleHByZXNzaW9uV2l0aEFyZ3VtZW50c1RvRXh0cmFjdCBpbnN0YW5jZW9mIEludGVycG9sYXRpb24pIHtcbiAgICAgICAgLy8gSWYgd2UncmUgZGVhbGluZyB3aXRoIGFuIGludGVycG9sYXRpb24gb2YgMSB2YWx1ZSB3aXRoIGFuIGVtcHR5IHByZWZpeCBhbmQgc3VmZml4LCByZWR1Y2UgdGhlXG4gICAgICAgIC8vIGFyZ3MgcmV0dXJuZWQgdG8ganVzdCB0aGUgdmFsdWUsIGJlY2F1c2Ugd2UncmUgZ29pbmcgdG8gcGFzcyBpdCB0byBhIHNwZWNpYWwgaW5zdHJ1Y3Rpb24uXG4gICAgICAgIHZhciBzdHJpbmdzID0gZXhwcmVzc2lvbldpdGhBcmd1bWVudHNUb0V4dHJhY3Quc3RyaW5ncztcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAzICYmIHN0cmluZ3NbMF0gPT09ICcnICYmIHN0cmluZ3NbMV0gPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBTaW5nbGUgYXJndW1lbnQgaW50ZXJwb2xhdGUgaW5zdHJ1Y3Rpb25zLlxuICAgICAgICAgICAgYXJncyA9IFthcmdzWzFdXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA+PSAxOSkge1xuICAgICAgICAgICAgLy8gMTkgb3IgbW9yZSBhcmd1bWVudHMgbXVzdCBiZSBwYXNzZWQgdG8gdGhlIGBpbnRlcnBvbGF0ZVZgLXN0eWxlIGluc3RydWN0aW9ucywgd2hpY2ggYWNjZXB0XG4gICAgICAgICAgICAvLyBhbiBhcnJheSBvZiBhcmd1bWVudHNcbiAgICAgICAgICAgIGFyZ3MgPSBbbGl0ZXJhbEFycihhcmdzKV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3RtdHM6IHN0bXRzLCBhcmdzOiBhcmdzIH07XG59XG5mdW5jdGlvbiBnZXRTdGF0ZW1lbnRzRnJvbVZpc2l0b3IodmlzaXRvciwgYmluZGluZ0lkKSB7XG4gICAgdmFyIHN0bXRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aXNpdG9yLnRlbXBvcmFyeUNvdW50OyBpKyspIHtcbiAgICAgICAgc3RtdHMucHVzaCh0ZW1wb3JhcnlEZWNsYXJhdGlvbihiaW5kaW5nSWQsIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0bXRzO1xufVxuZnVuY3Rpb24gY29udmVydEJ1aWx0aW5zKGNvbnZlcnRlckZhY3RvcnksIGFzdCkge1xuICAgIHZhciB2aXNpdG9yID0gbmV3IF9CdWlsdGluQXN0Q29udmVydGVyKGNvbnZlcnRlckZhY3RvcnkpO1xuICAgIHJldHVybiBhc3QudmlzaXQodmlzaXRvcik7XG59XG5mdW5jdGlvbiB0ZW1wb3JhcnlOYW1lKGJpbmRpbmdJZCwgdGVtcG9yYXJ5TnVtYmVyKSB7XG4gICAgcmV0dXJuIFwidG1wX1wiICsgYmluZGluZ0lkICsgXCJfXCIgKyB0ZW1wb3JhcnlOdW1iZXI7XG59XG5mdW5jdGlvbiB0ZW1wb3JhcnlEZWNsYXJhdGlvbihiaW5kaW5nSWQsIHRlbXBvcmFyeU51bWJlcikge1xuICAgIHJldHVybiBuZXcgRGVjbGFyZVZhclN0bXQodGVtcG9yYXJ5TmFtZShiaW5kaW5nSWQsIHRlbXBvcmFyeU51bWJlciksIE5VTExfRVhQUik7XG59XG5mdW5jdGlvbiBwcmVwZW5kVGVtcG9yYXJ5RGVjbHModGVtcG9yYXJ5Q291bnQsIGJpbmRpbmdJZCwgc3RhdGVtZW50cykge1xuICAgIGZvciAodmFyIGkgPSB0ZW1wb3JhcnlDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHN0YXRlbWVudHMudW5zaGlmdCh0ZW1wb3JhcnlEZWNsYXJhdGlvbihiaW5kaW5nSWQsIGkpKTtcbiAgICB9XG59XG52YXIgX01vZGU7XG4oZnVuY3Rpb24gKF9Nb2RlKSB7XG4gICAgX01vZGVbX01vZGVbXCJTdGF0ZW1lbnRcIl0gPSAwXSA9IFwiU3RhdGVtZW50XCI7XG4gICAgX01vZGVbX01vZGVbXCJFeHByZXNzaW9uXCJdID0gMV0gPSBcIkV4cHJlc3Npb25cIjtcbn0pKF9Nb2RlIHx8IChfTW9kZSA9IHt9KSk7XG5mdW5jdGlvbiBlbnN1cmVTdGF0ZW1lbnRNb2RlKG1vZGUsIGFzdCkge1xuICAgIGlmIChtb2RlICE9PSBfTW9kZS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYSBzdGF0ZW1lbnQsIGJ1dCBzYXcgXCIgKyBhc3QpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVuc3VyZUV4cHJlc3Npb25Nb2RlKG1vZGUsIGFzdCkge1xuICAgIGlmIChtb2RlICE9PSBfTW9kZS5FeHByZXNzaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGFuIGV4cHJlc3Npb24sIGJ1dCBzYXcgXCIgKyBhc3QpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGV4cHIpIHtcbiAgICBpZiAobW9kZSA9PT0gX01vZGUuU3RhdGVtZW50KSB7XG4gICAgICAgIHJldHVybiBleHByLnRvU3RtdCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxufVxudmFyIF9CdWlsdGluQXN0Q29udmVydGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhfQnVpbHRpbkFzdENvbnZlcnRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBfQnVpbHRpbkFzdENvbnZlcnRlcihfY29udmVydGVyRmFjdG9yeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY29udmVydGVyRmFjdG9yeSA9IF9jb252ZXJ0ZXJGYWN0b3J5O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9CdWlsdGluQXN0Q29udmVydGVyLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gX19zcHJlYWQoW2FzdC5leHBdLCBhc3QuYXJncykubWFwKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGFzdC52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJ1aWx0aW5GdW5jdGlvbkNhbGwoYXN0LnNwYW4sIGFyZ3MsIHRoaXMuX2NvbnZlcnRlckZhY3RvcnkuY3JlYXRlUGlwZUNvbnZlcnRlcihhc3QubmFtZSwgYXJncy5sZW5ndGgpKTtcbiAgICB9O1xuICAgIF9CdWlsdGluQXN0Q29udmVydGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBhc3QuZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGFzdC52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJ1aWx0aW5GdW5jdGlvbkNhbGwoYXN0LnNwYW4sIGFyZ3MsIHRoaXMuX2NvbnZlcnRlckZhY3RvcnkuY3JlYXRlTGl0ZXJhbEFycmF5Q29udmVydGVyKGFzdC5leHByZXNzaW9ucy5sZW5ndGgpKTtcbiAgICB9O1xuICAgIF9CdWlsdGluQXN0Q29udmVydGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gYXN0LnZhbHVlcy5tYXAoZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVpbHRpbkZ1bmN0aW9uQ2FsbChhc3Quc3BhbiwgYXJncywgdGhpcy5fY29udmVydGVyRmFjdG9yeS5jcmVhdGVMaXRlcmFsTWFwQ29udmVydGVyKGFzdC5rZXlzKSk7XG4gICAgfTtcbiAgICByZXR1cm4gX0J1aWx0aW5Bc3RDb252ZXJ0ZXI7XG59KEFzdFRyYW5zZm9ybWVyJDEpKTtcbnZhciBfQXN0VG9JclZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX0FzdFRvSXJWaXNpdG9yKF9sb2NhbFJlc29sdmVyLCBfaW1wbGljaXRSZWNlaXZlciwgYmluZGluZ0lkLCBpbnRlcnBvbGF0aW9uRnVuY3Rpb24sIGJhc2VTb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsUmVzb2x2ZXIgPSBfbG9jYWxSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5faW1wbGljaXRSZWNlaXZlciA9IF9pbXBsaWNpdFJlY2VpdmVyO1xuICAgICAgICB0aGlzLmJpbmRpbmdJZCA9IGJpbmRpbmdJZDtcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBpbnRlcnBvbGF0aW9uRnVuY3Rpb247XG4gICAgICAgIHRoaXMuYmFzZVNvdXJjZVNwYW4gPSBiYXNlU291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5fbm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcmVzdWx0TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5ID0gMDtcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlDb3VudCA9IDA7XG4gICAgICAgIHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIG9wO1xuICAgICAgICBzd2l0Y2ggKGFzdC5vcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuUGx1cztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTWludXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5EaXZpZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk1vZHVsbztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkFuZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3x8JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk9yO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuRXF1YWxzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkxvd2VyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5CaWdnZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFscztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFscztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgb3BlcmF0aW9uIFwiICsgYXN0Lm9wZXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIob3AsIHRoaXMuX3Zpc2l0KGFzdC5sZWZ0LCBfTW9kZS5FeHByZXNzaW9uKSwgdGhpcy5fdmlzaXQoYXN0LnJpZ2h0LCBfTW9kZS5FeHByZXNzaW9uKSwgdW5kZWZpbmVkLCB0aGlzLmNvbnZlcnRTb3VyY2VTcGFuKGFzdC5zcGFuKSkpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICBlbnN1cmVTdGF0ZW1lbnRNb2RlKG1vZGUsIGFzdCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgbW9kZSk7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3Zpc2l0KGFzdC5jb25kaXRpb24sIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdmFsdWUuY29uZGl0aW9uYWwodGhpcy5fdmlzaXQoYXN0LnRydWVFeHAsIF9Nb2RlLkV4cHJlc3Npb24pLCB0aGlzLl92aXNpdChhc3QuZmFsc2VFeHAsIF9Nb2RlLkV4cHJlc3Npb24pLCB0aGlzLmNvbnZlcnRTb3VyY2VTcGFuKGFzdC5zcGFuKSkpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IFBpcGVzIHNob3VsZCBoYXZlIGJlZW4gY29udmVydGVkIGludG8gZnVuY3Rpb25zLiBQaXBlOiBcIiArIGFzdC5uYW1lKTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciBjb252ZXJ0ZWRBcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncywgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHZhciBmblJlc3VsdDtcbiAgICAgICAgaWYgKGFzdCBpbnN0YW5jZW9mIEJ1aWx0aW5GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgIGZuUmVzdWx0ID0gYXN0LmNvbnZlcnRlcihjb252ZXJ0ZWRBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZuUmVzdWx0ID0gdGhpcy5fdmlzaXQoYXN0LnRhcmdldCwgX01vZGUuRXhwcmVzc2lvbilcbiAgICAgICAgICAgICAgICAuY2FsbEZuKGNvbnZlcnRlZEFyZ3MsIHRoaXMuY29udmVydFNvdXJjZVNwYW4oYXN0LnNwYW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgZm5SZXN1bHQpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIGVuc3VyZUV4cHJlc3Npb25Nb2RlKG1vZGUsIGFzdCk7XG4gICAgICAgIHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXIgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5faW1wbGljaXRSZWNlaXZlcjtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpO1xuICAgICAgICB2YXIgYXJncyA9IFtsaXRlcmFsKGFzdC5leHByZXNzaW9ucy5sZW5ndGgpXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc3Quc3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChsaXRlcmFsKGFzdC5zdHJpbmdzW2ldKSk7XG4gICAgICAgICAgICBhcmdzLnB1c2godGhpcy5fdmlzaXQoYXN0LmV4cHJlc3Npb25zW2ldLCBfTW9kZS5FeHByZXNzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy5wdXNoKGxpdGVyYWwoYXN0LnN0cmluZ3NbYXN0LnN0cmluZ3MubGVuZ3RoIC0gMV0pKTtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJwb2xhdGlvbkZ1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnBvbGF0aW9uRnVuY3Rpb24oYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdC5leHByZXNzaW9ucy5sZW5ndGggPD0gOSA/XG4gICAgICAgICAgICBpbXBvcnRFeHByKElkZW50aWZpZXJzLmlubGluZUludGVycG9sYXRlKS5jYWxsRm4oYXJncykgOlxuICAgICAgICAgICAgaW1wb3J0RXhwcihJZGVudGlmaWVycy5pbnRlcnBvbGF0ZSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBhcmdzWzBdLCBsaXRlcmFsQXJyKGFyZ3Muc2xpY2UoMSksIHVuZGVmaW5lZCwgdGhpcy5jb252ZXJ0U291cmNlU3Bhbihhc3Quc3BhbikpXG4gICAgICAgICAgICBdKTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciBsZWZ0TW9zdFNhZmUgPSB0aGlzLmxlZnRNb3N0U2FmZU5vZGUoYXN0KTtcbiAgICAgICAgaWYgKGxlZnRNb3N0U2FmZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCBsZWZ0TW9zdFNhZmUsIG1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHRoaXMuX3Zpc2l0KGFzdC5vYmosIF9Nb2RlLkV4cHJlc3Npb24pLmtleSh0aGlzLl92aXNpdChhc3Qua2V5LCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuX3Zpc2l0KGFzdC5vYmosIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5fdmlzaXQoYXN0LmtleSwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3Zpc2l0KGFzdC52YWx1ZSwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBvYmoua2V5KGtleSkuc2V0KHZhbHVlKSk7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIFN0YXRlOiBsaXRlcmFsIGFycmF5cyBzaG91bGQgaGF2ZSBiZWVuIGNvbnZlcnRlZCBpbnRvIGZ1bmN0aW9uc1wiKTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIFN0YXRlOiBsaXRlcmFsIG1hcHMgc2hvdWxkIGhhdmUgYmVlbiBjb252ZXJ0ZWQgaW50byBmdW5jdGlvbnNcIik7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgLy8gRm9yIGxpdGVyYWwgdmFsdWVzIG9mIG51bGwsIHVuZGVmaW5lZCwgdHJ1ZSwgb3IgZmFsc2UgYWxsb3cgdHlwZSBpbnRlcmZlcmVuY2VcbiAgICAgICAgLy8gdG8gaW5mZXIgdGhlIHR5cGUuXG4gICAgICAgIHZhciB0eXBlID0gYXN0LnZhbHVlID09PSBudWxsIHx8IGFzdC52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGFzdC52YWx1ZSA9PT0gdHJ1ZSB8fCBhc3QudmFsdWUgPT09IHRydWUgP1xuICAgICAgICAgICAgSU5GRVJSRURfVFlQRSA6XG4gICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBsaXRlcmFsKGFzdC52YWx1ZSwgdHlwZSwgdGhpcy5jb252ZXJ0U291cmNlU3Bhbihhc3Quc3BhbikpKTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUuX2dldExvY2FsID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHRoaXMuX2xvY2FsUmVzb2x2ZXIuZ2V0TG9jYWwobmFtZSk7IH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIGlmIChhc3QucmVjZWl2ZXIgaW5zdGFuY2VvZiBJbXBsaWNpdFJlY2VpdmVyICYmIGFzdC5uYW1lID09ICckYW55Jykge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYWxsIHRvICRhbnksIGV4cGVjdGVkIDEgYXJndW1lbnQgYnV0IHJlY2VpdmVkIFwiICsgKGFyZ3MubGVuZ3RoIHx8ICdub25lJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF0uY2FzdChEWU5BTUlDX1RZUEUsIHRoaXMuY29udmVydFNvdXJjZVNwYW4oYXN0LnNwYW4pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdE1vc3RTYWZlID0gdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCk7XG4gICAgICAgIGlmIChsZWZ0TW9zdFNhZmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncywgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgICB2YXIgcHJldlVzZXNJbXBsaWNpdFJlY2VpdmVyID0gdGhpcy51c2VzSW1wbGljaXRSZWNlaXZlcjtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fdmlzaXQoYXN0LnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PT0gdGhpcy5faW1wbGljaXRSZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHZhciB2YXJFeHByID0gdGhpcy5fZ2V0TG9jYWwoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YXJFeHByKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIFwidXNlc0ltcGxpY2l0UmVjZWl2ZXJcIiBzdGF0ZSBzaW5jZSB0aGUgaW1wbGljaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjZWl2ZXIgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBhIHJlc29sdmVkIGxvY2FsIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXIgPSBwcmV2VXNlc0ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhckV4cHIuY2FsbEZuKGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyLmNhbGxNZXRob2QoYXN0Lm5hbWUsIGFyZ3MsIHRoaXMuY29udmVydFNvdXJjZVNwYW4oYXN0LnNwYW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJlZml4Tm90ID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgbm90KHRoaXMuX3Zpc2l0KGFzdC5leHByZXNzaW9uLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5vbk51bGxBc3NlcnQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBhc3NlcnROb3ROdWxsKHRoaXMuX3Zpc2l0KGFzdC5leHByZXNzaW9uLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIGxlZnRNb3N0U2FmZSA9IHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpO1xuICAgICAgICBpZiAobGVmdE1vc3RTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBwcmV2VXNlc0ltcGxpY2l0UmVjZWl2ZXIgPSB0aGlzLnVzZXNJbXBsaWNpdFJlY2VpdmVyO1xuICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fdmlzaXQoYXN0LnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PT0gdGhpcy5faW1wbGljaXRSZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2dldExvY2FsKGFzdC5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIFwidXNlc0ltcGxpY2l0UmVjZWl2ZXJcIiBzdGF0ZSBzaW5jZSB0aGUgaW1wbGljaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjZWl2ZXIgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBhIHJlc29sdmVkIGxvY2FsIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXIgPSBwcmV2VXNlc0ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIucHJvcChhc3QubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3Zpc2l0KGFzdC5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHZhciBwcmV2VXNlc0ltcGxpY2l0UmVjZWl2ZXIgPSB0aGlzLnVzZXNJbXBsaWNpdFJlY2VpdmVyO1xuICAgICAgICB2YXIgdmFyRXhwciA9IG51bGw7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gdGhpcy5faW1wbGljaXRSZWNlaXZlcikge1xuICAgICAgICAgICAgdmFyIGxvY2FsRXhwciA9IHRoaXMuX2dldExvY2FsKGFzdC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChsb2NhbEV4cHIpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxFeHByIGluc3RhbmNlb2YgUmVhZFByb3BFeHByKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsb2NhbCB2YXJpYWJsZSBpcyBhIHByb3BlcnR5IHJlYWQgZXhwcmVzc2lvbiwgaXQncyBhIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyB0byBhICdjb250ZXh0LnByb3BlcnR5JyB2YWx1ZSBhbmQgd2lsbCBiZSB1c2VkIGFzIHRoZSB0YXJnZXQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdyaXRlIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIHZhckV4cHIgPSBsb2NhbEV4cHI7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIFwidXNlc0ltcGxpY2l0UmVjZWl2ZXJcIiBzdGF0ZSBzaW5jZSB0aGUgaW1wbGljaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjZWl2ZXIgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBhIHJlc29sdmVkIGxvY2FsIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXIgPSBwcmV2VXNlc0ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgaXQncyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXNzaWduIHRvIGEgcmVmZXJlbmNlIG9yIHZhcmlhYmxlIScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBsb2NhbCBleHByZXNzaW9uIGNvdWxkIGJlIHByb2R1Y2VkLCB1c2UgdGhlIG9yaWdpbmFsIHJlY2VpdmVyJ3NcbiAgICAgICAgLy8gcHJvcGVydHkgYXMgdGhlIHRhcmdldC5cbiAgICAgICAgaWYgKHZhckV4cHIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhckV4cHIgPSByZWNlaXZlci5wcm9wKGFzdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdmFyRXhwci5zZXQodGhpcy5fdmlzaXQoYXN0LnZhbHVlLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCksIG1vZGUpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpLCBtb2RlKTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cywgbW9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gYXN0cy5tYXAoZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gX3RoaXMuX3Zpc2l0KGFzdCwgbW9kZSk7IH0pO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFF1b3RlID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdW90ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGV2YWx1YXRpb24hXFxuICAgICAgICBTdGF0ZW1lbnQ6IFwiICsgYXN0LnVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uICsgXCIgbG9jYXRlZCBhdCBcIiArIGFzdC5sb2NhdGlvbik7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLl92aXNpdCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3Jlc3VsdE1hcC5nZXQoYXN0KTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHJldHVybiAodGhpcy5fbm9kZU1hcC5nZXQoYXN0KSB8fCBhc3QpLnZpc2l0KHRoaXMsIG1vZGUpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5jb252ZXJ0U2FmZUFjY2VzcyA9IGZ1bmN0aW9uIChhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSkge1xuICAgICAgICAvLyBJZiB0aGUgZXhwcmVzc2lvbiBjb250YWlucyBhIHNhZmUgYWNjZXNzIG5vZGUgb24gdGhlIGxlZnQgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkIHRvXG4gICAgICAgIC8vIGFuIGV4cHJlc3Npb24gdGhhdCBndWFyZHMgdGhlIGFjY2VzcyB0byB0aGUgbWVtYmVyIGJ5IGNoZWNraW5nIHRoZSByZWNlaXZlciBmb3IgYmxhbmsuIEFzXG4gICAgICAgIC8vIGV4ZWN1dGlvbiBwcm9jZWVkcyBmcm9tIGxlZnQgdG8gcmlnaHQsIHRoZSBsZWZ0IG1vc3QgcGFydCBvZiB0aGUgZXhwcmVzc2lvbiBtdXN0IGJlIGd1YXJkZWRcbiAgICAgICAgLy8gZmlyc3QgYnV0LCBiZWNhdXNlIG1lbWJlciBhY2Nlc3MgaXMgbGVmdCBhc3NvY2lhdGl2ZSwgdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGV4cHJlc3Npb24gaXMgYXRcbiAgICAgICAgLy8gdGhlIHRvcCBvZiB0aGUgQVNULiBUaGUgZGVzaXJlZCByZXN1bHQgcmVxdWlyZXMgbGlmdGluZyBhIGNvcHkgb2YgdGhlIHRoZSBsZWZ0IHBhcnQgb2YgdGhlXG4gICAgICAgIC8vIGV4cHJlc3Npb24gdXAgdG8gdGVzdCBpdCBmb3IgYmxhbmsgYmVmb3JlIGdlbmVyYXRpbmcgdGhlIHVuZ3VhcmRlZCB2ZXJzaW9uLlxuICAgICAgICAvLyBDb25zaWRlciwgZm9yIGV4YW1wbGUgdGhlIGZvbGxvd2luZyBleHByZXNzaW9uOiBhPy5iLmM/LmQuZVxuICAgICAgICAvLyBUaGlzIHJlc3VsdHMgaW4gdGhlIGFzdDpcbiAgICAgICAgLy8gICAgICAgICAuXG4gICAgICAgIC8vICAgICAgICAvIFxcXG4gICAgICAgIC8vICAgICAgID8uICAgZVxuICAgICAgICAvLyAgICAgIC8gIFxcXG4gICAgICAgIC8vICAgICAuICAgIGRcbiAgICAgICAgLy8gICAgLyBcXFxuICAgICAgICAvLyAgID8uICBjXG4gICAgICAgIC8vICAvICBcXFxuICAgICAgICAvLyBhICAgIGJcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyB0cmVlIHNob3VsZCBiZSBnZW5lcmF0ZWQ6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICAvLS0tLSA/IC0tLS1cXFxuICAgICAgICAvLyAgICAgICAvICAgICAgfCAgICAgIFxcXG4gICAgICAgIC8vICAgICBhICAgLy0tLSA/IC0tLVxcICBudWxsXG4gICAgICAgIC8vICAgICAgICAvICAgICB8ICAgICBcXFxuICAgICAgICAvLyAgICAgICAuICAgICAgLiAgICAgbnVsbFxuICAgICAgICAvLyAgICAgIC8gXFwgICAgLyBcXFxuICAgICAgICAvLyAgICAgLiAgYyAgIC4gICBlXG4gICAgICAgIC8vICAgIC8gXFwgICAgLyBcXFxuICAgICAgICAvLyAgIGEgICBiICAuICAgZFxuICAgICAgICAvLyAgICAgICAgIC8gXFxcbiAgICAgICAgLy8gICAgICAgIC4gICBjXG4gICAgICAgIC8vICAgICAgIC8gXFxcbiAgICAgICAgLy8gICAgICBhICAgYlxuICAgICAgICAvL1xuICAgICAgICAvLyBOb3RpY2UgdGhhdCB0aGUgZmlyc3QgZ3VhcmQgY29uZGl0aW9uIGlzIHRoZSBsZWZ0IGhhbmQgb2YgdGhlIGxlZnQgbW9zdCBzYWZlIGFjY2VzcyBub2RlXG4gICAgICAgIC8vIHdoaWNoIGNvbWVzIGluIGFzIGxlZnRNb3N0U2FmZSB0byB0aGlzIHJvdXRpbmUuXG4gICAgICAgIHZhciBndWFyZGVkRXhwcmVzc2lvbiA9IHRoaXMuX3Zpc2l0KGxlZnRNb3N0U2FmZS5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHZhciB0ZW1wb3JhcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLm5lZWRzVGVtcG9yYXJ5KGxlZnRNb3N0U2FmZS5yZWNlaXZlcikpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBleHByZXNzaW9uIGhhcyBtZXRob2QgY2FsbHMgb3IgcGlwZXMgdGhlbiB3ZSBuZWVkIHRvIHNhdmUgdGhlIHJlc3VsdCBpbnRvIGFcbiAgICAgICAgICAgIC8vIHRlbXBvcmFyeSB2YXJpYWJsZSB0byBhdm9pZCBjYWxsaW5nIHN0YXRlZnVsIG9yIGltcHVyZSBjb2RlIG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICAgICAgdGVtcG9yYXJ5ID0gdGhpcy5hbGxvY2F0ZVRlbXBvcmFyeSgpO1xuICAgICAgICAgICAgLy8gUHJlc2VydmUgdGhlIHJlc3VsdCBpbiB0aGUgdGVtcG9yYXJ5IHZhcmlhYmxlXG4gICAgICAgICAgICBndWFyZGVkRXhwcmVzc2lvbiA9IHRlbXBvcmFyeS5zZXQoZ3VhcmRlZEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgLy8gRW5zdXJlIGFsbCBmdXJ0aGVyIHJlZmVyZW5jZXMgdG8gdGhlIGd1YXJkZWQgZXhwcmVzc2lvbiByZWZlciB0byB0aGUgdGVtcG9yYXJ5IGluc3RlYWQuXG4gICAgICAgICAgICB0aGlzLl9yZXN1bHRNYXAuc2V0KGxlZnRNb3N0U2FmZS5yZWNlaXZlciwgdGVtcG9yYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29uZGl0aW9uID0gZ3VhcmRlZEV4cHJlc3Npb24uaXNCbGFuaygpO1xuICAgICAgICAvLyBDb252ZXJ0IHRoZSBhc3QgdG8gYW4gdW5ndWFyZGVkIGFjY2VzcyB0byB0aGUgcmVjZWl2ZXIncyBtZW1iZXIuIFRoZSBtYXAgd2lsbCBzdWJzdGl0dXRlXG4gICAgICAgIC8vIGxlZnRNb3N0Tm9kZSB3aXRoIGl0cyB1bmd1YXJkZWQgdmVyc2lvbiBpbiB0aGUgY2FsbCB0byBgdGhpcy52aXNpdCgpYC5cbiAgICAgICAgaWYgKGxlZnRNb3N0U2FmZSBpbnN0YW5jZW9mIFNhZmVNZXRob2RDYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2RlTWFwLnNldChsZWZ0TW9zdFNhZmUsIG5ldyBNZXRob2RDYWxsKGxlZnRNb3N0U2FmZS5zcGFuLCBsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIGxlZnRNb3N0U2FmZS5uYW1lLCBsZWZ0TW9zdFNhZmUuYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbm9kZU1hcC5zZXQobGVmdE1vc3RTYWZlLCBuZXcgUHJvcGVydHlSZWFkKGxlZnRNb3N0U2FmZS5zcGFuLCBsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIGxlZnRNb3N0U2FmZS5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB0aGUgbm9kZSBub3cgd2l0aG91dCB0aGUgZ3VhcmRlZCBtZW1iZXIgYWNjZXNzLlxuICAgICAgICB2YXIgYWNjZXNzID0gdGhpcy5fdmlzaXQoYXN0LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBtYXBwaW5nLiBUaGlzIGlzIG5vdCBzdHJpY3RseSByZXF1aXJlZCBhcyB0aGUgY29udmVydGVyIG9ubHkgdHJhdmVyc2VzIGVhY2ggbm9kZVxuICAgICAgICAvLyBvbmNlIGJ1dCBpcyBzYWZlciBpZiB0aGUgY29udmVyc2lvbiBpcyBjaGFuZ2VkIHRvIHRyYXZlcnNlIHRoZSBub2RlcyBtb3JlIHRoYW4gb25jZS5cbiAgICAgICAgdGhpcy5fbm9kZU1hcC5kZWxldGUobGVmdE1vc3RTYWZlKTtcbiAgICAgICAgLy8gSWYgd2UgYWxsb2NhdGVkIGEgdGVtcG9yYXJ5LCByZWxlYXNlIGl0LlxuICAgICAgICBpZiAodGVtcG9yYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VUZW1wb3JhcnkodGVtcG9yYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm9kdWNlIHRoZSBjb25kaXRpb25hbFxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgY29uZGl0aW9uLmNvbmRpdGlvbmFsKGxpdGVyYWwobnVsbCksIGFjY2VzcykpO1xuICAgIH07XG4gICAgLy8gR2l2ZW4gYSBleHByZXNzaW9uIG9mIHRoZSBmb3JtIGE/LmIuYz8uZC5lIHRoZSB0aGUgbGVmdCBtb3N0IHNhZmUgbm9kZSBpc1xuICAgIC8vIHRoZSAoYT8uYikuIFRoZSAuIGFuZCA/LiBhcmUgbGVmdCBhc3NvY2lhdGl2ZSB0aHVzIGNhbiBiZSByZXdyaXR0ZW4gYXM6XG4gICAgLy8gKCgoKGE/LmMpLmIpLmMpPy5kKS5lLiBUaGlzIHJldHVybnMgdGhlIG1vc3QgZGVlcGx5IG5lc3RlZCBzYWZlIHJlYWQgb3JcbiAgICAvLyBzYWZlIG1ldGhvZCBjYWxsIGFzIHRoaXMgbmVlZHMgYmUgdHJhbnNmb3JtIGluaXRpYWxseSB0bzpcbiAgICAvLyAgIGEgPT0gbnVsbCA/IG51bGwgOiBhLmMuYi5jPy5kLmVcbiAgICAvLyB0aGVuIHRvOlxuICAgIC8vICAgYSA9PSBudWxsID8gbnVsbCA6IGEuYi5jID09IG51bGwgPyBudWxsIDogYS5iLmMuZC5lXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5sZWZ0TW9zdFNhZmVOb2RlID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgYXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gKF90aGlzLl9ub2RlTWFwLmdldChhc3QpIHx8IGFzdCkudmlzaXQodmlzaXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhc3QudmlzaXQoe1xuICAgICAgICAgICAgdmlzaXRCaW5hcnk6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICB2aXNpdENoYWluOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgdmlzaXRDb25kaXRpb25hbDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIHZpc2l0RnVuY3Rpb25DYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgdmlzaXRJbXBsaWNpdFJlY2VpdmVyOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgdmlzaXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgdmlzaXRLZXllZFJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5vYmopOyB9LFxuICAgICAgICAgICAgdmlzaXRLZXllZFdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgdmlzaXRMaXRlcmFsQXJyYXk6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxNYXA6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxQcmltaXRpdmU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICB2aXNpdE1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcik7IH0sXG4gICAgICAgICAgICB2aXNpdFBpcGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICB2aXNpdFByZWZpeE5vdDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIHZpc2l0Tm9uTnVsbEFzc2VydDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIHZpc2l0UHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpOyB9LFxuICAgICAgICAgICAgdmlzaXRQcm9wZXJ0eVdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgdmlzaXRRdW90ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIHZpc2l0U2FmZU1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcikgfHwgYXN0OyB9LFxuICAgICAgICAgICAgdmlzaXRTYWZlUHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcikgfHwgYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgdHJ1ZSBvZiB0aGUgQVNUIGluY2x1ZGVzIGEgbWV0aG9kIG9yIGEgcGlwZSBpbmRpY2F0aW5nIHRoYXQsIGlmIHRoZVxuICAgIC8vIGV4cHJlc3Npb24gaXMgdXNlZCBhcyB0aGUgdGFyZ2V0IG9mIGEgc2FmZSBwcm9wZXJ0eSBvciBtZXRob2QgYWNjZXNzIHRoZW5cbiAgICAvLyB0aGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgc3RvcmVkIGludG8gYSB0ZW1wb3JhcnkgdmFyaWFibGUuXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5uZWVkc1RlbXBvcmFyeSA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGFzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzdCAmJiAoX3RoaXMuX25vZGVNYXAuZ2V0KGFzdCkgfHwgYXN0KS52aXNpdCh2aXNpdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHZpc2l0U29tZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBhc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3Quc29tZShmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh2aXNpdG9yLCBhc3QpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGFzdC52aXNpdCh7XG4gICAgICAgICAgICB2aXNpdEJpbmFyeTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0LmxlZnQpIHx8IHZpc2l0KHRoaXMsIGFzdC5yaWdodCk7IH0sXG4gICAgICAgICAgICB2aXNpdENoYWluOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIHZpc2l0Q29uZGl0aW9uYWw6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LmNvbmRpdGlvbikgfHwgdmlzaXQodGhpcywgYXN0LnRydWVFeHApIHx8XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0KHRoaXMsIGFzdC5mYWxzZUV4cCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRGdW5jdGlvbkNhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXI6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgdmlzaXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdFNvbWUodGhpcywgYXN0LmV4cHJlc3Npb25zKTsgfSxcbiAgICAgICAgICAgIHZpc2l0S2V5ZWRSZWFkOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIHZpc2l0S2V5ZWRXcml0ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxBcnJheTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbE1hcDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICB2aXNpdE1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICB2aXNpdFBpcGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICB2aXNpdFByZWZpeE5vdDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0LmV4cHJlc3Npb24pOyB9LFxuICAgICAgICAgICAgdmlzaXROb25OdWxsQXNzZXJ0OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3QuZXhwcmVzc2lvbik7IH0sXG4gICAgICAgICAgICB2aXNpdFByb3BlcnR5UmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICB2aXNpdFByb3BlcnR5V3JpdGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgdmlzaXRRdW90ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICB2aXNpdFNhZmVNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgdmlzaXRTYWZlUHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUuYWxsb2NhdGVUZW1wb3JhcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZW1wTnVtYmVyID0gdGhpcy5fY3VycmVudFRlbXBvcmFyeSsrO1xuICAgICAgICB0aGlzLnRlbXBvcmFyeUNvdW50ID0gTWF0aC5tYXgodGhpcy5fY3VycmVudFRlbXBvcmFyeSwgdGhpcy50ZW1wb3JhcnlDb3VudCk7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZFZhckV4cHIodGVtcG9yYXJ5TmFtZSh0aGlzLmJpbmRpbmdJZCwgdGVtcE51bWJlcikpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5yZWxlYXNlVGVtcG9yYXJ5ID0gZnVuY3Rpb24gKHRlbXBvcmFyeSkge1xuICAgICAgICB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5LS07XG4gICAgICAgIGlmICh0ZW1wb3JhcnkubmFtZSAhPSB0ZW1wb3JhcnlOYW1lKHRoaXMuYmluZGluZ0lkLCB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVtcG9yYXJ5IFwiICsgdGVtcG9yYXJ5Lm5hbWUgKyBcIiByZWxlYXNlZCBvdXQgb2Ygb3JkZXJcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYWJzb2x1dGUgYFBhcnNlU291cmNlU3BhbmAgZnJvbSB0aGUgcmVsYXRpdmUgYFBhcnNlU3BhbmAuXG4gICAgICpcbiAgICAgKiBgUGFyc2VTcGFuYCBvYmplY3RzIGFyZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGV4cHJlc3Npb24uXG4gICAgICogVGhpcyBtZXRob2QgY29udmVydHMgdGhlc2UgdG8gZnVsbCBgUGFyc2VTb3VyY2VTcGFuYCBvYmplY3RzIHRoYXRcbiAgICAgKiBzaG93IHdoZXJlIHRoZSBzcGFuIGlzIHdpdGhpbiB0aGUgb3ZlcmFsbCBzb3VyY2UgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzcGFuIHRoZSByZWxhdGl2ZSBzcGFuIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMgYSBgUGFyc2VTb3VyY2VTcGFuYCBmb3IgdGhlIHRoZSBnaXZlbiBzcGFuIG9yIG51bGwgaWYgbm9cbiAgICAgKiBgYmFzZVNvdXJjZVNwYW5gIHdhcyBwcm92aWRlZCB0byB0aGlzIGNsYXNzLlxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUuY29udmVydFNvdXJjZVNwYW4gPSBmdW5jdGlvbiAoc3Bhbikge1xuICAgICAgICBpZiAodGhpcy5iYXNlU291cmNlU3Bhbikge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5iYXNlU291cmNlU3Bhbi5zdGFydC5tb3ZlQnkoc3Bhbi5zdGFydCk7XG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5iYXNlU291cmNlU3Bhbi5zdGFydC5tb3ZlQnkoc3Bhbi5lbmQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIF9Bc3RUb0lyVmlzaXRvcjtcbn0oKSk7XG5mdW5jdGlvbiBmbGF0dGVuU3RhdGVtZW50cyhhcmcsIG91dHB1dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBmbGF0dGVuU3RhdGVtZW50cyhlbnRyeSwgb3V0cHV0KTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaChhcmcpO1xuICAgIH1cbn1cbnZhciBEZWZhdWx0TG9jYWxSZXNvbHZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZhdWx0TG9jYWxSZXNvbHZlcigpIHtcbiAgICB9XG4gICAgRGVmYXVsdExvY2FsUmVzb2x2ZXIucHJvdG90eXBlLm5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgRGVmYXVsdExvY2FsUmVzb2x2ZXIucHJvdG90eXBlLmdldExvY2FsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IEV2ZW50SGFuZGxlclZhcnMuZXZlbnQubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIEV2ZW50SGFuZGxlclZhcnMuZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdExvY2FsUmVzb2x2ZXI7XG59KCkpO1xuZnVuY3Rpb24gY3JlYXRlQ3VyclZhbHVlRXhwcihiaW5kaW5nSWQpIHtcbiAgICByZXR1cm4gdmFyaWFibGUoXCJjdXJyVmFsX1wiICsgYmluZGluZ0lkKTsgLy8gZml4IHN5bnRheCBoaWdobGlnaHRpbmc6IGBcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByZXZlbnREZWZhdWx0VmFyKGJpbmRpbmdJZCkge1xuICAgIHJldHVybiB2YXJpYWJsZShcInBkX1wiICsgYmluZGluZ0lkKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRTdG10SW50b0V4cHJlc3Npb24oc3RtdCkge1xuICAgIGlmIChzdG10IGluc3RhbmNlb2YgRXhwcmVzc2lvblN0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4gc3RtdC5leHByO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdG10IGluc3RhbmNlb2YgUmV0dXJuU3RhdGVtZW50KSB7XG4gICAgICAgIHJldHVybiBzdG10LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbnZhciBCdWlsdGluRnVuY3Rpb25DYWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdWlsdGluRnVuY3Rpb25DYWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1aWx0aW5GdW5jdGlvbkNhbGwoc3BhbiwgYXJncywgY29udmVydGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIG51bGwsIGFyZ3MpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICBfdGhpcy5jb252ZXJ0ZXIgPSBjb252ZXJ0ZXI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJ1aWx0aW5GdW5jdGlvbkNhbGw7XG59KEZ1bmN0aW9uQ2FsbCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFRoaXMgZmlsZSBpcyBhIHBvcnQgb2Ygc2hhZG93Q1NTIGZyb20gd2ViY29tcG9uZW50cy5qcyB0byBUeXBlU2NyaXB0LlxuICpcbiAqIFBsZWFzZSBtYWtlIHN1cmUgdG8ga2VlcCB0byBlZGl0cyBpbiBzeW5jIHdpdGggdGhlIHNvdXJjZSBmaWxlLlxuICpcbiAqIFNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcy9ibG9iLzRlZmVjZDdlMGUvc3JjL1NoYWRvd0NTUy9TaGFkb3dDU1MuanNcbiAqXG4gKiBUaGUgb3JpZ2luYWwgZmlsZSBsZXZlbCBjb21tZW50IGlzIHJlcHJvZHVjZWQgYmVsb3dcbiAqL1xuLypcbiAgVGhpcyBpcyBhIGxpbWl0ZWQgc2hpbSBmb3IgU2hhZG93RE9NIGNzcyBzdHlsaW5nLlxuICBodHRwczovL2R2Y3MudzMub3JnL2hnL3dlYmNvbXBvbmVudHMvcmF3LWZpbGUvdGlwL3NwZWMvc2hhZG93L2luZGV4Lmh0bWwjc3R5bGVzXG5cbiAgVGhlIGludGVudGlvbiBoZXJlIGlzIHRvIHN1cHBvcnQgb25seSB0aGUgc3R5bGluZyBmZWF0dXJlcyB3aGljaCBjYW4gYmVcbiAgcmVsYXRpdmVseSBzaW1wbHkgaW1wbGVtZW50ZWQuIFRoZSBnb2FsIGlzIHRvIGFsbG93IHVzZXJzIHRvIGF2b2lkIHRoZVxuICBtb3N0IG9idmlvdXMgcGl0ZmFsbHMgYW5kIGRvIHNvIHdpdGhvdXQgY29tcHJvbWlzaW5nIHBlcmZvcm1hbmNlIHNpZ25pZmljYW50bHkuXG4gIEZvciBTaGFkb3dET00gc3R5bGluZyB0aGF0J3Mgbm90IGNvdmVyZWQgaGVyZSwgYSBzZXQgb2YgYmVzdCBwcmFjdGljZXNcbiAgY2FuIGJlIHByb3ZpZGVkIHRoYXQgc2hvdWxkIGFsbG93IHVzZXJzIHRvIGFjY29tcGxpc2ggbW9yZSBjb21wbGV4IHN0eWxpbmcuXG5cbiAgVGhlIGZvbGxvd2luZyBpcyBhIGxpc3Qgb2Ygc3BlY2lmaWMgU2hhZG93RE9NIHN0eWxpbmcgZmVhdHVyZXMgYW5kIGEgYnJpZWZcbiAgZGlzY3Vzc2lvbiBvZiB0aGUgYXBwcm9hY2ggdXNlZCB0byBzaGltLlxuXG4gIFNoaW1tZWQgZmVhdHVyZXM6XG5cbiAgKiA6aG9zdCwgOmhvc3QtY29udGV4dDogU2hhZG93RE9NIGFsbG93cyBzdHlsaW5nIG9mIHRoZSBzaGFkb3dSb290J3MgaG9zdFxuICBlbGVtZW50IHVzaW5nIHRoZSA6aG9zdCBydWxlLiBUbyBzaGltIHRoaXMgZmVhdHVyZSwgdGhlIDpob3N0IHN0eWxlcyBhcmVcbiAgcmVmb3JtYXR0ZWQgYW5kIHByZWZpeGVkIHdpdGggYSBnaXZlbiBzY29wZSBuYW1lIGFuZCBwcm9tb3RlZCB0byBhXG4gIGRvY3VtZW50IGxldmVsIHN0eWxlc2hlZXQuXG4gIEZvciBleGFtcGxlLCBnaXZlbiBhIHNjb3BlIG5hbWUgb2YgLmZvbywgYSBydWxlIGxpa2UgdGhpczpcblxuICAgIDpob3N0IHtcbiAgICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgICAgfVxuICAgIH1cblxuICBiZWNvbWVzOlxuXG4gICAgLmZvbyB7XG4gICAgICBiYWNrZ3JvdW5kOiByZWQ7XG4gICAgfVxuXG4gICogZW5jYXBzdWxhdGlvbjogU3R5bGVzIGRlZmluZWQgd2l0aGluIFNoYWRvd0RPTSwgYXBwbHkgb25seSB0b1xuICBkb20gaW5zaWRlIHRoZSBTaGFkb3dET00uIFBvbHltZXIgdXNlcyBvbmUgb2YgdHdvIHRlY2huaXF1ZXMgdG8gaW1wbGVtZW50XG4gIHRoaXMgZmVhdHVyZS5cblxuICBCeSBkZWZhdWx0LCBydWxlcyBhcmUgcHJlZml4ZWQgd2l0aCB0aGUgaG9zdCBlbGVtZW50IHRhZyBuYW1lXG4gIGFzIGEgZGVzY2VuZGFudCBzZWxlY3Rvci4gVGhpcyBlbnN1cmVzIHN0eWxpbmcgZG9lcyBub3QgbGVhayBvdXQgb2YgdGhlICd0b3AnXG4gIG9mIHRoZSBlbGVtZW50J3MgU2hhZG93RE9NLiBGb3IgZXhhbXBsZSxcblxuICBkaXYge1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgfVxuXG4gIGJlY29tZXM6XG5cbiAgeC1mb28gZGl2IHtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIH1cblxuICBiZWNvbWVzOlxuXG5cbiAgQWx0ZXJuYXRpdmVseSwgaWYgV2ViQ29tcG9uZW50cy5TaGFkb3dDU1Muc3RyaWN0U3R5bGluZyBpcyBzZXQgdG8gdHJ1ZSB0aGVuXG4gIHNlbGVjdG9ycyBhcmUgc2NvcGVkIGJ5IGFkZGluZyBhbiBhdHRyaWJ1dGUgc2VsZWN0b3Igc3VmZml4IHRvIGVhY2hcbiAgc2ltcGxlIHNlbGVjdG9yIHRoYXQgY29udGFpbnMgdGhlIGhvc3QgZWxlbWVudCB0YWcgbmFtZS4gRWFjaCBlbGVtZW50XG4gIGluIHRoZSBlbGVtZW50J3MgU2hhZG93RE9NIHRlbXBsYXRlIGlzIGFsc28gZ2l2ZW4gdGhlIHNjb3BlIGF0dHJpYnV0ZS5cbiAgVGh1cywgdGhlc2UgcnVsZXMgbWF0Y2ggb25seSBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHNjb3BlIGF0dHJpYnV0ZS5cbiAgRm9yIGV4YW1wbGUsIGdpdmVuIGEgc2NvcGUgbmFtZSBvZiB4LWZvbywgYSBydWxlIGxpa2UgdGhpczpcblxuICAgIGRpdiB7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB9XG5cbiAgYmVjb21lczpcblxuICAgIGRpdlt4LWZvb10ge1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgfVxuXG4gIE5vdGUgdGhhdCBlbGVtZW50cyB0aGF0IGFyZSBkeW5hbWljYWxseSBhZGRlZCB0byBhIHNjb3BlIG11c3QgaGF2ZSB0aGUgc2NvcGVcbiAgc2VsZWN0b3IgYWRkZWQgdG8gdGhlbSBtYW51YWxseS5cblxuICAqIHVwcGVyL2xvd2VyIGJvdW5kIGVuY2Fwc3VsYXRpb246IFN0eWxlcyB3aGljaCBhcmUgZGVmaW5lZCBvdXRzaWRlIGFcbiAgc2hhZG93Um9vdCBzaG91bGQgbm90IGNyb3NzIHRoZSBTaGFkb3dET00gYm91bmRhcnkgYW5kIHNob3VsZCBub3QgYXBwbHlcbiAgaW5zaWRlIGEgc2hhZG93Um9vdC5cblxuICBUaGlzIHN0eWxpbmcgYmVoYXZpb3IgaXMgbm90IGVtdWxhdGVkLiBTb21lIHBvc3NpYmxlIHdheXMgdG8gZG8gdGhpcyB0aGF0XG4gIHdlcmUgcmVqZWN0ZWQgZHVlIHRvIGNvbXBsZXhpdHkgYW5kL29yIHBlcmZvcm1hbmNlIGNvbmNlcm5zIGluY2x1ZGU6ICgxKSByZXNldFxuICBldmVyeSBwb3NzaWJsZSBwcm9wZXJ0eSBmb3IgZXZlcnkgcG9zc2libGUgc2VsZWN0b3IgZm9yIGEgZ2l2ZW4gc2NvcGUgbmFtZTtcbiAgKDIpIHJlLWltcGxlbWVudCBjc3MgaW4gamF2YXNjcmlwdC5cblxuICBBcyBhbiBhbHRlcm5hdGl2ZSwgdXNlcnMgc2hvdWxkIG1ha2Ugc3VyZSB0byB1c2Ugc2VsZWN0b3JzXG4gIHNwZWNpZmljIHRvIHRoZSBzY29wZSBpbiB3aGljaCB0aGV5IGFyZSB3b3JraW5nLlxuXG4gICogOjpkaXN0cmlidXRlZDogVGhpcyBiZWhhdmlvciBpcyBub3QgZW11bGF0ZWQuIEl0J3Mgb2Z0ZW4gbm90IG5lY2Vzc2FyeVxuICB0byBzdHlsZSB0aGUgY29udGVudHMgb2YgYSBzcGVjaWZpYyBpbnNlcnRpb24gcG9pbnQgYW5kIGluc3RlYWQsIGRlc2NlbmRhbnRzXG4gIG9mIHRoZSBob3N0IGVsZW1lbnQgY2FuIGJlIHN0eWxlZCBzZWxlY3RpdmVseS4gVXNlcnMgY2FuIGFsc28gY3JlYXRlIGFuXG4gIGV4dHJhIG5vZGUgYXJvdW5kIGFuIGluc2VydGlvbiBwb2ludCBhbmQgc3R5bGUgdGhhdCBub2RlJ3MgY29udGVudHNcbiAgdmlhIGRlc2NlbmRlbnQgc2VsZWN0b3JzLiBGb3IgZXhhbXBsZSwgd2l0aCBhIHNoYWRvd1Jvb3QgbGlrZSB0aGlzOlxuXG4gICAgPHN0eWxlPlxuICAgICAgOjpjb250ZW50KGRpdikge1xuICAgICAgICBiYWNrZ3JvdW5kOiByZWQ7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cbiAgICA8Y29udGVudD48L2NvbnRlbnQ+XG5cbiAgY291bGQgYmVjb21lOlxuXG4gICAgPHN0eWxlPlxuICAgICAgLyAqQHBvbHlmaWxsIC5jb250ZW50LWNvbnRhaW5lciBkaXYgKiAvXG4gICAgICA6OmNvbnRlbnQoZGl2KSB7XG4gICAgICAgIGJhY2tncm91bmQ6IHJlZDtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuICAgIDxkaXYgY2xhc3M9XCJjb250ZW50LWNvbnRhaW5lclwiPlxuICAgICAgPGNvbnRlbnQ+PC9jb250ZW50PlxuICAgIDwvZGl2PlxuXG4gIE5vdGUgdGhlIHVzZSBvZiBAcG9seWZpbGwgaW4gdGhlIGNvbW1lbnQgYWJvdmUgYSBTaGFkb3dET00gc3BlY2lmaWMgc3R5bGVcbiAgZGVjbGFyYXRpb24uIFRoaXMgaXMgYSBkaXJlY3RpdmUgdG8gdGhlIHN0eWxpbmcgc2hpbSB0byB1c2UgdGhlIHNlbGVjdG9yXG4gIGluIGNvbW1lbnRzIGluIGxpZXUgb2YgdGhlIG5leHQgc2VsZWN0b3Igd2hlbiBydW5uaW5nIHVuZGVyIHBvbHlmaWxsLlxuKi9cbnZhciBTaGFkb3dDc3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2hhZG93Q3NzKCkge1xuICAgICAgICB0aGlzLnN0cmljdFN0eWxpbmcgPSB0cnVlO1xuICAgIH1cbiAgICAvKlxuICAgICogU2hpbSBzb21lIGNzc1RleHQgd2l0aCB0aGUgZ2l2ZW4gc2VsZWN0b3IuIFJldHVybnMgY3NzVGV4dCB0aGF0IGNhblxuICAgICogYmUgaW5jbHVkZWQgaW4gdGhlIGRvY3VtZW50IHZpYSBXZWJDb21wb25lbnRzLlNoYWRvd0NTUy5hZGRDc3NUb0RvY3VtZW50KGNzcykuXG4gICAgKlxuICAgICogV2hlbiBzdHJpY3RTdHlsaW5nIGlzIHRydWU6XG4gICAgKiAtIHNlbGVjdG9yIGlzIHRoZSBhdHRyaWJ1dGUgYWRkZWQgdG8gYWxsIGVsZW1lbnRzIGluc2lkZSB0aGUgaG9zdCxcbiAgICAqIC0gaG9zdFNlbGVjdG9yIGlzIHRoZSBhdHRyaWJ1dGUgYWRkZWQgdG8gdGhlIGhvc3QgaXRzZWxmLlxuICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5zaGltQ3NzVGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0LCBzZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChob3N0U2VsZWN0b3IgPT09IHZvaWQgMCkgeyBob3N0U2VsZWN0b3IgPSAnJzsgfVxuICAgICAgICB2YXIgY29tbWVudHNXaXRoSGFzaCA9IGV4dHJhY3RDb21tZW50c1dpdGhIYXNoKGNzc1RleHQpO1xuICAgICAgICBjc3NUZXh0ID0gc3RyaXBDb21tZW50cyhjc3NUZXh0KTtcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2luc2VydERpcmVjdGl2ZXMoY3NzVGV4dCk7XG4gICAgICAgIHZhciBzY29wZWRDc3NUZXh0ID0gdGhpcy5fc2NvcGVDc3NUZXh0KGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gX19zcHJlYWQoW3Njb3BlZENzc1RleHRdLCBjb21tZW50c1dpdGhIYXNoKS5qb2luKCdcXG4nKTtcbiAgICB9O1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2luc2VydERpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICBjc3NUZXh0ID0gdGhpcy5faW5zZXJ0UG9seWZpbGxEaXJlY3RpdmVzSW5Dc3NUZXh0KGNzc1RleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0UG9seWZpbGxSdWxlc0luQ3NzVGV4dChjc3NUZXh0KTtcbiAgICB9O1xuICAgIC8qXG4gICAgICogUHJvY2VzcyBzdHlsZXMgdG8gY29udmVydCBuYXRpdmUgU2hhZG93RE9NIHJ1bGVzIHRoYXQgd2lsbCB0cmlwXG4gICAgICogdXAgdGhlIGNzcyBwYXJzZXI7IHdlIHJlbHkgb24gZGVjb3JhdGluZyB0aGUgc3R5bGVzaGVldCB3aXRoIGluZXJ0IHJ1bGVzLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIHdlIGNvbnZlcnQgdGhpcyBydWxlOlxuICAgICAqXG4gICAgICogcG9seWZpbGwtbmV4dC1zZWxlY3RvciB7IGNvbnRlbnQ6ICc6aG9zdCBtZW51LWl0ZW0nOyB9XG4gICAgICogOjpjb250ZW50IG1lbnUtaXRlbSB7XG4gICAgICpcbiAgICAgKiB0byB0aGlzOlxuICAgICAqXG4gICAgICogc2NvcGVOYW1lIG1lbnUtaXRlbSB7XG4gICAgICpcbiAgICAqKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnRQb2x5ZmlsbERpcmVjdGl2ZXNJbkNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXG4gICAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoX2Nzc0NvbnRlbnROZXh0U2VsZWN0b3JSZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1bMl0gKyAneyc7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLypcbiAgICAgKiBQcm9jZXNzIHN0eWxlcyB0byBhZGQgcnVsZXMgd2hpY2ggd2lsbCBvbmx5IGFwcGx5IHVuZGVyIHRoZSBwb2x5ZmlsbFxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIHdlIGNvbnZlcnQgdGhpcyBydWxlOlxuICAgICAqXG4gICAgICogcG9seWZpbGwtcnVsZSB7XG4gICAgICogICBjb250ZW50OiAnOmhvc3QgbWVudS1pdGVtJztcbiAgICAgKiAuLi5cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB0byB0aGlzOlxuICAgICAqXG4gICAgICogc2NvcGVOYW1lIG1lbnUtaXRlbSB7Li4ufVxuICAgICAqXG4gICAgKiovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5faW5zZXJ0UG9seWZpbGxSdWxlc0luQ3NzVGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB3ZWJjb21wb25lbnRzLmpzOiBkb2VzIG5vdCBoYW5kbGUgY29tbWVudHNcbiAgICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShfY3NzQ29udGVudFJ1bGVSZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJ1bGUgPSBtWzBdLnJlcGxhY2UobVsxXSwgJycpLnJlcGxhY2UobVsyXSwgJycpO1xuICAgICAgICAgICAgcmV0dXJuIG1bNF0gKyBydWxlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qIEVuc3VyZSBzdHlsZXMgYXJlIHNjb3BlZC4gUHNldWRvLXNjb3BpbmcgdGFrZXMgYSBydWxlIGxpa2U6XG4gICAgICpcbiAgICAgKiAgLmZvbyB7Li4uIH1cbiAgICAgKlxuICAgICAqICBhbmQgY29udmVydHMgdGhpcyB0b1xuICAgICAqXG4gICAgICogIHNjb3BlTmFtZSAuZm9vIHsgLi4uIH1cbiAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3Njb3BlQ3NzVGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIHVuc2NvcGVkUnVsZXMgPSB0aGlzLl9leHRyYWN0VW5zY29wZWRSdWxlc0Zyb21Dc3NUZXh0KGNzc1RleHQpO1xuICAgICAgICAvLyByZXBsYWNlIDpob3N0IGFuZCA6aG9zdC1jb250ZXh0IC1zaGFkb3djc3Nob3N0IGFuZCAtc2hhZG93Y3NzaG9zdCByZXNwZWN0aXZlbHlcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2luc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dChjc3NUZXh0KTtcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRDb2xvbkhvc3QoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0Q29sb25Ib3N0Q29udGV4dChjc3NUZXh0KTtcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRTaGFkb3dET01TZWxlY3RvcnMoY3NzVGV4dCk7XG4gICAgICAgIGlmIChzY29wZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICBjc3NUZXh0ID0gdGhpcy5fc2NvcGVTZWxlY3RvcnMoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dCArICdcXG4nICsgdW5zY29wZWRSdWxlcztcbiAgICAgICAgcmV0dXJuIGNzc1RleHQudHJpbSgpO1xuICAgIH07XG4gICAgLypcbiAgICAgKiBQcm9jZXNzIHN0eWxlcyB0byBhZGQgcnVsZXMgd2hpY2ggd2lsbCBvbmx5IGFwcGx5IHVuZGVyIHRoZSBwb2x5ZmlsbFxuICAgICAqIGFuZCBkbyBub3QgcHJvY2VzcyB2aWEgQ1NTT00uIChDU1NPTSBpcyBkZXN0cnVjdGl2ZSB0byBydWxlcyBvbiByYXJlXG4gICAgICogb2NjYXNpb25zLCBlLmcuIC13ZWJraXQtY2FsYyBvbiBTYWZhcmkuKVxuICAgICAqIEZvciBleGFtcGxlLCB3ZSBjb252ZXJ0IHRoaXMgcnVsZTpcbiAgICAgKlxuICAgICAqIEBwb2x5ZmlsbC11bnNjb3BlZC1ydWxlIHtcbiAgICAgKiAgIGNvbnRlbnQ6ICdtZW51LWl0ZW0nO1xuICAgICAqIC4uLiB9XG4gICAgICpcbiAgICAgKiB0byB0aGlzOlxuICAgICAqXG4gICAgICogbWVudS1pdGVtIHsuLi59XG4gICAgICpcbiAgICAqKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9leHRyYWN0VW5zY29wZWRSdWxlc0Zyb21Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgLy8gRGlmZmVyZW5jZSB3aXRoIHdlYmNvbXBvbmVudHMuanM6IGRvZXMgbm90IGhhbmRsZSBjb21tZW50c1xuICAgICAgICB2YXIgciA9ICcnO1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoKG0gPSBfY3NzQ29udGVudFVuc2NvcGVkUnVsZVJlLmV4ZWMoY3NzVGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcnVsZSA9IG1bMF0ucmVwbGFjZShtWzJdLCAnJykucmVwbGFjZShtWzFdLCBtWzRdKTtcbiAgICAgICAgICAgIHIgKz0gcnVsZSArICdcXG5cXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLypcbiAgICAgKiBjb252ZXJ0IGEgcnVsZSBsaWtlIDpob3N0KC5mb28pID4gLmJhciB7IH1cbiAgICAgKlxuICAgICAqIHRvXG4gICAgICpcbiAgICAgKiAuZm9vPHNjb3BlTmFtZT4gPiAuYmFyXG4gICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0Q29sb25Ib3N0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRDb2xvblJ1bGUoY3NzVGV4dCwgX2Nzc0NvbG9uSG9zdFJlLCB0aGlzLl9jb2xvbkhvc3RQYXJ0UmVwbGFjZXIpO1xuICAgIH07XG4gICAgLypcbiAgICAgKiBjb252ZXJ0IGEgcnVsZSBsaWtlIDpob3N0LWNvbnRleHQoLmZvbykgPiAuYmFyIHsgfVxuICAgICAqXG4gICAgICogdG9cbiAgICAgKlxuICAgICAqIC5mb288c2NvcGVOYW1lPiA+IC5iYXIsIC5mb28gc2NvcGVOYW1lID4gLmJhciB7IH1cbiAgICAgKlxuICAgICAqIGFuZFxuICAgICAqXG4gICAgICogOmhvc3QtY29udGV4dCguZm9vOmhvc3QpIC5iYXIgeyAuLi4gfVxuICAgICAqXG4gICAgICogdG9cbiAgICAgKlxuICAgICAqIC5mb288c2NvcGVOYW1lPiAuYmFyIHsgLi4uIH1cbiAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbnZlcnRDb2xvbkhvc3RDb250ZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRDb2xvblJ1bGUoY3NzVGV4dCwgX2Nzc0NvbG9uSG9zdENvbnRleHRSZSwgdGhpcy5fY29sb25Ib3N0Q29udGV4dFBhcnRSZXBsYWNlcik7XG4gICAgfTtcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0Q29sb25SdWxlID0gZnVuY3Rpb24gKGNzc1RleHQsIHJlZ0V4cCwgcGFydFJlcGxhY2VyKSB7XG4gICAgICAgIC8vIG1bMV0gPSA6aG9zdCgtY29udGV4dCksIG1bMl0gPSBjb250ZW50cyBvZiAoKSwgbVszXSByZXN0IG9mIHJ1bGVcbiAgICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShyZWdFeHAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIG1bX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtWzJdKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gbVsyXS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIHZhciByID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBhcnRzW2ldLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHIucHVzaChwYXJ0UmVwbGFjZXIoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciwgcCwgbVszXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gci5qb2luKCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciArIG1bM107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29sb25Ib3N0Q29udGV4dFBhcnRSZXBsYWNlciA9IGZ1bmN0aW9uIChob3N0LCBwYXJ0LCBzdWZmaXgpIHtcbiAgICAgICAgaWYgKHBhcnQuaW5kZXhPZihfcG9seWZpbGxIb3N0KSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb25Ib3N0UGFydFJlcGxhY2VyKGhvc3QsIHBhcnQsIHN1ZmZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaG9zdCArIHBhcnQgKyBzdWZmaXggKyAnLCAnICsgcGFydCArICcgJyArIGhvc3QgKyBzdWZmaXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbG9uSG9zdFBhcnRSZXBsYWNlciA9IGZ1bmN0aW9uIChob3N0LCBwYXJ0LCBzdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIGhvc3QgKyBwYXJ0LnJlcGxhY2UoX3BvbHlmaWxsSG9zdCwgJycpICsgc3VmZml4O1xuICAgIH07XG4gICAgLypcbiAgICAgKiBDb252ZXJ0IGNvbWJpbmF0b3JzIGxpa2UgOjpzaGFkb3cgYW5kIHBzZXVkby1lbGVtZW50cyBsaWtlIDo6Y29udGVudFxuICAgICAqIGJ5IHJlcGxhY2luZyB3aXRoIHNwYWNlLlxuICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29udmVydFNoYWRvd0RPTVNlbGVjdG9ycyA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIHJldHVybiBfc2hhZG93RE9NU2VsZWN0b3JzUmUucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHBhdHRlcm4pIHsgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKHBhdHRlcm4sICcgJyk7IH0sIGNzc1RleHQpO1xuICAgIH07XG4gICAgLy8gY2hhbmdlIGEgc2VsZWN0b3IgbGlrZSAnZGl2JyB0byAnbmFtZSBkaXYnXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVTZWxlY3RvcnMgPSBmdW5jdGlvbiAoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBwcm9jZXNzUnVsZXMoY3NzVGV4dCwgZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHJ1bGUuc2VsZWN0b3I7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJ1bGUuY29udGVudDtcbiAgICAgICAgICAgIGlmIChydWxlLnNlbGVjdG9yWzBdICE9ICdAJykge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Njb3BlU2VsZWN0b3IocnVsZS5zZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yLCBfdGhpcy5zdHJpY3RTdHlsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQG1lZGlhJykgfHwgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAc3VwcG9ydHMnKSB8fFxuICAgICAgICAgICAgICAgIHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQHBhZ2UnKSB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0Bkb2N1bWVudCcpKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IF90aGlzLl9zY29wZVNlbGVjdG9ycyhydWxlLmNvbnRlbnQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3Njb3BlU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvciwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzZWxlY3Rvci5zcGxpdCgnLCcpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwYXJ0KSB7IHJldHVybiBwYXJ0LnRyaW0oKS5zcGxpdChfc2hhZG93RGVlcFNlbGVjdG9ycyk7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkZWVwUGFydHMpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChkZWVwUGFydHMpLCBzaGFsbG93UGFydCA9IF9hWzBdLCBvdGhlclBhcnRzID0gX2Euc2xpY2UoMSk7XG4gICAgICAgICAgICB2YXIgYXBwbHlTY29wZSA9IGZ1bmN0aW9uIChzaGFsbG93UGFydCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc2VsZWN0b3JOZWVkc1Njb3Bpbmcoc2hhbGxvd1BhcnQsIHNjb3BlU2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpY3QgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FwcGx5U3RyaWN0U2VsZWN0b3JTY29wZShzaGFsbG93UGFydCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwbHlTZWxlY3RvclNjb3BlKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3dQYXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWQoW2FwcGx5U2NvcGUoc2hhbGxvd1BhcnQpXSwgb3RoZXJQYXJ0cykuam9pbignICcpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgfTtcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zZWxlY3Rvck5lZWRzU2NvcGluZyA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICB2YXIgcmUgPSB0aGlzLl9tYWtlU2NvcGVNYXRjaGVyKHNjb3BlU2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gIXJlLnRlc3Qoc2VsZWN0b3IpO1xuICAgIH07XG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fbWFrZVNjb3BlTWF0Y2hlciA9IGZ1bmN0aW9uIChzY29wZVNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBscmUgPSAvXFxbL2c7XG4gICAgICAgIHZhciBycmUgPSAvXFxdL2c7XG4gICAgICAgIHNjb3BlU2VsZWN0b3IgPSBzY29wZVNlbGVjdG9yLnJlcGxhY2UobHJlLCAnXFxcXFsnKS5yZXBsYWNlKHJyZSwgJ1xcXFxdJyk7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdeKCcgKyBzY29wZVNlbGVjdG9yICsgJyknICsgX3NlbGVjdG9yUmVTdWZmaXgsICdtJyk7XG4gICAgfTtcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICAvLyBEaWZmZXJlbmNlIGZyb20gd2ViY29tcG9uZW50cy5qczogc2NvcGVTZWxlY3RvciBjb3VsZCBub3QgYmUgYW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZShzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICB9O1xuICAgIC8vIHNjb3BlIHZpYSBuYW1lIGFuZCBbaXM9bmFtZV1cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICAvLyBJbiBBbmRyb2lkIGJyb3dzZXIsIHRoZSBsYXN0SW5kZXggaXMgbm90IHJlc2V0IHdoZW4gdGhlIHJlZ2V4IGlzIHVzZWQgaW4gU3RyaW5nLnJlcGxhY2UoKVxuICAgICAgICBfcG9seWZpbGxIb3N0UmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgaWYgKF9wb2x5ZmlsbEhvc3RSZS50ZXN0KHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VCeV8xID0gdGhpcy5zdHJpY3RTdHlsaW5nID8gXCJbXCIgKyBob3N0U2VsZWN0b3IgKyBcIl1cIiA6IHNjb3BlU2VsZWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAucmVwbGFjZShfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUsIGZ1bmN0aW9uIChobmMsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoLyhbXjpdKikoOiopKC4qKS8sIGZ1bmN0aW9uIChfLCBiZWZvcmUsIGNvbG9uLCBhZnRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlICsgcmVwbGFjZUJ5XzEgKyBjb2xvbiArIGFmdGVyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShfcG9seWZpbGxIb3N0UmUsIHJlcGxhY2VCeV8xICsgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcGVTZWxlY3RvciArICcgJyArIHNlbGVjdG9yO1xuICAgIH07XG4gICAgLy8gcmV0dXJuIGEgc2VsZWN0b3Igd2l0aCBbbmFtZV0gc3VmZml4IG9uIGVhY2ggc2ltcGxlIHNlbGVjdG9yXG4gICAgLy8gZS5nLiAuZm9vLmJhciA+IC56b3QgYmVjb21lcyAuZm9vW25hbWVdLmJhcltuYW1lXSA+IC56b3RbbmFtZV0gIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVN0cmljdFNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaXNSZSA9IC9cXFtpcz0oW15cXF1dKilcXF0vZztcbiAgICAgICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShpc1JlLCBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHBhcnRzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGF0dHJOYW1lID0gJ1snICsgc2NvcGVTZWxlY3RvciArICddJztcbiAgICAgICAgdmFyIF9zY29wZVNlbGVjdG9yUGFydCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICB2YXIgc2NvcGVkUCA9IHAudHJpbSgpO1xuICAgICAgICAgICAgaWYgKCFzY29wZWRQKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAuaW5kZXhPZihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVkUCA9IF90aGlzLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUocCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSA6aG9zdCBzaW5jZSBpdCBzaG91bGQgYmUgdW5uZWNlc3NhcnlcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHAucmVwbGFjZShfcG9seWZpbGxIb3N0UmUsICcnKTtcbiAgICAgICAgICAgICAgICBpZiAodC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gdC5tYXRjaCgvKFteOl0qKSg6KikoLiopLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZWRQID0gbWF0Y2hlc1sxXSArIGF0dHJOYW1lICsgbWF0Y2hlc1syXSArIG1hdGNoZXNbM107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVkUDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNhZmVDb250ZW50ID0gbmV3IFNhZmVTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIHNlbGVjdG9yID0gc2FmZUNvbnRlbnQuY29udGVudCgpO1xuICAgICAgICB2YXIgc2NvcGVkU2VsZWN0b3IgPSAnJztcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSAwO1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICB2YXIgc2VwID0gLyggfD58XFwrfH4oPyE9KSlcXHMqL2c7XG4gICAgICAgIC8vIElmIGEgc2VsZWN0b3IgYXBwZWFycyBiZWZvcmUgOmhvc3QgaXQgc2hvdWxkIG5vdCBiZSBzaGltbWVkIGFzIGl0XG4gICAgICAgIC8vIG1hdGNoZXMgb24gYW5jZXN0b3IgZWxlbWVudHMgYW5kIG5vdCBvbiBlbGVtZW50cyBpbiB0aGUgaG9zdCdzIHNoYWRvd1xuICAgICAgICAvLyBgOmhvc3QtY29udGV4dChkaXYpYCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAgICAgICAvLyBgLXNoYWRvd2Nzc2hvc3Qtbm8tY29tYmluYXRvcmRpdiwgZGl2IC1zaGFkb3djc3Nob3N0LW5vLWNvbWJpbmF0b3JgXG4gICAgICAgIC8vIHRoZSBgZGl2YCBpcyBub3QgcGFydCBvZiB0aGUgY29tcG9uZW50IGluIHRoZSAybmQgc2VsZWN0b3JzIGFuZCBzaG91bGQgbm90IGJlIHNjb3BlZC5cbiAgICAgICAgLy8gSGlzdG9yaWNhbGx5IGBjb21wb25lbnQtdGFnOmhvc3RgIHdhcyBtYXRjaGluZyB0aGUgY29tcG9uZW50IHNvIHdlIGFsc28gd2FudCB0byBwcmVzZXJ2ZVxuICAgICAgICAvLyB0aGlzIGJlaGF2aW9yIHRvIGF2b2lkIGJyZWFraW5nIGxlZ2FjeSBhcHBzIChpdCBzaG91bGQgbm90IG1hdGNoKS5cbiAgICAgICAgLy8gVGhlIGJlaGF2aW9yIHNob3VsZCBiZTpcbiAgICAgICAgLy8gLSBgdGFnOmhvc3RgIC0+IGB0YWdbaF1gICh0aGlzIGlzIHRvIGF2b2lkIGJyZWFraW5nIGxlZ2FjeSBhcHBzLCBzaG91bGQgbm90IG1hdGNoIGFueXRoaW5nKVxuICAgICAgICAvLyAtIGB0YWcgOmhvc3RgIC0+IGB0YWcgW2hdYCAoYHRhZ2AgaXMgbm90IHNjb3BlZCBiZWNhdXNlIGl0J3MgY29uc2lkZXJlZCBwYXJ0IG9mIGFcbiAgICAgICAgLy8gICBgOmhvc3QtY29udGV4dCh0YWcpYClcbiAgICAgICAgdmFyIGhhc0hvc3QgPSBzZWxlY3Rvci5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTE7XG4gICAgICAgIC8vIE9ubHkgc2NvcGUgcGFydHMgYWZ0ZXIgdGhlIGZpcnN0IGAtc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yYCB3aGVuIGl0IGlzIHByZXNlbnRcbiAgICAgICAgdmFyIHNob3VsZFNjb3BlID0gIWhhc0hvc3Q7XG4gICAgICAgIHdoaWxlICgocmVzID0gc2VwLmV4ZWMoc2VsZWN0b3IpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IHJlc1sxXTtcbiAgICAgICAgICAgIHZhciBwYXJ0XzEgPSBzZWxlY3Rvci5zbGljZShzdGFydEluZGV4LCByZXMuaW5kZXgpLnRyaW0oKTtcbiAgICAgICAgICAgIHNob3VsZFNjb3BlID0gc2hvdWxkU2NvcGUgfHwgcGFydF8xLmluZGV4T2YoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcikgPiAtMTtcbiAgICAgICAgICAgIHZhciBzY29wZWRQYXJ0ID0gc2hvdWxkU2NvcGUgPyBfc2NvcGVTZWxlY3RvclBhcnQocGFydF8xKSA6IHBhcnRfMTtcbiAgICAgICAgICAgIHNjb3BlZFNlbGVjdG9yICs9IHNjb3BlZFBhcnQgKyBcIiBcIiArIHNlcGFyYXRvciArIFwiIFwiO1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IHNlcC5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnQgPSBzZWxlY3Rvci5zdWJzdHJpbmcoc3RhcnRJbmRleCk7XG4gICAgICAgIHNob3VsZFNjb3BlID0gc2hvdWxkU2NvcGUgfHwgcGFydC5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTE7XG4gICAgICAgIHNjb3BlZFNlbGVjdG9yICs9IHNob3VsZFNjb3BlID8gX3Njb3BlU2VsZWN0b3JQYXJ0KHBhcnQpIDogcGFydDtcbiAgICAgICAgLy8gcmVwbGFjZSB0aGUgcGxhY2Vob2xkZXJzIHdpdGggdGhlaXIgb3JpZ2luYWwgdmFsdWVzXG4gICAgICAgIHJldHVybiBzYWZlQ29udGVudC5yZXN0b3JlKHNjb3BlZFNlbGVjdG9yKTtcbiAgICB9O1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2luc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZShfY29sb25Ib3N0Q29udGV4dFJlLCBfcG9seWZpbGxIb3N0Q29udGV4dClcbiAgICAgICAgICAgIC5yZXBsYWNlKF9jb2xvbkhvc3RSZSwgX3BvbHlmaWxsSG9zdCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2hhZG93Q3NzO1xufSgpKTtcbnZhciBTYWZlU2VsZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2FmZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJzID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAvLyBSZXBsYWNlcyBhdHRyaWJ1dGUgc2VsZWN0b3JzIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAgICAvLyBUaGUgV1MgaW4gW2F0dHI9XCJ2YSBsdWVcIl0gd291bGQgb3RoZXJ3aXNlIGJlIGludGVycHJldGVkIGFzIGEgc2VsZWN0b3Igc2VwYXJhdG9yLlxuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoLyhcXFtbXlxcXV0qXFxdKS9nLCBmdW5jdGlvbiAoXywga2VlcCkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VCeSA9IFwiX19waC1cIiArIF90aGlzLmluZGV4ICsgXCJfX1wiO1xuICAgICAgICAgICAgX3RoaXMucGxhY2Vob2xkZXJzLnB1c2goa2VlcCk7XG4gICAgICAgICAgICBfdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VCeTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlcGxhY2VzIHRoZSBleHByZXNzaW9uIGluIGA6bnRoLWNoaWxkKDJuICsgMSlgIHdpdGggYSBwbGFjZWhvbGRlci5cbiAgICAgICAgLy8gV1MgYW5kIFwiK1wiIHdvdWxkIG90aGVyd2lzZSBiZSBpbnRlcnByZXRlZCBhcyBzZWxlY3RvciBzZXBhcmF0b3JzLlxuICAgICAgICB0aGlzLl9jb250ZW50ID0gc2VsZWN0b3IucmVwbGFjZSgvKDpudGgtWy1cXHddKykoXFwoW14pXStcXCkpL2csIGZ1bmN0aW9uIChfLCBwc2V1ZG8sIGV4cCkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VCeSA9IFwiX19waC1cIiArIF90aGlzLmluZGV4ICsgXCJfX1wiO1xuICAgICAgICAgICAgX3RoaXMucGxhY2Vob2xkZXJzLnB1c2goZXhwKTtcbiAgICAgICAgICAgIF90aGlzLmluZGV4Kys7XG4gICAgICAgICAgICByZXR1cm4gcHNldWRvICsgcmVwbGFjZUJ5O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgU2FmZVNlbGVjdG9yLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvX19waC0oXFxkKylfXy9nLCBmdW5jdGlvbiAocGgsIGluZGV4KSB7IHJldHVybiBfdGhpcy5wbGFjZWhvbGRlcnNbK2luZGV4XTsgfSk7XG4gICAgfTtcbiAgICBTYWZlU2VsZWN0b3IucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb250ZW50OyB9O1xuICAgIHJldHVybiBTYWZlU2VsZWN0b3I7XG59KCkpO1xudmFyIF9jc3NDb250ZW50TmV4dFNlbGVjdG9yUmUgPSAvcG9seWZpbGwtbmV4dC1zZWxlY3RvcltefV0qY29udGVudDpbXFxzXSo/KFsnXCJdKSguKj8pXFwxWztcXHNdKn0oW157XSo/KXsvZ2ltO1xudmFyIF9jc3NDb250ZW50UnVsZVJlID0gLyhwb2x5ZmlsbC1ydWxlKVtefV0qKGNvbnRlbnQ6W1xcc10qKFsnXCJdKSguKj8pXFwzKVs7XFxzXSpbXn1dKn0vZ2ltO1xudmFyIF9jc3NDb250ZW50VW5zY29wZWRSdWxlUmUgPSAvKHBvbHlmaWxsLXVuc2NvcGVkLXJ1bGUpW159XSooY29udGVudDpbXFxzXSooWydcIl0pKC4qPylcXDMpWztcXHNdKltefV0qfS9naW07XG52YXIgX3BvbHlmaWxsSG9zdCA9ICctc2hhZG93Y3NzaG9zdCc7XG4vLyBub3RlOiA6aG9zdC1jb250ZXh0IHByZS1wcm9jZXNzZWQgdG8gLXNoYWRvd2Nzc2hvc3Rjb250ZXh0LlxudmFyIF9wb2x5ZmlsbEhvc3RDb250ZXh0ID0gJy1zaGFkb3djc3Njb250ZXh0JztcbnZhciBfcGFyZW5TdWZmaXggPSAnKSg/OlxcXFwoKCcgK1xuICAgICcoPzpcXFxcKFteKShdKlxcXFwpfFteKShdKikrPycgK1xuICAgICcpXFxcXCkpPyhbXix7XSopJztcbnZhciBfY3NzQ29sb25Ib3N0UmUgPSBuZXcgUmVnRXhwKCcoJyArIF9wb2x5ZmlsbEhvc3QgKyBfcGFyZW5TdWZmaXgsICdnaW0nKTtcbnZhciBfY3NzQ29sb25Ib3N0Q29udGV4dFJlID0gbmV3IFJlZ0V4cCgnKCcgKyBfcG9seWZpbGxIb3N0Q29udGV4dCArIF9wYXJlblN1ZmZpeCwgJ2dpbScpO1xudmFyIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IgPSBfcG9seWZpbGxIb3N0ICsgJy1uby1jb21iaW5hdG9yJztcbnZhciBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUgPSAvLXNoYWRvd2Nzc2hvc3Qtbm8tY29tYmluYXRvcihbXlxcc10qKS87XG52YXIgX3NoYWRvd0RPTVNlbGVjdG9yc1JlID0gW1xuICAgIC86OnNoYWRvdy9nLFxuICAgIC86OmNvbnRlbnQvZyxcbiAgICAvLyBEZXByZWNhdGVkIHNlbGVjdG9yc1xuICAgIC9cXC9zaGFkb3ctZGVlcFxcLy9nLFxuICAgIC9cXC9zaGFkb3dcXC8vZyxcbl07XG4vLyBUaGUgZGVlcCBjb21iaW5hdG9yIGlzIGRlcHJlY2F0ZWQgaW4gdGhlIENTUyBzcGVjXG4vLyBTdXBwb3J0IGZvciBgPj4+YCwgYGRlZXBgLCBgOjpuZy1kZWVwYCBpcyB0aGVuIGFsc28gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9wdWxsLzE3Njc3XG52YXIgX3NoYWRvd0RlZXBTZWxlY3RvcnMgPSAvKD86Pj4+KXwoPzpcXC9kZWVwXFwvKXwoPzo6Om5nLWRlZXApL2c7XG52YXIgX3NlbGVjdG9yUmVTdWZmaXggPSAnKFs+XFxcXHN+K1xcWy4sezpdW1xcXFxzXFxcXFNdKik/JCc7XG52YXIgX3BvbHlmaWxsSG9zdFJlID0gLy1zaGFkb3djc3Nob3N0L2dpbTtcbnZhciBfY29sb25Ib3N0UmUgPSAvOmhvc3QvZ2ltO1xudmFyIF9jb2xvbkhvc3RDb250ZXh0UmUgPSAvOmhvc3QtY29udGV4dC9naW07XG52YXIgX2NvbW1lbnRSZSA9IC9cXC9cXCpcXHMqW1xcc1xcU10qP1xcKlxcLy9nO1xuZnVuY3Rpb24gc3RyaXBDb21tZW50cyhpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKF9jb21tZW50UmUsICcnKTtcbn1cbnZhciBfY29tbWVudFdpdGhIYXNoUmUgPSAvXFwvXFwqXFxzKiNcXHMqc291cmNlKE1hcHBpbmcpP1VSTD1bXFxzXFxTXSs/XFwqXFwvL2c7XG5mdW5jdGlvbiBleHRyYWN0Q29tbWVudHNXaXRoSGFzaChpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5tYXRjaChfY29tbWVudFdpdGhIYXNoUmUpIHx8IFtdO1xufVxudmFyIF9ydWxlUmUgPSAvKFxccyopKFteO1xce1xcfV0rPykoXFxzKikoKD86eyVCTE9DSyV9P1xccyo7Pyl8KD86XFxzKjspKS9nO1xudmFyIF9jdXJseVJlID0gLyhbe31dKS9nO1xudmFyIE9QRU5fQ1VSTFkgPSAneyc7XG52YXIgQ0xPU0VfQ1VSTFkgPSAnfSc7XG52YXIgQkxPQ0tfUExBQ0VIT0xERVIgPSAnJUJMT0NLJSc7XG52YXIgQ3NzUnVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDc3NSdWxlKHNlbGVjdG9yLCBjb250ZW50KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB9XG4gICAgcmV0dXJuIENzc1J1bGU7XG59KCkpO1xuZnVuY3Rpb24gcHJvY2Vzc1J1bGVzKGlucHV0LCBydWxlQ2FsbGJhY2spIHtcbiAgICB2YXIgaW5wdXRXaXRoRXNjYXBlZEJsb2NrcyA9IGVzY2FwZUJsb2NrcyhpbnB1dCk7XG4gICAgdmFyIG5leHRCbG9ja0luZGV4ID0gMDtcbiAgICByZXR1cm4gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5lc2NhcGVkU3RyaW5nLnJlcGxhY2UoX3J1bGVSZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxlY3RvciA9IG1bMl07XG4gICAgICAgIHZhciBjb250ZW50ID0gJyc7XG4gICAgICAgIHZhciBzdWZmaXggPSBtWzRdO1xuICAgICAgICB2YXIgY29udGVudFByZWZpeCA9ICcnO1xuICAgICAgICBpZiAoc3VmZml4ICYmIHN1ZmZpeC5zdGFydHNXaXRoKCd7JyArIEJMT0NLX1BMQUNFSE9MREVSKSkge1xuICAgICAgICAgICAgY29udGVudCA9IGlucHV0V2l0aEVzY2FwZWRCbG9ja3MuYmxvY2tzW25leHRCbG9ja0luZGV4KytdO1xuICAgICAgICAgICAgc3VmZml4ID0gc3VmZml4LnN1YnN0cmluZyhCTE9DS19QTEFDRUhPTERFUi5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgIGNvbnRlbnRQcmVmaXggPSAneyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJ1bGUgPSBydWxlQ2FsbGJhY2sobmV3IENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpKTtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBtWzFdICsgcnVsZS5zZWxlY3RvciArIG1bM10gKyBjb250ZW50UHJlZml4ICsgcnVsZS5jb250ZW50ICsgc3VmZml4O1xuICAgIH0pO1xufVxudmFyIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzKGVzY2FwZWRTdHJpbmcsIGJsb2Nrcykge1xuICAgICAgICB0aGlzLmVzY2FwZWRTdHJpbmcgPSBlc2NhcGVkU3RyaW5nO1xuICAgICAgICB0aGlzLmJsb2NrcyA9IGJsb2NrcztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzO1xufSgpKTtcbmZ1bmN0aW9uIGVzY2FwZUJsb2NrcyhpbnB1dCkge1xuICAgIHZhciBpbnB1dFBhcnRzID0gaW5wdXQuc3BsaXQoX2N1cmx5UmUpO1xuICAgIHZhciByZXN1bHRQYXJ0cyA9IFtdO1xuICAgIHZhciBlc2NhcGVkQmxvY2tzID0gW107XG4gICAgdmFyIGJyYWNrZXRDb3VudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRCbG9ja1BhcnRzID0gW107XG4gICAgZm9yICh2YXIgcGFydEluZGV4ID0gMDsgcGFydEluZGV4IDwgaW5wdXRQYXJ0cy5sZW5ndGg7IHBhcnRJbmRleCsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaW5wdXRQYXJ0c1twYXJ0SW5kZXhdO1xuICAgICAgICBpZiAocGFydCA9PSBDTE9TRV9DVVJMWSkge1xuICAgICAgICAgICAgYnJhY2tldENvdW50LS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJyYWNrZXRDb3VudCA+IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnRCbG9ja1BhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEJsb2NrUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGVzY2FwZWRCbG9ja3MucHVzaChjdXJyZW50QmxvY2tQYXJ0cy5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0UGFydHMucHVzaChCTE9DS19QTEFDRUhPTERFUik7XG4gICAgICAgICAgICAgICAgY3VycmVudEJsb2NrUGFydHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQgPT0gT1BFTl9DVVJMWSkge1xuICAgICAgICAgICAgYnJhY2tldENvdW50Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRCbG9ja1BhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZXNjYXBlZEJsb2Nrcy5wdXNoKGN1cnJlbnRCbG9ja1BhcnRzLmpvaW4oJycpKTtcbiAgICAgICAgcmVzdWx0UGFydHMucHVzaChCTE9DS19QTEFDRUhPTERFUik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3RyaW5nV2l0aEVzY2FwZWRCbG9ja3MocmVzdWx0UGFydHMuam9pbignJyksIGVzY2FwZWRCbG9ja3MpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQ09NUE9ORU5UX1ZBUklBQkxFID0gJyVDT01QJSc7XG52YXIgSE9TVF9BVFRSID0gXCJfbmdob3N0LVwiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xudmFyIENPTlRFTlRfQVRUUiA9IFwiX25nY29udGVudC1cIiArIENPTVBPTkVOVF9WQVJJQUJMRTtcbnZhciBTdHlsZXNDb21waWxlRGVwZW5kZW5jeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHlsZXNDb21waWxlRGVwZW5kZW5jeShuYW1lLCBtb2R1bGVVcmwsIHNldFZhbHVlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubW9kdWxlVXJsID0gbW9kdWxlVXJsO1xuICAgICAgICB0aGlzLnNldFZhbHVlID0gc2V0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBTdHlsZXNDb21waWxlRGVwZW5kZW5jeTtcbn0oKSk7XG52YXIgQ29tcGlsZWRTdHlsZXNoZWV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVkU3R5bGVzaGVldChvdXRwdXRDdHgsIHN0eWxlc1ZhciwgZGVwZW5kZW5jaWVzLCBpc1NoaW1tZWQsIG1ldGEpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRDdHggPSBvdXRwdXRDdHg7XG4gICAgICAgIHRoaXMuc3R5bGVzVmFyID0gc3R5bGVzVmFyO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbiAgICAgICAgdGhpcy5pc1NoaW1tZWQgPSBpc1NoaW1tZWQ7XG4gICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlZFN0eWxlc2hlZXQ7XG59KCkpO1xudmFyIFN0eWxlQ29tcGlsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVDb21waWxlcihfdXJsUmVzb2x2ZXIpIHtcbiAgICAgICAgdGhpcy5fdXJsUmVzb2x2ZXIgPSBfdXJsUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3NoYWRvd0NzcyA9IG5ldyBTaGFkb3dDc3MoKTtcbiAgICB9XG4gICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChvdXRwdXRDdHgsIGNvbXApIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gY29tcC50ZW1wbGF0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVTdHlsZXMob3V0cHV0Q3R4LCBjb21wLCBuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7XG4gICAgICAgICAgICBzdHlsZXM6IHRlbXBsYXRlLnN0eWxlcyxcbiAgICAgICAgICAgIHN0eWxlVXJsczogdGVtcGxhdGUuc3R5bGVVcmxzLFxuICAgICAgICAgICAgbW9kdWxlVXJsOiBpZGVudGlmaWVyTW9kdWxlVXJsKGNvbXAudHlwZSlcbiAgICAgICAgfSksIHRoaXMubmVlZHNTdHlsZVNoaW0oY29tcCksIHRydWUpO1xuICAgIH07XG4gICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZVN0eWxlcyA9IGZ1bmN0aW9uIChvdXRwdXRDdHgsIGNvbXAsIHN0eWxlc2hlZXQsIHNoaW0pIHtcbiAgICAgICAgaWYgKHNoaW0gPT09IHZvaWQgMCkgeyBzaGltID0gdGhpcy5uZWVkc1N0eWxlU2hpbShjb21wKTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZVN0eWxlcyhvdXRwdXRDdHgsIGNvbXAsIHN0eWxlc2hlZXQsIHNoaW0sIGZhbHNlKTtcbiAgICB9O1xuICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLm5lZWRzU3R5bGVTaGltID0gZnVuY3Rpb24gKGNvbXApIHtcbiAgICAgICAgcmV0dXJuIGNvbXAudGVtcGxhdGUuZW5jYXBzdWxhdGlvbiA9PT0gVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQ7XG4gICAgfTtcbiAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZVN0eWxlcyA9IGZ1bmN0aW9uIChvdXRwdXRDdHgsIGNvbXAsIHN0eWxlc2hlZXQsIHNoaW0sIGlzQ29tcG9uZW50U3R5bGVzaGVldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3R5bGVFeHByZXNzaW9ucyA9IHN0eWxlc2hlZXQuc3R5bGVzLm1hcChmdW5jdGlvbiAocGxhaW5TdHlsZSkgeyByZXR1cm4gbGl0ZXJhbChfdGhpcy5fc2hpbUlmTmVlZGVkKHBsYWluU3R5bGUsIHNoaW0pKTsgfSk7XG4gICAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgc3R5bGVzaGVldC5zdHlsZVVybHMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVVcmwpIHtcbiAgICAgICAgICAgIHZhciBleHBySW5kZXggPSBzdHlsZUV4cHJlc3Npb25zLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIE5vdGU6IFRoaXMgcGxhY2Vob2xkZXIgd2lsbCBiZSBmaWxsZWQgbGF0ZXIuXG4gICAgICAgICAgICBzdHlsZUV4cHJlc3Npb25zLnB1c2gobnVsbCk7XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChuZXcgU3R5bGVzQ29tcGlsZURlcGVuZGVuY3koZ2V0U3R5bGVzVmFyTmFtZShudWxsKSwgc3R5bGVVcmwsIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc3R5bGVFeHByZXNzaW9uc1tleHBySW5kZXhdID0gb3V0cHV0Q3R4LmltcG9ydEV4cHIodmFsdWUpOyB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBzdHlsZXMgdmFyaWFibGUgY29udGFpbnMgcGxhaW4gc3RyaW5ncyBhbmQgYXJyYXlzIG9mIG90aGVyIHN0eWxlcyBhcnJheXMgKHJlY3Vyc2l2ZSksXG4gICAgICAgIC8vIHNvIHdlIHNldCBpdHMgdHlwZSB0byBkeW5hbWljLlxuICAgICAgICB2YXIgc3R5bGVzVmFyID0gZ2V0U3R5bGVzVmFyTmFtZShpc0NvbXBvbmVudFN0eWxlc2hlZXQgPyBjb21wIDogbnVsbCk7XG4gICAgICAgIHZhciBzdG10ID0gdmFyaWFibGUoc3R5bGVzVmFyKVxuICAgICAgICAgICAgLnNldChsaXRlcmFsQXJyKHN0eWxlRXhwcmVzc2lvbnMsIG5ldyBBcnJheVR5cGUoRFlOQU1JQ19UWVBFLCBbVHlwZU1vZGlmaWVyLkNvbnN0XSkpKVxuICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgaXNDb21wb25lbnRTdHlsZXNoZWV0ID8gW1N0bXRNb2RpZmllci5GaW5hbF0gOiBbXG4gICAgICAgICAgICBTdG10TW9kaWZpZXIuRmluYWwsIFN0bXRNb2RpZmllci5FeHBvcnRlZFxuICAgICAgICBdKTtcbiAgICAgICAgb3V0cHV0Q3R4LnN0YXRlbWVudHMucHVzaChzdG10KTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlZFN0eWxlc2hlZXQob3V0cHV0Q3R4LCBzdHlsZXNWYXIsIGRlcGVuZGVuY2llcywgc2hpbSwgc3R5bGVzaGVldCk7XG4gICAgfTtcbiAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5fc2hpbUlmTmVlZGVkID0gZnVuY3Rpb24gKHN0eWxlLCBzaGltKSB7XG4gICAgICAgIHJldHVybiBzaGltID8gdGhpcy5fc2hhZG93Q3NzLnNoaW1Dc3NUZXh0KHN0eWxlLCBDT05URU5UX0FUVFIsIEhPU1RfQVRUUikgOiBzdHlsZTtcbiAgICB9O1xuICAgIHJldHVybiBTdHlsZUNvbXBpbGVyO1xufSgpKTtcbmZ1bmN0aW9uIGdldFN0eWxlc1Zhck5hbWUoY29tcG9uZW50KSB7XG4gICAgdmFyIHJlc3VsdCA9IFwic3R5bGVzXCI7XG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICByZXN1bHQgKz0gXCJfXCIgKyBpZGVudGlmaWVyTmFtZShjb21wb25lbnQudHlwZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSBwYXRoIGlzIGFuIG9yZGVyZWQgc2V0IG9mIGVsZW1lbnRzLiBUeXBpY2FsbHkgYSBwYXRoIGlzIHRvICBhXG4gKiBwYXJ0aWN1bGFyIG9mZnNldCBpbiBhIHNvdXJjZSBmaWxlLiBUaGUgaGVhZCBvZiB0aGUgbGlzdCBpcyB0aGUgdG9wXG4gKiBtb3N0IG5vZGUuIFRoZSB0YWlsIGlzIHRoZSBub2RlIHRoYXQgY29udGFpbnMgdGhlIG9mZnNldCBkaXJlY3RseS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgdGhlIGV4cHJlc3Npb24gYGEgKyBiICsgY2AgbWlnaHQgaGF2ZSBhbiBhc3QgdGhhdCBsb29rc1xuICogbGlrZTpcbiAqICAgICArXG4gKiAgICAvIFxcXG4gKiAgIGEgICArXG4gKiAgICAgIC8gXFxcbiAqICAgICBiICAgY1xuICpcbiAqIFRoZSBwYXRoIHRvIHRoZSBub2RlIGF0IG9mZnNldCA5IHdvdWxkIGJlIGBbJysnIGF0IDEtMTAsICcrJyBhdCA3LTEwLFxuICogJ2MnIGF0IDktMTBdYCBhbmQgdGhlIHBhdGggdGhlIG5vZGUgYXQgb2Zmc2V0IDEgd291bGQgYmVcbiAqIGBbJysnIGF0IDEtMTAsICdhJyBhdCAxLTJdYC5cbiAqL1xudmFyIEFzdFBhdGggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN0UGF0aChwYXRoLCBwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gPT09IHZvaWQgMCkgeyBwb3NpdGlvbiA9IC0xOyB9XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzdFBhdGgucHJvdG90eXBlLCBcImVtcHR5XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5wYXRoIHx8ICF0aGlzLnBhdGgubGVuZ3RoOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXN0UGF0aC5wcm90b3R5cGUsIFwiaGVhZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXRoWzBdOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXN0UGF0aC5wcm90b3R5cGUsIFwidGFpbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQXN0UGF0aC5wcm90b3R5cGUucGFyZW50T2YgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSAmJiB0aGlzLnBhdGhbdGhpcy5wYXRoLmluZGV4T2Yobm9kZSkgLSAxXTtcbiAgICB9O1xuICAgIEFzdFBhdGgucHJvdG90eXBlLmNoaWxkT2YgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdGhpcy5wYXRoW3RoaXMucGF0aC5pbmRleE9mKG5vZGUpICsgMV07IH07XG4gICAgQXN0UGF0aC5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbiAoY3Rvcikge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5wYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMucGF0aFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN0UGF0aC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChub2RlKSB7IHRoaXMucGF0aC5wdXNoKG5vZGUpOyB9O1xuICAgIEFzdFBhdGgucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGF0aC5wb3AoKTsgfTtcbiAgICByZXR1cm4gQXN0UGF0aDtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUZXh0JDMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGV4dCh2YWx1ZSwgc291cmNlU3BhbiwgaTE4bikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuaTE4biA9IGkxOG47XG4gICAgfVxuICAgIFRleHQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBUZXh0O1xufSgpKTtcbnZhciBFeHBhbnNpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwYW5zaW9uKHN3aXRjaFZhbHVlLCB0eXBlLCBjYXNlcywgc291cmNlU3Bhbiwgc3dpdGNoVmFsdWVTb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMuc3dpdGNoVmFsdWUgPSBzd2l0Y2hWYWx1ZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5jYXNlcyA9IGNhc2VzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLnN3aXRjaFZhbHVlU291cmNlU3BhbiA9IHN3aXRjaFZhbHVlU291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICB9XG4gICAgRXhwYW5zaW9uLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RXhwYW5zaW9uKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBFeHBhbnNpb247XG59KCkpO1xudmFyIEV4cGFuc2lvbkNhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwYW5zaW9uQ2FzZSh2YWx1ZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdmFsdWVTb3VyY2VTcGFuLCBleHBTb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNvdXJjZVNwYW4gPSB2YWx1ZVNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuZXhwU291cmNlU3BhbiA9IGV4cFNvdXJjZVNwYW47XG4gICAgfVxuICAgIEV4cGFuc2lvbkNhc2UucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHBhbnNpb25DYXNlKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBFeHBhbnNpb25DYXNlO1xufSgpKTtcbnZhciBBdHRyaWJ1dGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4sIGkxOG4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLnZhbHVlU3BhbiA9IHZhbHVlU3BhbjtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICB9XG4gICAgQXR0cmlidXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0QXR0cmlidXRlKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBBdHRyaWJ1dGU7XG59KCkpO1xudmFyIEVsZW1lbnQkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbGVtZW50KG5hbWUsIGF0dHJzLCBjaGlsZHJlbiwgc291cmNlU3Bhbiwgc3RhcnRTb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIGlmIChzdGFydFNvdXJjZVNwYW4gPT09IHZvaWQgMCkgeyBzdGFydFNvdXJjZVNwYW4gPSBudWxsOyB9XG4gICAgICAgIGlmIChlbmRTb3VyY2VTcGFuID09PSB2b2lkIDApIHsgZW5kU291cmNlU3BhbiA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuc3RhcnRTb3VyY2VTcGFuID0gc3RhcnRTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICBFbGVtZW50LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudCh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gRWxlbWVudDtcbn0oKSk7XG52YXIgQ29tbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21tZW50KHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgQ29tbWVudC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdENvbW1lbnQodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIENvbW1lbnQ7XG59KCkpO1xuZnVuY3Rpb24gdmlzaXRBbGwkMSh2aXNpdG9yLCBub2RlcywgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHZpc2l0ID0gdmlzaXRvci52aXNpdCA/XG4gICAgICAgIGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXQoYXN0LCBjb250ZXh0KSB8fCBhc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7IH0gOlxuICAgICAgICBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBhc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7IH07XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgIHZhciBhc3RSZXN1bHQgPSB2aXNpdChhc3QpO1xuICAgICAgICBpZiAoYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhc3RSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBSZWN1cnNpdmVWaXNpdG9yJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjdXJzaXZlVmlzaXRvcigpIHtcbiAgICB9XG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4oY29udGV4dCwgZnVuY3Rpb24gKHZpc2l0KSB7XG4gICAgICAgICAgICB2aXNpdChhc3QuYXR0cnMpO1xuICAgICAgICAgICAgdmlzaXQoYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBSZWN1cnNpdmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFJlY3Vyc2l2ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGNvbnRleHQsIGZ1bmN0aW9uICh2aXNpdCkgeyB2aXNpdChhc3QuY2FzZXMpOyB9KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBSZWN1cnNpdmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdENoaWxkcmVuID0gZnVuY3Rpb24gKGNvbnRleHQsIGNiKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gdmlzaXQoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbilcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmlzaXRBbGwkMSh0LCBjaGlsZHJlbiwgY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGNiKHZpc2l0KTtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHJlc3VsdHMpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlY3Vyc2l2ZVZpc2l0b3I7XG59KCkpO1xuZnVuY3Rpb24gc3Bhbk9mKGFzdCkge1xuICAgIHZhciBzdGFydCA9IGFzdC5zb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldDtcbiAgICB2YXIgZW5kID0gYXN0LnNvdXJjZVNwYW4uZW5kLm9mZnNldDtcbiAgICBpZiAoYXN0IGluc3RhbmNlb2YgRWxlbWVudCQxKSB7XG4gICAgICAgIGlmIChhc3QuZW5kU291cmNlU3Bhbikge1xuICAgICAgICAgICAgZW5kID0gYXN0LmVuZFNvdXJjZVNwYW4uZW5kLm9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QuY2hpbGRyZW4gJiYgYXN0LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kID0gc3Bhbk9mKGFzdC5jaGlsZHJlblthc3QuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pLmVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG59XG5mdW5jdGlvbiBmaW5kTm9kZShub2RlcywgcG9zaXRpb24pIHtcbiAgICB2YXIgcGF0aCA9IFtdO1xuICAgIHZhciB2aXNpdG9yID0gbmV3IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgc3BhbiA9IHNwYW5PZihhc3QpO1xuICAgICAgICAgICAgaWYgKHNwYW4uc3RhcnQgPD0gcG9zaXRpb24gJiYgcG9zaXRpb24gPCBzcGFuLmVuZCkge1xuICAgICAgICAgICAgICAgIHBhdGgucHVzaChhc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuaW5nIGEgdmFsdWUgaGVyZSB3aWxsIHJlc3VsdCBpbiB0aGUgY2hpbGRyZW4gYmVpbmcgc2tpcHBlZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgfShSZWN1cnNpdmVWaXNpdG9yJDEpKTtcbiAgICB2aXNpdEFsbCQxKHZpc2l0b3IsIG5vZGVzKTtcbiAgICByZXR1cm4gbmV3IEFzdFBhdGgocGF0aCwgcG9zaXRpb24pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVG9rZW5UeXBlO1xuKGZ1bmN0aW9uIChUb2tlblR5cGUpIHtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiVEFHX09QRU5fU1RBUlRcIl0gPSAwXSA9IFwiVEFHX09QRU5fU1RBUlRcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiVEFHX09QRU5fRU5EXCJdID0gMV0gPSBcIlRBR19PUEVOX0VORFwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJUQUdfT1BFTl9FTkRfVk9JRFwiXSA9IDJdID0gXCJUQUdfT1BFTl9FTkRfVk9JRFwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJUQUdfQ0xPU0VcIl0gPSAzXSA9IFwiVEFHX0NMT1NFXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIlRFWFRcIl0gPSA0XSA9IFwiVEVYVFwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJFU0NBUEFCTEVfUkFXX1RFWFRcIl0gPSA1XSA9IFwiRVNDQVBBQkxFX1JBV19URVhUXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIlJBV19URVhUXCJdID0gNl0gPSBcIlJBV19URVhUXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNPTU1FTlRfU1RBUlRcIl0gPSA3XSA9IFwiQ09NTUVOVF9TVEFSVFwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJDT01NRU5UX0VORFwiXSA9IDhdID0gXCJDT01NRU5UX0VORFwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJDREFUQV9TVEFSVFwiXSA9IDldID0gXCJDREFUQV9TVEFSVFwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJDREFUQV9FTkRcIl0gPSAxMF0gPSBcIkNEQVRBX0VORFwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJBVFRSX05BTUVcIl0gPSAxMV0gPSBcIkFUVFJfTkFNRVwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJBVFRSX1FVT1RFXCJdID0gMTJdID0gXCJBVFRSX1FVT1RFXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkFUVFJfVkFMVUVcIl0gPSAxM10gPSBcIkFUVFJfVkFMVUVcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRE9DX1RZUEVcIl0gPSAxNF0gPSBcIkRPQ19UWVBFXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVYUEFOU0lPTl9GT1JNX1NUQVJUXCJdID0gMTVdID0gXCJFWFBBTlNJT05fRk9STV9TVEFSVFwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJFWFBBTlNJT05fQ0FTRV9WQUxVRVwiXSA9IDE2XSA9IFwiRVhQQU5TSU9OX0NBU0VfVkFMVUVcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUXCJdID0gMTddID0gXCJFWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlRcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0NBU0VfRVhQX0VORFwiXSA9IDE4XSA9IFwiRVhQQU5TSU9OX0NBU0VfRVhQX0VORFwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJFWFBBTlNJT05fRk9STV9FTkRcIl0gPSAxOV0gPSBcIkVYUEFOU0lPTl9GT1JNX0VORFwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJFT0ZcIl0gPSAyMF0gPSBcIkVPRlwiO1xufSkoVG9rZW5UeXBlIHx8IChUb2tlblR5cGUgPSB7fSkpO1xudmFyIFRva2VuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRva2VuKHR5cGUsIHBhcnRzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMucGFydHMgPSBwYXJ0cztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgcmV0dXJuIFRva2VuO1xufSgpKTtcbnZhciBUb2tlbkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUb2tlbkVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRva2VuRXJyb3IoZXJyb3JNc2csIHRva2VuVHlwZSwgc3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBlcnJvck1zZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9rZW5UeXBlID0gdG9rZW5UeXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUb2tlbkVycm9yO1xufShQYXJzZUVycm9yKSk7XG52YXIgVG9rZW5pemVSZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9rZW5pemVSZXN1bHQodG9rZW5zLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gVG9rZW5pemVSZXN1bHQ7XG59KCkpO1xuZnVuY3Rpb24gdG9rZW5pemUoc291cmNlLCB1cmwsIGdldFRhZ0RlZmluaXRpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHJldHVybiBuZXcgX1Rva2VuaXplcihuZXcgUGFyc2VTb3VyY2VGaWxlKHNvdXJjZSwgdXJsKSwgZ2V0VGFnRGVmaW5pdGlvbiwgb3B0aW9ucykudG9rZW5pemUoKTtcbn1cbnZhciBfQ1JfT1JfQ1JMRl9SRUdFWFAgPSAvXFxyXFxuPy9nO1xuZnVuY3Rpb24gX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyhjaGFyQ29kZSkge1xuICAgIHZhciBjaGFyID0gY2hhckNvZGUgPT09ICRFT0YgPyAnRU9GJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgIHJldHVybiBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyIFxcXCJcIiArIGNoYXIgKyBcIlxcXCJcIjtcbn1cbmZ1bmN0aW9uIF91bmtub3duRW50aXR5RXJyb3JNc2coZW50aXR5U3JjKSB7XG4gICAgcmV0dXJuIFwiVW5rbm93biBlbnRpdHkgXFxcIlwiICsgZW50aXR5U3JjICsgXCJcXFwiIC0gdXNlIHRoZSBcXFwiJiM8ZGVjaW1hbD47XFxcIiBvciAgXFxcIiYjeDxoZXg+O1xcXCIgc3ludGF4XCI7XG59XG52YXIgX0NvbnRyb2xGbG93RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX0NvbnRyb2xGbG93RXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gX0NvbnRyb2xGbG93RXJyb3I7XG59KCkpO1xuLy8gU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1MS9zeW50YXguaHRtbCN3cml0aW5nXG52YXIgX1Rva2VuaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gX2ZpbGUgVGhlIGh0bWwgc291cmNlIGZpbGUgYmVpbmcgdG9rZW5pemVkLlxuICAgICAqIEBwYXJhbSBfZ2V0VGFnRGVmaW5pdGlvbiBBIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXRyaWV2ZSBhIHRhZyBkZWZpbml0aW9uIGZvciBhIGdpdmVuIHRhZyBuYW1lLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb2YgdGhlIHRva2VuaXphdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfVG9rZW5pemVyKF9maWxlLCBfZ2V0VGFnRGVmaW5pdGlvbiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9nZXRUYWdEZWZpbml0aW9uID0gX2dldFRhZ0RlZmluaXRpb247XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9pbkludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fdG9rZW5pemVJY3UgPSBvcHRpb25zLnRva2VuaXplRXhwYW5zaW9uRm9ybXMgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgPSBvcHRpb25zLmludGVycG9sYXRpb25Db25maWcgfHwgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRztcbiAgICAgICAgdGhpcy5fbGVhZGluZ1RyaXZpYUNvZGVQb2ludHMgPVxuICAgICAgICAgICAgb3B0aW9ucy5sZWFkaW5nVHJpdmlhQ2hhcnMgJiYgb3B0aW9ucy5sZWFkaW5nVHJpdmlhQ2hhcnMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmNvZGVQb2ludEF0KDApIHx8IDA7IH0pO1xuICAgICAgICB2YXIgcmFuZ2UgPSBvcHRpb25zLnJhbmdlIHx8IHsgZW5kUG9zOiBfZmlsZS5jb250ZW50Lmxlbmd0aCwgc3RhcnRQb3M6IDAsIHN0YXJ0TGluZTogMCwgc3RhcnRDb2w6IDAgfTtcbiAgICAgICAgdGhpcy5fY3Vyc29yID0gb3B0aW9ucy5lc2NhcGVkU3RyaW5nID8gbmV3IEVzY2FwZWRDaGFyYWN0ZXJDdXJzb3IoX2ZpbGUsIHJhbmdlKSA6XG4gICAgICAgICAgICBuZXcgUGxhaW5DaGFyYWN0ZXJDdXJzb3IoX2ZpbGUsIHJhbmdlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgICAgICAgLy8gSW4gb3JkZXIgdG8ga2VlcCB0aGUgb3JpZ2luYWwgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSwgd2UgY2FuIG5vdFxuICAgICAgICAvLyBwcmUtcHJvY2VzcyBpdC5cbiAgICAgICAgLy8gSW5zdGVhZCBDUnMgYXJlIHByb2Nlc3NlZCByaWdodCBiZWZvcmUgaW5zdGFudGlhdGluZyB0aGUgdG9rZW5zLlxuICAgICAgICByZXR1cm4gY29udGVudC5yZXBsYWNlKF9DUl9PUl9DUkxGX1JFR0VYUCwgJ1xcbicpO1xuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9jdXJzb3IucGVlaygpICE9PSAkRU9GKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTFQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEJBTkcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRMQlJBQ0tFVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ2RhdGEoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRNSU5VUykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ29tbWVudChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRG9jVHlwZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRTTEFTSCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdDbG9zZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGFnT3BlbihzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoISh0aGlzLl90b2tlbml6ZUljdSAmJiB0aGlzLl90b2tlbml6ZUV4cGFuc2lvbkZvcm0oKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuRU9GKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuaXplUmVzdWx0KG1lcmdlVGV4dFRva2Vucyh0aGlzLnRva2VucyksIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHdoZXRoZXIgYW4gSUNVIHRva2VuIGhhcyBiZWVuIGNyZWF0ZWRcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fdG9rZW5pemVFeHBhbnNpb25Gb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0V4cGFuc2lvbkZvcm1TdGFydCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lRXhwYW5zaW9uRm9ybVN0YXJ0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFeHBhbnNpb25DYXNlU3RhcnQodGhpcy5fY3Vyc29yLnBlZWsoKSkgJiYgdGhpcy5faXNJbkV4cGFuc2lvbkZvcm0oKSkge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkNhc2VTdGFydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgPT09ICRSQlJBQ0UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0luRXhwYW5zaW9uQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkNhc2VFbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0luRXhwYW5zaW9uRm9ybSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkZvcm1FbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYmVnaW5Ub2tlbiA9IGZ1bmN0aW9uICh0eXBlLCBzdGFydCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpOyB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblR5cGUgPSB0eXBlO1xuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2VuZFRva2VuID0gZnVuY3Rpb24gKHBhcnRzLCBlbmQpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpOyB9XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50VG9rZW5TdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRva2VuRXJyb3IoJ1Byb2dyYW1taW5nIGVycm9yIC0gYXR0ZW1wdGVkIHRvIGVuZCBhIHRva2VuIHdoZW4gdGhlcmUgd2FzIG5vIHN0YXJ0IHRvIHRoZSB0b2tlbicsIHRoaXMuX2N1cnJlbnRUb2tlblR5cGUsIHRoaXMuX2N1cnNvci5nZXRTcGFuKGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50VG9rZW5UeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9rZW5FcnJvcignUHJvZ3JhbW1pbmcgZXJyb3IgLSBhdHRlbXB0ZWQgdG8gZW5kIGEgdG9rZW4gd2hpY2ggaGFzIG5vIHRva2VuIHR5cGUnLCBudWxsLCB0aGlzLl9jdXJzb3IuZ2V0U3Bhbih0aGlzLl9jdXJyZW50VG9rZW5TdGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b2tlbiA9IG5ldyBUb2tlbih0aGlzLl9jdXJyZW50VG9rZW5UeXBlLCBwYXJ0cywgdGhpcy5fY3Vyc29yLmdldFNwYW4odGhpcy5fY3VycmVudFRva2VuU3RhcnQsIHRoaXMuX2xlYWRpbmdUcml2aWFDb2RlUG9pbnRzKSk7XG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5TdGFydCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblR5cGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBzcGFuKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0luRXhwYW5zaW9uRm9ybSgpKSB7XG4gICAgICAgICAgICBtc2cgKz0gXCIgKERvIHlvdSBoYXZlIGFuIHVuZXNjYXBlZCBcXFwie1xcXCIgaW4geW91ciB0ZW1wbGF0ZT8gVXNlIFxcXCJ7eyAneycgfX1cXFwiKSB0byBlc2NhcGUgaXQuKVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBUb2tlbkVycm9yKG1zZywgdGhpcy5fY3VycmVudFRva2VuVHlwZSwgc3Bhbik7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgX0NvbnRyb2xGbG93RXJyb3IoZXJyb3IpO1xuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEN1cnNvckVycm9yKSB7XG4gICAgICAgICAgICBlID0gdGhpcy5fY3JlYXRlRXJyb3IoZS5tc2csIHRoaXMuX2N1cnNvci5nZXRTcGFuKGUuY3Vyc29yKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBfQ29udHJvbEZsb3dFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0Q2hhckNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgPT09IGNoYXJDb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgICAgICBpZiAoY29tcGFyZUNoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlKHRoaXMuX2N1cnNvci5wZWVrKCksIGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXF1aXJlQ2hhckNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdENoYXJDb2RlKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9jdXJzb3IucGVlaygpKSwgdGhpcy5fY3Vyc29yLmdldFNwYW4obG9jYXRpb24pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRTdHIgPSBmdW5jdGlvbiAoY2hhcnMpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNoYXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5jaGFyc0xlZnQoKSA8IGxlbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbml0aWFsUG9zaXRpb24gPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGUoY2hhcnMuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhdHRlbXB0aW5nIHRvIHBhcnNlIHRoZSBzdHJpbmcgZmFpbHMsIHdlIHdhbnQgdG8gcmVzZXQgdGhlIHBhcnNlclxuICAgICAgICAgICAgICAgIC8vIHRvIHdoZXJlIGl0IHdhcyBiZWZvcmUgdGhlIGF0dGVtcHRcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBpbml0aWFsUG9zaXRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRTdHJDYXNlSW5zZW5zaXRpdmUgPSBmdW5jdGlvbiAoY2hhcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGVDYXNlSW5zZW5zaXRpdmUoY2hhcnMuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVxdWlyZVN0ciA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICB2YXIgbG9jYXRpb24gPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0U3RyKGNoYXJzKSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9jdXJzb3IucGVlaygpKSwgdGhpcy5fY3Vyc29yLmdldFNwYW4obG9jYXRpb24pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4gPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgIHdoaWxlICghcHJlZGljYXRlKHRoaXMuX2N1cnNvci5wZWVrKCkpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVxdWlyZUNoYXJDb2RlVW50aWxGbiA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGxlbikge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihwcmVkaWNhdGUpO1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIGlmIChlbmQuZGlmZihzdGFydCkgPCBsZW4pIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fY3Vyc29yLnBlZWsoKSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0VW50aWxDaGFyID0gZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT09IGNoYXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkQ2hhciA9IGZ1bmN0aW9uIChkZWNvZGVFbnRpdGllcykge1xuICAgICAgICBpZiAoZGVjb2RlRW50aXRpZXMgJiYgdGhpcy5fY3Vyc29yLnBlZWsoKSA9PT0gJEFNUEVSU0FORCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZUVudGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRG9uJ3QgcmVseSB1cG9uIHJlYWRpbmcgZGlyZWN0bHkgZnJvbSBgX2lucHV0YCBhcyB0aGUgYWN0dWFsIGNoYXIgdmFsdWVcbiAgICAgICAgICAgIC8vIG1heSBoYXZlIGJlZW4gZ2VuZXJhdGVkIGZyb20gYW4gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgdmFyIGNoYXIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh0aGlzLl9jdXJzb3IucGVlaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gY2hhcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2RlY29kZUVudGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEhBU0gpKSB7XG4gICAgICAgICAgICB2YXIgaXNIZXggPSB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJHgpIHx8IHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkWCk7XG4gICAgICAgICAgICB2YXIgY29kZVN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzRGlnaXRFbnRpdHlFbmQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT0gJFNFTUlDT0xPTikge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fY3Vyc29yLnBlZWsoKSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0ck51bSA9IHRoaXMuX2N1cnNvci5nZXRDaGFycyhjb2RlU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gcGFyc2VJbnQoc3RyTnVtLCBpc0hleCA/IDE2IDogMTApO1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmtub3duRW50aXR5RXJyb3JNc2codGhpcy5fY3Vyc29yLmdldENoYXJzKHN0YXJ0KSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5hbWVTdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05hbWVkRW50aXR5RW5kKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJzb3IucGVlaygpICE9ICRTRU1JQ09MT04pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBuYW1lU3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcmJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0aGlzLl9jdXJzb3IuZ2V0Q2hhcnMobmFtZVN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgICAgICB2YXIgY2hhciA9IE5BTUVEX0VOVElUSUVTW25hbWVfMV07XG4gICAgICAgICAgICBpZiAoIWNoYXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5rbm93bkVudGl0eUVycm9yTXNnKG5hbWVfMSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVSYXdUZXh0ID0gZnVuY3Rpb24gKGRlY29kZUVudGl0aWVzLCBlbmRNYXJrZXJQcmVkaWNhdGUpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihkZWNvZGVFbnRpdGllcyA/IFRva2VuVHlwZS5FU0NBUEFCTEVfUkFXX1RFWFQgOiBUb2tlblR5cGUuUkFXX1RFWFQpO1xuICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciB0YWdDbG9zZVN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgZm91bmRFbmRNYXJrZXIgPSBlbmRNYXJrZXJQcmVkaWNhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IHRhZ0Nsb3NlU3RhcnQ7XG4gICAgICAgICAgICBpZiAoZm91bmRFbmRNYXJrZXIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIoZGVjb2RlRW50aXRpZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW5kVG9rZW4oW3RoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMocGFydHMuam9pbignJykpXSk7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUNvbW1lbnQgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuQ09NTUVOVF9TVEFSVCwgc3RhcnQpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJE1JTlVTKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dChmYWxzZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2F0dGVtcHRTdHIoJy0tPicpOyB9KTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuQ09NTUVOVF9FTkQpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlU3RyKCctLT4nKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVDZGF0YSA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5DREFUQV9TVEFSVCwgc3RhcnQpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlU3RyKCdDREFUQVsnKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dChmYWxzZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2F0dGVtcHRTdHIoJ11dPicpOyB9KTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuQ0RBVEFfRU5EKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZVN0cignXV0+Jyk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRG9jVHlwZSA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5ET0NfVFlQRSwgc3RhcnQpO1xuICAgICAgICB2YXIgY29udGVudFN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRVbnRpbENoYXIoJEdUKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLl9jdXJzb3IuZ2V0Q2hhcnMoY29udGVudFN0YXJ0KTtcbiAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW2NvbnRlbnRdKTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lUHJlZml4QW5kTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5hbWVPclByZWZpeFN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIHZhciBwcmVmaXggPSAnJztcbiAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT09ICRDT0xPTiAmJiAhaXNQcmVmaXhFbmQodGhpcy5fY3Vyc29yLnBlZWsoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWVTdGFydDtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgPT09ICRDT0xPTikge1xuICAgICAgICAgICAgcHJlZml4ID0gdGhpcy5fY3Vyc29yLmdldENoYXJzKG5hbWVPclByZWZpeFN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgICAgICBuYW1lU3RhcnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hbWVTdGFydCA9IG5hbWVPclByZWZpeFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4oaXNOYW1lRW5kLCBwcmVmaXggPT09ICcnID8gMCA6IDEpO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuX2N1cnNvci5nZXRDaGFycyhuYW1lU3RhcnQpO1xuICAgICAgICByZXR1cm4gW3ByZWZpeCwgbmFtZV07XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW4gPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIHRhZ05hbWU7XG4gICAgICAgIHZhciBwcmVmaXg7XG4gICAgICAgIHZhciBvcGVuVGFnVG9rZW47XG4gICAgICAgIHZhciB0b2tlbnNCZWZvcmVUYWdPcGVuID0gdGhpcy50b2tlbnMubGVuZ3RoO1xuICAgICAgICB2YXIgaW5uZXJTdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFpc0FzY2lpTGV0dGVyKHRoaXMuX2N1cnNvci5wZWVrKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9jdXJzb3IucGVlaygpKSwgdGhpcy5fY3Vyc29yLmdldFNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wZW5UYWdUb2tlbiA9IHRoaXMuX2NvbnN1bWVUYWdPcGVuU3RhcnQoc3RhcnQpO1xuICAgICAgICAgICAgcHJlZml4ID0gb3BlblRhZ1Rva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgdGFnTmFtZSA9IG9wZW5UYWdUb2tlbi5wYXJ0c1sxXTtcbiAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9jdXJzb3IucGVlaygpICE9PSAkU0xBU0ggJiYgdGhpcy5fY3Vyc29yLnBlZWsoKSAhPT0gJEdUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUF0dHJpYnV0ZU5hbWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkRVEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUF0dHJpYnV0ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdPcGVuRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgX0NvbnRyb2xGbG93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBzdGFydCB0YWcgaXMgaW52YWxpZCAoaW5jbHVkaW5nIGludmFsaWQgXCJhdHRyaWJ1dGVzXCIpLCBhc3N1bWUgd2Ugd2FudCBhIFwiPFwiXG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gaW5uZXJTdGFydDtcbiAgICAgICAgICAgICAgICBpZiAob3BlblRhZ1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9rZW5zLmxlbmd0aCA9IHRva2Vuc0JlZm9yZVRhZ09wZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJhY2sgdG8gYmFjayB0ZXh0IHRva2VucyBhcmUgbWVyZ2VkIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5URVhULCBzdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kVG9rZW4oWyc8J10pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRlbnRUb2tlblR5cGUgPSB0aGlzLl9nZXRUYWdEZWZpbml0aW9uKHRhZ05hbWUpLmNvbnRlbnRUeXBlO1xuICAgICAgICBpZiAoY29udGVudFRva2VuVHlwZSA9PT0gVGFnQ29udGVudFR5cGUuUkFXX1RFWFQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlKHByZWZpeCwgdGFnTmFtZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnRUb2tlblR5cGUgPT09IFRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCkge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZVJhd1RleHRXaXRoVGFnQ2xvc2UocHJlZml4LCB0YWdOYW1lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlID0gZnVuY3Rpb24gKHByZWZpeCwgdGFnTmFtZSwgZGVjb2RlRW50aXRpZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRleHRUb2tlbiA9IHRoaXMuX2NvbnN1bWVSYXdUZXh0KGRlY29kZUVudGl0aWVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLl9hdHRlbXB0Q2hhckNvZGUoJExUKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIV90aGlzLl9hdHRlbXB0Q2hhckNvZGUoJFNMQVNIKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBfdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5fYXR0ZW1wdFN0ckNhc2VJbnNlbnNpdGl2ZSh0YWdOYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBfdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEdUKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlLlRBR19DTE9TRSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4oZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIGNvZGUgPT09ICRHVDsgfSwgMyk7XG4gICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7IC8vIENvbnN1bWUgdGhlIGA+YFxuICAgICAgICB0aGlzLl9lbmRUb2tlbihbcHJlZml4LCB0YWdOYW1lXSk7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW5TdGFydCA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5UQUdfT1BFTl9TVEFSVCwgc3RhcnQpO1xuICAgICAgICB2YXIgcGFydHMgPSB0aGlzLl9jb25zdW1lUHJlZml4QW5kTmFtZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kVG9rZW4ocGFydHMpO1xuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXR0ck5hbWVTdGFydCA9IHRoaXMuX2N1cnNvci5wZWVrKCk7XG4gICAgICAgIGlmIChhdHRyTmFtZVN0YXJ0ID09PSAkU1EgfHwgYXR0ck5hbWVTdGFydCA9PT0gJERRKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKGF0dHJOYW1lU3RhcnQpLCB0aGlzLl9jdXJzb3IuZ2V0U3BhbigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5BVFRSX05BTUUpO1xuICAgICAgICB2YXIgcHJlZml4QW5kTmFtZSA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKHByZWZpeEFuZE5hbWUpO1xuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fY3Vyc29yLnBlZWsoKSA9PT0gJFNRIHx8IHRoaXMuX2N1cnNvci5wZWVrKCkgPT09ICREUSkge1xuICAgICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuQVRUUl9RVU9URSk7XG4gICAgICAgICAgICB2YXIgcXVvdGVDaGFyID0gdGhpcy5fY3Vyc29yLnBlZWsoKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbU3RyaW5nLmZyb21Db2RlUG9pbnQocXVvdGVDaGFyKV0pO1xuICAgICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuQVRUUl9WQUxVRSk7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9jdXJzb3IucGVlaygpICE9PSBxdW90ZUNoYXIpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX3JlYWRDaGFyKHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gcGFydHMuam9pbignJyk7XG4gICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyh2YWx1ZSldKTtcbiAgICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlLkFUVFJfUVVPVEUpO1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtTdHJpbmcuZnJvbUNvZGVQb2ludChxdW90ZUNoYXIpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5BVFRSX1ZBTFVFKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZVN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGVVbnRpbEZuKGlzTmFtZUVuZCwgMSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2N1cnNvci5nZXRDaGFycyh2YWx1ZVN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKHZhbHVlKV0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW5FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2tlblR5cGUgPSB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJFNMQVNIKSA/IFRva2VuVHlwZS5UQUdfT1BFTl9FTkRfVk9JRCA6IFRva2VuVHlwZS5UQUdfT1BFTl9FTkQ7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4odG9rZW5UeXBlKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRHVCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGFnQ2xvc2UgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuVEFHX0NMT1NFLCBzdGFydCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdmFyIHByZWZpeEFuZE5hbWUgPSB0aGlzLl9jb25zdW1lUHJlZml4QW5kTmFtZSgpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkR1QpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihwcmVmaXhBbmROYW1lKTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uRm9ybVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5FWFBBTlNJT05fRk9STV9TVEFSVCk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTEJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucHVzaChUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fU1RBUlQpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5SQVdfVEVYVCk7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSB0aGlzLl9yZWFkVW50aWwoJENPTU1BKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW2NvbmRpdGlvbl0pO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJENPTU1BKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5SQVdfVEVYVCk7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5fcmVhZFVudGlsKCRDT01NQSk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFt0eXBlXSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkQ09NTUEpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbkNhc2VTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfVkFMVUUpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9yZWFkVW50aWwoJExCUkFDRSkudHJpbSgpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdmFsdWVdKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJExCUkFDRSk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucHVzaChUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUKTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uQ2FzZUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfRVhQX0VORCk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wb3AoKTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uRm9ybUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fRU5EKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRSQlJBQ0UpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wb3AoKTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlLlRFWFQsIHN0YXJ0KTtcbiAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnICYmIHRoaXMuX2F0dGVtcHRTdHIodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luSW50ZXJwb2xhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnICYmIHRoaXMuX2luSW50ZXJwb2xhdGlvbiAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRTdHIodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQpKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLmVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5JbnRlcnBvbGF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX3JlYWRDaGFyKHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoIXRoaXMuX2lzVGV4dEVuZCgpKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3RoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMocGFydHMuam9pbignJykpXSk7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5faXNUZXh0RW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY3Vyc29yLnBlZWsoKSA9PT0gJExUIHx8IHRoaXMuX2N1cnNvci5wZWVrKCkgPT09ICRFT0YpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90b2tlbml6ZUljdSAmJiAhdGhpcy5faW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0V4cGFuc2lvbkZvcm1TdGFydCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgb2YgYW4gZXhwYW5zaW9uIGZvcm1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJzb3IucGVlaygpID09PSAkUkJSQUNFICYmIHRoaXMuX2lzSW5FeHBhbnNpb25DYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBlbmQgb2YgYW5kIGV4cGFuc2lvbiBjYXNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlYWRVbnRpbCA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0VW50aWxDaGFyKGNoYXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY3Vyc29yLmdldENoYXJzKHN0YXJ0KTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9pc0luRXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2tbdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCAtIDFdID09PVxuICAgICAgICAgICAgICAgIFRva2VuVHlwZS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQ7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5faXNJbkV4cGFuc2lvbkZvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrW3RoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggLSAxXSA9PT1cbiAgICAgICAgICAgICAgICBUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fU1RBUlQ7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5pc0V4cGFuc2lvbkZvcm1TdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT09ICRMQlJBQ0UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgaXNJbnRlcnBvbGF0aW9uID0gdGhpcy5fYXR0ZW1wdFN0cih0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IHN0YXJ0O1xuICAgICAgICAgICAgcmV0dXJuICFpc0ludGVycG9sYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gX1Rva2VuaXplcjtcbn0oKSk7XG5mdW5jdGlvbiBpc05vdFdoaXRlc3BhY2UoY29kZSkge1xuICAgIHJldHVybiAhaXNXaGl0ZXNwYWNlKGNvZGUpIHx8IGNvZGUgPT09ICRFT0Y7XG59XG5mdW5jdGlvbiBpc05hbWVFbmQoY29kZSkge1xuICAgIHJldHVybiBpc1doaXRlc3BhY2UoY29kZSkgfHwgY29kZSA9PT0gJEdUIHx8IGNvZGUgPT09ICRTTEFTSCB8fFxuICAgICAgICBjb2RlID09PSAkU1EgfHwgY29kZSA9PT0gJERRIHx8IGNvZGUgPT09ICRFUTtcbn1cbmZ1bmN0aW9uIGlzUHJlZml4RW5kKGNvZGUpIHtcbiAgICByZXR1cm4gKGNvZGUgPCAkYSB8fCAkeiA8IGNvZGUpICYmIChjb2RlIDwgJEEgfHwgJFogPCBjb2RlKSAmJlxuICAgICAgICAoY29kZSA8ICQwIHx8IGNvZGUgPiAkOSk7XG59XG5mdW5jdGlvbiBpc0RpZ2l0RW50aXR5RW5kKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PSAkU0VNSUNPTE9OIHx8IGNvZGUgPT0gJEVPRiB8fCAhaXNBc2NpaUhleERpZ2l0KGNvZGUpO1xufVxuZnVuY3Rpb24gaXNOYW1lZEVudGl0eUVuZChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gJFNFTUlDT0xPTiB8fCBjb2RlID09ICRFT0YgfHwgIWlzQXNjaWlMZXR0ZXIoY29kZSk7XG59XG5mdW5jdGlvbiBpc0V4cGFuc2lvbkNhc2VTdGFydChwZWVrKSB7XG4gICAgcmV0dXJuIHBlZWsgPT09ICRFUSB8fCBpc0FzY2lpTGV0dGVyKHBlZWspIHx8IGlzRGlnaXQocGVlayk7XG59XG5mdW5jdGlvbiBjb21wYXJlQ2hhckNvZGVDYXNlSW5zZW5zaXRpdmUoY29kZTEsIGNvZGUyKSB7XG4gICAgcmV0dXJuIHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZTEpID09IHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZTIpO1xufVxuZnVuY3Rpb24gdG9VcHBlckNhc2VDaGFyQ29kZShjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gJGEgJiYgY29kZSA8PSAkeiA/IGNvZGUgLSAkYSArICRBIDogY29kZTtcbn1cbmZ1bmN0aW9uIG1lcmdlVGV4dFRva2VucyhzcmNUb2tlbnMpIHtcbiAgICB2YXIgZHN0VG9rZW5zID0gW107XG4gICAgdmFyIGxhc3REc3RUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNyY1Rva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG9rZW4gPSBzcmNUb2tlbnNbaV07XG4gICAgICAgIGlmIChsYXN0RHN0VG9rZW4gJiYgbGFzdERzdFRva2VuLnR5cGUgPT0gVG9rZW5UeXBlLlRFWFQgJiYgdG9rZW4udHlwZSA9PSBUb2tlblR5cGUuVEVYVCkge1xuICAgICAgICAgICAgbGFzdERzdFRva2VuLnBhcnRzWzBdICs9IHRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgbGFzdERzdFRva2VuLnNvdXJjZVNwYW4uZW5kID0gdG9rZW4uc291cmNlU3Bhbi5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYXN0RHN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIGRzdFRva2Vucy5wdXNoKGxhc3REc3RUb2tlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRzdFRva2Vucztcbn1cbnZhciBQbGFpbkNoYXJhY3RlckN1cnNvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQbGFpbkNoYXJhY3RlckN1cnNvcihmaWxlT3JDdXJzb3IsIHJhbmdlKSB7XG4gICAgICAgIGlmIChmaWxlT3JDdXJzb3IgaW5zdGFuY2VvZiBQbGFpbkNoYXJhY3RlckN1cnNvcikge1xuICAgICAgICAgICAgdGhpcy5maWxlID0gZmlsZU9yQ3Vyc29yLmZpbGU7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gZmlsZU9yQ3Vyc29yLmlucHV0O1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBmaWxlT3JDdXJzb3IuZW5kO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IF9fYXNzaWduKHt9LCBmaWxlT3JDdXJzb3Iuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvZ3JhbW1pbmcgZXJyb3I6IHRoZSByYW5nZSBhcmd1bWVudCBtdXN0IGJlIHByb3ZpZGVkIHdpdGggYSBmaWxlIGFyZ3VtZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maWxlID0gZmlsZU9yQ3Vyc29yO1xuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IGZpbGVPckN1cnNvci5jb250ZW50O1xuICAgICAgICAgICAgdGhpcy5lbmQgPSByYW5nZS5lbmRQb3M7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgICAgIHBlZWs6IC0xLFxuICAgICAgICAgICAgICAgIG9mZnNldDogcmFuZ2Uuc3RhcnRQb3MsXG4gICAgICAgICAgICAgICAgbGluZTogcmFuZ2Uuc3RhcnRMaW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogcmFuZ2Uuc3RhcnRDb2wsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIFBsYWluQ2hhcmFjdGVyQ3Vyc29yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQbGFpbkNoYXJhY3RlckN1cnNvcih0aGlzKTsgfTtcbiAgICBQbGFpbkNoYXJhY3RlckN1cnNvci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuc3RhdGUucGVlazsgfTtcbiAgICBQbGFpbkNoYXJhY3RlckN1cnNvci5wcm90b3R5cGUuY2hhcnNMZWZ0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5lbmQgLSB0aGlzLnN0YXRlLm9mZnNldDsgfTtcbiAgICBQbGFpbkNoYXJhY3RlckN1cnNvci5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChvdGhlcikgeyByZXR1cm4gdGhpcy5zdGF0ZS5vZmZzZXQgLSBvdGhlci5zdGF0ZS5vZmZzZXQ7IH07XG4gICAgUGxhaW5DaGFyYWN0ZXJDdXJzb3IucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiAoKSB7IHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuc3RhdGUpOyB9O1xuICAgIFBsYWluQ2hhcmFjdGVyQ3Vyc29yLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLnVwZGF0ZVBlZWsodGhpcy5zdGF0ZSk7IH07XG4gICAgUGxhaW5DaGFyYWN0ZXJDdXJzb3IucHJvdG90eXBlLmdldFNwYW4gPSBmdW5jdGlvbiAoc3RhcnQsIGxlYWRpbmdUcml2aWFDb2RlUG9pbnRzKSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgdGhpcztcbiAgICAgICAgaWYgKGxlYWRpbmdUcml2aWFDb2RlUG9pbnRzKSB7XG4gICAgICAgICAgICBzdGFydCA9IHN0YXJ0LmNsb25lKCk7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5kaWZmKHN0YXJ0KSA+IDAgJiYgbGVhZGluZ1RyaXZpYUNvZGVQb2ludHMuaW5kZXhPZihzdGFydC5wZWVrKCkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0LmFkdmFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlU291cmNlU3BhbihuZXcgUGFyc2VMb2NhdGlvbihzdGFydC5maWxlLCBzdGFydC5zdGF0ZS5vZmZzZXQsIHN0YXJ0LnN0YXRlLmxpbmUsIHN0YXJ0LnN0YXRlLmNvbHVtbiksIG5ldyBQYXJzZUxvY2F0aW9uKHRoaXMuZmlsZSwgdGhpcy5zdGF0ZS5vZmZzZXQsIHRoaXMuc3RhdGUubGluZSwgdGhpcy5zdGF0ZS5jb2x1bW4pKTtcbiAgICB9O1xuICAgIFBsYWluQ2hhcmFjdGVyQ3Vyc29yLnByb3RvdHlwZS5nZXRDaGFycyA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQuc3RhdGUub2Zmc2V0LCB0aGlzLnN0YXRlLm9mZnNldCk7XG4gICAgfTtcbiAgICBQbGFpbkNoYXJhY3RlckN1cnNvci5wcm90b3R5cGUuY2hhckF0ID0gZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyk7IH07XG4gICAgUGxhaW5DaGFyYWN0ZXJDdXJzb3IucHJvdG90eXBlLmFkdmFuY2VTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID49IHRoaXMuZW5kKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3Vyc29yRXJyb3IoJ1VuZXhwZWN0ZWQgY2hhcmFjdGVyIFwiRU9GXCInLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudENoYXIgPSB0aGlzLmNoYXJBdChzdGF0ZS5vZmZzZXQpO1xuICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICRMRikge1xuICAgICAgICAgICAgc3RhdGUubGluZSsrO1xuICAgICAgICAgICAgc3RhdGUuY29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNOZXdMaW5lKGN1cnJlbnRDaGFyKSkge1xuICAgICAgICAgICAgc3RhdGUuY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUub2Zmc2V0Kys7XG4gICAgICAgIHRoaXMudXBkYXRlUGVlayhzdGF0ZSk7XG4gICAgfTtcbiAgICBQbGFpbkNoYXJhY3RlckN1cnNvci5wcm90b3R5cGUudXBkYXRlUGVlayA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5wZWVrID0gc3RhdGUub2Zmc2V0ID49IHRoaXMuZW5kID8gJEVPRiA6IHRoaXMuY2hhckF0KHN0YXRlLm9mZnNldCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGxhaW5DaGFyYWN0ZXJDdXJzb3I7XG59KCkpO1xudmFyIEVzY2FwZWRDaGFyYWN0ZXJDdXJzb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVzY2FwZWRDaGFyYWN0ZXJDdXJzb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXNjYXBlZENoYXJhY3RlckN1cnNvcihmaWxlT3JDdXJzb3IsIHJhbmdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChmaWxlT3JDdXJzb3IgaW5zdGFuY2VvZiBFc2NhcGVkQ2hhcmFjdGVyQ3Vyc29yKSB7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZpbGVPckN1cnNvcikgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmludGVybmFsU3RhdGUgPSBfX2Fzc2lnbih7fSwgZmlsZU9yQ3Vyc29yLmludGVybmFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBmaWxlT3JDdXJzb3IsIHJhbmdlKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuaW50ZXJuYWxTdGF0ZSA9IF90aGlzLnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRXNjYXBlZENoYXJhY3RlckN1cnNvci5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuaW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5hZHZhbmNlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0VzY2FwZVNlcXVlbmNlKCk7XG4gICAgfTtcbiAgICBFc2NhcGVkQ2hhcmFjdGVyQ3Vyc29yLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzRXNjYXBlU2VxdWVuY2UoKTtcbiAgICB9O1xuICAgIEVzY2FwZWRDaGFyYWN0ZXJDdXJzb3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEVzY2FwZWRDaGFyYWN0ZXJDdXJzb3IodGhpcyk7IH07XG4gICAgRXNjYXBlZENoYXJhY3RlckN1cnNvci5wcm90b3R5cGUuZ2V0Q2hhcnMgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIGN1cnNvciA9IHN0YXJ0LmNsb25lKCk7XG4gICAgICAgIHZhciBjaGFycyA9ICcnO1xuICAgICAgICB3aGlsZSAoY3Vyc29yLmludGVybmFsU3RhdGUub2Zmc2V0IDwgdGhpcy5pbnRlcm5hbFN0YXRlLm9mZnNldCkge1xuICAgICAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY3Vyc29yLnBlZWsoKSk7XG4gICAgICAgICAgICBjdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIGVzY2FwZSBzZXF1ZW5jZSB0aGF0IHN0YXJ0cyBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgdGV4dC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB0byBlbnN1cmUgdGhhdCBgcGVla2AgaGFzIHRoZSB1bmVzY2FwZWQgdmFsdWUgb2YgZXNjYXBlIHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBFc2NhcGVkQ2hhcmFjdGVyQ3Vyc29yLnByb3RvdHlwZS5wcm9jZXNzRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwZWVrID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaW50ZXJuYWxTdGF0ZS5wZWVrOyB9O1xuICAgICAgICBpZiAocGVlaygpID09PSAkQkFDS1NMQVNIKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGhpdCBhbiBlc2NhcGUgc2VxdWVuY2Ugc28gd2UgbmVlZCB0aGUgaW50ZXJuYWwgc3RhdGUgdG8gYmVjb21lIGluZGVwZW5kZW50XG4gICAgICAgICAgICAvLyBvZiB0aGUgZXh0ZXJuYWwgc3RhdGUuXG4gICAgICAgICAgICB0aGlzLmludGVybmFsU3RhdGUgPSBfX2Fzc2lnbih7fSwgdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICAvLyBNb3ZlIHBhc3QgdGhlIGJhY2tzbGFzaFxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIGZvciBzdGFuZGFyZCBjb250cm9sIGNoYXIgc2VxdWVuY2VzXG4gICAgICAgICAgICBpZiAocGVlaygpID09PSAkbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9ICRMRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBlZWsoKSA9PT0gJHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSAkQ1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwZWVrKCkgPT09ICR2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gJFZUQUI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwZWVrKCkgPT09ICR0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gJFRBQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBlZWsoKSA9PT0gJGIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSAkQlNQQUNFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGVlaygpID09PSAkZikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9ICRGRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdyBjb25zaWRlciBtb3JlIGNvbXBsZXggc2VxdWVuY2VzXG4gICAgICAgICAgICBlbHNlIGlmIChwZWVrKCkgPT09ICR1KSB7XG4gICAgICAgICAgICAgICAgLy8gVW5pY29kZSBjb2RlLXBvaW50IHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTsgLy8gYWR2YW5jZSBwYXN0IHRoZSBgdWAgY2hhclxuICAgICAgICAgICAgICAgIGlmIChwZWVrKCkgPT09ICRMQlJBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFyaWFibGUgbGVuZ3RoIFVuaWNvZGUsIGUuZy4gYFxceHsxMjN9YFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpOyAvLyBhZHZhbmNlIHBhc3QgdGhlIGB7YCBjaGFyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgdmFyaWFibGUgbnVtYmVyIG9mIGhleCBkaWdpdHMgdW50aWwgd2UgaGl0IGEgYH1gIGNoYXJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpZ2l0U3RhcnQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwZWVrKCkgIT09ICRSQlJBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhfMSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9IHRoaXMuZGVjb2RlSGV4RGlnaXRzKGRpZ2l0U3RhcnQsIGxlbmd0aF8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeGVkIGxlbmd0aCBVbmljb2RlLCBlLmcuIGBcXHUxMjM0YFxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlnaXRTdGFydCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gdGhpcy5kZWNvZGVIZXhEaWdpdHMoZGlnaXRTdGFydCwgNCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGVlaygpID09PSAkeCkge1xuICAgICAgICAgICAgICAgIC8vIEhleCBjaGFyIGNvZGUsIGUuZy4gYFxceDJGYFxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7IC8vIGFkdmFuY2UgcGFzdCB0aGUgYHhgIGNoYXJcbiAgICAgICAgICAgICAgICB2YXIgZGlnaXRTdGFydCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9IHRoaXMuZGVjb2RlSGV4RGlnaXRzKGRpZ2l0U3RhcnQsIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPY3RhbERpZ2l0KHBlZWsoKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBPY3RhbCBjaGFyIGNvZGUsIGUuZy4gYFxcMDEyYCxcbiAgICAgICAgICAgICAgICB2YXIgb2N0YWwgPSAnJztcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzIgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXNPY3RhbERpZ2l0KHBlZWsoKSkgJiYgbGVuZ3RoXzIgPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBvY3RhbCArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChwZWVrKCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGhfMisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSBwYXJzZUludChvY3RhbCwgOCk7XG4gICAgICAgICAgICAgICAgLy8gQmFja3VwIG9uZSBjaGFyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gcHJldmlvdXMuaW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTmV3TGluZSh0aGlzLmludGVybmFsU3RhdGUucGVlaykpIHtcbiAgICAgICAgICAgICAgICAvLyBMaW5lIGNvbnRpbnVhdGlvbiBgXFxgIGZvbGxvd2VkIGJ5IGEgbmV3IGxpbmVcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpOyAvLyBhZHZhbmNlIG92ZXIgdGhlIG5ld2xpbmVcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5pbnRlcm5hbFN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm9uZSBvZiB0aGUgYGlmYCBibG9ja3Mgd2VyZSBleGVjdXRlZCB0aGVuIHdlIGp1c3QgaGF2ZSBhbiBlc2NhcGVkIG5vcm1hbCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlIHdlIGp1c3QsIGVmZmVjdGl2ZWx5LCBza2lwIHRoZSBiYWNrc2xhc2ggZnJvbSB0aGUgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9IHRoaXMuaW50ZXJuYWxTdGF0ZS5wZWVrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFc2NhcGVkQ2hhcmFjdGVyQ3Vyc29yLnByb3RvdHlwZS5kZWNvZGVIZXhEaWdpdHMgPSBmdW5jdGlvbiAoc3RhcnQsIGxlbmd0aCkge1xuICAgICAgICB2YXIgaGV4ID0gdGhpcy5pbnB1dC5zdWJzdHIoc3RhcnQuaW50ZXJuYWxTdGF0ZS5vZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgIHZhciBjaGFyQ29kZSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICBpZiAoIWlzTmFOKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoYXJDb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQuc3RhdGUgPSBzdGFydC5pbnRlcm5hbFN0YXRlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEN1cnNvckVycm9yKCdJbnZhbGlkIGhleGFkZWNpbWFsIGVzY2FwZSBzZXF1ZW5jZScsIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEVzY2FwZWRDaGFyYWN0ZXJDdXJzb3I7XG59KFBsYWluQ2hhcmFjdGVyQ3Vyc29yKSk7XG52YXIgQ3Vyc29yRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ3Vyc29yRXJyb3IobXNnLCBjdXJzb3IpIHtcbiAgICAgICAgdGhpcy5tc2cgPSBtc2c7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gY3Vyc29yO1xuICAgIH1cbiAgICByZXR1cm4gQ3Vyc29yRXJyb3I7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVHJlZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmVlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHJlZUVycm9yKGVsZW1lbnROYW1lLCBzcGFuLCBtc2cpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgbXNnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lbGVtZW50TmFtZSA9IGVsZW1lbnROYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRyZWVFcnJvci5jcmVhdGUgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIHNwYW4sIG1zZykge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVFcnJvcihlbGVtZW50TmFtZSwgc3BhbiwgbXNnKTtcbiAgICB9O1xuICAgIHJldHVybiBUcmVlRXJyb3I7XG59KFBhcnNlRXJyb3IpKTtcbnZhciBQYXJzZVRyZWVSZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VUcmVlUmVzdWx0KHJvb3ROb2RlcywgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMucm9vdE5vZGVzID0gcm9vdE5vZGVzO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlVHJlZVJlc3VsdDtcbn0oKSk7XG52YXIgUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlcihnZXRUYWdEZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbiA9IGdldFRhZ0RlZmluaXRpb247XG4gICAgfVxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCB1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRva2Vuc0FuZEVycm9ycyA9IHRva2VuaXplKHNvdXJjZSwgdXJsLCB0aGlzLmdldFRhZ0RlZmluaXRpb24sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgdHJlZUFuZEVycm9ycyA9IG5ldyBfVHJlZUJ1aWxkZXIodG9rZW5zQW5kRXJyb3JzLnRva2VucywgdGhpcy5nZXRUYWdEZWZpbml0aW9uKS5idWlsZCgpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdCh0cmVlQW5kRXJyb3JzLnJvb3ROb2RlcywgdG9rZW5zQW5kRXJyb3JzLmVycm9ycy5jb25jYXQodHJlZUFuZEVycm9ycy5lcnJvcnMpKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZXI7XG59KCkpO1xudmFyIF9UcmVlQnVpbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfVHJlZUJ1aWxkZXIodG9rZW5zLCBnZXRUYWdEZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICB0aGlzLmdldFRhZ0RlZmluaXRpb24gPSBnZXRUYWdEZWZpbml0aW9uO1xuICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xuICAgICAgICB0aGlzLl9yb290Tm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgfVxuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgIT09IFRva2VuVHlwZS5FT0YpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZS5UQUdfT1BFTl9TVEFSVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVTdGFydFRhZyh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUuVEFHX0NMT1NFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUVuZFRhZyh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUuQ0RBVEFfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVZvaWRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNkYXRhKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZS5DT01NRU5UX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VWb2lkRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVDb21tZW50KHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZS5URVhUIHx8IHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlLlJBV19URVhUIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUuRVNDQVBBQkxFX1JBV19URVhUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VWb2lkRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUZXh0KHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZS5FWFBBTlNJT05fRk9STV9TVEFSVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb24odGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgYWxsIG90aGVyIHRva2Vucy4uLlxuICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdCh0aGlzLl9yb290Tm9kZXMsIHRoaXMuX2Vycm9ycyk7XG4gICAgfTtcbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJldiA9IHRoaXMuX3BlZWs7XG4gICAgICAgIGlmICh0aGlzLl9pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IHRoZXJlIGlzIGFsd2F5cyBhbiBFT0YgdG9rZW4gYXQgdGhlIGVuZFxuICAgICAgICAgICAgdGhpcy5faW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wZWVrID0gdGhpcy50b2tlbnNbdGhpcy5faW5kZXhdO1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICB9O1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2FkdmFuY2VJZiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lQ2RhdGEgPSBmdW5jdGlvbiAoc3RhcnRUb2tlbikge1xuICAgICAgICB0aGlzLl9jb25zdW1lVGV4dCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICB0aGlzLl9hZHZhbmNlSWYoVG9rZW5UeXBlLkNEQVRBX0VORCk7XG4gICAgfTtcbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lQ29tbWVudCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2FkdmFuY2VJZihUb2tlblR5cGUuUkFXX1RFWFQpO1xuICAgICAgICB0aGlzLl9hZHZhbmNlSWYoVG9rZW5UeXBlLkNPTU1FTlRfRU5EKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGV4dCAhPSBudWxsID8gdGV4dC5wYXJ0c1swXS50cmltKCkgOiBudWxsO1xuICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgQ29tbWVudCh2YWx1ZSwgdG9rZW4uc291cmNlU3BhbikpO1xuICAgIH07XG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgc3dpdGNoVmFsdWUgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB2YXIgY2FzZXMgPSBbXTtcbiAgICAgICAgLy8gcmVhZCA9XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZS5FWFBBTlNJT05fQ0FTRV9WQUxVRSkge1xuICAgICAgICAgICAgdmFyIGV4cENhc2UgPSB0aGlzLl9wYXJzZUV4cGFuc2lvbkNhc2UoKTtcbiAgICAgICAgICAgIGlmICghZXhwQ2FzZSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIGVycm9yXG4gICAgICAgICAgICBjYXNlcy5wdXNoKGV4cENhc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWQgdGhlIGZpbmFsIH1cbiAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSAhPT0gVG9rZW5UeXBlLkVYUEFOU0lPTl9GT1JNX0VORCkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCB0aGlzLl9wZWVrLnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4odG9rZW4uc291cmNlU3Bhbi5zdGFydCwgdGhpcy5fcGVlay5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KG5ldyBFeHBhbnNpb24oc3dpdGNoVmFsdWUucGFydHNbMF0sIHR5cGUucGFydHNbMF0sIGNhc2VzLCBzb3VyY2VTcGFuLCBzd2l0Y2hWYWx1ZS5zb3VyY2VTcGFuKSk7XG4gICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICB9O1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX3BhcnNlRXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAvLyByZWFkIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSAhPT0gVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCB0aGlzLl9wZWVrLnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAneycuXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWQgdW50aWwgfVxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIHZhciBleHAgPSB0aGlzLl9jb2xsZWN0RXhwYW5zaW9uRXhwVG9rZW5zKHN0YXJ0KTtcbiAgICAgICAgaWYgKCFleHApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgZXhwLnB1c2gobmV3IFRva2VuKFRva2VuVHlwZS5FT0YsIFtdLCBlbmQuc291cmNlU3BhbikpO1xuICAgICAgICAvLyBwYXJzZSBldmVyeXRoaW5nIGluIGJldHdlZW4geyBhbmQgfVxuICAgICAgICB2YXIgcGFyc2VkRXhwID0gbmV3IF9UcmVlQnVpbGRlcihleHAsIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbikuYnVpbGQoKTtcbiAgICAgICAgaWYgKHBhcnNlZEV4cC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzID0gdGhpcy5fZXJyb3JzLmNvbmNhdChwYXJzZWRFeHAuZXJyb3JzKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3Bhbih2YWx1ZS5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQuc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICB2YXIgZXhwU291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnQuc291cmNlU3Bhbi5zdGFydCwgZW5kLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFeHBhbnNpb25DYXNlKHZhbHVlLnBhcnRzWzBdLCBwYXJzZWRFeHAucm9vdE5vZGVzLCBzb3VyY2VTcGFuLCB2YWx1ZS5zb3VyY2VTcGFuLCBleHBTb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbGxlY3RFeHBhbnNpb25FeHBUb2tlbnMgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIGV4cCA9IFtdO1xuICAgICAgICB2YXIgZXhwYW5zaW9uRm9ybVN0YWNrID0gW1Rva2VuVHlwZS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlRdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlLkVYUEFOU0lPTl9GT1JNX1NUQVJUIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5zaW9uRm9ybVN0YWNrLnB1c2godGhpcy5fcGVlay50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZS5FWFBBTlNJT05fQ0FTRV9FWFBfRU5EKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RPblN0YWNrKGV4cGFuc2lvbkZvcm1TdGFjaywgVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5zaW9uRm9ybVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwYW5zaW9uRm9ybVN0YWNrLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgc3RhcnQuc291cmNlU3BhbiwgXCJJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5cIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fRU5EKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RPblN0YWNrKGV4cGFuc2lvbkZvcm1TdGFjaywgVG9rZW5UeXBlLkVYUEFOU0lPTl9GT1JNX1NUQVJUKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBhbnNpb25Gb3JtU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHN0YXJ0LnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlLkVPRikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgc3RhcnQuc291cmNlU3BhbiwgXCJJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5cIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwLnB1c2godGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZVRleHQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIHRleHQgPSB0b2tlbi5wYXJ0c1swXTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCAmJiB0ZXh0WzBdID09ICdcXG4nKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50XzEgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAocGFyZW50XzEgIT0gbnVsbCAmJiBwYXJlbnRfMS5jaGlsZHJlbi5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihwYXJlbnRfMS5uYW1lKS5pZ25vcmVGaXJzdExmKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KG5ldyBUZXh0JDModGV4dCwgdG9rZW4uc291cmNlU3BhbikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jbG9zZVZvaWRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIGlmIChlbCAmJiB0aGlzLmdldFRhZ0RlZmluaXRpb24oZWwubmFtZSkuaXNWb2lkKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVTdGFydFRhZyA9IGZ1bmN0aW9uIChzdGFydFRhZ1Rva2VuKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSBzdGFydFRhZ1Rva2VuLnBhcnRzWzBdO1xuICAgICAgICB2YXIgbmFtZSA9IHN0YXJ0VGFnVG9rZW4ucGFydHNbMV07XG4gICAgICAgIHZhciBhdHRycyA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUuQVRUUl9OQU1FKSB7XG4gICAgICAgICAgICBhdHRycy5wdXNoKHRoaXMuX2NvbnN1bWVBdHRyKHRoaXMuX2FkdmFuY2UoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdWxsTmFtZSA9IHRoaXMuX2dldEVsZW1lbnRGdWxsTmFtZShwcmVmaXgsIG5hbWUsIHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKSk7XG4gICAgICAgIHZhciBzZWxmQ2xvc2luZyA9IGZhbHNlO1xuICAgICAgICAvLyBOb3RlOiBUaGVyZSBjb3VsZCBoYXZlIGJlZW4gYSB0b2tlbml6ZXIgZXJyb3JcbiAgICAgICAgLy8gc28gdGhhdCB3ZSBkb24ndCBnZXQgYSB0b2tlbiBmb3IgdGhlIGVuZCB0YWcuLi5cbiAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlLlRBR19PUEVOX0VORF9WT0lEKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICBzZWxmQ2xvc2luZyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgdGFnRGVmID0gdGhpcy5nZXRUYWdEZWZpbml0aW9uKGZ1bGxOYW1lKTtcbiAgICAgICAgICAgIGlmICghKHRhZ0RlZi5jYW5TZWxmQ2xvc2UgfHwgZ2V0TnNQcmVmaXgoZnVsbE5hbWUpICE9PSBudWxsIHx8IHRhZ0RlZi5pc1ZvaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShmdWxsTmFtZSwgc3RhcnRUYWdUb2tlbi5zb3VyY2VTcGFuLCBcIk9ubHkgdm9pZCBhbmQgZm9yZWlnbiBlbGVtZW50cyBjYW4gYmUgc2VsZiBjbG9zZWQgXFxcIlwiICsgc3RhcnRUYWdUb2tlbi5wYXJ0c1sxXSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUuVEFHX09QRU5fRU5EKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICBzZWxmQ2xvc2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLl9wZWVrLnNvdXJjZVNwYW4uc3RhcnQ7XG4gICAgICAgIHZhciBzcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydFRhZ1Rva2VuLnNvdXJjZVNwYW4uc3RhcnQsIGVuZCk7XG4gICAgICAgIHZhciBlbCA9IG5ldyBFbGVtZW50JDEoZnVsbE5hbWUsIGF0dHJzLCBbXSwgc3Bhbiwgc3BhbiwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fcHVzaEVsZW1lbnQoZWwpO1xuICAgICAgICBpZiAoc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcEVsZW1lbnQoZnVsbE5hbWUpO1xuICAgICAgICAgICAgZWwuZW5kU291cmNlU3BhbiA9IHNwYW47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX3B1c2hFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBwYXJlbnRFbCA9IHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKHBhcmVudEVsICYmIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihwYXJlbnRFbC5uYW1lKS5pc0Nsb3NlZEJ5Q2hpbGQoZWwubmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChlbCk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5wdXNoKGVsKTtcbiAgICB9O1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVFbmRUYWcgPSBmdW5jdGlvbiAoZW5kVGFnVG9rZW4pIHtcbiAgICAgICAgdmFyIGZ1bGxOYW1lID0gdGhpcy5fZ2V0RWxlbWVudEZ1bGxOYW1lKGVuZFRhZ1Rva2VuLnBhcnRzWzBdLCBlbmRUYWdUb2tlbi5wYXJ0c1sxXSwgdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpKTtcbiAgICAgICAgaWYgKHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpLmVuZFNvdXJjZVNwYW4gPSBlbmRUYWdUb2tlbi5zb3VyY2VTcGFuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdldFRhZ0RlZmluaXRpb24oZnVsbE5hbWUpLmlzVm9pZCkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShmdWxsTmFtZSwgZW5kVGFnVG9rZW4uc291cmNlU3BhbiwgXCJWb2lkIGVsZW1lbnRzIGRvIG5vdCBoYXZlIGVuZCB0YWdzIFxcXCJcIiArIGVuZFRhZ1Rva2VuLnBhcnRzWzFdICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5fcG9wRWxlbWVudChmdWxsTmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBlcnJNc2cgPSBcIlVuZXhwZWN0ZWQgY2xvc2luZyB0YWcgXFxcIlwiICsgZnVsbE5hbWUgKyBcIlxcXCIuIEl0IG1heSBoYXBwZW4gd2hlbiB0aGUgdGFnIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ5IGFub3RoZXIgdGFnLiBGb3IgbW9yZSBpbmZvIHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjY2xvc2luZy1lbGVtZW50cy10aGF0LWhhdmUtaW1wbGllZC1lbmQtdGFnc1wiO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShmdWxsTmFtZSwgZW5kVGFnVG9rZW4uc291cmNlU3BhbiwgZXJyTXNnKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX3BvcEVsZW1lbnQgPSBmdW5jdGlvbiAoZnVsbE5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgc3RhY2tJbmRleCA9IHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxOyBzdGFja0luZGV4ID49IDA7IHN0YWNrSW5kZXgtLSkge1xuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5fZWxlbWVudFN0YWNrW3N0YWNrSW5kZXhdO1xuICAgICAgICAgICAgaWYgKGVsLm5hbWUgPT0gZnVsbE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2suc3BsaWNlKHN0YWNrSW5kZXgsIHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSBzdGFja0luZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRUYWdEZWZpbml0aW9uKGVsLm5hbWUpLmNsb3NlZEJ5UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVBdHRyID0gZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgIHZhciBmdWxsTmFtZSA9IG1lcmdlTnNBbmROYW1lKGF0dHJOYW1lLnBhcnRzWzBdLCBhdHRyTmFtZS5wYXJ0c1sxXSk7XG4gICAgICAgIHZhciBlbmQgPSBhdHRyTmFtZS5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgdmFyIHZhbHVlID0gJyc7XG4gICAgICAgIHZhciB2YWx1ZVNwYW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZS5BVFRSX1FVT1RFKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlLkFUVFJfVkFMVUUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZVRva2VuID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgZW5kID0gdmFsdWVUb2tlbi5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgICAgIHZhbHVlU3BhbiA9IHZhbHVlVG9rZW4uc291cmNlU3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUuQVRUUl9RVU9URSkge1xuICAgICAgICAgICAgdmFyIHF1b3RlVG9rZW4gPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICBlbmQgPSBxdW90ZVRva2VuLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlKGZ1bGxOYW1lLCB2YWx1ZSwgbmV3IFBhcnNlU291cmNlU3BhbihhdHRyTmFtZS5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQpLCB2YWx1ZVNwYW4pO1xuICAgIH07XG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fZ2V0UGFyZW50RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggPiAwID8gdGhpcy5fZWxlbWVudFN0YWNrW3RoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgaW4gdGhlIERPTSBhbmQgdGhlIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIGA8bmctY29udGFpbmVyPmAgZWxlbWVudHMgYXJlIHNraXBwZWQgYXMgdGhleSBhcmUgbm90IHJlbmRlcmVkIGFzIERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldFBhcmVudEVsZW1lbnRTa2lwcGluZ0NvbnRhaW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoIWlzTmdDb250YWluZXIodGhpcy5fZWxlbWVudFN0YWNrW2ldLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcGFyZW50OiB0aGlzLl9lbGVtZW50U3RhY2tbaV0sIGNvbnRhaW5lcjogY29udGFpbmVyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLl9lbGVtZW50U3RhY2tbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcGFyZW50OiBudWxsLCBjb250YWluZXI6IGNvbnRhaW5lciB9O1xuICAgIH07XG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fYWRkVG9QYXJlbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpO1xuICAgICAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcm9vdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5vZGUgYmV0d2VlbiB0aGUgcGFyZW50IGFuZCB0aGUgY29udGFpbmVyLlxuICAgICAqIFdoZW4gbm8gY29udGFpbmVyIGlzIGdpdmVuLCB0aGUgbm9kZSBpcyBhcHBlbmRlZCBhcyBhIGNoaWxkIG9mIHRoZSBwYXJlbnQuXG4gICAgICogQWxzbyB1cGRhdGVzIHRoZSBlbGVtZW50IHN0YWNrIGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5faW5zZXJ0QmVmb3JlQ29udGFpbmVyID0gZnVuY3Rpb24gKHBhcmVudCwgY29udGFpbmVyLCBub2RlKSB7XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChub2RlKTtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIGNvbnRhaW5lciB3aXRoIHRoZSBuZXcgbm9kZSBpbiB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbltpbmRleF0gPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goY29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5zcGxpY2UodGhpcy5fZWxlbWVudFN0YWNrLmluZGV4T2YoY29udGFpbmVyKSwgMCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldEVsZW1lbnRGdWxsTmFtZSA9IGZ1bmN0aW9uIChwcmVmaXgsIGxvY2FsTmFtZSwgcGFyZW50RWxlbWVudCkge1xuICAgICAgICBpZiAocHJlZml4ID09PSAnJykge1xuICAgICAgICAgICAgcHJlZml4ID0gdGhpcy5nZXRUYWdEZWZpbml0aW9uKGxvY2FsTmFtZSkuaW1wbGljaXROYW1lc3BhY2VQcmVmaXggfHwgJyc7XG4gICAgICAgICAgICBpZiAocHJlZml4ID09PSAnJyAmJiBwYXJlbnRFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBnZXROc1ByZWZpeChwYXJlbnRFbGVtZW50Lm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZU5zQW5kTmFtZShwcmVmaXgsIGxvY2FsTmFtZSk7XG4gICAgfTtcbiAgICByZXR1cm4gX1RyZWVCdWlsZGVyO1xufSgpKTtcbmZ1bmN0aW9uIGxhc3RPblN0YWNrKHN0YWNrLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIHN0YWNrLmxlbmd0aCA+IDAgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBIdG1sUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIdG1sUGFyc2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEh0bWxQYXJzZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBnZXRIdG1sVGFnRGVmaW5pdGlvbikgfHwgdGhpcztcbiAgICB9XG4gICAgSHRtbFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCB1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucGFyc2UuY2FsbCh0aGlzLCBzb3VyY2UsIHVybCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbFBhcnNlcjtcbn0oUGFyc2VyKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBQUkVTRVJWRV9XU19BVFRSX05BTUUgPSAnbmdQcmVzZXJ2ZVdoaXRlc3BhY2VzJztcbnZhciBTS0lQX1dTX1RSSU1fVEFHUyA9IG5ldyBTZXQoWydwcmUnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAnc2NyaXB0JywgJ3N0eWxlJ10pO1xuLy8gRXF1aXZhbGVudCB0byBcXHMgd2l0aCBcXHUwMGEwIChub24tYnJlYWtpbmcgc3BhY2UpIGV4Y2x1ZGVkLlxuLy8gQmFzZWQgb24gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwXG52YXIgV1NfQ0hBUlMgPSAnIFxcZlxcblxcclxcdFxcdlxcdTE2ODBcXHUxODBlXFx1MjAwMC1cXHUyMDBhXFx1MjAyOFxcdTIwMjlcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmJztcbnZhciBOT19XU19SRUdFWFAgPSBuZXcgUmVnRXhwKFwiW15cIiArIFdTX0NIQVJTICsgXCJdXCIpO1xudmFyIFdTX1JFUExBQ0VfUkVHRVhQID0gbmV3IFJlZ0V4cChcIltcIiArIFdTX0NIQVJTICsgXCJdezIsfVwiLCAnZycpO1xuZnVuY3Rpb24gaGFzUHJlc2VydmVXaGl0ZXNwYWNlc0F0dHIoYXR0cnMpIHtcbiAgICByZXR1cm4gYXR0cnMuc29tZShmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSBQUkVTRVJWRV9XU19BVFRSX05BTUU7IH0pO1xufVxuLyoqXG4gKiBBbmd1bGFyIERhcnQgaW50cm9kdWNlZCAmbmdzcDsgYXMgYSBwbGFjZWhvbGRlciBmb3Igbm9uLXJlbW92YWJsZSBzcGFjZSwgc2VlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2RhcnQtbGFuZy9hbmd1bGFyL2Jsb2IvMGJiNjExMzg3ZDI5ZDY1YjVhZjdmOWQyNTE1YWI1NzFmZDNmYmVlNC9fdGVzdHMvdGVzdC9jb21waWxlci9wcmVzZXJ2ZV93aGl0ZXNwYWNlX3Rlc3QuZGFydCNMMjUtTDMyXG4gKiBJbiBBbmd1bGFyIERhcnQgJm5nc3A7IGlzIGNvbnZlcnRlZCB0byB0aGUgMHhFNTAwIFBVQSAoUHJpdmF0ZSBVc2UgQXJlYXMpIHVuaWNvZGUgY2hhcmFjdGVyXG4gKiBhbmQgbGF0ZXIgb24gcmVwbGFjZWQgYnkgYSBzcGFjZS4gV2UgYXJlIHJlLWltcGxlbWVudGluZyB0aGUgc2FtZSBpZGVhIGhlcmUuXG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2VOZ3NwKHZhbHVlKSB7XG4gICAgLy8gbGV4ZXIgaXMgcmVwbGFjaW5nIHRoZSAmbmdzcDsgcHNldWRvLWVudGl0eSB3aXRoIE5HU1BfVU5JQ09ERVxuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAoTkdTUF9VTklDT0RFLCAnZycpLCAnICcpO1xufVxuLyoqXG4gKiBUaGlzIHZpc2l0b3IgY2FuIHdhbGsgSFRNTCBwYXJzZSB0cmVlIGFuZCByZW1vdmUgLyB0cmltIHRleHQgbm9kZXMgdXNpbmcgdGhlIGZvbGxvd2luZyBydWxlczpcbiAqIC0gY29uc2lkZXIgc3BhY2VzLCB0YWJzIGFuZCBuZXcgbGluZXMgYXMgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzO1xuICogLSBkcm9wIHRleHQgbm9kZXMgY29uc2lzdGluZyBvZiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgb25seTtcbiAqIC0gZm9yIGFsbCBvdGhlciB0ZXh0IG5vZGVzIHJlcGxhY2UgY29uc2VjdXRpdmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHdpdGggb25lIHNwYWNlO1xuICogLSBjb252ZXJ0ICZuZ3NwOyBwc2V1ZG8tZW50aXR5IHRvIGEgc2luZ2xlIHNwYWNlO1xuICpcbiAqIFJlbW92YWwgYW5kIHRyaW1taW5nIG9mIHdoaXRlc3BhY2VzIGhhdmUgcG9zaXRpdmUgcGVyZm9ybWFuY2UgaW1wYWN0IChsZXNzIGNvZGUgdG8gZ2VuZXJhdGVcbiAqIHdoaWxlIGNvbXBpbGluZyB0ZW1wbGF0ZXMsIGZhc3RlciB2aWV3IGNyZWF0aW9uKS4gQXQgdGhlIHNhbWUgdGltZSBpdCBjYW4gYmUgXCJkZXN0cnVjdGl2ZVwiXG4gKiBpbiBzb21lIGNhc2VzICh3aGl0ZXNwYWNlcyBjYW4gaW5mbHVlbmNlIGxheW91dCkuIEJlY2F1c2Ugb2YgdGhlIHBvdGVudGlhbCBvZiBicmVha2luZyBsYXlvdXRcbiAqIHRoaXMgdmlzaXRvciBpcyBub3QgYWN0aXZhdGVkIGJ5IGRlZmF1bHQgaW4gQW5ndWxhciA1IGFuZCBwZW9wbGUgbmVlZCB0byBleHBsaWNpdGx5IG9wdC1pbiBmb3JcbiAqIHdoaXRlc3BhY2UgcmVtb3ZhbC4gVGhlIGRlZmF1bHQgb3B0aW9uIGZvciB3aGl0ZXNwYWNlIHJlbW92YWwgd2lsbCBiZSByZXZpc2l0ZWQgaW4gQW5ndWxhciA2XG4gKiBhbmQgbWlnaHQgYmUgY2hhbmdlZCB0byBcIm9uXCIgYnkgZGVmYXVsdC5cbiAqL1xudmFyIFdoaXRlc3BhY2VWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdoaXRlc3BhY2VWaXNpdG9yKCkge1xuICAgIH1cbiAgICBXaGl0ZXNwYWNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKFNLSVBfV1NfVFJJTV9UQUdTLmhhcyhlbGVtZW50Lm5hbWUpIHx8IGhhc1ByZXNlcnZlV2hpdGVzcGFjZXNBdHRyKGVsZW1lbnQuYXR0cnMpKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBkZXNjZW50IGludG8gZWxlbWVudHMgd2hlcmUgd2UgbmVlZCB0byBwcmVzZXJ2ZSB3aGl0ZXNwYWNlc1xuICAgICAgICAgICAgLy8gYnV0IHN0aWxsIHZpc2l0IGFsbCBhdHRyaWJ1dGVzIHRvIGVsaW1pbmF0ZSBvbmUgdXNlZCBhcyBhIG1hcmtldCB0byBwcmVzZXJ2ZSBXU1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50JDEoZWxlbWVudC5uYW1lLCB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQuYXR0cnMpLCBlbGVtZW50LmNoaWxkcmVuLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4sIGVsZW1lbnQuaTE4bik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50JDEoZWxlbWVudC5uYW1lLCBlbGVtZW50LmF0dHJzLCB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4pLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4sIGVsZW1lbnQuaTE4bik7XG4gICAgfTtcbiAgICBXaGl0ZXNwYWNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGUubmFtZSAhPT0gUFJFU0VSVkVfV1NfQVRUUl9OQU1FID8gYXR0cmlidXRlIDogbnVsbDtcbiAgICB9O1xuICAgIFdoaXRlc3BhY2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkge1xuICAgICAgICB2YXIgaXNOb3RCbGFuayA9IHRleHQudmFsdWUubWF0Y2goTk9fV1NfUkVHRVhQKTtcbiAgICAgICAgaWYgKGlzTm90QmxhbmspIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dCQzKHJlcGxhY2VOZ3NwKHRleHQudmFsdWUpLnJlcGxhY2UoV1NfUkVQTEFDRV9SRUdFWFAsICcgJyksIHRleHQuc291cmNlU3BhbiwgdGV4dC5pMThuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFdoaXRlc3BhY2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyByZXR1cm4gY29tbWVudDsgfTtcbiAgICBXaGl0ZXNwYWNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoZXhwYW5zaW9uLCBjb250ZXh0KSB7IHJldHVybiBleHBhbnNpb247IH07XG4gICAgV2hpdGVzcGFjZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7IHJldHVybiBleHBhbnNpb25DYXNlOyB9O1xuICAgIHJldHVybiBXaGl0ZXNwYWNlVmlzaXRvcjtcbn0oKSk7XG5mdW5jdGlvbiByZW1vdmVXaGl0ZXNwYWNlcyhodG1sQXN0V2l0aEVycm9ycykge1xuICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHZpc2l0QWxsJDEobmV3IFdoaXRlc3BhY2VWaXNpdG9yKCksIGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2RlcyksIGh0bWxBc3RXaXRoRXJyb3JzLmVycm9ycyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIGh0dHA6Ly9jbGRyLnVuaWNvZGUub3JnL2luZGV4L2NsZHItc3BlYy9wbHVyYWwtcnVsZXNcbnZhciBQTFVSQUxfQ0FTRVMgPSBbJ3plcm8nLCAnb25lJywgJ3R3bycsICdmZXcnLCAnbWFueScsICdvdGhlciddO1xuLyoqXG4gKiBFeHBhbmRzIHNwZWNpYWwgZm9ybXMgaW50byBlbGVtZW50cy5cbiAqXG4gKiBGb3IgZXhhbXBsZSxcbiAqXG4gKiBgYGBcbiAqIHsgbWVzc2FnZXMubGVuZ3RoLCBwbHVyYWwsXG4gKiAgID0wIHt6ZXJvfVxuICogICA9MSB7b25lfVxuICogICBvdGhlciB7bW9yZSB0aGFuIG9uZX1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIHdpbGwgYmUgZXhwYW5kZWQgaW50b1xuICpcbiAqIGBgYFxuICogPG5nLWNvbnRhaW5lciBbbmdQbHVyYWxdPVwibWVzc2FnZXMubGVuZ3RoXCI+XG4gKiAgIDxuZy10ZW1wbGF0ZSBuZ1BsdXJhbENhc2U9XCI9MFwiPnplcm88L25nLXRlbXBsYXRlPlxuICogICA8bmctdGVtcGxhdGUgbmdQbHVyYWxDYXNlPVwiPTFcIj5vbmU8L25nLXRlbXBsYXRlPlxuICogICA8bmctdGVtcGxhdGUgbmdQbHVyYWxDYXNlPVwib3RoZXJcIj5tb3JlIHRoYW4gb25lPC9uZy10ZW1wbGF0ZT5cbiAqIDwvbmctY29udGFpbmVyPlxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZE5vZGVzKG5vZGVzKSB7XG4gICAgdmFyIGV4cGFuZGVyID0gbmV3IF9FeHBhbmRlcigpO1xuICAgIHJldHVybiBuZXcgRXhwYW5zaW9uUmVzdWx0KHZpc2l0QWxsJDEoZXhwYW5kZXIsIG5vZGVzKSwgZXhwYW5kZXIuaXNFeHBhbmRlZCwgZXhwYW5kZXIuZXJyb3JzKTtcbn1cbnZhciBFeHBhbnNpb25SZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwYW5zaW9uUmVzdWx0KG5vZGVzLCBleHBhbmRlZCwgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IGV4cGFuZGVkO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG4gICAgcmV0dXJuIEV4cGFuc2lvblJlc3VsdDtcbn0oKSk7XG52YXIgRXhwYW5zaW9uRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4cGFuc2lvbkVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4cGFuc2lvbkVycm9yKHNwYW4sIGVycm9yTXNnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBlcnJvck1zZykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEV4cGFuc2lvbkVycm9yO1xufShQYXJzZUVycm9yKSk7XG4vKipcbiAqIEV4cGFuZCBleHBhbnNpb24gZm9ybXMgKHBsdXJhbCwgc2VsZWN0KSB0byBkaXJlY3RpdmVzXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBfRXhwYW5kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX0V4cGFuZGVyKCkge1xuICAgICAgICB0aGlzLmlzRXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICB9XG4gICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQkMShlbGVtZW50Lm5hbWUsIGVsZW1lbnQuYXR0cnMsIHZpc2l0QWxsJDEodGhpcywgZWxlbWVudC5jaGlsZHJlbiksIGVsZW1lbnQuc291cmNlU3BhbiwgZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGVsZW1lbnQuZW5kU291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkgeyByZXR1cm4gYXR0cmlidXRlOyB9O1xuICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIHRleHQ7IH07XG4gICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyByZXR1cm4gY29tbWVudDsgfTtcbiAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmlzRXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gaWN1LnR5cGUgPT0gJ3BsdXJhbCcgPyBfZXhwYW5kUGx1cmFsRm9ybShpY3UsIHRoaXMuZXJyb3JzKSA6XG4gICAgICAgICAgICBfZXhwYW5kRGVmYXVsdEZvcm0oaWN1LCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChpY3VDYXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBiZSByZWFjaGVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gX0V4cGFuZGVyO1xufSgpKTtcbi8vIFBsdXJhbCBmb3JtcyBhcmUgZXhwYW5kZWQgdG8gYE5nUGx1cmFsYCBhbmQgYE5nUGx1cmFsQ2FzZWBzXG5mdW5jdGlvbiBfZXhwYW5kUGx1cmFsRm9ybShhc3QsIGVycm9ycykge1xuICAgIHZhciBjaGlsZHJlbiA9IGFzdC5jYXNlcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKFBMVVJBTF9DQVNFUy5pbmRleE9mKGMudmFsdWUpID09IC0xICYmICFjLnZhbHVlLm1hdGNoKC9ePVxcZCskLykpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBFeHBhbnNpb25FcnJvcihjLnZhbHVlU291cmNlU3BhbiwgXCJQbHVyYWwgY2FzZXMgc2hvdWxkIGJlIFxcXCI9PG51bWJlcj5cXFwiIG9yIG9uZSBvZiBcIiArIFBMVVJBTF9DQVNFUy5qb2luKFwiLCBcIikpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhwYW5zaW9uUmVzdWx0ID0gZXhwYW5kTm9kZXMoYy5leHByZXNzaW9uKTtcbiAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBfX3NwcmVhZChleHBhbnNpb25SZXN1bHQuZXJyb3JzKSk7XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudCQxKFwibmctdGVtcGxhdGVcIiwgW25ldyBBdHRyaWJ1dGUoJ25nUGx1cmFsQ2FzZScsIFwiXCIgKyBjLnZhbHVlLCBjLnZhbHVlU291cmNlU3BhbildLCBleHBhbnNpb25SZXN1bHQubm9kZXMsIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4pO1xuICAgIH0pO1xuICAgIHZhciBzd2l0Y2hBdHRyID0gbmV3IEF0dHJpYnV0ZSgnW25nUGx1cmFsXScsIGFzdC5zd2l0Y2hWYWx1ZSwgYXN0LnN3aXRjaFZhbHVlU291cmNlU3Bhbik7XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50JDEoJ25nLWNvbnRhaW5lcicsIFtzd2l0Y2hBdHRyXSwgY2hpbGRyZW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4pO1xufVxuLy8gSUNVIG1lc3NhZ2VzIChleGNsdWRpbmcgcGx1cmFsIGZvcm0pIGFyZSBleHBhbmRlZCB0byBgTmdTd2l0Y2hgICBhbmQgYE5nU3dpdGNoQ2FzZWBzXG5mdW5jdGlvbiBfZXhwYW5kRGVmYXVsdEZvcm0oYXN0LCBlcnJvcnMpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBhc3QuY2FzZXMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBleHBhbnNpb25SZXN1bHQgPSBleHBhbmROb2RlcyhjLmV4cHJlc3Npb24pO1xuICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIF9fc3ByZWFkKGV4cGFuc2lvblJlc3VsdC5lcnJvcnMpKTtcbiAgICAgICAgaWYgKGMudmFsdWUgPT09ICdvdGhlcicpIHtcbiAgICAgICAgICAgIC8vIG90aGVyIGlzIHRoZSBkZWZhdWx0IGNhc2Ugd2hlbiBubyB2YWx1ZXMgbWF0Y2hcbiAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudCQxKFwibmctdGVtcGxhdGVcIiwgW25ldyBBdHRyaWJ1dGUoJ25nU3dpdGNoRGVmYXVsdCcsICcnLCBjLnZhbHVlU291cmNlU3BhbildLCBleHBhbnNpb25SZXN1bHQubm9kZXMsIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudCQxKFwibmctdGVtcGxhdGVcIiwgW25ldyBBdHRyaWJ1dGUoJ25nU3dpdGNoQ2FzZScsIFwiXCIgKyBjLnZhbHVlLCBjLnZhbHVlU291cmNlU3BhbildLCBleHBhbnNpb25SZXN1bHQubm9kZXMsIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4pO1xuICAgIH0pO1xuICAgIHZhciBzd2l0Y2hBdHRyID0gbmV3IEF0dHJpYnV0ZSgnW25nU3dpdGNoXScsIGFzdC5zd2l0Y2hWYWx1ZSwgYXN0LnN3aXRjaFZhbHVlU291cmNlU3Bhbik7XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50JDEoJ25nLWNvbnRhaW5lcicsIFtzd2l0Y2hBdHRyXSwgY2hpbGRyZW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX2E7XG4vKipcbiAqIEEgc2VnbWVudCBvZiB0ZXh0IHdpdGhpbiB0aGUgdGVtcGxhdGUuXG4gKi9cbnZhciBUZXh0QXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHRBc3QodmFsdWUsIG5nQ29udGVudEluZGV4LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBUZXh0QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gVGV4dEFzdDtcbn0oKSk7XG4vKipcbiAqIEEgYm91bmQgZXhwcmVzc2lvbiB3aXRoaW4gdGhlIHRleHQgb2YgYSB0ZW1wbGF0ZS5cbiAqL1xudmFyIEJvdW5kVGV4dEFzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCb3VuZFRleHRBc3QodmFsdWUsIG5nQ29udGVudEluZGV4LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBCb3VuZFRleHRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCb3VuZFRleHQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQm91bmRUZXh0QXN0O1xufSgpKTtcbi8qKlxuICogQSBwbGFpbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudC5cbiAqL1xudmFyIEF0dHJBc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXR0ckFzdChuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIEF0dHJBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRBdHRyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBBdHRyQXN0O1xufSgpKTtcbnZhciBCb3VuZFByb3BlcnR5TWFwcGluZyA9IChfYSA9IHt9LFxuICAgIF9hWzQgLyogQW5pbWF0aW9uICovXSA9IDQgLyogQW5pbWF0aW9uICovLFxuICAgIF9hWzEgLyogQXR0cmlidXRlICovXSA9IDEgLyogQXR0cmlidXRlICovLFxuICAgIF9hWzIgLyogQ2xhc3MgKi9dID0gMiAvKiBDbGFzcyAqLyxcbiAgICBfYVswIC8qIFByb3BlcnR5ICovXSA9IDAgLyogUHJvcGVydHkgKi8sXG4gICAgX2FbMyAvKiBTdHlsZSAqL10gPSAzIC8qIFN0eWxlICovLFxuICAgIF9hKTtcbi8qKlxuICogQSBiaW5kaW5nIGZvciBhbiBlbGVtZW50IHByb3BlcnR5IChlLmcuIGBbcHJvcGVydHldPVwiZXhwcmVzc2lvblwiYCkgb3IgYW4gYW5pbWF0aW9uIHRyaWdnZXIgKGUuZy5cbiAqIGBbQHRyaWdnZXJdPVwic3RhdGVFeHBcImApXG4gKi9cbnZhciBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdChuYW1lLCB0eXBlLCBzZWN1cml0eUNvbnRleHQsIHZhbHVlLCB1bml0LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc2VjdXJpdHlDb250ZXh0ID0gc2VjdXJpdHlDb250ZXh0O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudW5pdCA9IHVuaXQ7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuaXNBbmltYXRpb24gPSB0aGlzLnR5cGUgPT09IDQgLyogQW5pbWF0aW9uICovO1xuICAgIH1cbiAgICBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdC5mcm9tQm91bmRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHZhciB0eXBlID0gQm91bmRQcm9wZXJ0eU1hcHBpbmdbcHJvcC50eXBlXTtcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdChwcm9wLm5hbWUsIHR5cGUsIHByb3Auc2VjdXJpdHlDb250ZXh0LCBwcm9wLnZhbHVlLCBwcm9wLnVuaXQsIHByb3Auc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVsZW1lbnRQcm9wZXJ0eSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdDtcbn0oKSk7XG4vKipcbiAqIEEgYmluZGluZyBmb3IgYW4gZWxlbWVudCBldmVudCAoZS5nLiBgKGV2ZW50KT1cImhhbmRsZXIoKVwiYCkgb3IgYW4gYW5pbWF0aW9uIHRyaWdnZXIgZXZlbnQgKGUuZy5cbiAqIGAoQHRyaWdnZXIucGhhc2UpPVwiY2FsbGJhY2soJGV2ZW50KVwiYCkuXG4gKi9cbnZhciBCb3VuZEV2ZW50QXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvdW5kRXZlbnRBc3QobmFtZSwgdGFyZ2V0LCBwaGFzZSwgaGFuZGxlciwgc291cmNlU3BhbiwgaGFuZGxlclNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucGhhc2UgPSBwaGFzZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5oYW5kbGVyU3BhbiA9IGhhbmRsZXJTcGFuO1xuICAgICAgICB0aGlzLmZ1bGxOYW1lID0gQm91bmRFdmVudEFzdC5jYWxjRnVsbE5hbWUodGhpcy5uYW1lLCB0aGlzLnRhcmdldCwgdGhpcy5waGFzZSk7XG4gICAgICAgIHRoaXMuaXNBbmltYXRpb24gPSAhIXRoaXMucGhhc2U7XG4gICAgfVxuICAgIEJvdW5kRXZlbnRBc3QuY2FsY0Z1bGxOYW1lID0gZnVuY3Rpb24gKG5hbWUsIHRhcmdldCwgcGhhc2UpIHtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldCArIFwiOlwiICsgbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGhhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkBcIiArIG5hbWUgKyBcIi5cIiArIHBoYXNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG4gICAgQm91bmRFdmVudEFzdC5mcm9tUGFyc2VkRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnR5cGUgPT09IDAgLyogUmVndWxhciAqLyA/IGV2ZW50LnRhcmdldE9yUGhhc2UgOiBudWxsO1xuICAgICAgICB2YXIgcGhhc2UgPSBldmVudC50eXBlID09PSAxIC8qIEFuaW1hdGlvbiAqLyA/IGV2ZW50LnRhcmdldE9yUGhhc2UgOiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IEJvdW5kRXZlbnRBc3QoZXZlbnQubmFtZSwgdGFyZ2V0LCBwaGFzZSwgZXZlbnQuaGFuZGxlciwgZXZlbnQuc291cmNlU3BhbiwgZXZlbnQuaGFuZGxlclNwYW4pO1xuICAgIH07XG4gICAgQm91bmRFdmVudEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV2ZW50KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEJvdW5kRXZlbnRBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIHJlZmVyZW5jZSBkZWNsYXJhdGlvbiBvbiBhbiBlbGVtZW50IChlLmcuIGBsZXQgc29tZU5hbWU9XCJleHByZXNzaW9uXCJgKS5cbiAqL1xudmFyIFJlZmVyZW5jZUFzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZlcmVuY2VBc3QobmFtZSwgdmFsdWUsIG9yaWdpbmFsVmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9yaWdpbmFsVmFsdWUgPSBvcmlnaW5hbFZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBSZWZlcmVuY2VBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWZlcmVuY2UodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVmZXJlbmNlQXN0O1xufSgpKTtcbi8qKlxuICogQSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBvbiBhIDxuZy10ZW1wbGF0ZT4gKGUuZy4gYHZhci1zb21lTmFtZT1cInNvbWVMb2NhbE5hbWVcImApLlxuICovXG52YXIgVmFyaWFibGVBc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmFyaWFibGVBc3QobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBWYXJpYWJsZUFzdC5mcm9tUGFyc2VkVmFyaWFibGUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlQXN0KHYubmFtZSwgdi52YWx1ZSwgdi5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIFZhcmlhYmxlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VmFyaWFibGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gVmFyaWFibGVBc3Q7XG59KCkpO1xuLyoqXG4gKiBBbiBlbGVtZW50IGRlY2xhcmF0aW9uIGluIGEgdGVtcGxhdGUuXG4gKi9cbnZhciBFbGVtZW50QXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRBc3QobmFtZSwgYXR0cnMsIGlucHV0cywgb3V0cHV0cywgcmVmZXJlbmNlcywgZGlyZWN0aXZlcywgcHJvdmlkZXJzLCBoYXNWaWV3Q29udGFpbmVyLCBxdWVyeU1hdGNoZXMsIGNoaWxkcmVuLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3BhbiwgZW5kU291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgdGhpcy5oYXNWaWV3Q29udGFpbmVyID0gaGFzVmlld0NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5xdWVyeU1hdGNoZXMgPSBxdWVyeU1hdGNoZXM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgIH1cbiAgICBFbGVtZW50QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50QXN0O1xufSgpKTtcbi8qKlxuICogQSBgPG5nLXRlbXBsYXRlPmAgZWxlbWVudCBpbmNsdWRlZCBpbiBhbiBBbmd1bGFyIHRlbXBsYXRlLlxuICovXG52YXIgRW1iZWRkZWRUZW1wbGF0ZUFzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbWJlZGRlZFRlbXBsYXRlQXN0KGF0dHJzLCBvdXRwdXRzLCByZWZlcmVuY2VzLCB2YXJpYWJsZXMsIGRpcmVjdGl2ZXMsIHByb3ZpZGVycywgaGFzVmlld0NvbnRhaW5lciwgcXVlcnlNYXRjaGVzLCBjaGlsZHJlbiwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBwcm92aWRlcnM7XG4gICAgICAgIHRoaXMuaGFzVmlld0NvbnRhaW5lciA9IGhhc1ZpZXdDb250YWluZXI7XG4gICAgICAgIHRoaXMucXVlcnlNYXRjaGVzID0gcXVlcnlNYXRjaGVzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgRW1iZWRkZWRUZW1wbGF0ZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVtYmVkZGVkVGVtcGxhdGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRW1iZWRkZWRUZW1wbGF0ZUFzdDtcbn0oKSk7XG4vKipcbiAqIEEgZGlyZWN0aXZlIHByb3BlcnR5IHdpdGggYSBib3VuZCB2YWx1ZSAoZS5nLiBgKm5nSWY9XCJjb25kaXRpb25cIikuXG4gKi9cbnZhciBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QoZGlyZWN0aXZlTmFtZSwgdGVtcGxhdGVOYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmVOYW1lO1xuICAgICAgICB0aGlzLnRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlTmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGlyZWN0aXZlUHJvcGVydHkodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdDtcbn0oKSk7XG4vKipcbiAqIEEgZGlyZWN0aXZlIGRlY2xhcmVkIG9uIGFuIGVsZW1lbnQuXG4gKi9cbnZhciBEaXJlY3RpdmVBc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlyZWN0aXZlQXN0KGRpcmVjdGl2ZSwgaW5wdXRzLCBob3N0UHJvcGVydGllcywgaG9zdEV2ZW50cywgY29udGVudFF1ZXJ5U3RhcnRJZCwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgIHRoaXMuaG9zdFByb3BlcnRpZXMgPSBob3N0UHJvcGVydGllcztcbiAgICAgICAgdGhpcy5ob3N0RXZlbnRzID0gaG9zdEV2ZW50cztcbiAgICAgICAgdGhpcy5jb250ZW50UXVlcnlTdGFydElkID0gY29udGVudFF1ZXJ5U3RhcnRJZDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgRGlyZWN0aXZlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGlyZWN0aXZlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIERpcmVjdGl2ZUFzdDtcbn0oKSk7XG4vKipcbiAqIEEgcHJvdmlkZXIgZGVjbGFyZWQgb24gYW4gZWxlbWVudFxuICovXG52YXIgUHJvdmlkZXJBc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvdmlkZXJBc3QodG9rZW4sIG11bHRpUHJvdmlkZXIsIGVhZ2VyLCBwcm92aWRlcnMsIHByb3ZpZGVyVHlwZSwgbGlmZWN5Y2xlSG9va3MsIHNvdXJjZVNwYW4sIGlzTW9kdWxlKSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5tdWx0aVByb3ZpZGVyID0gbXVsdGlQcm92aWRlcjtcbiAgICAgICAgdGhpcy5lYWdlciA9IGVhZ2VyO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgdGhpcy5wcm92aWRlclR5cGUgPSBwcm92aWRlclR5cGU7XG4gICAgICAgIHRoaXMubGlmZWN5Y2xlSG9va3MgPSBsaWZlY3ljbGVIb29rcztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pc01vZHVsZSA9IGlzTW9kdWxlO1xuICAgIH1cbiAgICBQcm92aWRlckFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAvLyBObyB2aXNpdCBtZXRob2QgaW4gdGhlIHZpc2l0b3IgZm9yIG5vdy4uLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBQcm92aWRlckFzdDtcbn0oKSk7XG52YXIgUHJvdmlkZXJBc3RUeXBlO1xuKGZ1bmN0aW9uIChQcm92aWRlckFzdFR5cGUpIHtcbiAgICBQcm92aWRlckFzdFR5cGVbUHJvdmlkZXJBc3RUeXBlW1wiUHVibGljU2VydmljZVwiXSA9IDBdID0gXCJQdWJsaWNTZXJ2aWNlXCI7XG4gICAgUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZVtcIlByaXZhdGVTZXJ2aWNlXCJdID0gMV0gPSBcIlByaXZhdGVTZXJ2aWNlXCI7XG4gICAgUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZVtcIkNvbXBvbmVudFwiXSA9IDJdID0gXCJDb21wb25lbnRcIjtcbiAgICBQcm92aWRlckFzdFR5cGVbUHJvdmlkZXJBc3RUeXBlW1wiRGlyZWN0aXZlXCJdID0gM10gPSBcIkRpcmVjdGl2ZVwiO1xuICAgIFByb3ZpZGVyQXN0VHlwZVtQcm92aWRlckFzdFR5cGVbXCJCdWlsdGluXCJdID0gNF0gPSBcIkJ1aWx0aW5cIjtcbn0pKFByb3ZpZGVyQXN0VHlwZSB8fCAoUHJvdmlkZXJBc3RUeXBlID0ge30pKTtcbi8qKlxuICogUG9zaXRpb24gd2hlcmUgY29udGVudCBpcyB0byBiZSBwcm9qZWN0ZWQgKGluc3RhbmNlIG9mIGA8bmctY29udGVudD5gIGluIGEgdGVtcGxhdGUpLlxuICovXG52YXIgTmdDb250ZW50QXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5nQ29udGVudEFzdChpbmRleCwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIE5nQ29udGVudEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE5nQ29udGVudCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBOZ0NvbnRlbnRBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIHZpc2l0b3IgdGhhdCBhY2NlcHRzIGVhY2ggbm9kZSBidXQgZG9lc24ndCBkbyBhbnl0aGluZy4gSXQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZFxuICogYXMgdGhlIGJhc2UgY2xhc3MgZm9yIGEgdmlzaXRvciB0aGF0IGlzIG9ubHkgaW50ZXJlc3RlZCBpbiBhIHN1YnNldCBvZiB0aGUgbm9kZSB0eXBlcy5cbiAqL1xudmFyIE51bGxUZW1wbGF0ZVZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTnVsbFRlbXBsYXRlVmlzaXRvcigpIHtcbiAgICB9XG4gICAgTnVsbFRlbXBsYXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXROZ0NvbnRlbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgTnVsbFRlbXBsYXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbWJlZGRlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIE51bGxUZW1wbGF0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBOdWxsVGVtcGxhdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBOdWxsVGVtcGxhdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFZhcmlhYmxlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIE51bGxUZW1wbGF0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXZlbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgTnVsbFRlbXBsYXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgTnVsbFRlbXBsYXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIE51bGxUZW1wbGF0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIE51bGxUZW1wbGF0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBOdWxsVGVtcGxhdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBOdWxsVGVtcGxhdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZVByb3BlcnR5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIHJldHVybiBOdWxsVGVtcGxhdGVWaXNpdG9yO1xufSgpKTtcbi8qKlxuICogQmFzZSBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHRvIGJ1aWxkIGEgdmlzaXRvciB0aGF0IHZpc2l0cyBlYWNoIG5vZGVcbiAqIGluIGFuIHRlbXBsYXRlIGFzdCByZWN1cnNpdmVseS5cbiAqL1xudmFyIFJlY3Vyc2l2ZVRlbXBsYXRlQXN0VmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVjdXJzaXZlVGVtcGxhdGVBc3RWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlY3Vyc2l2ZVRlbXBsYXRlQXN0VmlzaXRvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8vIE5vZGVzIHdpdGggY2hpbGRyZW5cbiAgICBSZWN1cnNpdmVUZW1wbGF0ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjb250ZXh0LCBmdW5jdGlvbiAodmlzaXQpIHtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5hdHRycyk7XG4gICAgICAgICAgICB2aXNpdChhc3QucmVmZXJlbmNlcyk7XG4gICAgICAgICAgICB2aXNpdChhc3QudmFyaWFibGVzKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5kaXJlY3RpdmVzKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5wcm92aWRlcnMpO1xuICAgICAgICAgICAgdmlzaXQoYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVUZW1wbGF0ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjb250ZXh0LCBmdW5jdGlvbiAodmlzaXQpIHtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5hdHRycyk7XG4gICAgICAgICAgICB2aXNpdChhc3QuaW5wdXRzKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5vdXRwdXRzKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5yZWZlcmVuY2VzKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5kaXJlY3RpdmVzKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5wcm92aWRlcnMpO1xuICAgICAgICAgICAgdmlzaXQoYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVUZW1wbGF0ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGNvbnRleHQsIGZ1bmN0aW9uICh2aXNpdCkge1xuICAgICAgICAgICAgdmlzaXQoYXN0LmlucHV0cyk7XG4gICAgICAgICAgICB2aXNpdChhc3QuaG9zdFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgdmlzaXQoYXN0Lmhvc3RFdmVudHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZVRlbXBsYXRlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGlsZHJlbiA9IGZ1bmN0aW9uIChjb250ZXh0LCBjYikge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICAgIGZ1bmN0aW9uIHZpc2l0KGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0ZW1wbGF0ZVZpc2l0QWxsKHQsIGNoaWxkcmVuLCBjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2IodmlzaXQpO1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgcmVzdWx0cyk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVjdXJzaXZlVGVtcGxhdGVBc3RWaXNpdG9yO1xufShOdWxsVGVtcGxhdGVWaXNpdG9yKSk7XG4vKipcbiAqIFZpc2l0IGV2ZXJ5IG5vZGUgaW4gYSBsaXN0IG9mIHtAbGluayBUZW1wbGF0ZUFzdH1zIHdpdGggdGhlIGdpdmVuIHtAbGluayBUZW1wbGF0ZUFzdFZpc2l0b3J9LlxuICovXG5mdW5jdGlvbiB0ZW1wbGF0ZVZpc2l0QWxsKHZpc2l0b3IsIGFzdHMsIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciB2aXNpdCA9IHZpc2l0b3IudmlzaXQgP1xuICAgICAgICBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0KGFzdCwgY29udGV4dCkgfHwgYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9IDpcbiAgICAgICAgZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9O1xuICAgIGFzdHMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgIHZhciBhc3RSZXN1bHQgPSB2aXNpdChhc3QpO1xuICAgICAgICBpZiAoYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhc3RSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFByb3ZpZGVyRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb3ZpZGVyRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJvdmlkZXJFcnJvcihtZXNzYWdlLCBzcGFuKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUHJvdmlkZXJFcnJvcjtcbn0oUGFyc2VFcnJvcikpO1xudmFyIFByb3ZpZGVyVmlld0NvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvdmlkZXJWaWV3Q29udGV4dChyZWZsZWN0b3IsIGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlZmxlY3RvciA9IHJlZmxlY3RvcjtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMudmlld1F1ZXJpZXMgPSBfZ2V0Vmlld1F1ZXJpZXMoY29tcG9uZW50KTtcbiAgICAgICAgdGhpcy52aWV3UHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb21wb25lbnQudmlld1Byb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgaWYgKF90aGlzLnZpZXdQcm92aWRlcnMuZ2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnZpZXdQcm92aWRlcnMuc2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvdmlkZXJWaWV3Q29udGV4dDtcbn0oKSk7XG52YXIgUHJvdmlkZXJFbGVtZW50Q29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm92aWRlckVsZW1lbnRDb250ZXh0KHZpZXdDb250ZXh0LCBfcGFyZW50LCBfaXNWaWV3Um9vdCwgX2RpcmVjdGl2ZUFzdHMsIGF0dHJzLCByZWZzLCBpc1RlbXBsYXRlLCBjb250ZW50UXVlcnlTdGFydElkLCBfc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpZXdDb250ZXh0ID0gdmlld0NvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuX2lzVmlld1Jvb3QgPSBfaXNWaWV3Um9vdDtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlQXN0cyA9IF9kaXJlY3RpdmVBc3RzO1xuICAgICAgICB0aGlzLl9zb3VyY2VTcGFuID0gX3NvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zZWVuUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9xdWVyaWVkVG9rZW5zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybWVkSGFzVmlld0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hdHRycyA9IHt9O1xuICAgICAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyQXN0KSB7IHJldHVybiBfdGhpcy5fYXR0cnNbYXR0ckFzdC5uYW1lXSA9IGF0dHJBc3QudmFsdWU7IH0pO1xuICAgICAgICB2YXIgZGlyZWN0aXZlc01ldGEgPSBfZGlyZWN0aXZlQXN0cy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZUFzdCkgeyByZXR1cm4gZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZTsgfSk7XG4gICAgICAgIHRoaXMuX2FsbFByb3ZpZGVycyA9XG4gICAgICAgICAgICBfcmVzb2x2ZVByb3ZpZGVyc0Zyb21EaXJlY3RpdmVzKGRpcmVjdGl2ZXNNZXRhLCBfc291cmNlU3Bhbiwgdmlld0NvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgdGhpcy5fY29udGVudFF1ZXJpZXMgPSBfZ2V0Q29udGVudFF1ZXJpZXMoY29udGVudFF1ZXJ5U3RhcnRJZCwgZGlyZWN0aXZlc01ldGEpO1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMuX2FsbFByb3ZpZGVycy52YWx1ZXMoKSkuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9hZGRRdWVyeVJlYWRzVG8ocHJvdmlkZXIudG9rZW4sIHByb3ZpZGVyLnRva2VuLCBfdGhpcy5fcXVlcmllZFRva2Vucyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlUmVmSWQgPSBjcmVhdGVUb2tlbkZvckV4dGVybmFsUmVmZXJlbmNlKHRoaXMudmlld0NvbnRleHQucmVmbGVjdG9yLCBJZGVudGlmaWVycy5UZW1wbGF0ZVJlZik7XG4gICAgICAgICAgICB0aGlzLl9hZGRRdWVyeVJlYWRzVG8odGVtcGxhdGVSZWZJZCwgdGVtcGxhdGVSZWZJZCwgdGhpcy5fcXVlcmllZFRva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWZBc3QpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0UXVlcnlWYWx1ZSA9IHJlZkFzdC52YWx1ZSB8fFxuICAgICAgICAgICAgICAgIGNyZWF0ZVRva2VuRm9yRXh0ZXJuYWxSZWZlcmVuY2UoX3RoaXMudmlld0NvbnRleHQucmVmbGVjdG9yLCBJZGVudGlmaWVycy5FbGVtZW50UmVmKTtcbiAgICAgICAgICAgIF90aGlzLl9hZGRRdWVyeVJlYWRzVG8oeyB2YWx1ZTogcmVmQXN0Lm5hbWUgfSwgZGVmYXVsdFF1ZXJ5VmFsdWUsIF90aGlzLl9xdWVyaWVkVG9rZW5zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLl9xdWVyaWVkVG9rZW5zLmdldCh0aGlzLnZpZXdDb250ZXh0LnJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuVmlld0NvbnRhaW5lclJlZikpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybWVkSGFzVmlld0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBwcm92aWRlcnMgdGhhdCB3ZSBrbm93IGFyZSBlYWdlciBmaXJzdFxuICAgICAgICBBcnJheS5mcm9tKHRoaXMuX2FsbFByb3ZpZGVycy52YWx1ZXMoKSkuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHZhciBlYWdlciA9IHByb3ZpZGVyLmVhZ2VyIHx8IF90aGlzLl9xdWVyaWVkVG9rZW5zLmdldCh0b2tlblJlZmVyZW5jZShwcm92aWRlci50b2tlbikpO1xuICAgICAgICAgICAgaWYgKGVhZ2VyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihwcm92aWRlci5wcm92aWRlclR5cGUsIHByb3ZpZGVyLnRva2VuLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLmFmdGVyRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gY29sbGVjdCBsYXp5IHByb3ZpZGVyc1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMuX2FsbFByb3ZpZGVycy52YWx1ZXMoKSkuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci50b2tlbiwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Qcm92aWRlcnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IE1hcHMga2VlcCB0aGVpciBpbnNlcnRpb24gb3JkZXIuXG4gICAgICAgICAgICB2YXIgbGF6eVByb3ZpZGVycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGVhZ2VyUHJvdmlkZXJzID0gW107XG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci5lYWdlcikge1xuICAgICAgICAgICAgICAgICAgICBlYWdlclByb3ZpZGVycy5wdXNoKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhenlQcm92aWRlcnMucHVzaChwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbGF6eVByb3ZpZGVycy5jb25jYXQoZWFnZXJQcm92aWRlcnMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUsIFwidHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc29ydGVkUHJvdmlkZXJUeXBlcyA9IHRoaXMudHJhbnNmb3JtUHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIHByb3ZpZGVyLnRva2VuLmlkZW50aWZpZXI7IH0pO1xuICAgICAgICAgICAgdmFyIHNvcnRlZERpcmVjdGl2ZXMgPSB0aGlzLl9kaXJlY3RpdmVBc3RzLnNsaWNlKCk7XG4gICAgICAgICAgICBzb3J0ZWREaXJlY3RpdmVzLnNvcnQoZnVuY3Rpb24gKGRpcjEsIGRpcjIpIHsgcmV0dXJuIHNvcnRlZFByb3ZpZGVyVHlwZXMuaW5kZXhPZihkaXIxLmRpcmVjdGl2ZS50eXBlKSAtXG4gICAgICAgICAgICAgICAgc29ydGVkUHJvdmlkZXJUeXBlcy5pbmRleE9mKGRpcjIuZGlyZWN0aXZlLnR5cGUpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWREaXJlY3RpdmVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUsIFwicXVlcnlNYXRjaGVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYWxsTWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcXVlcmllZFRva2Vucy5mb3JFYWNoKGZ1bmN0aW9uIChtYXRjaGVzKSB7IGFsbE1hdGNoZXMucHVzaC5hcHBseShhbGxNYXRjaGVzLCBfX3NwcmVhZChtYXRjaGVzKSk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFsbE1hdGNoZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9hZGRRdWVyeVJlYWRzVG8gPSBmdW5jdGlvbiAodG9rZW4sIGRlZmF1bHRWYWx1ZSwgcXVlcnlSZWFkVG9rZW5zKSB7XG4gICAgICAgIHRoaXMuX2dldFF1ZXJpZXNGb3IodG9rZW4pLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgICAgICB2YXIgcXVlcnlWYWx1ZSA9IHF1ZXJ5Lm1ldGEucmVhZCB8fCBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB2YXIgdG9rZW5SZWYgPSB0b2tlblJlZmVyZW5jZShxdWVyeVZhbHVlKTtcbiAgICAgICAgICAgIHZhciBxdWVyeU1hdGNoZXMgPSBxdWVyeVJlYWRUb2tlbnMuZ2V0KHRva2VuUmVmKTtcbiAgICAgICAgICAgIGlmICghcXVlcnlNYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlNYXRjaGVzID0gW107XG4gICAgICAgICAgICAgICAgcXVlcnlSZWFkVG9rZW5zLnNldCh0b2tlblJlZiwgcXVlcnlNYXRjaGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlcy5wdXNoKHsgcXVlcnlJZDogcXVlcnkucXVlcnlJZCwgdmFsdWU6IHF1ZXJ5VmFsdWUgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldFF1ZXJpZXNGb3IgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudEVsID0gdGhpcztcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcbiAgICAgICAgdmFyIHF1ZXJpZXM7XG4gICAgICAgIHdoaWxlIChjdXJyZW50RWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXJpZXMgPSBjdXJyZW50RWwuX2NvbnRlbnRRdWVyaWVzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICAgICAgaWYgKHF1ZXJpZXMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIF9fc3ByZWFkKHF1ZXJpZXMuZmlsdGVyKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gcXVlcnkubWV0YS5kZXNjZW5kYW50cyB8fCBkaXN0YW5jZSA8PSAxOyB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRFbC5fZGlyZWN0aXZlQXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5fcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJpZXMgPSB0aGlzLnZpZXdDb250ZXh0LnZpZXdRdWVyaWVzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICBpZiAocXVlcmllcykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBfX3NwcmVhZChxdWVyaWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIgPSBmdW5jdGlvbiAocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgdG9rZW4sIGVhZ2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXNvbHZlZFByb3ZpZGVyID0gdGhpcy5fYWxsUHJvdmlkZXJzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICBpZiAoIXJlc29sdmVkUHJvdmlkZXIgfHwgKChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICByZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSkgJiZcbiAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UpIHx8XG4gICAgICAgICAgICAoKHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSB8fFxuICAgICAgICAgICAgICAgIHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlKSAmJlxuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuQnVpbHRpbikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID0gdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRQcm92aWRlckFzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc2VlblByb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pKSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LmVycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiQ2Fubm90IGluc3RhbnRpYXRlIGN5Y2xpYyBkZXBlbmRlbmN5ISBcIiArIHRva2VuTmFtZSh0b2tlbiksIHRoaXMuX3NvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMuc2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSwgdHJ1ZSk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZFByb3ZpZGVycyA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gcHJvdmlkZXIudXNlVmFsdWU7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IHByb3ZpZGVyLnVzZUV4aXN0aW5nO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkRGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci51c2VFeGlzdGluZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nRGlEZXAgPSBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgeyB0b2tlbjogcHJvdmlkZXIudXNlRXhpc3RpbmcgfSwgZWFnZXIpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0RpRGVwLnRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IGV4aXN0aW5nRGlEZXAudG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VWYWx1ZSA9IGV4aXN0aW5nRGlEZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VGYWN0b3J5LmRpRGVwcztcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZERlcHMgPVxuICAgICAgICAgICAgICAgICAgICBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgZGVwLCBlYWdlcik7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlQ2xhc3MuZGlEZXBzO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGVwcyA9XG4gICAgICAgICAgICAgICAgICAgIGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RyYW5zZm9ybVByb3ZpZGVyKHByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6IHRyYW5zZm9ybWVkVXNlVmFsdWUsXG4gICAgICAgICAgICAgICAgZGVwczogdHJhbnNmb3JtZWREZXBzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QgPVxuICAgICAgICAgICAgX3RyYW5zZm9ybVByb3ZpZGVyQXN0KHJlc29sdmVkUHJvdmlkZXIsIHsgZWFnZXI6IGVhZ2VyLCBwcm92aWRlcnM6IHRyYW5zZm9ybWVkUHJvdmlkZXJzIH0pO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy5zZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pLCB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3Q7XG4gICAgfTtcbiAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fZ2V0TG9jYWxEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpIHtcbiAgICAgICAgaWYgKGVhZ2VyID09PSB2b2lkIDApIHsgZWFnZXIgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoZGVwLmlzQXR0cmlidXRlKSB7XG4gICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gdGhpcy5fYXR0cnNbZGVwLnRva2VuLnZhbHVlXTtcbiAgICAgICAgICAgIHJldHVybiB7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBhdHRyVmFsdWUgPT0gbnVsbCA/IG51bGwgOiBhdHRyVmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVwLnRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGFjY2VzcyBidWlsdGludHNcbiAgICAgICAgICAgIGlmICgocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSB8fFxuICAgICAgICAgICAgICAgIHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5Db21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgPT09XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQucmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShJZGVudGlmaWVycy5SZW5kZXJlcikgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQucmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShJZGVudGlmaWVycy5FbGVtZW50UmVmKSB8fFxuICAgICAgICAgICAgICAgICAgICB0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3Q29udGV4dC5yZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmKSB8fFxuICAgICAgICAgICAgICAgICAgICB0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3Q29udGV4dC5yZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKElkZW50aWZpZXJzLlRlbXBsYXRlUmVmKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3Q29udGV4dC5yZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKElkZW50aWZpZXJzLlZpZXdDb250YWluZXJSZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhY2Nlc3MgdGhlIGluamVjdG9yXG4gICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT1cbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LnJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuSW5qZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFjY2VzcyBwcm92aWRlcnNcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwLnRva2VuLCBlYWdlcikgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKSB7XG4gICAgICAgIGlmIChlYWdlciA9PT0gdm9pZCAwKSB7IGVhZ2VyID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGN1cnJFbGVtZW50ID0gdGhpcztcbiAgICAgICAgdmFyIGN1cnJFYWdlciA9IGVhZ2VyO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFkZXAuaXNTa2lwU2VsZikge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0TG9jYWxEZXBlbmRlbmN5KHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXAuaXNTZWxmKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCAmJiBkZXAuaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHsgaXNWYWx1ZTogdHJ1ZSwgdmFsdWU6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHBhcmVudCBlbGVtZW50c1xuICAgICAgICAgICAgd2hpbGUgKCFyZXN1bHQgJiYgY3VyckVsZW1lbnQuX3BhcmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2RWxlbWVudCA9IGN1cnJFbGVtZW50O1xuICAgICAgICAgICAgICAgIGN1cnJFbGVtZW50ID0gY3VyckVsZW1lbnQuX3BhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAocHJldkVsZW1lbnQuX2lzVmlld1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyckVhZ2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGN1cnJFbGVtZW50Ll9nZXRMb2NhbERlcGVuZGVuY3koUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UsIGRlcCwgY3VyckVhZ2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIEBIb3N0IHJlc3RyaWN0aW9uXG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmICghZGVwLmlzSG9zdCB8fCB0aGlzLnZpZXdDb250ZXh0LmNvbXBvbmVudC5pc0hvc3QgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3Q29udGV4dC5jb21wb25lbnQudHlwZS5yZWZlcmVuY2UgPT09IHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3Q29udGV4dC52aWV3UHJvdmlkZXJzLmdldCh0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlcC5pc09wdGlvbmFsID8geyBpc1ZhbHVlOiB0cnVlLCB2YWx1ZTogbnVsbCB9IDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQuZXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJObyBwcm92aWRlciBmb3IgXCIgKyB0b2tlbk5hbWUoZGVwLnRva2VuKSwgdGhpcy5fc291cmNlU3BhbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvdmlkZXJFbGVtZW50Q29udGV4dDtcbn0oKSk7XG52YXIgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplcihyZWZsZWN0b3IsIG5nTW9kdWxlLCBleHRyYVByb3ZpZGVycywgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlZmxlY3RvciA9IHJlZmxlY3RvcjtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLl9hbGxQcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBuZ01vZHVsZVByb3ZpZGVyID0geyB0b2tlbjogeyBpZGVudGlmaWVyOiBuZ01vZHVsZVR5cGUgfSwgdXNlQ2xhc3M6IG5nTW9kdWxlVHlwZSB9O1xuICAgICAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMoW25nTW9kdWxlUHJvdmlkZXJdLCBQcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSwgdHJ1ZSwgc291cmNlU3BhbiwgX3RoaXMuX2Vycm9ycywgX3RoaXMuX2FsbFByb3ZpZGVycywgLyogaXNNb2R1bGUgKi8gdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLnByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS5wcm92aWRlcjsgfSkuY29uY2F0KGV4dHJhUHJvdmlkZXJzKSwgUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UsIGZhbHNlLCBzb3VyY2VTcGFuLCB0aGlzLl9lcnJvcnMsIHRoaXMuX2FsbFByb3ZpZGVycywgXG4gICAgICAgIC8qIGlzTW9kdWxlICovIGZhbHNlKTtcbiAgICB9XG4gICAgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9hbGxQcm92aWRlcnMudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBfdGhpcy5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyKHByb3ZpZGVyLnRva2VuLCBwcm92aWRlci5lYWdlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBlcnJvclN0cmluZyA9IHRoaXMuX2Vycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBNYXBzIGtlZXAgdGhlaXIgaW5zZXJ0aW9uIG9yZGVyLlxuICAgICAgICB2YXIgbGF6eVByb3ZpZGVycyA9IFtdO1xuICAgICAgICB2YXIgZWFnZXJQcm92aWRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci5lYWdlcikge1xuICAgICAgICAgICAgICAgIGVhZ2VyUHJvdmlkZXJzLnB1c2gocHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGF6eVByb3ZpZGVycy5wdXNoKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsYXp5UHJvdmlkZXJzLmNvbmNhdChlYWdlclByb3ZpZGVycyk7XG4gICAgfTtcbiAgICBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXIucHJvdG90eXBlLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIgPSBmdW5jdGlvbiAodG9rZW4sIGVhZ2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXNvbHZlZFByb3ZpZGVyID0gdGhpcy5fYWxsUHJvdmlkZXJzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICBpZiAoIXJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID0gdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRQcm92aWRlckFzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc2VlblByb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pKSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgUHJvdmlkZXJFcnJvcihcIkNhbm5vdCBpbnN0YW50aWF0ZSBjeWNsaWMgZGVwZW5kZW5jeSEgXCIgKyB0b2tlbk5hbWUodG9rZW4pLCByZXNvbHZlZFByb3ZpZGVyLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMuc2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSwgdHJ1ZSk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZFByb3ZpZGVycyA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gcHJvdmlkZXIudXNlVmFsdWU7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IHByb3ZpZGVyLnVzZUV4aXN0aW5nO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkRGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci51c2VFeGlzdGluZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nRGlEZXAgPSBfdGhpcy5fZ2V0RGVwZW5kZW5jeSh7IHRva2VuOiBwcm92aWRlci51c2VFeGlzdGluZyB9LCBlYWdlciwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdEaURlcC50b2tlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcgPSBleGlzdGluZ0RpRGVwLnRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlVmFsdWUgPSBleGlzdGluZ0RpRGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlRmFjdG9yeS5kaURlcHM7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWREZXBzID1cbiAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3koZGVwLCBlYWdlciwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICAgICAgICAgIHZhciBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VDbGFzcy5kaURlcHM7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWREZXBzID1cbiAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3koZGVwLCBlYWdlciwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RyYW5zZm9ybVByb3ZpZGVyKHByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6IHRyYW5zZm9ybWVkVXNlVmFsdWUsXG4gICAgICAgICAgICAgICAgZGVwczogdHJhbnNmb3JtZWREZXBzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QgPVxuICAgICAgICAgICAgX3RyYW5zZm9ybVByb3ZpZGVyQXN0KHJlc29sdmVkUHJvdmlkZXIsIHsgZWFnZXI6IGVhZ2VyLCBwcm92aWRlcnM6IHRyYW5zZm9ybWVkUHJvdmlkZXJzIH0pO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy5zZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pLCB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3Q7XG4gICAgfTtcbiAgICBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXIucHJvdG90eXBlLl9nZXREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKGRlcCwgZWFnZXIsIHJlcXVlc3RvclNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKGVhZ2VyID09PSB2b2lkIDApIHsgZWFnZXIgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgZm91bmRMb2NhbCA9IGZhbHNlO1xuICAgICAgICBpZiAoIWRlcC5pc1NraXBTZWxmICYmIGRlcC50b2tlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBhY2Nlc3MgdGhlIGluamVjdG9yXG4gICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT1cbiAgICAgICAgICAgICAgICB0aGlzLnJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuSW5qZWN0b3IpIHx8XG4gICAgICAgICAgICAgICAgdG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikpIHtcbiAgICAgICAgICAgICAgICBmb3VuZExvY2FsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBhY2Nlc3MgcHJvdmlkZXJzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIoZGVwLnRva2VuLCBlYWdlcikgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvdW5kTG9jYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXA7XG4gICAgfTtcbiAgICByZXR1cm4gTmdNb2R1bGVQcm92aWRlckFuYWx5emVyO1xufSgpKTtcbmZ1bmN0aW9uIF90cmFuc2Zvcm1Qcm92aWRlcihwcm92aWRlciwgX2EpIHtcbiAgICB2YXIgdXNlRXhpc3RpbmcgPSBfYS51c2VFeGlzdGluZywgdXNlVmFsdWUgPSBfYS51c2VWYWx1ZSwgZGVwcyA9IF9hLmRlcHM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IHByb3ZpZGVyLnRva2VuLFxuICAgICAgICB1c2VDbGFzczogcHJvdmlkZXIudXNlQ2xhc3MsXG4gICAgICAgIHVzZUV4aXN0aW5nOiB1c2VFeGlzdGluZyxcbiAgICAgICAgdXNlRmFjdG9yeTogcHJvdmlkZXIudXNlRmFjdG9yeSxcbiAgICAgICAgdXNlVmFsdWU6IHVzZVZhbHVlLFxuICAgICAgICBkZXBzOiBkZXBzLFxuICAgICAgICBtdWx0aTogcHJvdmlkZXIubXVsdGlcbiAgICB9O1xufVxuZnVuY3Rpb24gX3RyYW5zZm9ybVByb3ZpZGVyQXN0KHByb3ZpZGVyLCBfYSkge1xuICAgIHZhciBlYWdlciA9IF9hLmVhZ2VyLCBwcm92aWRlcnMgPSBfYS5wcm92aWRlcnM7XG4gICAgcmV0dXJuIG5ldyBQcm92aWRlckFzdChwcm92aWRlci50b2tlbiwgcHJvdmlkZXIubXVsdGlQcm92aWRlciwgcHJvdmlkZXIuZWFnZXIgfHwgZWFnZXIsIHByb3ZpZGVycywgcHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci5saWZlY3ljbGVIb29rcywgcHJvdmlkZXIuc291cmNlU3BhbiwgcHJvdmlkZXIuaXNNb2R1bGUpO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVQcm92aWRlcnNGcm9tRGlyZWN0aXZlcyhkaXJlY3RpdmVzLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMpIHtcbiAgICB2YXIgcHJvdmlkZXJzQnlUb2tlbiA9IG5ldyBNYXAoKTtcbiAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICB2YXIgZGlyUHJvdmlkZXIgPSB7IHRva2VuOiB7IGlkZW50aWZpZXI6IGRpcmVjdGl2ZS50eXBlIH0sIHVzZUNsYXNzOiBkaXJlY3RpdmUudHlwZSB9O1xuICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhbZGlyUHJvdmlkZXJdLCBkaXJlY3RpdmUuaXNDb21wb25lbnQgPyBQcm92aWRlckFzdFR5cGUuQ29tcG9uZW50IDogUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSwgdHJ1ZSwgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCBwcm92aWRlcnNCeVRva2VuLCAvKiBpc01vZHVsZSAqLyBmYWxzZSk7XG4gICAgfSk7XG4gICAgLy8gTm90ZTogZGlyZWN0aXZlcyBuZWVkIHRvIGJlIGFibGUgdG8gb3ZlcndyaXRlIHByb3ZpZGVycyBvZiBhIGNvbXBvbmVudCFcbiAgICB2YXIgZGlyZWN0aXZlc1dpdGhDb21wb25lbnRGaXJzdCA9IGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGRpci5pc0NvbXBvbmVudDsgfSkuY29uY2F0KGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuICFkaXIuaXNDb21wb25lbnQ7IH0pKTtcbiAgICBkaXJlY3RpdmVzV2l0aENvbXBvbmVudEZpcnN0LmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhkaXJlY3RpdmUucHJvdmlkZXJzLCBQcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSwgZmFsc2UsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgcHJvdmlkZXJzQnlUb2tlbiwgLyogaXNNb2R1bGUgKi8gZmFsc2UpO1xuICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhkaXJlY3RpdmUudmlld1Byb3ZpZGVycywgUHJvdmlkZXJBc3RUeXBlLlByaXZhdGVTZXJ2aWNlLCBmYWxzZSwgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCBwcm92aWRlcnNCeVRva2VuLCAvKiBpc01vZHVsZSAqLyBmYWxzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3ZpZGVyc0J5VG9rZW47XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVByb3ZpZGVycyhwcm92aWRlcnMsIHByb3ZpZGVyVHlwZSwgZWFnZXIsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgdGFyZ2V0UHJvdmlkZXJzQnlUb2tlbiwgaXNNb2R1bGUpIHtcbiAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIHJlc29sdmVkUHJvdmlkZXIgPSB0YXJnZXRQcm92aWRlcnNCeVRva2VuLmdldCh0b2tlblJlZmVyZW5jZShwcm92aWRlci50b2tlbikpO1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm92aWRlciAhPSBudWxsICYmICEhcmVzb2x2ZWRQcm92aWRlci5tdWx0aVByb3ZpZGVyICE9PSAhIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICB0YXJnZXRFcnJvcnMucHVzaChuZXcgUHJvdmlkZXJFcnJvcihcIk1peGluZyBtdWx0aSBhbmQgbm9uIG11bHRpIHByb3ZpZGVyIGlzIG5vdCBwb3NzaWJsZSBmb3IgdG9rZW4gXCIgKyB0b2tlbk5hbWUocmVzb2x2ZWRQcm92aWRlci50b2tlbiksIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHZhciBsaWZlY3ljbGVIb29rcyA9IHByb3ZpZGVyLnRva2VuLmlkZW50aWZpZXIgJiZcbiAgICAgICAgICAgICAgICBwcm92aWRlci50b2tlbi5pZGVudGlmaWVyLmxpZmVjeWNsZUhvb2tzID9cbiAgICAgICAgICAgICAgICBwcm92aWRlci50b2tlbi5pZGVudGlmaWVyLmxpZmVjeWNsZUhvb2tzIDpcbiAgICAgICAgICAgICAgICBbXTtcbiAgICAgICAgICAgIHZhciBpc1VzZVZhbHVlID0gIShwcm92aWRlci51c2VDbGFzcyB8fCBwcm92aWRlci51c2VFeGlzdGluZyB8fCBwcm92aWRlci51c2VGYWN0b3J5KTtcbiAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIgPSBuZXcgUHJvdmlkZXJBc3QocHJvdmlkZXIudG9rZW4sICEhcHJvdmlkZXIubXVsdGksIGVhZ2VyIHx8IGlzVXNlVmFsdWUsIFtwcm92aWRlcl0sIHByb3ZpZGVyVHlwZSwgbGlmZWN5Y2xlSG9va3MsIHNvdXJjZVNwYW4sIGlzTW9kdWxlKTtcbiAgICAgICAgICAgIHRhcmdldFByb3ZpZGVyc0J5VG9rZW4uc2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSwgcmVzb2x2ZWRQcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLnB1c2gocHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBfZ2V0Vmlld1F1ZXJpZXMoY29tcG9uZW50KSB7XG4gICAgLy8gTm90ZTogcXVlcmllcyBzdGFydCB3aXRoIGlkIDEgc28gd2UgY2FuIHVzZSB0aGUgbnVtYmVyIGluIGEgQmxvb20gZmlsdGVyIVxuICAgIHZhciB2aWV3UXVlcnlJZCA9IDE7XG4gICAgdmFyIHZpZXdRdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgIGlmIChjb21wb25lbnQudmlld1F1ZXJpZXMpIHtcbiAgICAgICAgY29tcG9uZW50LnZpZXdRdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBfYWRkUXVlcnlUb1Rva2VuTWFwKHZpZXdRdWVyaWVzLCB7IG1ldGE6IHF1ZXJ5LCBxdWVyeUlkOiB2aWV3UXVlcnlJZCsrIH0pOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdRdWVyaWVzO1xufVxuZnVuY3Rpb24gX2dldENvbnRlbnRRdWVyaWVzKGNvbnRlbnRRdWVyeVN0YXJ0SWQsIGRpcmVjdGl2ZXMpIHtcbiAgICB2YXIgY29udGVudFF1ZXJ5SWQgPSBjb250ZW50UXVlcnlTdGFydElkO1xuICAgIHZhciBjb250ZW50UXVlcmllcyA9IG5ldyBNYXAoKTtcbiAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSwgZGlyZWN0aXZlSW5kZXgpIHtcbiAgICAgICAgaWYgKGRpcmVjdGl2ZS5xdWVyaWVzKSB7XG4gICAgICAgICAgICBkaXJlY3RpdmUucXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gX2FkZFF1ZXJ5VG9Ub2tlbk1hcChjb250ZW50UXVlcmllcywgeyBtZXRhOiBxdWVyeSwgcXVlcnlJZDogY29udGVudFF1ZXJ5SWQrKyB9KTsgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY29udGVudFF1ZXJpZXM7XG59XG5mdW5jdGlvbiBfYWRkUXVlcnlUb1Rva2VuTWFwKG1hcCwgcXVlcnkpIHtcbiAgICBxdWVyeS5tZXRhLnNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgZW50cnkgPSBtYXAuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSk7XG4gICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gW107XG4gICAgICAgICAgICBtYXAuc2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSwgZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5LnB1c2gocXVlcnkpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgU3R5bGVXaXRoSW1wb3J0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHlsZVdpdGhJbXBvcnRzKHN0eWxlLCBzdHlsZVVybHMpIHtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IHN0eWxlVXJscztcbiAgICB9XG4gICAgcmV0dXJuIFN0eWxlV2l0aEltcG9ydHM7XG59KCkpO1xuZnVuY3Rpb24gaXNTdHlsZVVybFJlc29sdmFibGUodXJsKSB7XG4gICAgaWYgKHVybCA9PSBudWxsIHx8IHVybC5sZW5ndGggPT09IDAgfHwgdXJsWzBdID09ICcvJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBzY2hlbWVNYXRjaCA9IHVybC5tYXRjaChVUkxfV0lUSF9TQ0hFTUFfUkVHRVhQKTtcbiAgICByZXR1cm4gc2NoZW1lTWF0Y2ggPT09IG51bGwgfHwgc2NoZW1lTWF0Y2hbMV0gPT0gJ3BhY2thZ2UnIHx8IHNjaGVtZU1hdGNoWzFdID09ICdhc3NldCc7XG59XG4vKipcbiAqIFJld3JpdGVzIHN0eWxlc2hlZXRzIGJ5IHJlc29sdmluZyBhbmQgcmVtb3ZpbmcgdGhlIEBpbXBvcnQgdXJscyB0aGF0XG4gKiBhcmUgZWl0aGVyIHJlbGF0aXZlIG9yIGRvbid0IGhhdmUgYSBgcGFja2FnZTpgIHNjaGVtZVxuICovXG5mdW5jdGlvbiBleHRyYWN0U3R5bGVVcmxzKHJlc29sdmVyLCBiYXNlVXJsLCBjc3NUZXh0KSB7XG4gICAgdmFyIGZvdW5kVXJscyA9IFtdO1xuICAgIHZhciBtb2RpZmllZENzc1RleHQgPSBjc3NUZXh0LnJlcGxhY2UoQ1NTX1NUUklQUEFCTEVfQ09NTUVOVF9SRUdFWFAsICcnKVxuICAgICAgICAucmVwbGFjZShDU1NfSU1QT1JUX1JFR0VYUCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmwgPSBtWzFdIHx8IG1bMl07XG4gICAgICAgIGlmICghaXNTdHlsZVVybFJlc29sdmFibGUodXJsKSkge1xuICAgICAgICAgICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gcmVzb2x2ZSBub24tcGFja2FnZSBhYnNvbHV0ZSBVUkxzIHdpdGggVVJJXG4gICAgICAgICAgICAvLyBzY2hlbWVcbiAgICAgICAgICAgIHJldHVybiBtWzBdO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kVXJscy5wdXNoKHJlc29sdmVyLnJlc29sdmUoYmFzZVVybCwgdXJsKSk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFN0eWxlV2l0aEltcG9ydHMobW9kaWZpZWRDc3NUZXh0LCBmb3VuZFVybHMpO1xufVxudmFyIENTU19JTVBPUlRfUkVHRVhQID0gL0BpbXBvcnRcXHMrKD86dXJsXFwoKT9cXHMqKD86KD86WydcIl0oW14nXCJdKikpfChbXjtcXClcXHNdKikpW147XSo7Py9nO1xudmFyIENTU19TVFJJUFBBQkxFX0NPTU1FTlRfUkVHRVhQID0gL1xcL1xcKig/ISNcXHMqKD86c291cmNlVVJMfHNvdXJjZU1hcHBpbmdVUkwpPSlbXFxzXFxTXSs/XFwqXFwvL2c7XG52YXIgVVJMX1dJVEhfU0NIRU1BX1JFR0VYUCA9IC9eKFteOi8/I10rKTovO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUFJPUEVSVFlfUEFSVFNfU0VQQVJBVE9SID0gJy4nO1xudmFyIEFUVFJJQlVURV9QUkVGSVggPSAnYXR0cic7XG52YXIgQ0xBU1NfUFJFRklYID0gJ2NsYXNzJztcbnZhciBTVFlMRV9QUkVGSVggPSAnc3R5bGUnO1xudmFyIEFOSU1BVEVfUFJPUF9QUkVGSVggPSAnYW5pbWF0ZS0nO1xuLyoqXG4gKiBQYXJzZXMgYmluZGluZ3MgaW4gdGVtcGxhdGVzIGFuZCBpbiB0aGUgZGlyZWN0aXZlIGhvc3QgYXJlYS5cbiAqL1xudmFyIEJpbmRpbmdQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmluZGluZ1BhcnNlcihfZXhwclBhcnNlciwgX2ludGVycG9sYXRpb25Db25maWcsIF9zY2hlbWFSZWdpc3RyeSwgcGlwZXMsIGVycm9ycykge1xuICAgICAgICB0aGlzLl9leHByUGFyc2VyID0gX2V4cHJQYXJzZXI7XG4gICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgPSBfaW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLnBpcGVzQnlOYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdXNlZFBpcGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBXaGVuIHRoZSBgcGlwZXNgIHBhcmFtZXRlciBpcyBgbnVsbGAsIGRvIG5vdCBjaGVjayBmb3IgdXNlZCBwaXBlc1xuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgaW4gSVZZIHdoZW4gd2UgbWlnaHQgbm90IGtub3cgdGhlIGF2YWlsYWJsZSBwaXBlcyBhdCBjb21waWxlIHRpbWVcbiAgICAgICAgaWYgKHBpcGVzKSB7XG4gICAgICAgICAgICB2YXIgcGlwZXNCeU5hbWVfMSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHBpcGVzLmZvckVhY2goZnVuY3Rpb24gKHBpcGUpIHsgcmV0dXJuIHBpcGVzQnlOYW1lXzEuc2V0KHBpcGUubmFtZSwgcGlwZSk7IH0pO1xuICAgICAgICAgICAgdGhpcy5waXBlc0J5TmFtZSA9IHBpcGVzQnlOYW1lXzE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLCBcImludGVycG9sYXRpb25Db25maWdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2ludGVycG9sYXRpb25Db25maWc7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLmdldFVzZWRQaXBlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fdXNlZFBpcGVzLnZhbHVlcygpKTsgfTtcbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVCb3VuZEhvc3RQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGRpck1ldGEsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGRpck1ldGEuaG9zdFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciBib3VuZFByb3BzXzEgPSBbXTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRpck1ldGEuaG9zdFByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBkaXJNZXRhLmhvc3RQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBhcnNlUHJvcGVydHlCaW5kaW5nKHByb3BOYW1lLCBleHByZXNzaW9uLCB0cnVlLCBzb3VyY2VTcGFuLCBzb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldCwgdW5kZWZpbmVkLCBbXSwgYm91bmRQcm9wc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlZhbHVlIG9mIHRoZSBob3N0IHByb3BlcnR5IGJpbmRpbmcgXFxcIlwiICsgcHJvcE5hbWUgKyBcIlxcXCIgbmVlZHMgdG8gYmUgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGV4cHJlc3Npb24gYnV0IGdvdCBcXFwiXCIgKyBleHByZXNzaW9uICsgXCJcXFwiIChcIiArIHR5cGVvZiBleHByZXNzaW9uICsgXCIpXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJvdW5kUHJvcHNfMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLmNyZWF0ZURpcmVjdGl2ZUhvc3RQcm9wZXJ0eUFzdHMgPSBmdW5jdGlvbiAoZGlyTWV0YSwgZWxlbWVudFNlbGVjdG9yLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBib3VuZFByb3BzID0gdGhpcy5jcmVhdGVCb3VuZEhvc3RQcm9wZXJ0aWVzKGRpck1ldGEsIHNvdXJjZVNwYW4pO1xuICAgICAgICByZXR1cm4gYm91bmRQcm9wcyAmJlxuICAgICAgICAgICAgYm91bmRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIF90aGlzLmNyZWF0ZUJvdW5kRWxlbWVudFByb3BlcnR5KGVsZW1lbnRTZWxlY3RvciwgcHJvcCk7IH0pO1xuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuY3JlYXRlRGlyZWN0aXZlSG9zdEV2ZW50QXN0cyA9IGZ1bmN0aW9uIChkaXJNZXRhLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChkaXJNZXRhLmhvc3RMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRFdmVudHNfMSA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGlyTWV0YS5ob3N0TGlzdGVuZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gZGlyTWV0YS5ob3N0TGlzdGVuZXJzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHBhc3MgYSBtb3JlIGFjY3VyYXRlIGhhbmRsZXJTcGFuIGZvciB0aGlzIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXJzZUV2ZW50KHByb3BOYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBzb3VyY2VTcGFuLCBbXSwgdGFyZ2V0RXZlbnRzXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVmFsdWUgb2YgdGhlIGhvc3QgbGlzdGVuZXIgXFxcIlwiICsgcHJvcE5hbWUgKyBcIlxcXCIgbmVlZHMgdG8gYmUgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGV4cHJlc3Npb24gYnV0IGdvdCBcXFwiXCIgKyBleHByZXNzaW9uICsgXCJcXFwiIChcIiArIHR5cGVvZiBleHByZXNzaW9uICsgXCIpXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldEV2ZW50c18xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX2V4cHJQYXJzZXIucGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlLCBzb3VyY2VJbmZvLCBzb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldCwgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoYXN0KVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMoYXN0LmVycm9ycywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1BpcGVzKGFzdCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvLCBzb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFBhcnNlIGFuIGlubGluZSB0ZW1wbGF0ZSBiaW5kaW5nLiBpZSBgPHRhZyAqdHBsS2V5PVwiPHRwbFZhbHVlPlwiPmBcbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyA9IGZ1bmN0aW9uICh0cGxLZXksIHRwbFZhbHVlLCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzLCB0YXJnZXRWYXJzKSB7XG4gICAgICAgIHZhciBiaW5kaW5ncyA9IHRoaXMuX3BhcnNlVGVtcGxhdGVCaW5kaW5ncyh0cGxLZXksIHRwbFZhbHVlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nLmtleUlzVmFyKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0VmFycy5wdXNoKG5ldyBQYXJzZWRWYXJpYWJsZShiaW5kaW5nLmtleSwgYmluZGluZy5uYW1lLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kaW5nLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KGJpbmRpbmcua2V5LCBiaW5kaW5nLmV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHVuZGVmaW5lZCwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW2JpbmRpbmcua2V5LCAnJ10pO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VMaXRlcmFsQXR0cihiaW5kaW5nLmtleSwgbnVsbCwgc291cmNlU3BhbiwgYWJzb2x1dGVPZmZzZXQsIHVuZGVmaW5lZCwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3BhcnNlVGVtcGxhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uICh0cGxLZXksIHRwbFZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdzUmVzdWx0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZVRlbXBsYXRlQmluZGluZ3ModHBsS2V5LCB0cGxWYWx1ZSwgc291cmNlSW5mbywgc291cmNlU3Bhbi5zdGFydC5vZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhiaW5kaW5nc1Jlc3VsdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQudGVtcGxhdGVCaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2hlY2tQaXBlcyhiaW5kaW5nLmV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQud2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAod2FybmluZykgeyBfdGhpcy5fcmVwb3J0RXJyb3Iod2FybmluZywgc291cmNlU3BhbiwgUGFyc2VFcnJvckxldmVsLldBUk5JTkcpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBiaW5kaW5nc1Jlc3VsdC50ZW1wbGF0ZUJpbmRpbmdzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlTGl0ZXJhbEF0dHIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIGFic29sdXRlT2Zmc2V0LCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICBpZiAoaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJBc3NpZ25pbmcgYW5pbWF0aW9uIHRyaWdnZXJzIHZpYSBAcHJvcD1cXFwiZXhwXFxcIiBhdHRyaWJ1dGVzIHdpdGggYW4gZXhwcmVzc2lvbiBpcyBpbnZhbGlkLlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgVXNlIHByb3BlcnR5IGJpbmRpbmdzIChlLmcuIFtAcHJvcF09XFxcImV4cFxcXCIpIG9yIHVzZSBhbiBhdHRyaWJ1dGUgd2l0aG91dCBhIHZhbHVlIChlLmcuIEBwcm9wKSBpbnN0ZWFkLlwiLCBzb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb24obmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIGFic29sdXRlT2Zmc2V0LCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBQYXJzZWRQcm9wZXJ0eShuYW1lLCB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKHZhbHVlLCAnJywgYWJzb2x1dGVPZmZzZXQpLCBQYXJzZWRQcm9wZXJ0eVR5cGUuTElURVJBTF9BVFRSLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eUJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgaXNIb3N0LCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgdmFyIGlzQW5pbWF0aW9uUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKEFOSU1BVEVfUFJPUF9QUkVGSVgpKSB7XG4gICAgICAgICAgICBpc0FuaW1hdGlvblByb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKEFOSU1BVEVfUFJPUF9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0FuaW1hdGlvbkxhYmVsKG5hbWUpKSB7XG4gICAgICAgICAgICBpc0FuaW1hdGlvblByb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FuaW1hdGlvblByb3ApIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlQW5pbWF0aW9uKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIGFic29sdXRlT2Zmc2V0LCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KG5hbWUsIHRoaXMuX3BhcnNlQmluZGluZyhleHByZXNzaW9uLCBpc0hvc3QsIHZhbHVlU3BhbiB8fCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCksIHNvdXJjZVNwYW4sIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eUludGVycG9sYXRpb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUludGVycG9sYXRpb24odmFsdWUsIHZhbHVlU3BhbiB8fCBzb3VyY2VTcGFuKTtcbiAgICAgICAgaWYgKGV4cHIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlBc3QobmFtZSwgZXhwciwgc291cmNlU3BhbiwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3BhcnNlUHJvcGVydHlBc3QgPSBmdW5jdGlvbiAobmFtZSwgYXN0LCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtuYW1lLCBhc3Quc291cmNlXSk7XG4gICAgICAgIHRhcmdldFByb3BzLnB1c2gobmV3IFBhcnNlZFByb3BlcnR5KG5hbWUsIGFzdCwgUGFyc2VkUHJvcGVydHlUeXBlLkRFRkFVTFQsIHNvdXJjZVNwYW4sIHZhbHVlU3BhbikpO1xuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3BhcnNlQW5pbWF0aW9uID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIGFic29sdXRlT2Zmc2V0LCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICAvLyBUaGlzIHdpbGwgb2NjdXIgd2hlbiBhIEB0cmlnZ2VyIGlzIG5vdCBwYWlyZWQgd2l0aCBhbiBleHByZXNzaW9uLlxuICAgICAgICAvLyBGb3IgYW5pbWF0aW9ucyBpdCBpcyB2YWxpZCB0byBub3QgaGF2ZSBhbiBleHByZXNzaW9uIHNpbmNlICovdm9pZFxuICAgICAgICAvLyBzdGF0ZXMgd2lsbCBiZSBhcHBsaWVkIGJ5IGFuZ3VsYXIgd2hlbiB0aGUgZWxlbWVudCBpcyBhdHRhY2hlZC9kZXRhY2hlZFxuICAgICAgICB2YXIgYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nKGV4cHJlc3Npb24gfHwgJ3VuZGVmaW5lZCcsIGZhbHNlLCB2YWx1ZVNwYW4gfHwgc291cmNlU3BhbiwgYWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtuYW1lLCBhc3Quc291cmNlXSk7XG4gICAgICAgIHRhcmdldFByb3BzLnB1c2gobmV3IFBhcnNlZFByb3BlcnR5KG5hbWUsIGFzdCwgUGFyc2VkUHJvcGVydHlUeXBlLkFOSU1BVElPTiwgc291cmNlU3BhbiwgdmFsdWVTcGFuKSk7XG4gICAgfTtcbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VCaW5kaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBpc0hvc3RCaW5kaW5nLCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCkge1xuICAgICAgICB2YXIgc291cmNlSW5mbyA9IChzb3VyY2VTcGFuICYmIHNvdXJjZVNwYW4uc3RhcnQgfHwgJyh1bmtub3duKScpLnRvU3RyaW5nKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYXN0ID0gaXNIb3N0QmluZGluZyA/XG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwclBhcnNlci5wYXJzZVNpbXBsZUJpbmRpbmcodmFsdWUsIHNvdXJjZUluZm8sIGFic29sdXRlT2Zmc2V0LCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwclBhcnNlci5wYXJzZUJpbmRpbmcodmFsdWUsIHNvdXJjZUluZm8sIGFic29sdXRlT2Zmc2V0LCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgIGlmIChhc3QpXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGlwZXMoYXN0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8sIGFic29sdXRlT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuY3JlYXRlQm91bmRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAoZWxlbWVudFNlbGVjdG9yLCBib3VuZFByb3AsIHNraXBWYWxpZGF0aW9uLCBtYXBQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgaWYgKHNraXBWYWxpZGF0aW9uID09PSB2b2lkIDApIHsgc2tpcFZhbGlkYXRpb24gPSBmYWxzZTsgfVxuICAgICAgICBpZiAobWFwUHJvcGVydHlOYW1lID09PSB2b2lkIDApIHsgbWFwUHJvcGVydHlOYW1lID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoYm91bmRQcm9wLmlzQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kRWxlbWVudFByb3BlcnR5KGJvdW5kUHJvcC5uYW1lLCA0IC8qIEFuaW1hdGlvbiAqLywgU2VjdXJpdHlDb250ZXh0Lk5PTkUsIGJvdW5kUHJvcC5leHByZXNzaW9uLCBudWxsLCBib3VuZFByb3Auc291cmNlU3BhbiwgYm91bmRQcm9wLnZhbHVlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVuaXQgPSBudWxsO1xuICAgICAgICB2YXIgYmluZGluZ1R5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBib3VuZFByb3BlcnR5TmFtZSA9IG51bGw7XG4gICAgICAgIHZhciBwYXJ0cyA9IGJvdW5kUHJvcC5uYW1lLnNwbGl0KFBST1BFUlRZX1BBUlRTX1NFUEFSQVRPUik7XG4gICAgICAgIHZhciBzZWN1cml0eUNvbnRleHRzID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBDaGVjayBmb3Igc3BlY2lhbCBjYXNlcyAocHJlZml4IHN0eWxlLCBhdHRyLCBjbGFzcylcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0c1swXSA9PSBBVFRSSUJVVEVfUFJFRklYKSB7XG4gICAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgICBpZiAoIXNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlUHJvcGVydHlPckF0dHJpYnV0ZU5hbWUoYm91bmRQcm9wZXJ0eU5hbWUsIGJvdW5kUHJvcC5zb3VyY2VTcGFuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cyA9IGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHModGhpcy5fc2NoZW1hUmVnaXN0cnksIGVsZW1lbnRTZWxlY3RvciwgYm91bmRQcm9wZXJ0eU5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBuc1NlcGFyYXRvcklkeCA9IGJvdW5kUHJvcGVydHlOYW1lLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAobnNTZXBhcmF0b3JJZHggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnMgPSBib3VuZFByb3BlcnR5TmFtZS5zdWJzdHJpbmcoMCwgbnNTZXBhcmF0b3JJZHgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gYm91bmRQcm9wZXJ0eU5hbWUuc3Vic3RyaW5nKG5zU2VwYXJhdG9ySWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gbWVyZ2VOc0FuZE5hbWUobnMsIG5hbWVfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gMSAvKiBBdHRyaWJ1dGUgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1swXSA9PSBDTEFTU19QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gMiAvKiBDbGFzcyAqLztcbiAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzID0gW1NlY3VyaXR5Q29udGV4dC5OT05FXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzWzBdID09IFNUWUxFX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSBwYXJ0cy5sZW5ndGggPiAyID8gcGFydHNbMl0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgYmluZGluZ1R5cGUgPSAzIC8qIFN0eWxlICovO1xuICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMgPSBbU2VjdXJpdHlDb250ZXh0LlNUWUxFXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBub3QgYSBzcGVjaWFsIGNhc2UsIHVzZSB0aGUgZnVsbCBwcm9wZXJ0eSBuYW1lXG4gICAgICAgIGlmIChib3VuZFByb3BlcnR5TmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG1hcHBlZFByb3BOYW1lID0gdGhpcy5fc2NoZW1hUmVnaXN0cnkuZ2V0TWFwcGVkUHJvcE5hbWUoYm91bmRQcm9wLm5hbWUpO1xuICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBtYXBQcm9wZXJ0eU5hbWUgPyBtYXBwZWRQcm9wTmFtZSA6IGJvdW5kUHJvcC5uYW1lO1xuICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cyA9IGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHModGhpcy5fc2NoZW1hUmVnaXN0cnksIGVsZW1lbnRTZWxlY3RvciwgbWFwcGVkUHJvcE5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gMCAvKiBQcm9wZXJ0eSAqLztcbiAgICAgICAgICAgIGlmICghc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZVByb3BlcnR5T3JBdHRyaWJ1dGVOYW1lKG1hcHBlZFByb3BOYW1lLCBib3VuZFByb3Auc291cmNlU3BhbiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRFbGVtZW50UHJvcGVydHkoYm91bmRQcm9wZXJ0eU5hbWUsIGJpbmRpbmdUeXBlLCBzZWN1cml0eUNvbnRleHRzWzBdLCBib3VuZFByb3AuZXhwcmVzc2lvbiwgdW5pdCwgYm91bmRQcm9wLnNvdXJjZVNwYW4sIGJvdW5kUHJvcC52YWx1ZVNwYW4pO1xuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBoYW5kbGVyU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cykge1xuICAgICAgICBpZiAoaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb25FdmVudChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBoYW5kbGVyU3BhbiwgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlUmVndWxhckV2ZW50KG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIGhhbmRsZXJTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuY2FsY1Bvc3NpYmxlU2VjdXJpdHlDb250ZXh0cyA9IGZ1bmN0aW9uIChzZWxlY3RvciwgcHJvcE5hbWUsIGlzQXR0cmlidXRlKSB7XG4gICAgICAgIHZhciBwcm9wID0gdGhpcy5fc2NoZW1hUmVnaXN0cnkuZ2V0TWFwcGVkUHJvcE5hbWUocHJvcE5hbWUpO1xuICAgICAgICByZXR1cm4gY2FsY1Bvc3NpYmxlU2VjdXJpdHlDb250ZXh0cyh0aGlzLl9zY2hlbWFSZWdpc3RyeSwgc2VsZWN0b3IsIHByb3AsIGlzQXR0cmlidXRlKTtcbiAgICB9O1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZUFuaW1hdGlvbkV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIGhhbmRsZXJTcGFuLCB0YXJnZXRFdmVudHMpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBzcGxpdEF0UGVyaW9kKG5hbWUsIFtuYW1lLCAnJ10pO1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gbWF0Y2hlc1swXTtcbiAgICAgICAgdmFyIHBoYXNlID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAocGhhc2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGhhc2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgICAgICAgICAgIHZhciBhc3QgPSB0aGlzLl9wYXJzZUFjdGlvbihleHByZXNzaW9uLCBoYW5kbGVyU3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEV2ZW50cy5wdXNoKG5ldyBQYXJzZWRFdmVudChldmVudE5hbWUsIHBoYXNlLCAxIC8qIEFuaW1hdGlvbiAqLywgYXN0LCBzb3VyY2VTcGFuLCBoYW5kbGVyU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlRoZSBwcm92aWRlZCBhbmltYXRpb24gb3V0cHV0IHBoYXNlIHZhbHVlIFxcXCJcIiArIHBoYXNlICsgXCJcXFwiIGZvciBcXFwiQFwiICsgZXZlbnROYW1lICsgXCJcXFwiIGlzIG5vdCBzdXBwb3J0ZWQgKHVzZSBzdGFydCBvciBkb25lKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlRoZSBhbmltYXRpb24gdHJpZ2dlciBvdXRwdXQgZXZlbnQgKEBcIiArIGV2ZW50TmFtZSArIFwiKSBpcyBtaXNzaW5nIGl0cyBwaGFzZSB2YWx1ZSBuYW1lIChzdGFydCBvciBkb25lIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3BhcnNlUmVndWxhckV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIGhhbmRsZXJTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKSB7XG4gICAgICAgIC8vIGxvbmcgZm9ybWF0OiAndGFyZ2V0OiBldmVudE5hbWUnXG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChzcGxpdEF0Q29sb24obmFtZSwgW251bGwsIG5hbWVdKSwgMiksIHRhcmdldCA9IF9hWzBdLCBldmVudE5hbWUgPSBfYVsxXTtcbiAgICAgICAgdmFyIGFzdCA9IHRoaXMuX3BhcnNlQWN0aW9uKGV4cHJlc3Npb24sIGhhbmRsZXJTcGFuKTtcbiAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbbmFtZSwgYXN0LnNvdXJjZV0pO1xuICAgICAgICB0YXJnZXRFdmVudHMucHVzaChuZXcgUGFyc2VkRXZlbnQoZXZlbnROYW1lLCB0YXJnZXQsIDAgLyogUmVndWxhciAqLywgYXN0LCBzb3VyY2VTcGFuLCBoYW5kbGVyU3BhbikpO1xuICAgICAgICAvLyBEb24ndCBkZXRlY3QgZGlyZWN0aXZlcyBmb3IgZXZlbnQgbmFtZXMgZm9yIG5vdyxcbiAgICAgICAgLy8gc28gZG9uJ3QgYWRkIHRoZSBldmVudCBuYW1lIHRvIHRoZSBtYXRjaGFibGVBdHRyc1xuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3BhcnNlQWN0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBzb3VyY2VJbmZvID0gKHNvdXJjZVNwYW4gJiYgc291cmNlU3Bhbi5zdGFydCB8fCAnKHVua25vd24nKS50b1N0cmluZygpO1xuICAgICAgICB2YXIgYWJzb2x1dGVPZmZzZXQgPSAoc291cmNlU3BhbiAmJiBzb3VyY2VTcGFuLnN0YXJ0KSA/IHNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0IDogMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBhc3QgPSB0aGlzLl9leHByUGFyc2VyLnBhcnNlQWN0aW9uKHZhbHVlLCBzb3VyY2VJbmZvLCBhYnNvbHV0ZU9mZnNldCwgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXN0IHx8IGFzdC5hc3QgaW5zdGFuY2VvZiBFbXB0eUV4cHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkVtcHR5IGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZFwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvLCBhYnNvbHV0ZU9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jaGVja1BpcGVzKGFzdCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvLCBhYnNvbHV0ZU9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBzb3VyY2VTcGFuLCBsZXZlbCkge1xuICAgICAgICBpZiAobGV2ZWwgPT09IHZvaWQgMCkgeyBsZXZlbCA9IFBhcnNlRXJyb3JMZXZlbC5FUlJPUjsgfVxuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzZUVycm9yKHNvdXJjZVNwYW4sIG1lc3NhZ2UsIGxldmVsKSk7XG4gICAgfTtcbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyA9IGZ1bmN0aW9uIChlcnJvcnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBlcnJvcnNfMSA9IF9fdmFsdWVzKGVycm9ycyksIGVycm9yc18xXzEgPSBlcnJvcnNfMS5uZXh0KCk7ICFlcnJvcnNfMV8xLmRvbmU7IGVycm9yc18xXzEgPSBlcnJvcnNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBlcnJvcnNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVycm9yLm1lc3NhZ2UsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzXzFfMSAmJiAhZXJyb3JzXzFfMS5kb25lICYmIChfYSA9IGVycm9yc18xLnJldHVybikpIF9hLmNhbGwoZXJyb3JzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBNYWtlIHN1cmUgYWxsIHRoZSB1c2VkIHBpcGVzIGFyZSBrbm93biBpbiBgdGhpcy5waXBlc0J5TmFtZWBcbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fY2hlY2tQaXBlcyA9IGZ1bmN0aW9uIChhc3QsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFzdCAmJiB0aGlzLnBpcGVzQnlOYW1lKSB7XG4gICAgICAgICAgICB2YXIgY29sbGVjdG9yID0gbmV3IFBpcGVDb2xsZWN0b3IoKTtcbiAgICAgICAgICAgIGFzdC52aXNpdChjb2xsZWN0b3IpO1xuICAgICAgICAgICAgY29sbGVjdG9yLnBpcGVzLmZvckVhY2goZnVuY3Rpb24gKGFzdCwgcGlwZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGlwZU1ldGEgPSBfdGhpcy5waXBlc0J5TmFtZS5nZXQocGlwZU5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghcGlwZU1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVGhlIHBpcGUgJ1wiICsgcGlwZU5hbWUgKyBcIicgY291bGQgbm90IGJlIGZvdW5kXCIsIG5ldyBQYXJzZVNvdXJjZVNwYW4oc291cmNlU3Bhbi5zdGFydC5tb3ZlQnkoYXN0LnNwYW4uc3RhcnQpLCBzb3VyY2VTcGFuLnN0YXJ0Lm1vdmVCeShhc3Quc3Bhbi5lbmQpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdXNlZFBpcGVzLnNldChwaXBlTmFtZSwgcGlwZU1ldGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcHJvcE5hbWUgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IC8gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gaXNBdHRyIHRydWUgd2hlbiBiaW5kaW5nIHRvIGFuIGF0dHJpYnV0ZVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl92YWxpZGF0ZVByb3BlcnR5T3JBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzb3VyY2VTcGFuLCBpc0F0dHIpIHtcbiAgICAgICAgdmFyIHJlcG9ydCA9IGlzQXR0ciA/IHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LnZhbGlkYXRlQXR0cmlidXRlKHByb3BOYW1lKSA6XG4gICAgICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeS52YWxpZGF0ZVByb3BlcnR5KHByb3BOYW1lKTtcbiAgICAgICAgaWYgKHJlcG9ydC5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IocmVwb3J0Lm1zZywgc291cmNlU3BhbiwgUGFyc2VFcnJvckxldmVsLkVSUk9SKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJpbmRpbmdQYXJzZXI7XG59KCkpO1xudmFyIFBpcGVDb2xsZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBpcGVDb2xsZWN0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGlwZUNvbGxlY3RvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnBpcGVzID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBpcGVDb2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5waXBlcy5zZXQoYXN0Lm5hbWUsIGFzdCk7XG4gICAgICAgIGFzdC5leHAudmlzaXQodGhpcyk7XG4gICAgICAgIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBQaXBlQ29sbGVjdG9yO1xufShSZWN1cnNpdmVBc3RWaXNpdG9yJDEpKTtcbmZ1bmN0aW9uIGlzQW5pbWF0aW9uTGFiZWwobmFtZSkge1xuICAgIHJldHVybiBuYW1lWzBdID09ICdAJztcbn1cbmZ1bmN0aW9uIGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHMocmVnaXN0cnksIHNlbGVjdG9yLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpIHtcbiAgICB2YXIgY3R4cyA9IFtdO1xuICAgIENzc1NlbGVjdG9yLnBhcnNlKHNlbGVjdG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgZWxlbWVudE5hbWVzID0gc2VsZWN0b3IuZWxlbWVudCA/IFtzZWxlY3Rvci5lbGVtZW50XSA6IHJlZ2lzdHJ5LmFsbEtub3duRWxlbWVudE5hbWVzKCk7XG4gICAgICAgIHZhciBub3RFbGVtZW50TmFtZXMgPSBuZXcgU2V0KHNlbGVjdG9yLm5vdFNlbGVjdG9ycy5maWx0ZXIoZnVuY3Rpb24gKHNlbGVjdG9yKSB7IHJldHVybiBzZWxlY3Rvci5pc0VsZW1lbnRTZWxlY3RvcigpOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc2VsZWN0b3IpIHsgcmV0dXJuIHNlbGVjdG9yLmVsZW1lbnQ7IH0pKTtcbiAgICAgICAgdmFyIHBvc3NpYmxlRWxlbWVudE5hbWVzID0gZWxlbWVudE5hbWVzLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudE5hbWUpIHsgcmV0dXJuICFub3RFbGVtZW50TmFtZXMuaGFzKGVsZW1lbnROYW1lKTsgfSk7XG4gICAgICAgIGN0eHMucHVzaC5hcHBseShjdHhzLCBfX3NwcmVhZChwb3NzaWJsZUVsZW1lbnROYW1lcy5tYXAoZnVuY3Rpb24gKGVsZW1lbnROYW1lKSB7IHJldHVybiByZWdpc3RyeS5zZWN1cml0eUNvbnRleHQoZWxlbWVudE5hbWUsIHByb3BOYW1lLCBpc0F0dHJpYnV0ZSk7IH0pKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGN0eHMubGVuZ3RoID09PSAwID8gW1NlY3VyaXR5Q29udGV4dC5OT05FXSA6IEFycmF5LmZyb20obmV3IFNldChjdHhzKSkuc29ydCgpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgTkdfQ09OVEVOVF9TRUxFQ1RfQVRUUiA9ICdzZWxlY3QnO1xudmFyIExJTktfRUxFTUVOVCA9ICdsaW5rJztcbnZhciBMSU5LX1NUWUxFX1JFTF9BVFRSID0gJ3JlbCc7XG52YXIgTElOS19TVFlMRV9IUkVGX0FUVFIgPSAnaHJlZic7XG52YXIgTElOS19TVFlMRV9SRUxfVkFMVUUgPSAnc3R5bGVzaGVldCc7XG52YXIgU1RZTEVfRUxFTUVOVCA9ICdzdHlsZSc7XG52YXIgU0NSSVBUX0VMRU1FTlQgPSAnc2NyaXB0JztcbnZhciBOR19OT05fQklOREFCTEVfQVRUUiA9ICduZ05vbkJpbmRhYmxlJztcbnZhciBOR19QUk9KRUNUX0FTID0gJ25nUHJvamVjdEFzJztcbmZ1bmN0aW9uIHByZXBhcnNlRWxlbWVudChhc3QpIHtcbiAgICB2YXIgc2VsZWN0QXR0ciA9IG51bGw7XG4gICAgdmFyIGhyZWZBdHRyID0gbnVsbDtcbiAgICB2YXIgcmVsQXR0ciA9IG51bGw7XG4gICAgdmFyIG5vbkJpbmRhYmxlID0gZmFsc2U7XG4gICAgdmFyIHByb2plY3RBcyA9ICcnO1xuICAgIGFzdC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgIHZhciBsY0F0dHJOYW1lID0gYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChsY0F0dHJOYW1lID09IE5HX0NPTlRFTlRfU0VMRUNUX0FUVFIpIHtcbiAgICAgICAgICAgIHNlbGVjdEF0dHIgPSBhdHRyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxjQXR0ck5hbWUgPT0gTElOS19TVFlMRV9IUkVGX0FUVFIpIHtcbiAgICAgICAgICAgIGhyZWZBdHRyID0gYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsY0F0dHJOYW1lID09IExJTktfU1RZTEVfUkVMX0FUVFIpIHtcbiAgICAgICAgICAgIHJlbEF0dHIgPSBhdHRyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF0dHIubmFtZSA9PSBOR19OT05fQklOREFCTEVfQVRUUikge1xuICAgICAgICAgICAgbm9uQmluZGFibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF0dHIubmFtZSA9PSBOR19QUk9KRUNUX0FTKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdEFzID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHNlbGVjdEF0dHIgPSBub3JtYWxpemVOZ0NvbnRlbnRTZWxlY3Qoc2VsZWN0QXR0cik7XG4gICAgdmFyIG5vZGVOYW1lID0gYXN0Lm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLk9USEVSO1xuICAgIGlmIChpc05nQ29udGVudChub2RlTmFtZSkpIHtcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGVOYW1lID09IFNUWUxFX0VMRU1FTlQpIHtcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBTQ1JJUFRfRUxFTUVOVCkge1xuICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBMSU5LX0VMRU1FTlQgJiYgcmVsQXR0ciA9PSBMSU5LX1NUWUxFX1JFTF9WQUxVRSkge1xuICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcmVwYXJzZWRFbGVtZW50KHR5cGUsIHNlbGVjdEF0dHIsIGhyZWZBdHRyLCBub25CaW5kYWJsZSwgcHJvamVjdEFzKTtcbn1cbnZhciBQcmVwYXJzZWRFbGVtZW50VHlwZTtcbihmdW5jdGlvbiAoUHJlcGFyc2VkRWxlbWVudFR5cGUpIHtcbiAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIk5HX0NPTlRFTlRcIl0gPSAwXSA9IFwiTkdfQ09OVEVOVFwiO1xuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiU1RZTEVcIl0gPSAxXSA9IFwiU1RZTEVcIjtcbiAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIlNUWUxFU0hFRVRcIl0gPSAyXSA9IFwiU1RZTEVTSEVFVFwiO1xuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiU0NSSVBUXCJdID0gM10gPSBcIlNDUklQVFwiO1xuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiT1RIRVJcIl0gPSA0XSA9IFwiT1RIRVJcIjtcbn0pKFByZXBhcnNlZEVsZW1lbnRUeXBlIHx8IChQcmVwYXJzZWRFbGVtZW50VHlwZSA9IHt9KSk7XG52YXIgUHJlcGFyc2VkRWxlbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcmVwYXJzZWRFbGVtZW50KHR5cGUsIHNlbGVjdEF0dHIsIGhyZWZBdHRyLCBub25CaW5kYWJsZSwgcHJvamVjdEFzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc2VsZWN0QXR0ciA9IHNlbGVjdEF0dHI7XG4gICAgICAgIHRoaXMuaHJlZkF0dHIgPSBocmVmQXR0cjtcbiAgICAgICAgdGhpcy5ub25CaW5kYWJsZSA9IG5vbkJpbmRhYmxlO1xuICAgICAgICB0aGlzLnByb2plY3RBcyA9IHByb2plY3RBcztcbiAgICB9XG4gICAgcmV0dXJuIFByZXBhcnNlZEVsZW1lbnQ7XG59KCkpO1xuZnVuY3Rpb24gbm9ybWFsaXplTmdDb250ZW50U2VsZWN0KHNlbGVjdEF0dHIpIHtcbiAgICBpZiAoc2VsZWN0QXR0ciA9PT0gbnVsbCB8fCBzZWxlY3RBdHRyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyonO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0QXR0cjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEJJTkRfTkFNRV9SRUdFWFAgPSAvXig/Oig/Oig/OihiaW5kLSl8KGxldC0pfChyZWYtfCMpfChvbi0pfChiaW5kb24tKXwoQCkpKC4rKSl8XFxbXFwoKFteXFwpXSspXFwpXFxdfFxcWyhbXlxcXV0rKVxcXXxcXCgoW15cXCldKylcXCkpJC87XG4vLyBHcm91cCAxID0gXCJiaW5kLVwiXG52YXIgS1dfQklORF9JRFggPSAxO1xuLy8gR3JvdXAgMiA9IFwibGV0LVwiXG52YXIgS1dfTEVUX0lEWCA9IDI7XG4vLyBHcm91cCAzID0gXCJyZWYtLyNcIlxudmFyIEtXX1JFRl9JRFggPSAzO1xuLy8gR3JvdXAgNCA9IFwib24tXCJcbnZhciBLV19PTl9JRFggPSA0O1xuLy8gR3JvdXAgNSA9IFwiYmluZG9uLVwiXG52YXIgS1dfQklORE9OX0lEWCA9IDU7XG4vLyBHcm91cCA2ID0gXCJAXCJcbnZhciBLV19BVF9JRFggPSA2O1xuLy8gR3JvdXAgNyA9IHRoZSBpZGVudGlmaWVyIGFmdGVyIFwiYmluZC1cIiwgXCJsZXQtXCIsIFwicmVmLS8jXCIsIFwib24tXCIsIFwiYmluZG9uLVwiIG9yIFwiQFwiXG52YXIgSURFTlRfS1dfSURYID0gNztcbi8vIEdyb3VwIDggPSBpZGVudGlmaWVyIGluc2lkZSBbKCldXG52YXIgSURFTlRfQkFOQU5BX0JPWF9JRFggPSA4O1xuLy8gR3JvdXAgOSA9IGlkZW50aWZpZXIgaW5zaWRlIFtdXG52YXIgSURFTlRfUFJPUEVSVFlfSURYID0gOTtcbi8vIEdyb3VwIDEwID0gaWRlbnRpZmllciBpbnNpZGUgKClcbnZhciBJREVOVF9FVkVOVF9JRFggPSAxMDtcbnZhciBURU1QTEFURV9BVFRSX1BSRUZJWCA9ICcqJztcbnZhciBDTEFTU19BVFRSID0gJ2NsYXNzJztcbnZhciBfVEVYVF9DU1NfU0VMRUNUT1I7XG5mdW5jdGlvbiBURVhUX0NTU19TRUxFQ1RPUigpIHtcbiAgICBpZiAoIV9URVhUX0NTU19TRUxFQ1RPUikge1xuICAgICAgICBfVEVYVF9DU1NfU0VMRUNUT1IgPSBDc3NTZWxlY3Rvci5wYXJzZSgnKicpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gX1RFWFRfQ1NTX1NFTEVDVE9SO1xufVxudmFyIFRlbXBsYXRlUGFyc2VFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGVtcGxhdGVQYXJzZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VFcnJvcihtZXNzYWdlLCBzcGFuLCBsZXZlbCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgbWVzc2FnZSwgbGV2ZWwpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBUZW1wbGF0ZVBhcnNlRXJyb3I7XG59KFBhcnNlRXJyb3IpKTtcbnZhciBUZW1wbGF0ZVBhcnNlUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VSZXN1bHQodGVtcGxhdGVBc3QsIHVzZWRQaXBlcywgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVBc3QgPSB0ZW1wbGF0ZUFzdDtcbiAgICAgICAgdGhpcy51c2VkUGlwZXMgPSB1c2VkUGlwZXM7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gVGVtcGxhdGVQYXJzZVJlc3VsdDtcbn0oKSk7XG52YXIgVGVtcGxhdGVQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVtcGxhdGVQYXJzZXIoX2NvbmZpZywgX3JlZmxlY3RvciwgX2V4cHJQYXJzZXIsIF9zY2hlbWFSZWdpc3RyeSwgX2h0bWxQYXJzZXIsIF9jb25zb2xlLCB0cmFuc2Zvcm1zKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgICAgIHRoaXMuX2V4cHJQYXJzZXIgPSBfZXhwclBhcnNlcjtcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgdGhpcy5fY29uc29sZSA9IF9jb25zb2xlO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1zO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLCBcImV4cHJlc3Npb25QYXJzZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXI7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIHRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcywgdGVtcGxhdGVVcmwsIHByZXNlcnZlV2hpdGVzcGFjZXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMudHJ5UGFyc2UoY29tcG9uZW50LCB0ZW1wbGF0ZSwgZGlyZWN0aXZlcywgcGlwZXMsIHNjaGVtYXMsIHRlbXBsYXRlVXJsLCBwcmVzZXJ2ZVdoaXRlc3BhY2VzKTtcbiAgICAgICAgdmFyIHdhcm5pbmdzID0gcmVzdWx0LmVycm9ycy5maWx0ZXIoZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBlcnJvci5sZXZlbCA9PT0gUGFyc2VFcnJvckxldmVsLldBUk5JTkc7IH0pO1xuICAgICAgICB2YXIgZXJyb3JzID0gcmVzdWx0LmVycm9ycy5maWx0ZXIoZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBlcnJvci5sZXZlbCA9PT0gUGFyc2VFcnJvckxldmVsLkVSUk9SOyB9KTtcbiAgICAgICAgaWYgKHdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUud2FybihcIlRlbXBsYXRlIHBhcnNlIHdhcm5pbmdzOlxcblwiICsgd2FybmluZ3Muam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGVycm9yU3RyaW5nID0gZXJyb3JzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCJUZW1wbGF0ZSBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvclN0cmluZywgZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0ZW1wbGF0ZTogcmVzdWx0LnRlbXBsYXRlQXN0LCBwaXBlczogcmVzdWx0LnVzZWRQaXBlcyB9O1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLnRyeVBhcnNlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgdGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCB0ZW1wbGF0ZVVybCwgcHJlc2VydmVXaGl0ZXNwYWNlcykge1xuICAgICAgICB2YXIgaHRtbFBhcnNlUmVzdWx0ID0gdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCwge1xuICAgICAgICAgICAgICAgIHRva2VuaXplRXhwYW5zaW9uRm9ybXM6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbkNvbmZpZzogdGhpcy5nZXRJbnRlcnBvbGF0aW9uQ29uZmlnKGNvbXBvbmVudClcbiAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgIHRlbXBsYXRlO1xuICAgICAgICBpZiAoIXByZXNlcnZlV2hpdGVzcGFjZXMpIHtcbiAgICAgICAgICAgIGh0bWxQYXJzZVJlc3VsdCA9IHJlbW92ZVdoaXRlc3BhY2VzKGh0bWxQYXJzZVJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHJ5UGFyc2VIdG1sKHRoaXMuZXhwYW5kSHRtbChodG1sUGFyc2VSZXN1bHQpLCBjb21wb25lbnQsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS50cnlQYXJzZUh0bWwgPSBmdW5jdGlvbiAoaHRtbEFzdFdpdGhFcnJvcnMsIGNvbXBvbmVudCwgZGlyZWN0aXZlcywgcGlwZXMsIHNjaGVtYXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGVycm9ycyA9IGh0bWxBc3RXaXRoRXJyb3JzLmVycm9ycztcbiAgICAgICAgdmFyIHVzZWRQaXBlcyA9IFtdO1xuICAgICAgICBpZiAoaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciB1bmlxRGlyZWN0aXZlcyA9IHJlbW92ZVN1bW1hcnlEdXBsaWNhdGVzKGRpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgdmFyIHVuaXFQaXBlcyA9IHJlbW92ZVN1bW1hcnlEdXBsaWNhdGVzKHBpcGVzKTtcbiAgICAgICAgICAgIHZhciBwcm92aWRlclZpZXdDb250ZXh0ID0gbmV3IFByb3ZpZGVyVmlld0NvbnRleHQodGhpcy5fcmVmbGVjdG9yLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgdmFyIGludGVycG9sYXRpb25Db25maWcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LnRlbXBsYXRlICYmIGNvbXBvbmVudC50ZW1wbGF0ZS5pbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGNvbXBvbmVudC50ZW1wbGF0ZS5pbnRlcnBvbGF0aW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGNvbXBvbmVudC50ZW1wbGF0ZS5pbnRlcnBvbGF0aW9uWzFdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiaW5kaW5nUGFyc2VyID0gbmV3IEJpbmRpbmdQYXJzZXIodGhpcy5fZXhwclBhcnNlciwgaW50ZXJwb2xhdGlvbkNvbmZpZywgdGhpcy5fc2NoZW1hUmVnaXN0cnksIHVuaXFQaXBlcywgZXJyb3JzKTtcbiAgICAgICAgICAgIHZhciBwYXJzZVZpc2l0b3IgPSBuZXcgVGVtcGxhdGVQYXJzZVZpc2l0b3IodGhpcy5fcmVmbGVjdG9yLCB0aGlzLl9jb25maWcsIHByb3ZpZGVyVmlld0NvbnRleHQsIHVuaXFEaXJlY3RpdmVzLCBiaW5kaW5nUGFyc2VyLCB0aGlzLl9zY2hlbWFSZWdpc3RyeSwgc2NoZW1hcywgZXJyb3JzKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZpc2l0QWxsJDEocGFyc2VWaXNpdG9yLCBodG1sQXN0V2l0aEVycm9ycy5yb290Tm9kZXMsIEVNUFRZX0VMRU1FTlRfQ09OVEVYVCk7XG4gICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIF9fc3ByZWFkKHByb3ZpZGVyVmlld0NvbnRleHQuZXJyb3JzKSk7XG4gICAgICAgICAgICB1c2VkUGlwZXMucHVzaC5hcHBseSh1c2VkUGlwZXMsIF9fc3ByZWFkKGJpbmRpbmdQYXJzZXIuZ2V0VXNlZFBpcGVzKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Fzc2VydE5vUmVmZXJlbmNlRHVwbGljYXRpb25PblRlbXBsYXRlKHJlc3VsdCwgZXJyb3JzKTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlUGFyc2VSZXN1bHQocmVzdWx0LCB1c2VkUGlwZXMsIGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3Jtcykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1zLmZvckVhY2goZnVuY3Rpb24gKHRyYW5zZm9ybSkgeyByZXN1bHQgPSB0ZW1wbGF0ZVZpc2l0QWxsKHRyYW5zZm9ybSwgcmVzdWx0KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZVBhcnNlUmVzdWx0KHJlc3VsdCwgdXNlZFBpcGVzLCBlcnJvcnMpO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLmV4cGFuZEh0bWwgPSBmdW5jdGlvbiAoaHRtbEFzdFdpdGhFcnJvcnMsIGZvcmNlZCkge1xuICAgICAgICBpZiAoZm9yY2VkID09PSB2b2lkIDApIHsgZm9yY2VkID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGVycm9ycyA9IGh0bWxBc3RXaXRoRXJyb3JzLmVycm9ycztcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPT0gMCB8fCBmb3JjZWQpIHtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJQ1UgbWVzc2FnZXMgdG8gYW5ndWxhciBkaXJlY3RpdmVzXG4gICAgICAgICAgICB2YXIgZXhwYW5kZWRIdG1sQXN0ID0gZXhwYW5kTm9kZXMoaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzKTtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgX19zcHJlYWQoZXhwYW5kZWRIdG1sQXN0LmVycm9ycykpO1xuICAgICAgICAgICAgaHRtbEFzdFdpdGhFcnJvcnMgPSBuZXcgUGFyc2VUcmVlUmVzdWx0KGV4cGFuZGVkSHRtbEFzdC5ub2RlcywgZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbEFzdFdpdGhFcnJvcnM7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUuZ2V0SW50ZXJwb2xhdGlvbkNvbmZpZyA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudC50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEludGVycG9sYXRpb25Db25maWcuZnJvbUFycmF5KGNvbXBvbmVudC50ZW1wbGF0ZS5pbnRlcnBvbGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS5fYXNzZXJ0Tm9SZWZlcmVuY2VEdXBsaWNhdGlvbk9uVGVtcGxhdGUgPSBmdW5jdGlvbiAocmVzdWx0LCBlcnJvcnMpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nUmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiAhIWVsZW1lbnQucmVmZXJlbmNlczsgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LnJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAocmVmZXJlbmNlKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHJlZmVyZW5jZS5uYW1lO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nUmVmZXJlbmNlcy5pbmRleE9mKG5hbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nUmVmZXJlbmNlcy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IFRlbXBsYXRlUGFyc2VFcnJvcihcIlJlZmVyZW5jZSBcXFwiI1wiICsgbmFtZSArIFwiXFxcIiBpcyBkZWZpbmVkIHNldmVyYWwgdGltZXNcIiwgcmVmZXJlbmNlLnNvdXJjZVNwYW4sIFBhcnNlRXJyb3JMZXZlbC5FUlJPUik7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGVtcGxhdGVQYXJzZXI7XG59KCkpO1xudmFyIFRlbXBsYXRlUGFyc2VWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VWaXNpdG9yKHJlZmxlY3RvciwgY29uZmlnLCBwcm92aWRlclZpZXdDb250ZXh0LCBkaXJlY3RpdmVzLCBfYmluZGluZ1BhcnNlciwgX3NjaGVtYVJlZ2lzdHJ5LCBfc2NoZW1hcywgX3RhcmdldEVycm9ycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlZmxlY3RvciA9IHJlZmxlY3RvcjtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMucHJvdmlkZXJWaWV3Q29udGV4dCA9IHByb3ZpZGVyVmlld0NvbnRleHQ7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIgPSBfYmluZGluZ1BhcnNlcjtcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuX3NjaGVtYXMgPSBfc2NoZW1hcztcbiAgICAgICAgdGhpcy5fdGFyZ2V0RXJyb3JzID0gX3RhcmdldEVycm9ycztcbiAgICAgICAgdGhpcy5zZWxlY3Rvck1hdGNoZXIgPSBuZXcgU2VsZWN0b3JNYXRjaGVyKCk7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlc0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm5nQ29udGVudENvdW50ID0gMDtcbiAgICAgICAgLy8gTm90ZTogcXVlcmllcyBzdGFydCB3aXRoIGlkIDEgc28gd2UgY2FuIHVzZSB0aGUgbnVtYmVyIGluIGEgQmxvb20gZmlsdGVyIVxuICAgICAgICB0aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQgPSBwcm92aWRlclZpZXdDb250ZXh0LmNvbXBvbmVudC52aWV3UXVlcmllcy5sZW5ndGggKyAxO1xuICAgICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IENzc1NlbGVjdG9yLnBhcnNlKGRpcmVjdGl2ZS5zZWxlY3Rvcik7XG4gICAgICAgICAgICBfdGhpcy5zZWxlY3Rvck1hdGNoZXIuYWRkU2VsZWN0YWJsZXMoc2VsZWN0b3IsIGRpcmVjdGl2ZSk7XG4gICAgICAgICAgICBfdGhpcy5kaXJlY3RpdmVzSW5kZXguc2V0KGRpcmVjdGl2ZSwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIG5nQ29udGVudEluZGV4ID0gcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChURVhUX0NTU19TRUxFQ1RPUigpKTtcbiAgICAgICAgdmFyIHZhbHVlTm9OZ3NwID0gcmVwbGFjZU5nc3AodGV4dC52YWx1ZSk7XG4gICAgICAgIHZhciBleHByID0gdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUludGVycG9sYXRpb24odmFsdWVOb05nc3AsIHRleHQuc291cmNlU3Bhbik7XG4gICAgICAgIHJldHVybiBleHByID8gbmV3IEJvdW5kVGV4dEFzdChleHByLCBuZ0NvbnRlbnRJbmRleCwgdGV4dC5zb3VyY2VTcGFuKSA6XG4gICAgICAgICAgICBuZXcgVGV4dEFzdCh2YWx1ZU5vTmdzcCwgbmdDb250ZW50SW5kZXgsIHRleHQuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0ckFzdChhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlLCBhdHRyaWJ1dGUuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHF1ZXJ5U3RhcnRJbmRleCA9IHRoaXMuY29udGVudFF1ZXJ5U3RhcnRJZDtcbiAgICAgICAgdmFyIGVsTmFtZSA9IGVsZW1lbnQubmFtZTtcbiAgICAgICAgdmFyIHByZXBhcnNlZEVsZW1lbnQgPSBwcmVwYXJzZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRSkge1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHNjcmlwdD4gZm9yIHNlY3VyaXR5IHJlYXNvbnNcbiAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzdHlsZT4gYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxuICAgICAgICAgICAgLy8gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQgJiZcbiAgICAgICAgICAgIGlzU3R5bGVVcmxSZXNvbHZhYmxlKHByZXBhcnNlZEVsZW1lbnQuaHJlZkF0dHIpKSB7XG4gICAgICAgICAgICAvLyBTa2lwcGluZyBzdHlsZXNoZWV0cyB3aXRoIGVpdGhlciByZWxhdGl2ZSB1cmxzIG9yIHBhY2thZ2Ugc2NoZW1lIGFzIHdlIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICAgICAgICAvLyB0aGVtIGluIHRoZSBTdHlsZUNvbXBpbGVyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hhYmxlQXR0cnMgPSBbXTtcbiAgICAgICAgdmFyIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzID0gW107XG4gICAgICAgIHZhciBlbGVtZW50T3JEaXJlY3RpdmVSZWZzID0gW107XG4gICAgICAgIHZhciBlbGVtZW50VmFycyA9IFtdO1xuICAgICAgICB2YXIgZXZlbnRzID0gW107XG4gICAgICAgIHZhciB0ZW1wbGF0ZUVsZW1lbnRPckRpcmVjdGl2ZVByb3BzID0gW107XG4gICAgICAgIHZhciB0ZW1wbGF0ZU1hdGNoYWJsZUF0dHJzID0gW107XG4gICAgICAgIHZhciB0ZW1wbGF0ZUVsZW1lbnRWYXJzID0gW107XG4gICAgICAgIHZhciBoYXNJbmxpbmVUZW1wbGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGF0dHJzID0gW107XG4gICAgICAgIHZhciBpc1RlbXBsYXRlRWxlbWVudCA9IGlzTmdUZW1wbGF0ZShlbGVtZW50Lm5hbWUpO1xuICAgICAgICBlbGVtZW50LmF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWRWYXJpYWJsZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBoYXNCaW5kaW5nID0gX3RoaXMuX3BhcnNlQXR0cihpc1RlbXBsYXRlRWxlbWVudCwgYXR0ciwgbWF0Y2hhYmxlQXR0cnMsIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBldmVudHMsIGVsZW1lbnRPckRpcmVjdGl2ZVJlZnMsIGVsZW1lbnRWYXJzKTtcbiAgICAgICAgICAgIGVsZW1lbnRWYXJzLnB1c2guYXBwbHkoZWxlbWVudFZhcnMsIF9fc3ByZWFkKHBhcnNlZFZhcmlhYmxlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFZhcmlhYmxlQXN0LmZyb21QYXJzZWRWYXJpYWJsZSh2KTsgfSkpKTtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVZhbHVlO1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlS2V5O1xuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gX3RoaXMuX25vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0ci5uYW1lKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkTmFtZS5zdGFydHNXaXRoKFRFTVBMQVRFX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlS2V5ID0gbm9ybWFsaXplZE5hbWUuc3Vic3RyaW5nKFRFTVBMQVRFX0FUVFJfUFJFRklYLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaGFzVGVtcGxhdGVCaW5kaW5nID0gdGVtcGxhdGVWYWx1ZSAhPSBudWxsO1xuICAgICAgICAgICAgaWYgKGhhc1RlbXBsYXRlQmluZGluZykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNJbmxpbmVUZW1wbGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiQ2FuJ3QgaGF2ZSBtdWx0aXBsZSB0ZW1wbGF0ZSBiaW5kaW5ncyBvbiBvbmUgZWxlbWVudC4gVXNlIG9ubHkgb25lIGF0dHJpYnV0ZSBwcmVmaXhlZCB3aXRoICpcIiwgYXR0ci5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFzSW5saW5lVGVtcGxhdGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkVmFyaWFibGVzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyh0ZW1wbGF0ZUtleSwgdGVtcGxhdGVWYWx1ZSwgYXR0ci5zb3VyY2VTcGFuLCBhdHRyLnNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0LCB0ZW1wbGF0ZU1hdGNoYWJsZUF0dHJzLCB0ZW1wbGF0ZUVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBwYXJzZWRWYXJpYWJsZXNfMSk7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVFbGVtZW50VmFycy5wdXNoLmFwcGx5KHRlbXBsYXRlRWxlbWVudFZhcnMsIF9fc3ByZWFkKHBhcnNlZFZhcmlhYmxlc18xLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gVmFyaWFibGVBc3QuZnJvbVBhcnNlZFZhcmlhYmxlKHYpOyB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNCaW5kaW5nICYmICFoYXNUZW1wbGF0ZUJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBpbmNsdWRlIHRoZSBiaW5kaW5ncyBhcyBhdHRyaWJ1dGVzIGFzIHdlbGwgaW4gdGhlIEFTVFxuICAgICAgICAgICAgICAgIGF0dHJzLnB1c2goX3RoaXMudmlzaXRBdHRyaWJ1dGUoYXR0ciwgbnVsbCkpO1xuICAgICAgICAgICAgICAgIG1hdGNoYWJsZUF0dHJzLnB1c2goW2F0dHIubmFtZSwgYXR0ci52YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGVsZW1lbnRDc3NTZWxlY3RvciA9IGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3RvcihlbE5hbWUsIG1hdGNoYWJsZUF0dHJzKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fcGFyc2VEaXJlY3RpdmVzKHRoaXMuc2VsZWN0b3JNYXRjaGVyLCBlbGVtZW50Q3NzU2VsZWN0b3IpLCBkaXJlY3RpdmVNZXRhcyA9IF9hLmRpcmVjdGl2ZXMsIG1hdGNoRWxlbWVudCA9IF9hLm1hdGNoRWxlbWVudDtcbiAgICAgICAgdmFyIHJlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgdmFyIGJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgZGlyZWN0aXZlQXN0cyA9IHRoaXMuX2NyZWF0ZURpcmVjdGl2ZUFzdHMoaXNUZW1wbGF0ZUVsZW1lbnQsIGVsZW1lbnQubmFtZSwgZGlyZWN0aXZlTWV0YXMsIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLCBlbGVtZW50LnNvdXJjZVNwYW4sIHJlZmVyZW5jZXMsIGJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzKTtcbiAgICAgICAgdmFyIGVsZW1lbnRQcm9wcyA9IHRoaXMuX2NyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdHMoZWxlbWVudC5uYW1lLCBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgYm91bmREaXJlY3RpdmVQcm9wTmFtZXMpO1xuICAgICAgICB2YXIgaXNWaWV3Um9vdCA9IHBhcmVudC5pc1RlbXBsYXRlRWxlbWVudCB8fCBoYXNJbmxpbmVUZW1wbGF0ZXM7XG4gICAgICAgIHZhciBwcm92aWRlckNvbnRleHQgPSBuZXcgUHJvdmlkZXJFbGVtZW50Q29udGV4dCh0aGlzLnByb3ZpZGVyVmlld0NvbnRleHQsIHBhcmVudC5wcm92aWRlckNvbnRleHQsIGlzVmlld1Jvb3QsIGRpcmVjdGl2ZUFzdHMsIGF0dHJzLCByZWZlcmVuY2VzLCBpc1RlbXBsYXRlRWxlbWVudCwgcXVlcnlTdGFydEluZGV4LCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB2aXNpdEFsbCQxKHByZXBhcnNlZEVsZW1lbnQubm9uQmluZGFibGUgPyBOT05fQklOREFCTEVfVklTSVRPUiA6IHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIEVsZW1lbnRDb250ZXh0LmNyZWF0ZShpc1RlbXBsYXRlRWxlbWVudCwgZGlyZWN0aXZlQXN0cywgaXNUZW1wbGF0ZUVsZW1lbnQgPyBwYXJlbnQucHJvdmlkZXJDb250ZXh0IDogcHJvdmlkZXJDb250ZXh0KSk7XG4gICAgICAgIHByb3ZpZGVyQ29udGV4dC5hZnRlckVsZW1lbnQoKTtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGFjdHVhbCBzZWxlY3RvciB3aGVuIHRoZSBgbmdQcm9qZWN0QXNgIGF0dHJpYnV0ZSBpcyBwcm92aWRlZFxuICAgICAgICB2YXIgcHJvamVjdGlvblNlbGVjdG9yID0gcHJlcGFyc2VkRWxlbWVudC5wcm9qZWN0QXMgIT0gJycgP1xuICAgICAgICAgICAgQ3NzU2VsZWN0b3IucGFyc2UocHJlcGFyc2VkRWxlbWVudC5wcm9qZWN0QXMpWzBdIDpcbiAgICAgICAgICAgIGVsZW1lbnRDc3NTZWxlY3RvcjtcbiAgICAgICAgdmFyIG5nQ29udGVudEluZGV4ID0gcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChwcm9qZWN0aW9uU2VsZWN0b3IpO1xuICAgICAgICB2YXIgcGFyc2VkRWxlbWVudDtcbiAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuTkdfQ09OVEVOVCkge1xuICAgICAgICAgICAgLy8gYDxuZy1jb250ZW50PmAgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGRyZW4gJiYgIWVsZW1lbnQuY2hpbGRyZW4uZXZlcnkoX2lzRW1wdHlUZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIjxuZy1jb250ZW50PiBlbGVtZW50IGNhbm5vdCBoYXZlIGNvbnRlbnQuXCIsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IE5nQ29udGVudEFzdCh0aGlzLm5nQ29udGVudENvdW50KyssIGhhc0lubGluZVRlbXBsYXRlcyA/IG51bGwgOiBuZ0NvbnRlbnRJbmRleCwgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1RlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gYDxuZy10ZW1wbGF0ZT5gIGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydEFsbEV2ZW50c1B1Ymxpc2hlZEJ5RGlyZWN0aXZlcyhkaXJlY3RpdmVBc3RzLCBldmVudHMpO1xuICAgICAgICAgICAgdGhpcy5fYXNzZXJ0Tm9Db21wb25lbnRzTm9yRWxlbWVudEJpbmRpbmdzT25UZW1wbGF0ZShkaXJlY3RpdmVBc3RzLCBlbGVtZW50UHJvcHMsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IEVtYmVkZGVkVGVtcGxhdGVBc3QoYXR0cnMsIGV2ZW50cywgcmVmZXJlbmNlcywgZWxlbWVudFZhcnMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZERpcmVjdGl2ZUFzdHMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1Qcm92aWRlcnMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZEhhc1ZpZXdDb250YWluZXIsIHByb3ZpZGVyQ29udGV4dC5xdWVyeU1hdGNoZXMsIGNoaWxkcmVuLCBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogbmdDb250ZW50SW5kZXgsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlbGVtZW50IG90aGVyIHRoYW4gYDxuZy1jb250ZW50PmAgYW5kIGA8bmctdGVtcGxhdGU+YFxuICAgICAgICAgICAgdGhpcy5fYXNzZXJ0RWxlbWVudEV4aXN0cyhtYXRjaEVsZW1lbnQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fYXNzZXJ0T25seU9uZUNvbXBvbmVudChkaXJlY3RpdmVBc3RzLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgdmFyIG5nQ29udGVudEluZGV4XzEgPSBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChwcm9qZWN0aW9uU2VsZWN0b3IpO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbGVtZW50QXN0KGVsTmFtZSwgYXR0cnMsIGVsZW1lbnRQcm9wcywgZXZlbnRzLCByZWZlcmVuY2VzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtUHJvdmlkZXJzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyLCBwcm92aWRlckNvbnRleHQucXVlcnlNYXRjaGVzLCBjaGlsZHJlbiwgaGFzSW5saW5lVGVtcGxhdGVzID8gbnVsbCA6IG5nQ29udGVudEluZGV4XzEsIGVsZW1lbnQuc291cmNlU3BhbiwgZWxlbWVudC5lbmRTb3VyY2VTcGFuIHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNJbmxpbmVUZW1wbGF0ZXMpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGFzIGEgKi1hdHRyaWJ1dGVcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVF1ZXJ5U3RhcnRJbmRleCA9IHRoaXMuY29udGVudFF1ZXJ5U3RhcnRJZDtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVNlbGVjdG9yID0gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKCduZy10ZW1wbGF0ZScsIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMpO1xuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSB0aGlzLl9wYXJzZURpcmVjdGl2ZXModGhpcy5zZWxlY3Rvck1hdGNoZXIsIHRlbXBsYXRlU2VsZWN0b3IpLmRpcmVjdGl2ZXM7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVCb3VuZERpcmVjdGl2ZVByb3BOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZURpcmVjdGl2ZUFzdHMgPSB0aGlzLl9jcmVhdGVEaXJlY3RpdmVBc3RzKHRydWUsIGVsTmFtZSwgZGlyZWN0aXZlcywgdGVtcGxhdGVFbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgW10sIGVsZW1lbnQuc291cmNlU3BhbiwgW10sIHRlbXBsYXRlQm91bmREaXJlY3RpdmVQcm9wTmFtZXMpO1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlRWxlbWVudFByb3BzID0gdGhpcy5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyhlbE5hbWUsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIHRlbXBsYXRlQm91bmREaXJlY3RpdmVQcm9wTmFtZXMpO1xuICAgICAgICAgICAgdGhpcy5fYXNzZXJ0Tm9Db21wb25lbnRzTm9yRWxlbWVudEJpbmRpbmdzT25UZW1wbGF0ZSh0ZW1wbGF0ZURpcmVjdGl2ZUFzdHMsIHRlbXBsYXRlRWxlbWVudFByb3BzLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0ID0gbmV3IFByb3ZpZGVyRWxlbWVudENvbnRleHQodGhpcy5wcm92aWRlclZpZXdDb250ZXh0LCBwYXJlbnQucHJvdmlkZXJDb250ZXh0LCBwYXJlbnQuaXNUZW1wbGF0ZUVsZW1lbnQsIHRlbXBsYXRlRGlyZWN0aXZlQXN0cywgW10sIFtdLCB0cnVlLCB0ZW1wbGF0ZVF1ZXJ5U3RhcnRJbmRleCwgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0LmFmdGVyRWxlbWVudCgpO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbWJlZGRlZFRlbXBsYXRlQXN0KFtdLCBbXSwgW10sIHRlbXBsYXRlRWxlbWVudFZhcnMsIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybWVkRGlyZWN0aXZlQXN0cywgdGVtcGxhdGVQcm92aWRlckNvbnRleHQudHJhbnNmb3JtUHJvdmlkZXJzLCB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZEhhc1ZpZXdDb250YWluZXIsIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0LnF1ZXJ5TWF0Y2hlcywgW3BhcnNlZEVsZW1lbnRdLCBuZ0NvbnRlbnRJbmRleCwgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkRWxlbWVudDtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VBdHRyID0gZnVuY3Rpb24gKGlzVGVtcGxhdGVFbGVtZW50LCBhdHRyLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIHRhcmdldEV2ZW50cywgdGFyZ2V0UmVmcywgdGFyZ2V0VmFycykge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuX25vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0ci5uYW1lKTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICAgICAgdmFyIHNyY1NwYW4gPSBhdHRyLnNvdXJjZVNwYW47XG4gICAgICAgIHZhciBhYnNvbHV0ZU9mZnNldCA9IGF0dHIudmFsdWVTcGFuID8gYXR0ci52YWx1ZVNwYW4uc3RhcnQub2Zmc2V0IDogc3JjU3Bhbi5zdGFydC5vZmZzZXQ7XG4gICAgICAgIHZhciBib3VuZEV2ZW50cyA9IFtdO1xuICAgICAgICB2YXIgYmluZFBhcnRzID0gbmFtZS5tYXRjaChCSU5EX05BTUVfUkVHRVhQKTtcbiAgICAgICAgdmFyIGhhc0JpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGJpbmRQYXJ0cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaGFzQmluZGluZyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoYmluZFBhcnRzW0tXX0JJTkRfSURYXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCBhYnNvbHV0ZU9mZnNldCwgYXR0ci52YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfTEVUX0lEWF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBiaW5kUGFydHNbSURFTlRfS1dfSURYXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VWYXJpYWJsZShpZGVudGlmaWVyLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0VmFycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlxcXCJsZXQtXFxcIiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBuZy10ZW1wbGF0ZSBlbGVtZW50cy5cIiwgc3JjU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX1JFRl9JRFhdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBiaW5kUGFydHNbSURFTlRfS1dfSURYXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVJlZmVyZW5jZShpZGVudGlmaWVyLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0UmVmcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfT05fSURYXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VFdmVudChiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIHNyY1NwYW4sIGF0dHIudmFsdWVTcGFuIHx8IHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCBib3VuZEV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfQklORE9OX0lEWF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlCaW5kaW5nKGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIGFic29sdXRlT2Zmc2V0LCBhdHRyLnZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFzc2lnbm1lbnRFdmVudChiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIHNyY1NwYW4sIGF0dHIudmFsdWVTcGFuIHx8IHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCBib3VuZEV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfQVRfSURYXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VMaXRlcmFsQXR0cihuYW1lLCB2YWx1ZSwgc3JjU3BhbiwgYWJzb2x1dGVPZmZzZXQsIGF0dHIudmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0lERU5UX0JBTkFOQV9CT1hfSURYXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoYmluZFBhcnRzW0lERU5UX0JBTkFOQV9CT1hfSURYXSwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCBhYnNvbHV0ZU9mZnNldCwgYXR0ci52YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBc3NpZ25tZW50RXZlbnQoYmluZFBhcnRzW0lERU5UX0JBTkFOQV9CT1hfSURYXSwgdmFsdWUsIHNyY1NwYW4sIGF0dHIudmFsdWVTcGFuIHx8IHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCBib3VuZEV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbSURFTlRfUFJPUEVSVFlfSURYXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoYmluZFBhcnRzW0lERU5UX1BST1BFUlRZX0lEWF0sIHZhbHVlLCBmYWxzZSwgc3JjU3BhbiwgYWJzb2x1dGVPZmZzZXQsIGF0dHIudmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0lERU5UX0VWRU5UX0lEWF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlRXZlbnQoYmluZFBhcnRzW0lERU5UX0VWRU5UX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCBhdHRyLnZhbHVlU3BhbiB8fCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgYm91bmRFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFzQmluZGluZyA9IHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUludGVycG9sYXRpb24obmFtZSwgdmFsdWUsIHNyY1NwYW4sIGF0dHIudmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzQmluZGluZykge1xuICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUxpdGVyYWxBdHRyKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCBhYnNvbHV0ZU9mZnNldCwgYXR0ci52YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0RXZlbnRzLnB1c2guYXBwbHkodGFyZ2V0RXZlbnRzLCBfX3NwcmVhZChib3VuZEV2ZW50cy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIEJvdW5kRXZlbnRBc3QuZnJvbVBhcnNlZEV2ZW50KGUpOyB9KSkpO1xuICAgICAgICByZXR1cm4gaGFzQmluZGluZztcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fbm9ybWFsaXplQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICByZXR1cm4gL15kYXRhLS9pLnRlc3QoYXR0ck5hbWUpID8gYXR0ck5hbWUuc3Vic3RyaW5nKDUpIDogYXR0ck5hbWU7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlVmFyaWFibGUgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4sIHRhcmdldFZhcnMpIHtcbiAgICAgICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXFxcIi1cXFwiIGlzIG5vdCBhbGxvd2VkIGluIHZhcmlhYmxlIG5hbWVzXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFZhcnMucHVzaChuZXcgVmFyaWFibGVBc3QoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4pKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VSZWZlcmVuY2UgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4sIHRhcmdldFJlZnMpIHtcbiAgICAgICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXFxcIi1cXFwiIGlzIG5vdCBhbGxvd2VkIGluIHJlZmVyZW5jZSBuYW1lc1wiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRSZWZzLnB1c2gobmV3IEVsZW1lbnRPckRpcmVjdGl2ZVJlZihpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbikpO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUFzc2lnbm1lbnRFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUV2ZW50KG5hbWUgKyBcIkNoYW5nZVwiLCBleHByZXNzaW9uICsgXCI9JGV2ZW50XCIsIHNvdXJjZVNwYW4sIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlRGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChzZWxlY3Rvck1hdGNoZXIsIGVsZW1lbnRDc3NTZWxlY3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBOZWVkIHRvIHNvcnQgdGhlIGRpcmVjdGl2ZXMgc28gdGhhdCB3ZSBnZXQgY29uc2lzdGVudCByZXN1bHRzIHRocm91Z2hvdXQsXG4gICAgICAgIC8vIGFzIHNlbGVjdG9yTWF0Y2hlciB1c2VzIE1hcHMgaW5zaWRlLlxuICAgICAgICAvLyBBbHNvIGRlZHVwbGljYXRlIGRpcmVjdGl2ZXMgYXMgdGhleSBtaWdodCBtYXRjaCBtb3JlIHRoYW4gb25lIHRpbWUhXG4gICAgICAgIHZhciBkaXJlY3RpdmVzID0gbmV3IEFycmF5KHRoaXMuZGlyZWN0aXZlc0luZGV4LnNpemUpO1xuICAgICAgICAvLyBXaGV0aGVyIGFueSBkaXJlY3RpdmUgc2VsZWN0b3IgbWF0Y2hlcyBvbiB0aGUgZWxlbWVudCBuYW1lXG4gICAgICAgIHZhciBtYXRjaEVsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgc2VsZWN0b3JNYXRjaGVyLm1hdGNoKGVsZW1lbnRDc3NTZWxlY3RvciwgZnVuY3Rpb24gKHNlbGVjdG9yLCBkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZXNbX3RoaXMuZGlyZWN0aXZlc0luZGV4LmdldChkaXJlY3RpdmUpXSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgICAgIG1hdGNoRWxlbWVudCA9IG1hdGNoRWxlbWVudCB8fCBzZWxlY3Rvci5oYXNFbGVtZW50U2VsZWN0b3IoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLmZpbHRlcihmdW5jdGlvbiAoZGlyKSB7IHJldHVybiAhIWRpcjsgfSksXG4gICAgICAgICAgICBtYXRjaEVsZW1lbnQ6IG1hdGNoRWxlbWVudCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY3JlYXRlRGlyZWN0aXZlQXN0cyA9IGZ1bmN0aW9uIChpc1RlbXBsYXRlRWxlbWVudCwgZWxlbWVudE5hbWUsIGRpcmVjdGl2ZXMsIHByb3BzLCBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLCBlbGVtZW50U291cmNlU3BhbiwgdGFyZ2V0UmVmZXJlbmNlcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wTmFtZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1hdGNoZWRSZWZlcmVuY2VzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZUFzdHMgPSBkaXJlY3RpdmVzLm1hcChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oZWxlbWVudFNvdXJjZVNwYW4uc3RhcnQsIGVsZW1lbnRTb3VyY2VTcGFuLmVuZCwgXCJEaXJlY3RpdmUgXCIgKyBpZGVudGlmaWVyTmFtZShkaXJlY3RpdmUudHlwZSkpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGRpcmVjdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmVQcm9wZXJ0aWVzID0gW107XG4gICAgICAgICAgICB2YXIgYm91bmRQcm9wZXJ0aWVzID0gX3RoaXMuX2JpbmRpbmdQYXJzZXIuY3JlYXRlRGlyZWN0aXZlSG9zdFByb3BlcnR5QXN0cyhkaXJlY3RpdmUsIGVsZW1lbnROYW1lLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHZhciBob3N0UHJvcGVydGllcyA9IGJvdW5kUHJvcGVydGllcy5tYXAoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIEJvdW5kRWxlbWVudFByb3BlcnR5QXN0LmZyb21Cb3VuZFByb3BlcnR5KHByb3ApOyB9KTtcbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIG5lZWQgdG8gY2hlY2sgdGhlIGhvc3QgcHJvcGVydGllcyBoZXJlIGFzIHdlbGwsXG4gICAgICAgICAgICAvLyBhcyB3ZSBkb24ndCBrbm93IHRoZSBlbGVtZW50IG5hbWUgaW4gdGhlIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlciB5ZXQuXG4gICAgICAgICAgICBob3N0UHJvcGVydGllcyA9IF90aGlzLl9jaGVja1Byb3BlcnRpZXNJblNjaGVtYShlbGVtZW50TmFtZSwgaG9zdFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgdmFyIHBhcnNlZEV2ZW50cyA9IF90aGlzLl9iaW5kaW5nUGFyc2VyLmNyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMoZGlyZWN0aXZlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIF90aGlzLl9jcmVhdGVEaXJlY3RpdmVQcm9wZXJ0eUFzdHMoZGlyZWN0aXZlLmlucHV0cywgcHJvcHMsIGRpcmVjdGl2ZVByb3BlcnRpZXMsIHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzKTtcbiAgICAgICAgICAgIGVsZW1lbnRPckRpcmVjdGl2ZVJlZnMuZm9yRWFjaChmdW5jdGlvbiAoZWxPckRpclJlZikge1xuICAgICAgICAgICAgICAgIGlmICgoZWxPckRpclJlZi52YWx1ZS5sZW5ndGggPT09IDAgJiYgZGlyZWN0aXZlLmlzQ29tcG9uZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoZWxPckRpclJlZi5pc1JlZmVyZW5jZVRvRGlyZWN0aXZlKGRpcmVjdGl2ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFJlZmVyZW5jZXMucHVzaChuZXcgUmVmZXJlbmNlQXN0KGVsT3JEaXJSZWYubmFtZSwgY3JlYXRlVG9rZW5Gb3JSZWZlcmVuY2UoZGlyZWN0aXZlLnR5cGUucmVmZXJlbmNlKSwgZWxPckRpclJlZi52YWx1ZSwgZWxPckRpclJlZi5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRSZWZlcmVuY2VzLmFkZChlbE9yRGlyUmVmLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGhvc3RFdmVudHMgPSBwYXJzZWRFdmVudHMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBCb3VuZEV2ZW50QXN0LmZyb21QYXJzZWRFdmVudChlKTsgfSk7XG4gICAgICAgICAgICB2YXIgY29udGVudFF1ZXJ5U3RhcnRJZCA9IF90aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQ7XG4gICAgICAgICAgICBfdGhpcy5jb250ZW50UXVlcnlTdGFydElkICs9IGRpcmVjdGl2ZS5xdWVyaWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGlyZWN0aXZlQXN0KGRpcmVjdGl2ZSwgZGlyZWN0aXZlUHJvcGVydGllcywgaG9zdFByb3BlcnRpZXMsIGhvc3RFdmVudHMsIGNvbnRlbnRRdWVyeVN0YXJ0SWQsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudE9yRGlyZWN0aXZlUmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChlbE9yRGlyUmVmKSB7XG4gICAgICAgICAgICBpZiAoZWxPckRpclJlZi52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkUmVmZXJlbmNlcy5oYXMoZWxPckRpclJlZi5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJUaGVyZSBpcyBubyBkaXJlY3RpdmUgd2l0aCBcXFwiZXhwb3J0QXNcXFwiIHNldCB0byBcXFwiXCIgKyBlbE9yRGlyUmVmLnZhbHVlICsgXCJcXFwiXCIsIGVsT3JEaXJSZWYuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHZhciByZWZUb2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZlRva2VuID0gY3JlYXRlVG9rZW5Gb3JFeHRlcm5hbFJlZmVyZW5jZShfdGhpcy5yZWZsZWN0b3IsIElkZW50aWZpZXJzLlRlbXBsYXRlUmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0UmVmZXJlbmNlcy5wdXNoKG5ldyBSZWZlcmVuY2VBc3QoZWxPckRpclJlZi5uYW1lLCByZWZUb2tlbiwgZWxPckRpclJlZi52YWx1ZSwgZWxPckRpclJlZi5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGlyZWN0aXZlQXN0cztcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY3JlYXRlRGlyZWN0aXZlUHJvcGVydHlBc3RzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZVByb3BlcnRpZXMsIGJvdW5kUHJvcHMsIHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcHMsIHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzKSB7XG4gICAgICAgIGlmIChkaXJlY3RpdmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXIgYm91bmRQcm9wc0J5TmFtZV8xID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgYm91bmRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChib3VuZFByb3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gYm91bmRQcm9wc0J5TmFtZV8xLmdldChib3VuZFByb3AubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2VmFsdWUgfHwgcHJldlZhbHVlLmlzTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBnaXZlIFthXT1cImJcIiBhIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gYT1cImJcIiBvbiB0aGUgc2FtZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcHNCeU5hbWVfMS5zZXQoYm91bmRQcm9wLm5hbWUsIGJvdW5kUHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkaXJlY3RpdmVQcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJQcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsUHJvcCA9IGRpcmVjdGl2ZVByb3BlcnRpZXNbZGlyUHJvcF07XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kUHJvcCA9IGJvdW5kUHJvcHNCeU5hbWVfMS5nZXQoZWxQcm9wKTtcbiAgICAgICAgICAgICAgICAvLyBCaW5kaW5ncyBhcmUgb3B0aW9uYWwsIHNvIHRoaXMgYmluZGluZyBvbmx5IG5lZWRzIHRvIGJlIHNldCB1cCBpZiBhbiBleHByZXNzaW9uIGlzIGdpdmVuLlxuICAgICAgICAgICAgICAgIGlmIChib3VuZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wTmFtZXMuYWRkKGJvdW5kUHJvcC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5RXhwcmVzc2lvbihib3VuZFByb3AuZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcHMucHVzaChuZXcgQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdChkaXJQcm9wLCBib3VuZFByb3AubmFtZSwgYm91bmRQcm9wLmV4cHJlc3Npb24sIGJvdW5kUHJvcC5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVFbGVtZW50UHJvcGVydHlBc3RzID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCBwcm9wcywgYm91bmREaXJlY3RpdmVQcm9wTmFtZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGJvdW5kRWxlbWVudFByb3BzID0gW107XG4gICAgICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmICghcHJvcC5pc0xpdGVyYWwgJiYgIWJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzLmhhcyhwcm9wLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kUHJvcCA9IF90aGlzLl9iaW5kaW5nUGFyc2VyLmNyZWF0ZUJvdW5kRWxlbWVudFByb3BlcnR5KGVsZW1lbnROYW1lLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBib3VuZEVsZW1lbnRQcm9wcy5wdXNoKEJvdW5kRWxlbWVudFByb3BlcnR5QXN0LmZyb21Cb3VuZFByb3BlcnR5KGJvdW5kUHJvcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrUHJvcGVydGllc0luU2NoZW1hKGVsZW1lbnROYW1lLCBib3VuZEVsZW1lbnRQcm9wcyk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2ZpbmRDb21wb25lbnREaXJlY3RpdmVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZS5kaXJlY3RpdmUuaXNDb21wb25lbnQ7IH0pO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluZENvbXBvbmVudERpcmVjdGl2ZXMoZGlyZWN0aXZlcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gaWRlbnRpZmllck5hbWUoZGlyZWN0aXZlLmRpcmVjdGl2ZS50eXBlKTsgfSk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2Fzc2VydE9ubHlPbmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcywgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgY29tcG9uZW50VHlwZU5hbWVzID0gdGhpcy5fZmluZENvbXBvbmVudERpcmVjdGl2ZU5hbWVzKGRpcmVjdGl2ZXMpO1xuICAgICAgICBpZiAoY29tcG9uZW50VHlwZU5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiTW9yZSB0aGFuIG9uZSBjb21wb25lbnQgbWF0Y2hlZCBvbiB0aGlzIGVsZW1lbnQuXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiTWFrZSBzdXJlIHRoYXQgb25seSBvbmUgY29tcG9uZW50J3Mgc2VsZWN0b3IgY2FuIG1hdGNoIGEgZ2l2ZW4gZWxlbWVudC5cXG5cIiArXG4gICAgICAgICAgICAgICAgKFwiQ29uZmxpY3RpbmcgY29tcG9uZW50czogXCIgKyBjb21wb25lbnRUeXBlTmFtZXMuam9pbignLCcpKSwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VyZSB0aGF0IG5vbi1hbmd1bGFyIHRhZ3MgY29uZm9ybSB0byB0aGUgc2NoZW1hcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IEFuIGVsZW1lbnQgaXMgY29uc2lkZXJlZCBhbiBhbmd1bGFyIHRhZyB3aGVuIGF0IGxlYXN0IG9uZSBkaXJlY3RpdmUgc2VsZWN0b3IgbWF0Y2hlcyB0aGVcbiAgICAgKiB0YWcgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtYXRjaEVsZW1lbnQgV2hldGhlciBhbnkgZGlyZWN0aXZlIGhhcyBtYXRjaGVkIG9uIHRoZSB0YWcgbmFtZVxuICAgICAqIEBwYXJhbSBlbGVtZW50IHRoZSBodG1sIGVsZW1lbnRcbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2Fzc2VydEVsZW1lbnRFeGlzdHMgPSBmdW5jdGlvbiAobWF0Y2hFbGVtZW50LCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBlbE5hbWUgPSBlbGVtZW50Lm5hbWUucmVwbGFjZSgvXjp4aHRtbDovLCAnJyk7XG4gICAgICAgIGlmICghbWF0Y2hFbGVtZW50ICYmICF0aGlzLl9zY2hlbWFSZWdpc3RyeS5oYXNFbGVtZW50KGVsTmFtZSwgdGhpcy5fc2NoZW1hcykpIHtcbiAgICAgICAgICAgIHZhciBlcnJvck1zZyA9IFwiJ1wiICsgZWxOYW1lICsgXCInIGlzIG5vdCBhIGtub3duIGVsZW1lbnQ6XFxuXCI7XG4gICAgICAgICAgICBlcnJvck1zZyArPVxuICAgICAgICAgICAgICAgIFwiMS4gSWYgJ1wiICsgZWxOYW1lICsgXCInIGlzIGFuIEFuZ3VsYXIgY29tcG9uZW50LCB0aGVuIHZlcmlmeSB0aGF0IGl0IGlzIHBhcnQgb2YgdGhpcyBtb2R1bGUuXFxuXCI7XG4gICAgICAgICAgICBpZiAoZWxOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JNc2cgKz1cbiAgICAgICAgICAgICAgICAgICAgXCIyLiBJZiAnXCIgKyBlbE5hbWUgKyBcIicgaXMgYSBXZWIgQ29tcG9uZW50IHRoZW4gYWRkICdDVVNUT01fRUxFTUVOVFNfU0NIRU1BJyB0byB0aGUgJ0BOZ01vZHVsZS5zY2hlbWFzJyBvZiB0aGlzIGNvbXBvbmVudCB0byBzdXBwcmVzcyB0aGlzIG1lc3NhZ2UuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvck1zZyArPVxuICAgICAgICAgICAgICAgICAgICBcIjIuIFRvIGFsbG93IGFueSBlbGVtZW50IGFkZCAnTk9fRVJST1JTX1NDSEVNQScgdG8gdGhlICdATmdNb2R1bGUuc2NoZW1hcycgb2YgdGhpcyBjb21wb25lbnQuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlcnJvck1zZywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnROb0NvbXBvbmVudHNOb3JFbGVtZW50QmluZGluZ3NPblRlbXBsYXRlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIGVsZW1lbnRQcm9wcywgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29tcG9uZW50VHlwZU5hbWVzID0gdGhpcy5fZmluZENvbXBvbmVudERpcmVjdGl2ZU5hbWVzKGRpcmVjdGl2ZXMpO1xuICAgICAgICBpZiAoY29tcG9uZW50VHlwZU5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiQ29tcG9uZW50cyBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZTogXCIgKyBjb21wb25lbnRUeXBlTmFtZXMuam9pbignLCcpLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50UHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiUHJvcGVydHkgYmluZGluZyBcIiArIHByb3AubmFtZSArIFwiIG5vdCB1c2VkIGJ5IGFueSBkaXJlY3RpdmUgb24gYW4gZW1iZWRkZWQgdGVtcGxhdGUuIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm9wZXJ0eSBuYW1lIGlzIHNwZWxsZWQgY29ycmVjdGx5IGFuZCBhbGwgZGlyZWN0aXZlcyBhcmUgbGlzdGVkIGluIHRoZSBcXFwiQE5nTW9kdWxlLmRlY2xhcmF0aW9uc1xcXCIuXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fYXNzZXJ0QWxsRXZlbnRzUHVibGlzaGVkQnlEaXJlY3RpdmVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIGV2ZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYWxsRGlyZWN0aXZlRXZlbnRzID0gbmV3IFNldCgpO1xuICAgICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGlyZWN0aXZlLmRpcmVjdGl2ZS5vdXRwdXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGRpcmVjdGl2ZS5kaXJlY3RpdmUub3V0cHV0c1trXTtcbiAgICAgICAgICAgICAgICBhbGxEaXJlY3RpdmVFdmVudHMuYWRkKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPSBudWxsIHx8ICFhbGxEaXJlY3RpdmVFdmVudHMuaGFzKGV2ZW50Lm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiRXZlbnQgYmluZGluZyBcIiArIGV2ZW50LmZ1bGxOYW1lICsgXCIgbm90IGVtaXR0ZWQgYnkgYW55IGRpcmVjdGl2ZSBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZS4gTWFrZSBzdXJlIHRoYXQgdGhlIGV2ZW50IG5hbWUgaXMgc3BlbGxlZCBjb3JyZWN0bHkgYW5kIGFsbCBkaXJlY3RpdmVzIGFyZSBsaXN0ZWQgaW4gdGhlIFxcXCJATmdNb2R1bGUuZGVjbGFyYXRpb25zXFxcIi5cIiwgZXZlbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jaGVja1Byb3BlcnRpZXNJblNjaGVtYSA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgYm91bmRQcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBOb3RlOiBXZSBjYW4ndCBmaWx0ZXIgb3V0IGVtcHR5IGV4cHJlc3Npb25zIGJlZm9yZSB0aGlzIG1ldGhvZCxcbiAgICAgICAgLy8gYXMgd2Ugc3RpbGwgd2FudCB0byB2YWxpZGF0ZSB0aGVtIVxuICAgICAgICByZXR1cm4gYm91bmRQcm9wcy5maWx0ZXIoZnVuY3Rpb24gKGJvdW5kUHJvcCkge1xuICAgICAgICAgICAgaWYgKGJvdW5kUHJvcC50eXBlID09PSAwIC8qIFByb3BlcnR5ICovICYmXG4gICAgICAgICAgICAgICAgIV90aGlzLl9zY2hlbWFSZWdpc3RyeS5oYXNQcm9wZXJ0eShlbGVtZW50TmFtZSwgYm91bmRQcm9wLm5hbWUsIF90aGlzLl9zY2hlbWFzKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvck1zZyA9IFwiQ2FuJ3QgYmluZCB0byAnXCIgKyBib3VuZFByb3AubmFtZSArIFwiJyBzaW5jZSBpdCBpc24ndCBhIGtub3duIHByb3BlcnR5IG9mICdcIiArIGVsZW1lbnROYW1lICsgXCInLlwiO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50TmFtZS5zdGFydHNXaXRoKCduZy0nKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1zZyArPVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4xLiBJZiAnXCIgKyBib3VuZFByb3AubmFtZSArIFwiJyBpcyBhbiBBbmd1bGFyIGRpcmVjdGl2ZSwgdGhlbiBhZGQgJ0NvbW1vbk1vZHVsZScgdG8gdGhlICdATmdNb2R1bGUuaW1wb3J0cycgb2YgdGhpcyBjb21wb25lbnQuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuMi4gVG8gYWxsb3cgYW55IHByb3BlcnR5IGFkZCAnTk9fRVJST1JTX1NDSEVNQScgdG8gdGhlICdATmdNb2R1bGUuc2NoZW1hcycgb2YgdGhpcyBjb21wb25lbnQuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnROYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTXNnICs9XG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcbjEuIElmICdcIiArIGVsZW1lbnROYW1lICsgXCInIGlzIGFuIEFuZ3VsYXIgY29tcG9uZW50IGFuZCBpdCBoYXMgJ1wiICsgYm91bmRQcm9wLm5hbWUgKyBcIicgaW5wdXQsIHRoZW4gdmVyaWZ5IHRoYXQgaXQgaXMgcGFydCBvZiB0aGlzIG1vZHVsZS5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiXFxuMi4gSWYgJ1wiICsgZWxlbWVudE5hbWUgKyBcIicgaXMgYSBXZWIgQ29tcG9uZW50IHRoZW4gYWRkICdDVVNUT01fRUxFTUVOVFNfU0NIRU1BJyB0byB0aGUgJ0BOZ01vZHVsZS5zY2hlbWFzJyBvZiB0aGlzIGNvbXBvbmVudCB0byBzdXBwcmVzcyB0aGlzIG1lc3NhZ2UuXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbjMuIFRvIGFsbG93IGFueSBwcm9wZXJ0eSBhZGQgJ05PX0VSUk9SU19TQ0hFTUEnIHRvIHRoZSAnQE5nTW9kdWxlLnNjaGVtYXMnIG9mIHRoaXMgY29tcG9uZW50LlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoZXJyb3JNc2csIGJvdW5kUHJvcC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhaXNFbXB0eUV4cHJlc3Npb24oYm91bmRQcm9wLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNvdXJjZVNwYW4sIGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gUGFyc2VFcnJvckxldmVsLkVSUk9SOyB9XG4gICAgICAgIHRoaXMuX3RhcmdldEVycm9ycy5wdXNoKG5ldyBQYXJzZUVycm9yKHNvdXJjZVNwYW4sIG1lc3NhZ2UsIGxldmVsKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGVtcGxhdGVQYXJzZVZpc2l0b3I7XG59KCkpO1xudmFyIE5vbkJpbmRhYmxlVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb25CaW5kYWJsZVZpc2l0b3IoKSB7XG4gICAgfVxuICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgIHZhciBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGFzdCk7XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRSB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUKSB7XG4gICAgICAgICAgICAvLyBTa2lwcGluZyA8c2NyaXB0PiBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHN0eWxlPiBhbmQgc3R5bGVzaGVldHMgYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxuICAgICAgICAgICAgLy8gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdHRyTmFtZUFuZFZhbHVlcyA9IGFzdC5hdHRycy5tYXAoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIFthdHRyLm5hbWUsIGF0dHIudmFsdWVdOyB9KTtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKGFzdC5uYW1lLCBhdHRyTmFtZUFuZFZhbHVlcyk7XG4gICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleCA9IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgoc2VsZWN0b3IpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB2aXNpdEFsbCQxKHRoaXMsIGFzdC5jaGlsZHJlbiwgRU1QVFlfRUxFTUVOVF9DT05URVhUKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50QXN0KGFzdC5uYW1lLCB2aXNpdEFsbCQxKHRoaXMsIGFzdC5hdHRycyksIFtdLCBbXSwgW10sIFtdLCBbXSwgZmFsc2UsIFtdLCBjaGlsZHJlbiwgbmdDb250ZW50SW5kZXgsIGFzdC5zb3VyY2VTcGFuLCBhc3QuZW5kU291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0ckFzdChhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlLCBhdHRyaWJ1dGUuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIG5nQ29udGVudEluZGV4ID0gcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChURVhUX0NTU19TRUxFQ1RPUigpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0QXN0KHRleHQudmFsdWUsIG5nQ29udGVudEluZGV4LCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGNvbnRleHQpIHsgcmV0dXJuIGV4cGFuc2lvbjsgfTtcbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7IHJldHVybiBleHBhbnNpb25DYXNlOyB9O1xuICAgIHJldHVybiBOb25CaW5kYWJsZVZpc2l0b3I7XG59KCkpO1xuLyoqXG4gKiBBIHJlZmVyZW5jZSB0byBhbiBlbGVtZW50IG9yIGRpcmVjdGl2ZSBpbiBhIHRlbXBsYXRlLiBFLmcuLCB0aGUgcmVmZXJlbmNlIGluIHRoaXMgdGVtcGxhdGU6XG4gKlxuICogPGRpdiAjbXlNZW51PVwiY29vbE1lbnVcIj5cbiAqXG4gKiB3b3VsZCBiZSB7bmFtZTogJ215TWVudScsIHZhbHVlOiAnY29vbE1lbnUnLCBzb3VyY2VTcGFuOiAuLi59XG4gKi9cbnZhciBFbGVtZW50T3JEaXJlY3RpdmVSZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudE9yRGlyZWN0aXZlUmVmKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqIEdldHMgd2hldGhlciB0aGlzIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBnaXZlbiBkaXJlY3RpdmUuICovXG4gICAgRWxlbWVudE9yRGlyZWN0aXZlUmVmLnByb3RvdHlwZS5pc1JlZmVyZW5jZVRvRGlyZWN0aXZlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICByZXR1cm4gc3BsaXRFeHBvcnRBcyhkaXJlY3RpdmUuZXhwb3J0QXMpLmluZGV4T2YodGhpcy52YWx1ZSkgIT09IC0xO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRPckRpcmVjdGl2ZVJlZjtcbn0oKSk7XG4vKiogU3BsaXRzIGEgcmF3LCBwb3RlbnRpYWxseSBjb21tYS1kZWxpbWl0ZWQgYGV4cG9ydEFzYCB2YWx1ZSBpbnRvIGFuIGFycmF5IG9mIG5hbWVzLiAqL1xuZnVuY3Rpb24gc3BsaXRFeHBvcnRBcyhleHBvcnRBcykge1xuICAgIHJldHVybiBleHBvcnRBcyA/IGV4cG9ydEFzLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRyaW0oKTsgfSkgOiBbXTtcbn1cbmZ1bmN0aW9uIHNwbGl0Q2xhc3NlcyhjbGFzc0F0dHJWYWx1ZSkge1xuICAgIHJldHVybiBjbGFzc0F0dHJWYWx1ZS50cmltKCkuc3BsaXQoL1xccysvZyk7XG59XG52YXIgRWxlbWVudENvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudENvbnRleHQoaXNUZW1wbGF0ZUVsZW1lbnQsIF9uZ0NvbnRlbnRJbmRleE1hdGNoZXIsIF93aWxkY2FyZE5nQ29udGVudEluZGV4LCBwcm92aWRlckNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pc1RlbXBsYXRlRWxlbWVudCA9IGlzVGVtcGxhdGVFbGVtZW50O1xuICAgICAgICB0aGlzLl9uZ0NvbnRlbnRJbmRleE1hdGNoZXIgPSBfbmdDb250ZW50SW5kZXhNYXRjaGVyO1xuICAgICAgICB0aGlzLl93aWxkY2FyZE5nQ29udGVudEluZGV4ID0gX3dpbGRjYXJkTmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMucHJvdmlkZXJDb250ZXh0ID0gcHJvdmlkZXJDb250ZXh0O1xuICAgIH1cbiAgICBFbGVtZW50Q29udGV4dC5jcmVhdGUgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGRpcmVjdGl2ZXMsIHByb3ZpZGVyQ29udGV4dCkge1xuICAgICAgICB2YXIgbWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgdmFyIHdpbGRjYXJkTmdDb250ZW50SW5kZXggPSBudWxsO1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gZGlyZWN0aXZlcy5maW5kKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZS5kaXJlY3RpdmUuaXNDb21wb25lbnQ7IH0pO1xuICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgbmdDb250ZW50U2VsZWN0b3JzID0gY29tcG9uZW50LmRpcmVjdGl2ZS50ZW1wbGF0ZS5uZ0NvbnRlbnRTZWxlY3RvcnM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5nQ29udGVudFNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IG5nQ29udGVudFNlbGVjdG9yc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICB3aWxkY2FyZE5nQ29udGVudEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXIuYWRkU2VsZWN0YWJsZXMoQ3NzU2VsZWN0b3IucGFyc2UobmdDb250ZW50U2VsZWN0b3JzW2ldKSwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudENvbnRleHQoaXNUZW1wbGF0ZUVsZW1lbnQsIG1hdGNoZXIsIHdpbGRjYXJkTmdDb250ZW50SW5kZXgsIHByb3ZpZGVyQ29udGV4dCk7XG4gICAgfTtcbiAgICBFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuZmluZE5nQ29udGVudEluZGV4ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBuZ0NvbnRlbnRJbmRpY2VzID0gW107XG4gICAgICAgIHRoaXMuX25nQ29udGVudEluZGV4TWF0Y2hlci5tYXRjaChzZWxlY3RvciwgZnVuY3Rpb24gKHNlbGVjdG9yLCBuZ0NvbnRlbnRJbmRleCkgeyBuZ0NvbnRlbnRJbmRpY2VzLnB1c2gobmdDb250ZW50SW5kZXgpOyB9KTtcbiAgICAgICAgbmdDb250ZW50SW5kaWNlcy5zb3J0KCk7XG4gICAgICAgIGlmICh0aGlzLl93aWxkY2FyZE5nQ29udGVudEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5nQ29udGVudEluZGljZXMucHVzaCh0aGlzLl93aWxkY2FyZE5nQ29udGVudEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmdDb250ZW50SW5kaWNlcy5sZW5ndGggPiAwID8gbmdDb250ZW50SW5kaWNlc1swXSA6IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gRWxlbWVudENvbnRleHQ7XG59KCkpO1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGNzc1NlbGVjdG9yID0gbmV3IENzc1NlbGVjdG9yKCk7XG4gICAgdmFyIGVsTmFtZU5vTnMgPSBzcGxpdE5zTmFtZShlbGVtZW50TmFtZSlbMV07XG4gICAgY3NzU2VsZWN0b3Iuc2V0RWxlbWVudChlbE5hbWVOb05zKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGF0dHJOYW1lID0gYXR0cmlidXRlc1tpXVswXTtcbiAgICAgICAgdmFyIGF0dHJOYW1lTm9OcyA9IHNwbGl0TnNOYW1lKGF0dHJOYW1lKVsxXTtcbiAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IGF0dHJpYnV0ZXNbaV1bMV07XG4gICAgICAgIGNzc1NlbGVjdG9yLmFkZEF0dHJpYnV0ZShhdHRyTmFtZU5vTnMsIGF0dHJWYWx1ZSk7XG4gICAgICAgIGlmIChhdHRyTmFtZS50b0xvd2VyQ2FzZSgpID09IENMQVNTX0FUVFIpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzID0gc3BsaXRDbGFzc2VzKGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICBjbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gY3NzU2VsZWN0b3IuYWRkQ2xhc3NOYW1lKGNsYXNzTmFtZSk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjc3NTZWxlY3Rvcjtcbn1cbnZhciBFTVBUWV9FTEVNRU5UX0NPTlRFWFQgPSBuZXcgRWxlbWVudENvbnRleHQodHJ1ZSwgbmV3IFNlbGVjdG9yTWF0Y2hlcigpLCBudWxsLCBudWxsKTtcbnZhciBOT05fQklOREFCTEVfVklTSVRPUiA9IG5ldyBOb25CaW5kYWJsZVZpc2l0b3IoKTtcbmZ1bmN0aW9uIF9pc0VtcHR5VGV4dE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGV4dCQzICYmIG5vZGUudmFsdWUudHJpbSgpLmxlbmd0aCA9PSAwO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3VtbWFyeUR1cGxpY2F0ZXMoaXRlbXMpIHtcbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFtYXAuZ2V0KGl0ZW0udHlwZS5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGl0ZW0udHlwZS5yZWZlcmVuY2UsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obWFwLnZhbHVlcygpKTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlFeHByZXNzaW9uKGFzdCkge1xuICAgIGlmIChhc3QgaW5zdGFuY2VvZiBBU1RXaXRoU291cmNlKSB7XG4gICAgICAgIGFzdCA9IGFzdC5hc3Q7XG4gICAgfVxuICAgIHJldHVybiBhc3QgaW5zdGFuY2VvZiBFbXB0eUV4cHI7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogUGFyc2VzIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHN0eWxlIGFuZCBjb252ZXJ0cyBpdCBpbnRvIG9iamVjdCBsaXRlcmFsLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2Ygc3R5bGUgYXMgdXNlZCBpbiB0aGUgYHN0eWxlYCBhdHRyaWJ1dGUgaW4gSFRNTC5cbiAqICAgRXhhbXBsZTogYGNvbG9yOiByZWQ7IGhlaWdodDogYXV0b2AuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdHlsZSBwcm9wZXJ0eSBuYW1lIGFuZCB2YWx1ZSBwYWlycywgZS5nLiBgWydjb2xvcicsICdyZWQnLCAnaGVpZ2h0JyxcbiAqICdhdXRvJ11gXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHZhbHVlKSB7XG4gICAgLy8gd2UgdXNlIGEgc3RyaW5nIGFycmF5IGhlcmUgaW5zdGVhZCBvZiBhIHN0cmluZyBtYXBcbiAgICAvLyBiZWNhdXNlIGEgc3RyaW5nLW1hcCBpcyBub3QgZ3VhcmFudGVlZCB0byByZXRhaW4gdGhlXG4gICAgLy8gb3JkZXIgb2YgdGhlIGVudHJpZXMgd2hlcmVhcyBhIHN0cmluZyBhcnJheSBjYW4gYmVcbiAgICAvLyBjb25zdHJ1dGVkIGluIGEgW2tleSwgdmFsdWUsIGtleSwgdmFsdWVdIGZvcm1hdC5cbiAgICB2YXIgc3R5bGVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBwYXJlbkRlcHRoID0gMDtcbiAgICB2YXIgcXVvdGUgPSAwIC8qIFF1b3RlTm9uZSAqLztcbiAgICB2YXIgdmFsdWVTdGFydCA9IDA7XG4gICAgdmFyIHByb3BTdGFydCA9IDA7XG4gICAgdmFyIGN1cnJlbnRQcm9wID0gbnVsbDtcbiAgICB2YXIgdmFsdWVIYXNRdW90ZXMgPSBmYWxzZTtcbiAgICB3aGlsZSAoaSA8IHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgdG9rZW4gPSB2YWx1ZS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgNDAgLyogT3BlblBhcmVuICovOlxuICAgICAgICAgICAgICAgIHBhcmVuRGVwdGgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDEgLyogQ2xvc2VQYXJlbiAqLzpcbiAgICAgICAgICAgICAgICBwYXJlbkRlcHRoLS07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM5IC8qIFF1b3RlU2luZ2xlICovOlxuICAgICAgICAgICAgICAgIC8vIHZhbHVlU3RhcnQgbmVlZHMgdG8gYmUgdGhlcmUgc2luY2UgcHJvcCB2YWx1ZXMgZG9uJ3RcbiAgICAgICAgICAgICAgICAvLyBoYXZlIHF1b3RlcyBpbiBDU1NcbiAgICAgICAgICAgICAgICB2YWx1ZUhhc1F1b3RlcyA9IHZhbHVlSGFzUXVvdGVzIHx8IHZhbHVlU3RhcnQgPiAwO1xuICAgICAgICAgICAgICAgIGlmIChxdW90ZSA9PT0gMCAvKiBRdW90ZU5vbmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSAzOSAvKiBRdW90ZVNpbmdsZSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocXVvdGUgPT09IDM5IC8qIFF1b3RlU2luZ2xlICovICYmIHZhbHVlLmNoYXJDb2RlQXQoaSAtIDEpICE9PSA5MiAvKiBCYWNrU2xhc2ggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSAwIC8qIFF1b3RlTm9uZSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM0IC8qIFF1b3RlRG91YmxlICovOlxuICAgICAgICAgICAgICAgIC8vIHNhbWUgbG9naWMgYXMgYWJvdmVcbiAgICAgICAgICAgICAgICB2YWx1ZUhhc1F1b3RlcyA9IHZhbHVlSGFzUXVvdGVzIHx8IHZhbHVlU3RhcnQgPiAwO1xuICAgICAgICAgICAgICAgIGlmIChxdW90ZSA9PT0gMCAvKiBRdW90ZU5vbmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSAzNCAvKiBRdW90ZURvdWJsZSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocXVvdGUgPT09IDM0IC8qIFF1b3RlRG91YmxlICovICYmIHZhbHVlLmNoYXJDb2RlQXQoaSAtIDEpICE9PSA5MiAvKiBCYWNrU2xhc2ggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSAwIC8qIFF1b3RlTm9uZSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU4IC8qIENvbG9uICovOlxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb3AgJiYgcGFyZW5EZXB0aCA9PT0gMCAmJiBxdW90ZSA9PT0gMCAvKiBRdW90ZU5vbmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3AgPSBoeXBoZW5hdGUodmFsdWUuc3Vic3RyaW5nKHByb3BTdGFydCwgaSAtIDEpLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlU3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTkgLyogU2VtaWNvbG9uICovOlxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJvcCAmJiB2YWx1ZVN0YXJ0ID4gMCAmJiBwYXJlbkRlcHRoID09PSAwICYmIHF1b3RlID09PSAwIC8qIFF1b3RlTm9uZSAqLykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVWYWwgPSB2YWx1ZS5zdWJzdHJpbmcodmFsdWVTdGFydCwgaSAtIDEpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goY3VycmVudFByb3AsIHZhbHVlSGFzUXVvdGVzID8gc3RyaXBVbm5lY2Vzc2FyeVF1b3RlcyhzdHlsZVZhbCkgOiBzdHlsZVZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlSGFzUXVvdGVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50UHJvcCAmJiB2YWx1ZVN0YXJ0KSB7XG4gICAgICAgIHZhciBzdHlsZVZhbCA9IHZhbHVlLnN1YnN0cih2YWx1ZVN0YXJ0KS50cmltKCk7XG4gICAgICAgIHN0eWxlcy5wdXNoKGN1cnJlbnRQcm9wLCB2YWx1ZUhhc1F1b3RlcyA/IHN0cmlwVW5uZWNlc3NhcnlRdW90ZXMoc3R5bGVWYWwpIDogc3R5bGVWYWwpO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xufVxuZnVuY3Rpb24gc3RyaXBVbm5lY2Vzc2FyeVF1b3Rlcyh2YWx1ZSkge1xuICAgIHZhciBxUyA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHFFID0gdmFsdWUuY2hhckNvZGVBdCh2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICBpZiAocVMgPT0gcUUgJiYgKHFTID09IDM5IC8qIFF1b3RlU2luZ2xlICovIHx8IHFTID09IDM0IC8qIFF1b3RlRG91YmxlICovKSkge1xuICAgICAgICB2YXIgdGVtcFZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdXNpbmcgYSBtdWx0aS1xdW90ZWQgc3RyaW5nIHRoYXQgd2FzIGp1c3QgY2hvbXBlZFxuICAgICAgICAvLyAoZS5nLiBgZm9udC1mYW1pbHk6IFwiVmVyZGFuYVwiLCBcInNhbnMtc2VyaWZcImApXG4gICAgICAgIGlmICh0ZW1wVmFsdWUuaW5kZXhPZignXFwnJykgPT0gLTEgJiYgdGVtcFZhbHVlLmluZGV4T2YoJ1wiJykgPT0gLTEpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGVtcFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGh5cGhlbmF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bYS16XVtBLVpdL2csIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB2LmNoYXJBdCgwKSArICctJyArIHYuY2hhckF0KDEpO1xuICAgIH0pLnRvTG93ZXJDYXNlKCk7XG59XG5cbnZhciBJTVBPUlRBTlRfRkxBRyA9ICchaW1wb3J0YW50Jztcbi8qKlxuICogUHJvZHVjZXMgY3JlYXRpb24vdXBkYXRlIGluc3RydWN0aW9ucyBmb3IgYWxsIHN0eWxpbmcgYmluZGluZ3MgKGNsYXNzIGFuZCBzdHlsZSlcbiAqXG4gKiBJdCBhbHNvIHByb2R1Y2VzIHRoZSBjcmVhdGlvbiBpbnN0cnVjdGlvbiB0byByZWdpc3RlciBhbGwgaW5pdGlhbCBzdHlsaW5nIHZhbHVlc1xuICogKHdoaWNoIGFyZSBhbGwgdGhlIHN0YXRpYyBjbGFzcz1cIi4uLlwiIGFuZCBzdHlsZT1cIi4uLlwiIGF0dHJpYnV0ZSB2YWx1ZXMgdGhhdCBleGlzdFxuICogb24gYW4gZWxlbWVudCB3aXRoaW4gYSB0ZW1wbGF0ZSkuXG4gKlxuICogVGhlIGJ1aWxkZXIgY2xhc3MgYmVsb3cgaGFuZGxlcyBwcm9kdWNpbmcgaW5zdHJ1Y3Rpb25zIGZvciB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICpcbiAqIC0gU3RhdGljIHN0eWxlL2NsYXNzIGF0dHJpYnV0ZXMgKHN0eWxlPVwiLi4uXCIgYW5kIGNsYXNzPVwiLi4uXCIpXG4gKiAtIER5bmFtaWMgc3R5bGUvY2xhc3MgbWFwIGJpbmRpbmdzIChbc3R5bGVdPVwibWFwXCIgYW5kIFtjbGFzc109XCJtYXB8c3RyaW5nXCIpXG4gKiAtIER5bmFtaWMgc3R5bGUvY2xhc3MgcHJvcGVydHkgYmluZGluZ3MgKFtzdHlsZS5wcm9wXT1cImV4cFwiIGFuZCBbY2xhc3MubmFtZV09XCJleHBcIilcbiAqXG4gKiBEdWUgdG8gdGhlIGNvbXBsZXggcmVsYXRpb25zaGlwIG9mIGFsbCBvZiB0aGVzZSBjYXNlcywgdGhlIGluc3RydWN0aW9ucyBnZW5lcmF0ZWRcbiAqIGZvciB0aGVzZSBhdHRyaWJ1dGVzL3Byb3BlcnRpZXMvYmluZGluZ3MgbXVzdCBiZSBkb25lIHNvIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBUaGVcbiAqIG9yZGVyIHdoaWNoIHRoZXNlIG11c3QgYmUgZ2VuZXJhdGVkIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogaWYgKGNyZWF0ZU1vZGUpIHtcbiAqICAgc3R5bGluZyguLi4pXG4gKiB9XG4gKiBpZiAodXBkYXRlTW9kZSkge1xuICogICBzdHlsZU1hcCguLi4pXG4gKiAgIGNsYXNzTWFwKC4uLilcbiAqICAgc3R5bGVQcm9wKC4uLilcbiAqICAgY2xhc3NQcm9wKC4uLilcbiAqICAgc3R5bGluZ0FwcGx5KC4uLilcbiAqIH1cbiAqXG4gKiBUaGUgY3JlYXRpb24vdXBkYXRlIG1ldGhvZHMgd2l0aGluIHRoZSBidWlsZGVyIGNsYXNzIHByb2R1Y2UgdGhlc2UgaW5zdHJ1Y3Rpb25zLlxuICovXG52YXIgU3R5bGluZ0J1aWxkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3R5bGluZ0J1aWxkZXIoX2VsZW1lbnRJbmRleEV4cHIsIF9kaXJlY3RpdmVFeHByKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRJbmRleEV4cHIgPSBfZWxlbWVudEluZGV4RXhwcjtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlRXhwciA9IF9kaXJlY3RpdmVFeHByO1xuICAgICAgICAvKiogV2hldGhlciBvciBub3QgdGhlcmUgYXJlIGFueSBzdGF0aWMgc3R5bGluZyB2YWx1ZXMgcHJlc2VudCAqL1xuICAgICAgICB0aGlzLl9oYXNJbml0aWFsVmFsdWVzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgV2hldGhlciBvciBub3QgdGhlcmUgYXJlIGFueSBzdHlsaW5nIGJpbmRpbmdzIHByZXNlbnRcbiAgICAgICAgICogIChpLmUuIGBbc3R5bGVdYCwgYFtjbGFzc11gLCBgW3N0eWxlLnByb3BdYCBvciBgW2NsYXNzLm5hbWVdYClcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzQmluZGluZ3MgPSBmYWxzZTtcbiAgICAgICAgLyoqIHRoZSBpbnB1dCBmb3IgW2NsYXNzXSAoaWYgaXQgZXhpc3RzKSAqL1xuICAgICAgICB0aGlzLl9jbGFzc01hcElucHV0ID0gbnVsbDtcbiAgICAgICAgLyoqIHRoZSBpbnB1dCBmb3IgW3N0eWxlXSAoaWYgaXQgZXhpc3RzKSAqL1xuICAgICAgICB0aGlzLl9zdHlsZU1hcElucHV0ID0gbnVsbDtcbiAgICAgICAgLyoqIGFuIGFycmF5IG9mIGVhY2ggW3N0eWxlLnByb3BdIGlucHV0ICovXG4gICAgICAgIHRoaXMuX3NpbmdsZVN0eWxlSW5wdXRzID0gbnVsbDtcbiAgICAgICAgLyoqIGFuIGFycmF5IG9mIGVhY2ggW2NsYXNzLm5hbWVdIGlucHV0ICovXG4gICAgICAgIHRoaXMuX3NpbmdsZUNsYXNzSW5wdXRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdFN0eWxpbmdJbnB1dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZpcnN0U3R5bGluZ0lucHV0ID0gbnVsbDtcbiAgICAgICAgLy8gbWFwcyBhcmUgdXNlZCBpbnN0ZWFkIG9mIGhhc2ggbWFwcyBiZWNhdXNlIGEgTWFwIHdpbGxcbiAgICAgICAgLy8gcmV0YWluIHRoZSBvcmRlcmluZyBvZiB0aGUga2V5c1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwcmVzZW50cyB0aGUgbG9jYXRpb24gb2YgZWFjaCBzdHlsZSBiaW5kaW5nIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgKiAoZS5nLiBgPGRpdiBbc3R5bGUud2lkdGhdPVwid1wiIFtzdHlsZS5oZWlnaHRdPVwiaFwiPmAgaW1wbGllc1xuICAgICAgICAgKiB0aGF0IGB3aWR0aD0wYCBhbmQgYGhlaWdodD0xYClcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3N0eWxlc0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwcmVzZW50cyB0aGUgbG9jYXRpb24gb2YgZWFjaCBjbGFzcyBiaW5kaW5nIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgKiAoZS5nLiBgPGRpdiBbY2xhc3MuYmlnXT1cImJcIiBbY2xhc3MuaGlkZGVuXT1cImhcIj5gIGltcGxpZXNcbiAgICAgICAgICogdGhhdCBgYmlnPTBgIGFuZCBgaGlkZGVuPTFgKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY2xhc3Nlc0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9pbml0aWFsU3R5bGVWYWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzVmFsdWVzID0gW107XG4gICAgICAgIC8vIGNlcnRhaW4gc3R5bGUgcHJvcGVydGllcyBBTFdBWVMgbmVlZCBzYW5pdGl6YXRpb25cbiAgICAgICAgLy8gdGhpcyBpcyBjaGVja2VkIGVhY2ggdGltZSBuZXcgc3R5bGVzIGFyZSBlbmNvdW50ZXJlZFxuICAgICAgICB0aGlzLl91c2VEZWZhdWx0U2FuaXRpemVyID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGdpdmVuIGlucHV0IHRvIHRoZSBzdHlsaW5nIGJ1aWxkZXIgdG8gYmUgbGF0ZXIgdXNlZCB3aGVuIHByb2R1Y2luZyBBT1QgY29kZS5cbiAgICAgKlxuICAgICAqIFRoZSBjb2RlIGJlbG93IHdpbGwgb25seSBhY2NlcHQgdGhlIGlucHV0IGlmIGl0IGlzIHNvbWVob3cgdGllZCB0byBzdHlsaW5nICh3aGV0aGVyIGl0IGJlXG4gICAgICogc3R5bGUvY2xhc3MgYmluZGluZ3Mgb3Igc3RhdGljIHN0eWxlL2NsYXNzIGF0dHJpYnV0ZXMpLlxuICAgICAqL1xuICAgIFN0eWxpbmdCdWlsZGVyLnByb3RvdHlwZS5yZWdpc3RlckJvdW5kSW5wdXQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgLy8gW2F0dHIuc3R5bGVdIG9yIFthdHRyLmNsYXNzXSBhcmUgc2tpcHBlZCBpbiB0aGUgY29kZSBiZWxvdyxcbiAgICAgICAgLy8gdGhleSBzaG91bGQgbm90IGJlIHRyZWF0ZWQgYXMgc3R5bGluZy1iYXNlZCBiaW5kaW5ncyBzaW5jZVxuICAgICAgICAvLyB0aGV5IGFyZSBpbnRlbmRlZCB0byBiZSB3cml0dGVuIGRpcmVjdGx5IHRvIHRoZSBhdHRyIGFuZFxuICAgICAgICAvLyB3aWxsIHRoZXJlZm9yZSBza2lwIGFsbCBzdHlsZS9jbGFzcyByZXNvbHV0aW9uIHRoYXQgaXMgcHJlc2VudFxuICAgICAgICAvLyB3aXRoIHN0eWxlPVwiXCIsIFtzdHlsZV09XCJcIiBhbmQgW3N0eWxlLnByb3BdPVwiXCIsIGNsYXNzPVwiXCIsXG4gICAgICAgIC8vIFtjbGFzcy5wcm9wXT1cIlwiLiBbY2xhc3NdPVwiXCIgYXNzaWdubWVudHNcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBudWxsO1xuICAgICAgICB2YXIgbmFtZSA9IGlucHV0Lm5hbWU7XG4gICAgICAgIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIFByb3BlcnR5ICovOlxuICAgICAgICAgICAgICAgIGJpbmRpbmcgPSB0aGlzLnJlZ2lzdGVySW5wdXRCYXNlZE9uTmFtZShuYW1lLCBpbnB1dC52YWx1ZSwgaW5wdXQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMgLyogU3R5bGUgKi86XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IHRoaXMucmVnaXN0ZXJTdHlsZUlucHV0KG5hbWUsIGZhbHNlLCBpbnB1dC52YWx1ZSwgaW5wdXQuc291cmNlU3BhbiwgaW5wdXQudW5pdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogQ2xhc3MgKi86XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IHRoaXMucmVnaXN0ZXJDbGFzc0lucHV0KG5hbWUsIGZhbHNlLCBpbnB1dC52YWx1ZSwgaW5wdXQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpbmRpbmcgPyB0cnVlIDogZmFsc2U7XG4gICAgfTtcbiAgICBTdHlsaW5nQnVpbGRlci5wcm90b3R5cGUucmVnaXN0ZXJJbnB1dEJhc2VkT25OYW1lID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBudWxsO1xuICAgICAgICB2YXIgbmFtZVRvTWF0Y2ggPSBuYW1lLnN1YnN0cmluZygwLCA1KTsgLy8gY2xhc3MgfCBzdHlsZVxuICAgICAgICB2YXIgaXNTdHlsZSA9IG5hbWVUb01hdGNoID09PSAnc3R5bGUnO1xuICAgICAgICB2YXIgaXNDbGFzcyA9IGlzU3R5bGUgPyBmYWxzZSA6IChuYW1lVG9NYXRjaCA9PT0gJ2NsYXNzJyk7XG4gICAgICAgIGlmIChpc1N0eWxlIHx8IGlzQ2xhc3MpIHtcbiAgICAgICAgICAgIHZhciBpc01hcEJhc2VkID0gbmFtZS5jaGFyQXQoNSkgIT09ICcuJzsgLy8gc3R5bGUucHJvcCBvciBjbGFzcy5wcm9wIG1ha2VzIHRoaXMgYSBub1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gbmFtZS5zdWJzdHIoaXNNYXBCYXNlZCA/IDUgOiA2KTsgLy8gdGhlIGRvdCBleHBsYWlucyB3aHkgdGhlcmUncyBhICsxXG4gICAgICAgICAgICBpZiAoaXNTdHlsZSkge1xuICAgICAgICAgICAgICAgIGJpbmRpbmcgPSB0aGlzLnJlZ2lzdGVyU3R5bGVJbnB1dChwcm9wZXJ0eSwgaXNNYXBCYXNlZCwgZXhwcmVzc2lvbiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nID0gdGhpcy5yZWdpc3RlckNsYXNzSW5wdXQocHJvcGVydHksIGlzTWFwQmFzZWQsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaW5kaW5nO1xuICAgIH07XG4gICAgU3R5bGluZ0J1aWxkZXIucHJvdG90eXBlLnJlZ2lzdGVyU3R5bGVJbnB1dCA9IGZ1bmN0aW9uIChuYW1lLCBpc01hcEJhc2VkLCB2YWx1ZSwgc291cmNlU3BhbiwgdW5pdCkge1xuICAgICAgICBpZiAoaXNFbXB0eUV4cHJlc3Npb24odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gbm9ybWFsaXplUHJvcE5hbWUobmFtZSk7XG4gICAgICAgIHZhciBfYSA9IHBhcnNlUHJvcGVydHkobmFtZSksIHByb3BlcnR5ID0gX2EucHJvcGVydHksIGhhc092ZXJyaWRlRmxhZyA9IF9hLmhhc092ZXJyaWRlRmxhZywgYmluZGluZ1VuaXQgPSBfYS51bml0O1xuICAgICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgIHVuaXQ6IHVuaXQgfHwgYmluZGluZ1VuaXQsIHZhbHVlOiB2YWx1ZSwgc291cmNlU3Bhbjogc291cmNlU3BhbiwgaGFzT3ZlcnJpZGVGbGFnOiBoYXNPdmVycmlkZUZsYWdcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzTWFwQmFzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3VzZURlZmF1bHRTYW5pdGl6ZXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVNYXBJbnB1dCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHRoaXMuX3NpbmdsZVN0eWxlSW5wdXRzID0gdGhpcy5fc2luZ2xlU3R5bGVJbnB1dHMgfHwgW10pLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgdGhpcy5fdXNlRGVmYXVsdFNhbml0aXplciA9IHRoaXMuX3VzZURlZmF1bHRTYW5pdGl6ZXIgfHwgaXNTdHlsZVNhbml0aXphYmxlKG5hbWUpO1xuICAgICAgICAgICAgcmVnaXN0ZXJJbnRvTWFwKHRoaXMuX3N0eWxlc0luZGV4LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdFN0eWxpbmdJbnB1dCA9IGVudHJ5O1xuICAgICAgICB0aGlzLl9maXJzdFN0eWxpbmdJbnB1dCA9IHRoaXMuX2ZpcnN0U3R5bGluZ0lucHV0IHx8IGVudHJ5O1xuICAgICAgICB0aGlzLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH07XG4gICAgU3R5bGluZ0J1aWxkZXIucHJvdG90eXBlLnJlZ2lzdGVyQ2xhc3NJbnB1dCA9IGZ1bmN0aW9uIChuYW1lLCBpc01hcEJhc2VkLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAoaXNFbXB0eUV4cHJlc3Npb24odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSBwYXJzZVByb3BlcnR5KG5hbWUpLCBwcm9wZXJ0eSA9IF9hLnByb3BlcnR5LCBoYXNPdmVycmlkZUZsYWcgPSBfYS5oYXNPdmVycmlkZUZsYWc7XG4gICAgICAgIHZhciBlbnRyeSA9IHsgbmFtZTogcHJvcGVydHksIHZhbHVlOiB2YWx1ZSwgc291cmNlU3Bhbjogc291cmNlU3BhbiwgaGFzT3ZlcnJpZGVGbGFnOiBoYXNPdmVycmlkZUZsYWcsIHVuaXQ6IG51bGwgfTtcbiAgICAgICAgaWYgKGlzTWFwQmFzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsYXNzTWFwSW5wdXQgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICh0aGlzLl9zaW5nbGVDbGFzc0lucHV0cyA9IHRoaXMuX3NpbmdsZUNsYXNzSW5wdXRzIHx8IFtdKS5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIHJlZ2lzdGVySW50b01hcCh0aGlzLl9jbGFzc2VzSW5kZXgsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0U3R5bGluZ0lucHV0ID0gZW50cnk7XG4gICAgICAgIHRoaXMuX2ZpcnN0U3R5bGluZ0lucHV0ID0gdGhpcy5fZmlyc3RTdHlsaW5nSW5wdXQgfHwgZW50cnk7XG4gICAgICAgIHRoaXMuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIGVsZW1lbnQncyBzdGF0aWMgc3R5bGUgc3RyaW5nIHZhbHVlIHRvIHRoZSBidWlsZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHRoZSBzdHlsZSBzdHJpbmcgKGUuZy4gYHdpZHRoOjEwMHB4OyBoZWlnaHQ6MjAwcHg7YClcbiAgICAgKi9cbiAgICBTdHlsaW5nQnVpbGRlci5wcm90b3R5cGUucmVnaXN0ZXJTdHlsZUF0dHIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbFN0eWxlVmFsdWVzID0gcGFyc2UodmFsdWUpO1xuICAgICAgICB0aGlzLl9oYXNJbml0aWFsVmFsdWVzID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyB0aGUgZWxlbWVudCdzIHN0YXRpYyBjbGFzcyBzdHJpbmcgdmFsdWUgdG8gdGhlIGJ1aWxkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgdGhlIGNsYXNzTmFtZSBzdHJpbmcgKGUuZy4gYGRpc2FibGVkIGdvbGQgem9vbWApXG4gICAgICovXG4gICAgU3R5bGluZ0J1aWxkZXIucHJvdG90eXBlLnJlZ2lzdGVyQ2xhc3NBdHRyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxDbGFzc1ZhbHVlcyA9IHZhbHVlLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbiAgICAgICAgdGhpcy5faGFzSW5pdGlhbFZhbHVlcyA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGFsbCBzdHlsaW5nLXJlbGF0ZWQgZXhwcmVzc2lvbnMgdG8gdGhlIHByb3ZpZGVkIGF0dHJzIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGF0dHJzIGFuIGV4aXN0aW5nIGFycmF5IHdoZXJlIGVhY2ggb2YgdGhlIHN0eWxpbmcgZXhwcmVzc2lvbnNcbiAgICAgKiB3aWxsIGJlIGluc2VydGVkIGludG8uXG4gICAgICovXG4gICAgU3R5bGluZ0J1aWxkZXIucHJvdG90eXBlLnBvcHVsYXRlSW5pdGlhbFN0eWxpbmdBdHRycyA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgICAgICAvLyBbQ0xBU1NfTUFSS0VSLCAnZm9vJywgJ2JhcicsICdiYXonIC4uLl1cbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxDbGFzc1ZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF0dHJzLnB1c2gobGl0ZXJhbCgxIC8qIENsYXNzZXMgKi8pKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW5pdGlhbENsYXNzVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMucHVzaChsaXRlcmFsKHRoaXMuX2luaXRpYWxDbGFzc1ZhbHVlc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFtTVFlMRV9NQVJLRVIsICd3aWR0aCcsICcyMDBweCcsICdoZWlnaHQnLCAnMTAwcHgnLCAuLi5dXG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsU3R5bGVWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhdHRycy5wdXNoKGxpdGVyYWwoMiAvKiBTdHlsZXMgKi8pKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW5pdGlhbFN0eWxlVmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMucHVzaChsaXRlcmFsKHRoaXMuX2luaXRpYWxTdHlsZVZhbHVlc1tpXSksIGxpdGVyYWwodGhpcy5faW5pdGlhbFN0eWxlVmFsdWVzW2kgKyAxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYW4gaW5zdHJ1Y3Rpb24gd2l0aCBhbGwgdGhlIGV4cHJlc3Npb25zIGFuZCBwYXJhbWV0ZXJzIGZvciBgZWxlbWVudEhvc3RBdHRyc2AuXG4gICAgICpcbiAgICAgKiBUaGUgaW5zdHJ1Y3Rpb24gZ2VuZXJhdGlvbiBjb2RlIGJlbG93IGlzIHVzZWQgZm9yIHByb2R1Y2luZyB0aGUgQU9UIHN0YXRlbWVudCBjb2RlIHdoaWNoIGlzXG4gICAgICogcmVzcG9uc2libGUgZm9yIHJlZ2lzdGVyaW5nIGluaXRpYWwgc3R5bGVzICh3aXRoaW4gYSBkaXJlY3RpdmUgaG9zdEJpbmRpbmdzJyBjcmVhdGlvbiBibG9jayksXG4gICAgICogYXMgd2VsbCBhcyBhbnkgb2YgdGhlIHByb3ZpZGVkIGF0dHJpYnV0ZSB2YWx1ZXMsIHRvIHRoZSBkaXJlY3RpdmUgaG9zdCBlbGVtZW50LlxuICAgICAqL1xuICAgIFN0eWxpbmdCdWlsZGVyLnByb3RvdHlwZS5idWlsZEhvc3RBdHRyc0luc3RydWN0aW9uID0gZnVuY3Rpb24gKHNvdXJjZVNwYW4sIGF0dHJzLCBjb25zdGFudFBvb2wpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGl2ZUV4cHIgJiYgKGF0dHJzLmxlbmd0aCB8fCB0aGlzLl9oYXNJbml0aWFsVmFsdWVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBzb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogSWRlbnRpZmllcnMkMS5lbGVtZW50SG9zdEF0dHJzLFxuICAgICAgICAgICAgICAgIGFsbG9jYXRlQmluZGluZ1Nsb3RzOiAwLFxuICAgICAgICAgICAgICAgIHBhcmFtczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXJhbXMgPT4gZWxlbWVudEhvc3RBdHRycyhhdHRycylcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucG9wdWxhdGVJbml0aWFsU3R5bGluZ0F0dHJzKGF0dHJzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJBcnJheSA9ICFhdHRycy5zb21lKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyIGluc3RhbmNlb2YgV3JhcHBlZE5vZGVFeHByOyB9KSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25zdGFudExpdGVyYWxGcm9tQXJyYXkoY29uc3RhbnRQb29sLCBhdHRycykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbEFycihhdHRycyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYXR0ckFycmF5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQnVpbGRzIGFuIGluc3RydWN0aW9uIHdpdGggYWxsIHRoZSBleHByZXNzaW9ucyBhbmQgcGFyYW1ldGVycyBmb3IgYHN0eWxpbmdgLlxuICAgICAqXG4gICAgICogVGhlIGluc3RydWN0aW9uIGdlbmVyYXRpb24gY29kZSBiZWxvdyBpcyB1c2VkIGZvciBwcm9kdWNpbmcgdGhlIEFPVCBzdGF0ZW1lbnQgY29kZSB3aGljaCBpc1xuICAgICAqIHJlc3BvbnNpYmxlIGZvciByZWdpc3RlcmluZyBzdHlsZS9jbGFzcyBiaW5kaW5ncyB0byBhbiBlbGVtZW50LlxuICAgICAqL1xuICAgIFN0eWxpbmdCdWlsZGVyLnByb3RvdHlwZS5idWlsZFN0eWxpbmdJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIChzb3VyY2VTcGFuLCBjb25zdGFudFBvb2wpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQmluZGluZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc291cmNlU3Bhbjogc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICBhbGxvY2F0ZUJpbmRpbmdTbG90czogMCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2U6IElkZW50aWZpZXJzJDEuc3R5bGluZyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhbiBpbnN0cnVjdGlvbiB3aXRoIGFsbCB0aGUgZXhwcmVzc2lvbnMgYW5kIHBhcmFtZXRlcnMgZm9yIGBjbGFzc01hcGAuXG4gICAgICpcbiAgICAgKiBUaGUgaW5zdHJ1Y3Rpb24gZGF0YSB3aWxsIGNvbnRhaW4gYWxsIGV4cHJlc3Npb25zIGZvciBgY2xhc3NNYXBgIHRvIGZ1bmN0aW9uXG4gICAgICogd2hpY2ggaW5jbHVkZXMgdGhlIGBbY2xhc3NdYCBleHByZXNzaW9uIHBhcmFtcy5cbiAgICAgKi9cbiAgICBTdHlsaW5nQnVpbGRlci5wcm90b3R5cGUuYnVpbGRDbGFzc01hcEluc3RydWN0aW9uID0gZnVuY3Rpb24gKHZhbHVlQ29udmVydGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGFzc01hcElucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRNYXBCYXNlZEluc3RydWN0aW9uKHZhbHVlQ29udmVydGVyLCB0cnVlLCB0aGlzLl9jbGFzc01hcElucHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhbiBpbnN0cnVjdGlvbiB3aXRoIGFsbCB0aGUgZXhwcmVzc2lvbnMgYW5kIHBhcmFtZXRlcnMgZm9yIGBzdHlsZU1hcGAuXG4gICAgICpcbiAgICAgKiBUaGUgaW5zdHJ1Y3Rpb24gZGF0YSB3aWxsIGNvbnRhaW4gYWxsIGV4cHJlc3Npb25zIGZvciBgc3R5bGVNYXBgIHRvIGZ1bmN0aW9uXG4gICAgICogd2hpY2ggaW5jbHVkZXMgdGhlIGBbc3R5bGVdYCBleHByZXNzaW9uIHBhcmFtcy5cbiAgICAgKi9cbiAgICBTdHlsaW5nQnVpbGRlci5wcm90b3R5cGUuYnVpbGRTdHlsZU1hcEluc3RydWN0aW9uID0gZnVuY3Rpb24gKHZhbHVlQ29udmVydGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZU1hcElucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRNYXBCYXNlZEluc3RydWN0aW9uKHZhbHVlQ29udmVydGVyLCBmYWxzZSwgdGhpcy5fc3R5bGVNYXBJbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTdHlsaW5nQnVpbGRlci5wcm90b3R5cGUuX2J1aWxkTWFwQmFzZWRJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZUNvbnZlcnRlciwgaXNDbGFzc0Jhc2VkLCBzdHlsaW5nSW5wdXQpIHtcbiAgICAgICAgLy8gZWFjaCBzdHlsaW5nIGJpbmRpbmcgdmFsdWUgaXMgc3RvcmVkIGluIHRoZSBMVmlld1xuICAgICAgICB2YXIgdG90YWxCaW5kaW5nU2xvdHNSZXF1aXJlZCA9IDE7XG4gICAgICAgIC8vIHRoZXNlIHZhbHVlcyBtdXN0IGJlIG91dHNpZGUgb2YgdGhlIHVwZGF0ZSBibG9jayBzbyB0aGF0IHRoZXkgY2FuXG4gICAgICAgIC8vIGJlIGV2YWx1YXRlZCAodGhlIEFTVCB2aXNpdCBjYWxsKSBkdXJpbmcgY3JlYXRpb24gdGltZSBzbyB0aGF0IGFueVxuICAgICAgICAvLyBwaXBlcyBjYW4gYmUgcGlja2VkIHVwIGluIHRpbWUgYmVmb3JlIHRoZSB0ZW1wbGF0ZSBpcyBidWlsdFxuICAgICAgICB2YXIgbWFwVmFsdWUgPSBzdHlsaW5nSW5wdXQudmFsdWUudmlzaXQodmFsdWVDb252ZXJ0ZXIpO1xuICAgICAgICB2YXIgcmVmZXJlbmNlO1xuICAgICAgICBpZiAobWFwVmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uICYmIGlzQ2xhc3NCYXNlZCkge1xuICAgICAgICAgICAgdG90YWxCaW5kaW5nU2xvdHNSZXF1aXJlZCArPSBtYXBWYWx1ZS5leHByZXNzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICByZWZlcmVuY2UgPSBnZXRDbGFzc01hcEludGVycG9sYXRpb25FeHByZXNzaW9uKG1hcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IGlzQ2xhc3NCYXNlZCA/IElkZW50aWZpZXJzJDEuY2xhc3NNYXAgOiBJZGVudGlmaWVycyQxLnN0eWxlTWFwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBzdHlsaW5nSW5wdXQuc291cmNlU3BhbixcbiAgICAgICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICAgICAgYWxsb2NhdGVCaW5kaW5nU2xvdHM6IHRvdGFsQmluZGluZ1Nsb3RzUmVxdWlyZWQsXG4gICAgICAgICAgICBzdXBwb3J0c0ludGVycG9sYXRpb246IGlzQ2xhc3NCYXNlZCxcbiAgICAgICAgICAgIHBhcmFtczogZnVuY3Rpb24gKGNvbnZlcnRGbikge1xuICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0UmVzdWx0ID0gY29udmVydEZuKG1hcFZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjb252ZXJ0UmVzdWx0KSA/IGNvbnZlcnRSZXN1bHQgOiBbY29udmVydFJlc3VsdF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBTdHlsaW5nQnVpbGRlci5wcm90b3R5cGUuX2J1aWxkU2luZ2xlSW5wdXRzID0gZnVuY3Rpb24gKHJlZmVyZW5jZSwgaW5wdXRzLCBtYXBJbmRleCwgYWxsb3dVbml0cywgdmFsdWVDb252ZXJ0ZXIsIGdldEludGVycG9sYXRpb25FeHByZXNzaW9uRm4pIHtcbiAgICAgICAgdmFyIHRvdGFsQmluZGluZ1Nsb3RzUmVxdWlyZWQgPSAwO1xuICAgICAgICByZXR1cm4gaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0LnZhbHVlLnZpc2l0KHZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgIC8vIGVhY2ggc3R5bGluZyBiaW5kaW5nIHZhbHVlIGlzIHN0b3JlZCBpbiB0aGUgTFZpZXdcbiAgICAgICAgICAgIHZhciB0b3RhbEJpbmRpbmdTbG90c1JlcXVpcmVkID0gMTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0b3RhbEJpbmRpbmdTbG90c1JlcXVpcmVkICs9IHZhbHVlLmV4cHJlc3Npb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0SW50ZXJwb2xhdGlvbkV4cHJlc3Npb25Gbikge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2UgPSBnZXRJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbkZuKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGlucHV0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgc3VwcG9ydHNJbnRlcnBvbGF0aW9uOiAhIWdldEludGVycG9sYXRpb25FeHByZXNzaW9uRm4sXG4gICAgICAgICAgICAgICAgYWxsb2NhdGVCaW5kaW5nU2xvdHM6IHRvdGFsQmluZGluZ1Nsb3RzUmVxdWlyZWQsIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgIHBhcmFtczogZnVuY3Rpb24gKGNvbnZlcnRGbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXJhbXMgPT4gc3R5bGluZ1Byb3AocHJvcE5hbWUsIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGxpdGVyYWwoaW5wdXQubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udmVydFJlc3VsdCA9IGNvbnZlcnRGbih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnZlcnRSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaC5hcHBseShwYXJhbXMsIF9fc3ByZWFkKGNvbnZlcnRSZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGNvbnZlcnRSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxvd1VuaXRzICYmIGlucHV0LnVuaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGxpdGVyYWwoaW5wdXQudW5pdCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdHlsaW5nQnVpbGRlci5wcm90b3R5cGUuX2J1aWxkQ2xhc3NJbnB1dHMgPSBmdW5jdGlvbiAodmFsdWVDb252ZXJ0ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NpbmdsZUNsYXNzSW5wdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRTaW5nbGVJbnB1dHMoSWRlbnRpZmllcnMkMS5jbGFzc1Byb3AsIHRoaXMuX3NpbmdsZUNsYXNzSW5wdXRzLCB0aGlzLl9jbGFzc2VzSW5kZXgsIGZhbHNlLCB2YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgU3R5bGluZ0J1aWxkZXIucHJvdG90eXBlLl9idWlsZFN0eWxlSW5wdXRzID0gZnVuY3Rpb24gKHZhbHVlQ29udmVydGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaW5nbGVTdHlsZUlucHV0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkU2luZ2xlSW5wdXRzKElkZW50aWZpZXJzJDEuc3R5bGVQcm9wLCB0aGlzLl9zaW5nbGVTdHlsZUlucHV0cywgdGhpcy5fc3R5bGVzSW5kZXgsIHRydWUsIHZhbHVlQ29udmVydGVyLCBnZXRTdHlsZVByb3BJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgU3R5bGluZ0J1aWxkZXIucHJvdG90eXBlLl9idWlsZEFwcGx5Rm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiB0aGlzLl9sYXN0U3R5bGluZ0lucHV0ID8gdGhpcy5fbGFzdFN0eWxpbmdJbnB1dC5zb3VyY2VTcGFuIDogbnVsbCxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogSWRlbnRpZmllcnMkMS5zdHlsaW5nQXBwbHksXG4gICAgICAgICAgICBhbGxvY2F0ZUJpbmRpbmdTbG90czogMCxcbiAgICAgICAgICAgIHBhcmFtczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFN0eWxpbmdCdWlsZGVyLnByb3RvdHlwZS5fYnVpbGRTYW5pdGl6ZXJGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IHRoaXMuX2ZpcnN0U3R5bGluZ0lucHV0ID8gdGhpcy5fZmlyc3RTdHlsaW5nSW5wdXQuc291cmNlU3BhbiA6IG51bGwsXG4gICAgICAgICAgICByZWZlcmVuY2U6IElkZW50aWZpZXJzJDEuc3R5bGVTYW5pdGl6ZXIsXG4gICAgICAgICAgICBhbGxvY2F0ZUJpbmRpbmdTbG90czogMCxcbiAgICAgICAgICAgIHBhcmFtczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW2ltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5kZWZhdWx0U3R5bGVTYW5pdGl6ZXIpXTsgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbGwgaW5zdHJ1Y3Rpb25zIHdoaWNoIGNvbnRhaW4gdGhlIGV4cHJlc3Npb25zIHRoYXQgd2lsbCBiZSBwbGFjZWRcbiAgICAgKiBpbnRvIHRoZSB1cGRhdGUgYmxvY2sgb2YgYSB0ZW1wbGF0ZSBmdW5jdGlvbiBvciBhIGRpcmVjdGl2ZSBob3N0QmluZGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgU3R5bGluZ0J1aWxkZXIucHJvdG90eXBlLmJ1aWxkVXBkYXRlTGV2ZWxJbnN0cnVjdGlvbnMgPSBmdW5jdGlvbiAodmFsdWVDb252ZXJ0ZXIpIHtcbiAgICAgICAgdmFyIGluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5oYXNCaW5kaW5ncykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VzZURlZmF1bHRTYW5pdGl6ZXIpIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaCh0aGlzLl9idWlsZFNhbml0aXplckZuKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0eWxlTWFwSW5zdHJ1Y3Rpb24gPSB0aGlzLmJ1aWxkU3R5bGVNYXBJbnN0cnVjdGlvbih2YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgICAgICBpZiAoc3R5bGVNYXBJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKHN0eWxlTWFwSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNsYXNzTWFwSW5zdHJ1Y3Rpb24gPSB0aGlzLmJ1aWxkQ2xhc3NNYXBJbnN0cnVjdGlvbih2YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgICAgICBpZiAoY2xhc3NNYXBJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKGNsYXNzTWFwSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2guYXBwbHkoaW5zdHJ1Y3Rpb25zLCBfX3NwcmVhZCh0aGlzLl9idWlsZFN0eWxlSW5wdXRzKHZhbHVlQ29udmVydGVyKSkpO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2guYXBwbHkoaW5zdHJ1Y3Rpb25zLCBfX3NwcmVhZCh0aGlzLl9idWlsZENsYXNzSW5wdXRzKHZhbHVlQ29udmVydGVyKSkpO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2godGhpcy5fYnVpbGRBcHBseUZuKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbnM7XG4gICAgfTtcbiAgICByZXR1cm4gU3R5bGluZ0J1aWxkZXI7XG59KCkpO1xuZnVuY3Rpb24gcmVnaXN0ZXJJbnRvTWFwKG1hcCwga2V5KSB7XG4gICAgaWYgKCFtYXAuaGFzKGtleSkpIHtcbiAgICAgICAgbWFwLnNldChrZXksIG1hcC5zaXplKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1N0eWxlU2FuaXRpemFibGUocHJvcCkge1xuICAgIC8vIE5vdGUgdGhhdCBicm93c2VycyBzdXBwb3J0IGJvdGggdGhlIGRhc2ggY2FzZSBhbmRcbiAgICAvLyBjYW1lbCBjYXNlIHByb3BlcnR5IG5hbWVzIHdoZW4gc2V0dGluZyB0aHJvdWdoIEpTLlxuICAgIHJldHVybiBwcm9wID09PSAnYmFja2dyb3VuZC1pbWFnZScgfHwgcHJvcCA9PT0gJ2JhY2tncm91bmRJbWFnZScgfHwgcHJvcCA9PT0gJ2JhY2tncm91bmQnIHx8XG4gICAgICAgIHByb3AgPT09ICdib3JkZXItaW1hZ2UnIHx8IHByb3AgPT09ICdib3JkZXJJbWFnZScgfHwgcHJvcCA9PT0gJ2ZpbHRlcicgfHxcbiAgICAgICAgcHJvcCA9PT0gJ2xpc3Qtc3R5bGUnIHx8IHByb3AgPT09ICdsaXN0U3R5bGUnIHx8IHByb3AgPT09ICdsaXN0LXN0eWxlLWltYWdlJyB8fFxuICAgICAgICBwcm9wID09PSAnbGlzdFN0eWxlSW1hZ2UnIHx8IHByb3AgPT09ICdjbGlwLXBhdGgnIHx8IHByb3AgPT09ICdjbGlwUGF0aCc7XG59XG4vKipcbiAqIFNpbXBsZSBoZWxwZXIgZnVuY3Rpb24gdG8gZWl0aGVyIHByb3ZpZGUgdGhlIGNvbnN0YW50IGxpdGVyYWwgdGhhdCB3aWxsIGhvdXNlIHRoZSB2YWx1ZVxuICogaGVyZSBvciBhIG51bGwgdmFsdWUgaWYgdGhlIHByb3ZpZGVkIHZhbHVlcyBhcmUgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIGdldENvbnN0YW50TGl0ZXJhbEZyb21BcnJheShjb25zdGFudFBvb2wsIHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMubGVuZ3RoID8gY29uc3RhbnRQb29sLmdldENvbnN0TGl0ZXJhbChsaXRlcmFsQXJyKHZhbHVlcyksIHRydWUpIDogTlVMTF9FWFBSO1xufVxuLyoqXG4gKiBTaW1wbGUgaGVscGVyIGZ1bmN0aW9uIHRoYXQgYWRkcyBhIHBhcmFtZXRlciBvciBkb2VzIG5vdGhpbmcgYXQgYWxsIGRlcGVuZGluZyBvbiB0aGUgcHJvdmlkZWRcbiAqIHByZWRpY2F0ZSBhbmQgdG90YWxFeHBlY3RlZEFyZ3MgdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIGFkZFBhcmFtKHBhcmFtcywgcHJlZGljYXRlLCB2YWx1ZSwgYXJnTnVtYmVyLCB0b3RhbEV4cGVjdGVkQXJncykge1xuICAgIGlmIChwcmVkaWNhdGUgJiYgdmFsdWUpIHtcbiAgICAgICAgcGFyYW1zLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmdOdW1iZXIgPCB0b3RhbEV4cGVjdGVkQXJncykge1xuICAgICAgICBwYXJhbXMucHVzaChOVUxMX0VYUFIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlUHJvcGVydHkobmFtZSkge1xuICAgIHZhciBoYXNPdmVycmlkZUZsYWcgPSBmYWxzZTtcbiAgICB2YXIgb3ZlcnJpZGVJbmRleCA9IG5hbWUuaW5kZXhPZihJTVBPUlRBTlRfRkxBRyk7XG4gICAgaWYgKG92ZXJyaWRlSW5kZXggIT09IC0xKSB7XG4gICAgICAgIG5hbWUgPSBvdmVycmlkZUluZGV4ID4gMCA/IG5hbWUuc3Vic3RyaW5nKDAsIG92ZXJyaWRlSW5kZXgpIDogJyc7XG4gICAgICAgIGhhc092ZXJyaWRlRmxhZyA9IHRydWU7XG4gICAgfVxuICAgIHZhciB1bml0ID0gJyc7XG4gICAgdmFyIHByb3BlcnR5ID0gbmFtZTtcbiAgICB2YXIgdW5pdEluZGV4ID0gbmFtZS5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmICh1bml0SW5kZXggPiAwKSB7XG4gICAgICAgIHVuaXQgPSBuYW1lLnN1YnN0cih1bml0SW5kZXggKyAxKTtcbiAgICAgICAgcHJvcGVydHkgPSBuYW1lLnN1YnN0cmluZygwLCB1bml0SW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4geyBwcm9wZXJ0eTogcHJvcGVydHksIHVuaXQ6IHVuaXQsIGhhc092ZXJyaWRlRmxhZzogaGFzT3ZlcnJpZGVGbGFnIH07XG59XG4vKipcbiAqIEdldHMgdGhlIGluc3RydWN0aW9uIHRvIGdlbmVyYXRlIGZvciBhbiBpbnRlcnBvbGF0ZWQgY2xhc3MgbWFwLlxuICogQHBhcmFtIGludGVycG9sYXRpb24gQW4gSW50ZXJwb2xhdGlvbiBBU1RcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xhc3NNYXBJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihpbnRlcnBvbGF0aW9uKSB7XG4gICAgc3dpdGNoIChnZXRJbnRlcnBvbGF0aW9uQXJnc0xlbmd0aChpbnRlcnBvbGF0aW9uKSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5jbGFzc01hcDtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuY2xhc3NNYXBJbnRlcnBvbGF0ZTE7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLmNsYXNzTWFwSW50ZXJwb2xhdGUyO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlMztcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuY2xhc3NNYXBJbnRlcnBvbGF0ZTQ7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlNTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLmNsYXNzTWFwSW50ZXJwb2xhdGU2O1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuY2xhc3NNYXBJbnRlcnBvbGF0ZTc7XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLmNsYXNzTWFwSW50ZXJwb2xhdGVWO1xuICAgIH1cbn1cbi8qKlxuICogR2V0cyB0aGUgaW5zdHJ1Y3Rpb24gdG8gZ2VuZXJhdGUgZm9yIGFuIGludGVycG9sYXRlZCBzdHlsZSBwcm9wLlxuICogQHBhcmFtIGludGVycG9sYXRpb24gQW4gSW50ZXJwb2xhdGlvbiBBU1RcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVQcm9wSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oaW50ZXJwb2xhdGlvbikge1xuICAgIHN3aXRjaCAoZ2V0SW50ZXJwb2xhdGlvbkFyZ3NMZW5ndGgoaW50ZXJwb2xhdGlvbikpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVQcm9wO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZTE7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnN0eWxlUHJvcEludGVycG9sYXRlMjtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVQcm9wSW50ZXJwb2xhdGUzO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZTQ7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZTU7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZTY7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZTc7XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZTg7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZVY7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcE5hbWUocHJvcCkge1xuICAgIHJldHVybiBoeXBoZW5hdGUocHJvcCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUb2tlblR5cGUkMTtcbihmdW5jdGlvbiAoVG9rZW5UeXBlKSB7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNoYXJhY3RlclwiXSA9IDBdID0gXCJDaGFyYWN0ZXJcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiSWRlbnRpZmllclwiXSA9IDFdID0gXCJJZGVudGlmaWVyXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIktleXdvcmRcIl0gPSAyXSA9IFwiS2V5d29yZFwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJTdHJpbmdcIl0gPSAzXSA9IFwiU3RyaW5nXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIk9wZXJhdG9yXCJdID0gNF0gPSBcIk9wZXJhdG9yXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIk51bWJlclwiXSA9IDVdID0gXCJOdW1iZXJcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRXJyb3JcIl0gPSA2XSA9IFwiRXJyb3JcIjtcbn0pKFRva2VuVHlwZSQxIHx8IChUb2tlblR5cGUkMSA9IHt9KSk7XG52YXIgS0VZV09SRFMgPSBbJ3ZhcicsICdsZXQnLCAnYXMnLCAnbnVsbCcsICd1bmRlZmluZWQnLCAndHJ1ZScsICdmYWxzZScsICdpZicsICdlbHNlJywgJ3RoaXMnXTtcbnZhciBMZXhlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZXhlcigpIHtcbiAgICB9XG4gICAgTGV4ZXIucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIHNjYW5uZXIgPSBuZXcgX1NjYW5uZXIodGV4dCk7XG4gICAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgICAgdmFyIHRva2VuID0gc2Nhbm5lci5zY2FuVG9rZW4oKTtcbiAgICAgICAgd2hpbGUgKHRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIHRva2VuID0gc2Nhbm5lci5zY2FuVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH07XG4gICAgcmV0dXJuIExleGVyO1xufSgpKTtcbnZhciBUb2tlbiQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRva2VuKGluZGV4LCB0eXBlLCBudW1WYWx1ZSwgc3RyVmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm51bVZhbHVlID0gbnVtVmFsdWU7XG4gICAgICAgIHRoaXMuc3RyVmFsdWUgPSBzdHJWYWx1ZTtcbiAgICB9XG4gICAgVG9rZW4ucHJvdG90eXBlLmlzQ2hhcmFjdGVyID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUkMS5DaGFyYWN0ZXIgJiYgdGhpcy5udW1WYWx1ZSA9PSBjb2RlO1xuICAgIH07XG4gICAgVG9rZW4ucHJvdG90eXBlLmlzTnVtYmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZSQxLk51bWJlcjsgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNTdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlJDEuU3RyaW5nOyB9O1xuICAgIFRva2VuLnByb3RvdHlwZS5pc09wZXJhdG9yID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlJDEuT3BlcmF0b3IgJiYgdGhpcy5zdHJWYWx1ZSA9PSBvcGVyYXRvcjtcbiAgICB9O1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0lkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlJDEuSWRlbnRpZmllcjsgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZSQxLktleXdvcmQ7IH07XG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZExldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUkMS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ2xldCc7IH07XG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZEFzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZSQxLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAnYXMnOyB9O1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmROdWxsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZSQxLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAnbnVsbCc7IH07XG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZFVuZGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUkMS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ3VuZGVmaW5lZCc7XG4gICAgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkVHJ1ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUkMS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ3RydWUnOyB9O1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRGYWxzZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUkMS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ2ZhbHNlJzsgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUkMS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ3RoaXMnOyB9O1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0Vycm9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZSQxLkVycm9yOyB9O1xuICAgIFRva2VuLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUkMS5OdW1iZXIgPyB0aGlzLm51bVZhbHVlIDogLTE7IH07XG4gICAgVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUkMS5DaGFyYWN0ZXI6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZSQxLklkZW50aWZpZXI6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZSQxLktleXdvcmQ6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZSQxLk9wZXJhdG9yOlxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUkMS5TdHJpbmc6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZSQxLkVycm9yOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0clZhbHVlO1xuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUkMS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUb2tlbjtcbn0oKSk7XG5mdW5jdGlvbiBuZXdDaGFyYWN0ZXJUb2tlbihpbmRleCwgY29kZSkge1xuICAgIHJldHVybiBuZXcgVG9rZW4kMShpbmRleCwgVG9rZW5UeXBlJDEuQ2hhcmFjdGVyLCBjb2RlLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbn1cbmZ1bmN0aW9uIG5ld0lkZW50aWZpZXJUb2tlbihpbmRleCwgdGV4dCkge1xuICAgIHJldHVybiBuZXcgVG9rZW4kMShpbmRleCwgVG9rZW5UeXBlJDEuSWRlbnRpZmllciwgMCwgdGV4dCk7XG59XG5mdW5jdGlvbiBuZXdLZXl3b3JkVG9rZW4oaW5kZXgsIHRleHQpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuJDEoaW5kZXgsIFRva2VuVHlwZSQxLktleXdvcmQsIDAsIHRleHQpO1xufVxuZnVuY3Rpb24gbmV3T3BlcmF0b3JUb2tlbihpbmRleCwgdGV4dCkge1xuICAgIHJldHVybiBuZXcgVG9rZW4kMShpbmRleCwgVG9rZW5UeXBlJDEuT3BlcmF0b3IsIDAsIHRleHQpO1xufVxuZnVuY3Rpb24gbmV3U3RyaW5nVG9rZW4oaW5kZXgsIHRleHQpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuJDEoaW5kZXgsIFRva2VuVHlwZSQxLlN0cmluZywgMCwgdGV4dCk7XG59XG5mdW5jdGlvbiBuZXdOdW1iZXJUb2tlbihpbmRleCwgbikge1xuICAgIHJldHVybiBuZXcgVG9rZW4kMShpbmRleCwgVG9rZW5UeXBlJDEuTnVtYmVyLCBuLCAnJyk7XG59XG5mdW5jdGlvbiBuZXdFcnJvclRva2VuKGluZGV4LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbiQxKGluZGV4LCBUb2tlblR5cGUkMS5FcnJvciwgMCwgbWVzc2FnZSk7XG59XG52YXIgRU9GID0gbmV3IFRva2VuJDEoLTEsIFRva2VuVHlwZSQxLkNoYXJhY3RlciwgMCwgJycpO1xudmFyIF9TY2FubmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9TY2FubmVyKGlucHV0KSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5wZWVrID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgfVxuICAgIF9TY2FubmVyLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBlZWsgPSArK3RoaXMuaW5kZXggPj0gdGhpcy5sZW5ndGggPyAkRU9GIDogdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xuICAgIH07XG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5Ub2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dCwgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHZhciBwZWVrID0gdGhpcy5wZWVrLCBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZS5cbiAgICAgICAgd2hpbGUgKHBlZWsgPD0gJFNQQUNFKSB7XG4gICAgICAgICAgICBpZiAoKytpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwZWVrID0gJEVPRjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZWsgPSBpbnB1dC5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlZWsgPSBwZWVrO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBpZGVudGlmaWVycyBhbmQgbnVtYmVycy5cbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHBlZWspKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbklkZW50aWZpZXIoKTtcbiAgICAgICAgaWYgKGlzRGlnaXQocGVlaykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuTnVtYmVyKGluZGV4KTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIHN3aXRjaCAocGVlaykge1xuICAgICAgICAgICAgY2FzZSAkUEVSSU9EOlxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0RpZ2l0KHRoaXMucGVlaykgPyB0aGlzLnNjYW5OdW1iZXIoc3RhcnQpIDpcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hhcmFjdGVyVG9rZW4oc3RhcnQsICRQRVJJT0QpO1xuICAgICAgICAgICAgY2FzZSAkTFBBUkVOOlxuICAgICAgICAgICAgY2FzZSAkUlBBUkVOOlxuICAgICAgICAgICAgY2FzZSAkTEJSQUNFOlxuICAgICAgICAgICAgY2FzZSAkUkJSQUNFOlxuICAgICAgICAgICAgY2FzZSAkTEJSQUNLRVQ6XG4gICAgICAgICAgICBjYXNlICRSQlJBQ0tFVDpcbiAgICAgICAgICAgIGNhc2UgJENPTU1BOlxuICAgICAgICAgICAgY2FzZSAkQ09MT046XG4gICAgICAgICAgICBjYXNlICRTRU1JQ09MT046XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNoYXJhY3RlcihzdGFydCwgcGVlayk7XG4gICAgICAgICAgICBjYXNlICRTUTpcbiAgICAgICAgICAgIGNhc2UgJERROlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5TdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgJEhBU0g6XG4gICAgICAgICAgICBjYXNlICRQTFVTOlxuICAgICAgICAgICAgY2FzZSAkTUlOVVM6XG4gICAgICAgICAgICBjYXNlICRTVEFSOlxuICAgICAgICAgICAgY2FzZSAkU0xBU0g6XG4gICAgICAgICAgICBjYXNlICRQRVJDRU5UOlxuICAgICAgICAgICAgY2FzZSAkQ0FSRVQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk9wZXJhdG9yKHN0YXJ0LCBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspKTtcbiAgICAgICAgICAgIGNhc2UgJFFVRVNUSU9OOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsICc/JywgJFBFUklPRCwgJy4nKTtcbiAgICAgICAgICAgIGNhc2UgJExUOlxuICAgICAgICAgICAgY2FzZSAkR1Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgU3RyaW5nLmZyb21DaGFyQ29kZShwZWVrKSwgJEVRLCAnPScpO1xuICAgICAgICAgICAgY2FzZSAkQkFORzpcbiAgICAgICAgICAgIGNhc2UgJEVROlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsIFN0cmluZy5mcm9tQ2hhckNvZGUocGVlayksICRFUSwgJz0nLCAkRVEsICc9Jyk7XG4gICAgICAgICAgICBjYXNlICRBTVBFUlNBTkQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgJyYnLCAkQU1QRVJTQU5ELCAnJicpO1xuICAgICAgICAgICAgY2FzZSAkQkFSOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsICd8JywgJEJBUiwgJ3wnKTtcbiAgICAgICAgICAgIGNhc2UgJE5CU1A6XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlzV2hpdGVzcGFjZSh0aGlzLnBlZWspKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlciBbXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspICsgXCJdXCIsIDApO1xuICAgIH07XG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5DaGFyYWN0ZXIgPSBmdW5jdGlvbiAoc3RhcnQsIGNvZGUpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiBuZXdDaGFyYWN0ZXJUb2tlbihzdGFydCwgY29kZSk7XG4gICAgfTtcbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2Nhbk9wZXJhdG9yID0gZnVuY3Rpb24gKHN0YXJ0LCBzdHIpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiBuZXdPcGVyYXRvclRva2VuKHN0YXJ0LCBzdHIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVG9rZW5pemUgYSAyLzMgY2hhciBsb25nIG9wZXJhdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQgc3RhcnQgaW5kZXggaW4gdGhlIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gb25lIGZpcnN0IHN5bWJvbCAoYWx3YXlzIHBhcnQgb2YgdGhlIG9wZXJhdG9yKVxuICAgICAqIEBwYXJhbSB0d29Db2RlIGNvZGUgcG9pbnQgZm9yIHRoZSBzZWNvbmQgc3ltYm9sXG4gICAgICogQHBhcmFtIHR3byBzZWNvbmQgc3ltYm9sIChwYXJ0IG9mIHRoZSBvcGVyYXRvciB3aGVuIHRoZSBzZWNvbmQgY29kZSBwb2ludCBtYXRjaGVzKVxuICAgICAqIEBwYXJhbSB0aHJlZUNvZGUgY29kZSBwb2ludCBmb3IgdGhlIHRoaXJkIHN5bWJvbFxuICAgICAqIEBwYXJhbSB0aHJlZSB0aGlyZCBzeW1ib2wgKHBhcnQgb2YgdGhlIG9wZXJhdG9yIHdoZW4gcHJvdmlkZWQgYW5kIG1hdGNoZXMgc291cmNlIGV4cHJlc3Npb24pXG4gICAgICovXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5Db21wbGV4T3BlcmF0b3IgPSBmdW5jdGlvbiAoc3RhcnQsIG9uZSwgdHdvQ29kZSwgdHdvLCB0aHJlZUNvZGUsIHRocmVlKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB2YXIgc3RyID0gb25lO1xuICAgICAgICBpZiAodGhpcy5wZWVrID09IHR3b0NvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgc3RyICs9IHR3bztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyZWVDb2RlICE9IG51bGwgJiYgdGhpcy5wZWVrID09IHRocmVlQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICBzdHIgKz0gdGhyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld09wZXJhdG9yVG9rZW4oc3RhcnQsIHN0cik7XG4gICAgfTtcbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhbklkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB3aGlsZSAoaXNJZGVudGlmaWVyUGFydCh0aGlzLnBlZWspKVxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgIHJldHVybiBLRVlXT1JEUy5pbmRleE9mKHN0cikgPiAtMSA/IG5ld0tleXdvcmRUb2tlbihzdGFydCwgc3RyKSA6XG4gICAgICAgICAgICBuZXdJZGVudGlmaWVyVG9rZW4oc3RhcnQsIHN0cik7XG4gICAgfTtcbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2Nhbk51bWJlciA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgc2ltcGxlID0gKHRoaXMuaW5kZXggPT09IHN0YXJ0KTtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIFNraXAgaW5pdGlhbCBkaWdpdC5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChpc0RpZ2l0KHRoaXMucGVlaykpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09ICRQRVJJT0QpIHtcbiAgICAgICAgICAgICAgICBzaW1wbGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRXhwb25lbnRTdGFydCh0aGlzLnBlZWspKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXhwb25lbnRTaWduKHRoaXMucGVlaykpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmICghaXNEaWdpdCh0aGlzLnBlZWspKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignSW52YWxpZCBleHBvbmVudCcsIC0xKTtcbiAgICAgICAgICAgICAgICBzaW1wbGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgdmFyIHZhbHVlID0gc2ltcGxlID8gcGFyc2VJbnRBdXRvUmFkaXgoc3RyKSA6IHBhcnNlRmxvYXQoc3RyKTtcbiAgICAgICAgcmV0dXJuIG5ld051bWJlclRva2VuKHN0YXJ0LCB2YWx1ZSk7XG4gICAgfTtcbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhblN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdmFyIHF1b3RlID0gdGhpcy5wZWVrO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCBpbml0aWFsIHF1b3RlLlxuICAgICAgICB2YXIgYnVmZmVyID0gJyc7XG4gICAgICAgIHZhciBtYXJrZXIgPSB0aGlzLmluZGV4O1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgICAgICB3aGlsZSAodGhpcy5wZWVrICE9IHF1b3RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrID09ICRCQUNLU0xBU0gpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIgKz0gaW5wdXQuc3Vic3RyaW5nKG1hcmtlciwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHVuZXNjYXBlZENvZGUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgVFMyLjEtaW50cm9kdWNlZCB0eXBlIHN0cmljdG5lc3NcbiAgICAgICAgICAgICAgICB0aGlzLnBlZWsgPSB0aGlzLnBlZWs7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVlayA9PSAkdSkge1xuICAgICAgICAgICAgICAgICAgICAvLyA0IGNoYXJhY3RlciBoZXggY29kZSBmb3IgdW5pY29kZSBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgIHZhciBoZXggPSBpbnB1dC5zdWJzdHJpbmcodGhpcy5pbmRleCArIDEsIHRoaXMuaW5kZXggKyA1KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eWzAtOWEtZl0rJC9pLnRlc3QoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkQ29kZSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlIFtcXFxcdVwiICsgaGV4ICsgXCJdXCIsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkQ29kZSA9IHVuZXNjYXBlKHRoaXMucGVlayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bmVzY2FwZWRDb2RlKTtcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09ICRFT0YpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignVW50ZXJtaW5hdGVkIHF1b3RlJywgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFzdCA9IGlucHV0LnN1YnN0cmluZyhtYXJrZXIsIHRoaXMuaW5kZXgpO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCB0ZXJtaW5hdGluZyBxdW90ZS5cbiAgICAgICAgcmV0dXJuIG5ld1N0cmluZ1Rva2VuKHN0YXJ0LCBidWZmZXIgKyBsYXN0KTtcbiAgICB9O1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5pbmRleCArIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIG5ld0Vycm9yVG9rZW4ocG9zaXRpb24sIFwiTGV4ZXIgRXJyb3I6IFwiICsgbWVzc2FnZSArIFwiIGF0IGNvbHVtbiBcIiArIHBvc2l0aW9uICsgXCIgaW4gZXhwcmVzc2lvbiBbXCIgKyB0aGlzLmlucHV0ICsgXCJdXCIpO1xuICAgIH07XG4gICAgcmV0dXJuIF9TY2FubmVyO1xufSgpKTtcbmZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpIHtcbiAgICByZXR1cm4gKCRhIDw9IGNvZGUgJiYgY29kZSA8PSAkeikgfHwgKCRBIDw9IGNvZGUgJiYgY29kZSA8PSAkWikgfHxcbiAgICAgICAgKGNvZGUgPT0gJF8pIHx8IChjb2RlID09ICQkKTtcbn1cbmZ1bmN0aW9uIGlzSWRlbnRpZmllcihpbnB1dCkge1xuICAgIGlmIChpbnB1dC5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBzY2FubmVyID0gbmV3IF9TY2FubmVyKGlucHV0KTtcbiAgICBpZiAoIWlzSWRlbnRpZmllclN0YXJ0KHNjYW5uZXIucGVlaykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICB3aGlsZSAoc2Nhbm5lci5wZWVrICE9PSAkRU9GKSB7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChzY2FubmVyLnBlZWspKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNvZGUpIHtcbiAgICByZXR1cm4gaXNBc2NpaUxldHRlcihjb2RlKSB8fCBpc0RpZ2l0KGNvZGUpIHx8IChjb2RlID09ICRfKSB8fFxuICAgICAgICAoY29kZSA9PSAkJCk7XG59XG5mdW5jdGlvbiBpc0V4cG9uZW50U3RhcnQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09ICRlIHx8IGNvZGUgPT0gJEU7XG59XG5mdW5jdGlvbiBpc0V4cG9uZW50U2lnbihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gJE1JTlVTIHx8IGNvZGUgPT0gJFBMVVM7XG59XG5mdW5jdGlvbiBpc1F1b3RlKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gJFNRIHx8IGNvZGUgPT09ICREUSB8fCBjb2RlID09PSAkQlQ7XG59XG5mdW5jdGlvbiB1bmVzY2FwZShjb2RlKSB7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgJG46XG4gICAgICAgICAgICByZXR1cm4gJExGO1xuICAgICAgICBjYXNlICRmOlxuICAgICAgICAgICAgcmV0dXJuICRGRjtcbiAgICAgICAgY2FzZSAkcjpcbiAgICAgICAgICAgIHJldHVybiAkQ1I7XG4gICAgICAgIGNhc2UgJHQ6XG4gICAgICAgICAgICByZXR1cm4gJFRBQjtcbiAgICAgICAgY2FzZSAkdjpcbiAgICAgICAgICAgIHJldHVybiAkVlRBQjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSW50QXV0b1JhZGl4KHRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQodGV4dCk7XG4gICAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVnZXIgbGl0ZXJhbCB3aGVuIHBhcnNpbmcgJyArIHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgU3BsaXRJbnRlcnBvbGF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNwbGl0SW50ZXJwb2xhdGlvbihzdHJpbmdzLCBleHByZXNzaW9ucywgb2Zmc2V0cykge1xuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgIHRoaXMub2Zmc2V0cyA9IG9mZnNldHM7XG4gICAgfVxuICAgIHJldHVybiBTcGxpdEludGVycG9sYXRpb247XG59KCkpO1xudmFyIFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0KHRlbXBsYXRlQmluZGluZ3MsIHdhcm5pbmdzLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUJpbmRpbmdzID0gdGVtcGxhdGVCaW5kaW5ncztcbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IHdhcm5pbmdzO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG4gICAgcmV0dXJuIFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0O1xufSgpKTtcbmZ1bmN0aW9uIF9jcmVhdGVJbnRlcnBvbGF0ZVJlZ0V4cChjb25maWcpIHtcbiAgICB2YXIgcGF0dGVybiA9IGVzY2FwZVJlZ0V4cChjb25maWcuc3RhcnQpICsgJyhbXFxcXHNcXFxcU10qPyknICsgZXNjYXBlUmVnRXhwKGNvbmZpZy5lbmQpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sICdnJyk7XG59XG52YXIgUGFyc2VyJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VyKF9sZXhlcikge1xuICAgICAgICB0aGlzLl9sZXhlciA9IF9sZXhlcjtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICB9XG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFjdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgdGhpcy5fY2hlY2tOb0ludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdmFyIHNvdXJjZVRvTGV4ID0gdGhpcy5fc3RyaXBDb21tZW50cyhpbnB1dCk7XG4gICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZSh0aGlzLl9zdHJpcENvbW1lbnRzKGlucHV0KSk7XG4gICAgICAgIHZhciBhc3QgPSBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIHRva2Vucywgc291cmNlVG9MZXgubGVuZ3RoLCB0cnVlLCB0aGlzLmVycm9ycywgaW5wdXQubGVuZ3RoIC0gc291cmNlVG9MZXgubGVuZ3RoKVxuICAgICAgICAgICAgLnBhcnNlQ2hhaW4oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKGFzdCwgaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgdGhpcy5lcnJvcnMpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJpbmRpbmcgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIHZhciBhc3QgPSB0aGlzLl9wYXJzZUJpbmRpbmdBc3QoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShhc3QsIGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTaW1wbGVCaW5kaW5nID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICB2YXIgYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nQXN0KGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICB2YXIgZXJyb3JzID0gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIuY2hlY2soYXN0KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkhvc3QgYmluZGluZyBleHByZXNzaW9uIGNhbm5vdCBjb250YWluIFwiICsgZXJyb3JzLmpvaW4oJyAnKSwgaW5wdXQsIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBpbnB1dCwgZXJyTG9jYXRpb24sIGN0eExvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlckVycm9yKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlQmluZGluZ0FzdCA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIC8vIFF1b3RlcyBleHByZXNzaW9ucyB1c2UgM3JkLXBhcnR5IGV4cHJlc3Npb24gbGFuZ3VhZ2UuIFdlIGRvbid0IHdhbnQgdG8gdXNlXG4gICAgICAgIC8vIG91ciBsZXhlciBvciBwYXJzZXIgZm9yIHRoYXQsIHNvIHdlIGNoZWNrIGZvciB0aGF0IGFoZWFkIG9mIHRpbWUuXG4gICAgICAgIHZhciBxdW90ZSA9IHRoaXMuX3BhcnNlUXVvdGUoaW5wdXQsIGxvY2F0aW9uKTtcbiAgICAgICAgaWYgKHF1b3RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBxdW90ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGVja05vSW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICB2YXIgc291cmNlVG9MZXggPSB0aGlzLl9zdHJpcENvbW1lbnRzKGlucHV0KTtcbiAgICAgICAgdmFyIHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHNvdXJjZVRvTGV4KTtcbiAgICAgICAgcmV0dXJuIG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgdG9rZW5zLCBzb3VyY2VUb0xleC5sZW5ndGgsIGZhbHNlLCB0aGlzLmVycm9ycywgaW5wdXQubGVuZ3RoIC0gc291cmNlVG9MZXgubGVuZ3RoKVxuICAgICAgICAgICAgLnBhcnNlQ2hhaW4oKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlUXVvdGUgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uKSB7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBwcmVmaXhTZXBhcmF0b3JJbmRleCA9IGlucHV0LmluZGV4T2YoJzonKTtcbiAgICAgICAgaWYgKHByZWZpeFNlcGFyYXRvckluZGV4ID09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBwcmVmaXggPSBpbnB1dC5zdWJzdHJpbmcoMCwgcHJlZml4U2VwYXJhdG9ySW5kZXgpLnRyaW0oKTtcbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXIocHJlZml4KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgdW5pbnRlcnByZXRlZEV4cHJlc3Npb24gPSBpbnB1dC5zdWJzdHJpbmcocHJlZml4U2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdW90ZShuZXcgUGFyc2VTcGFuKDAsIGlucHV0Lmxlbmd0aCksIHByZWZpeCwgdW5pbnRlcnByZXRlZEV4cHJlc3Npb24sIGxvY2F0aW9uKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUZW1wbGF0ZUJpbmRpbmdzID0gZnVuY3Rpb24gKHRwbEtleSwgdHBsVmFsdWUsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCkge1xuICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUodHBsVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IF9QYXJzZUFTVCh0cGxWYWx1ZSwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0b2tlbnMsIHRwbFZhbHVlLmxlbmd0aCwgZmFsc2UsIHRoaXMuZXJyb3JzLCAwKVxuICAgICAgICAgICAgLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyh0cGxLZXkpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIHZhciBzcGxpdCA9IHRoaXMuc3BsaXRJbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIGlmIChzcGxpdCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0LmV4cHJlc3Npb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvblRleHQgPSBzcGxpdC5leHByZXNzaW9uc1tpXTtcbiAgICAgICAgICAgIHZhciBzb3VyY2VUb0xleCA9IHRoaXMuX3N0cmlwQ29tbWVudHMoZXhwcmVzc2lvblRleHQpO1xuICAgICAgICAgICAgdmFyIHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHNvdXJjZVRvTGV4KTtcbiAgICAgICAgICAgIHZhciBhc3QgPSBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIHRva2Vucywgc291cmNlVG9MZXgubGVuZ3RoLCBmYWxzZSwgdGhpcy5lcnJvcnMsIHNwbGl0Lm9mZnNldHNbaV0gKyAoZXhwcmVzc2lvblRleHQubGVuZ3RoIC0gc291cmNlVG9MZXgubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAucGFyc2VDaGFpbigpO1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChhc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShuZXcgSW50ZXJwb2xhdGlvbihuZXcgUGFyc2VTcGFuKDAsIGlucHV0ID09IG51bGwgPyAwIDogaW5wdXQubGVuZ3RoKSwgc3BsaXQuc3RyaW5ncywgZXhwcmVzc2lvbnMpLCBpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnNwbGl0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICB2YXIgcmVnZXhwID0gX2NyZWF0ZUludGVycG9sYXRlUmVnRXhwKGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICB2YXIgcGFydHMgPSBpbnB1dC5zcGxpdChyZWdleHApO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmdzID0gW107XG4gICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IFtdO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmIChpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGZpeGVkIHN0cmluZ1xuICAgICAgICAgICAgICAgIHN0cmluZ3MucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gcGFydC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0LnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGludGVycG9sYXRpb25Db25maWcuc3RhcnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHBhcnQubGVuZ3RoICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoJ0JsYW5rIGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZCBpbiBpbnRlcnBvbGF0ZWQgc3RyaW5ncycsIGlucHV0LCBcImF0IGNvbHVtbiBcIiArIHRoaXMuX2ZpbmRJbnRlcnBvbGF0aW9uRXJyb3JDb2x1bW4ocGFydHMsIGksIGludGVycG9sYXRpb25Db25maWcpICsgXCIgaW5cIiwgbG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goJyRpbXBsaWN0Jyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTcGxpdEludGVycG9sYXRpb24oc3RyaW5ncywgZXhwcmVzc2lvbnMsIG9mZnNldHMpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS53cmFwTGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShuZXcgTGl0ZXJhbFByaW1pdGl2ZShuZXcgUGFyc2VTcGFuKDAsIGlucHV0ID09IG51bGwgPyAwIDogaW5wdXQubGVuZ3RoKSwgaW5wdXQpLCBpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLl9zdHJpcENvbW1lbnRzID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fY29tbWVudFN0YXJ0KGlucHV0KTtcbiAgICAgICAgcmV0dXJuIGkgIT0gbnVsbCA/IGlucHV0LnN1YnN0cmluZygwLCBpKS50cmltKCkgOiBpbnB1dDtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuX2NvbW1lbnRTdGFydCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgb3V0ZXJRdW90ZSA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhciA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB2YXIgbmV4dENoYXIgPSBpbnB1dC5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAkU0xBU0ggJiYgbmV4dENoYXIgPT0gJFNMQVNIICYmIG91dGVyUXVvdGUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIGlmIChvdXRlclF1b3RlID09PSBjaGFyKSB7XG4gICAgICAgICAgICAgICAgb3V0ZXJRdW90ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdXRlclF1b3RlID09IG51bGwgJiYgaXNRdW90ZShjaGFyKSkge1xuICAgICAgICAgICAgICAgIG91dGVyUXVvdGUgPSBjaGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5fY2hlY2tOb0ludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHZhciByZWdleHAgPSBfY3JlYXRlSW50ZXJwb2xhdGVSZWdFeHAoaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHZhciBwYXJ0cyA9IGlucHV0LnNwbGl0KHJlZ2V4cCk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkdvdCBpbnRlcnBvbGF0aW9uIChcIiArIGludGVycG9sYXRpb25Db25maWcuc3RhcnQgKyBpbnRlcnBvbGF0aW9uQ29uZmlnLmVuZCArIFwiKSB3aGVyZSBleHByZXNzaW9uIHdhcyBleHBlY3RlZFwiLCBpbnB1dCwgXCJhdCBjb2x1bW4gXCIgKyB0aGlzLl9maW5kSW50ZXJwb2xhdGlvbkVycm9yQ29sdW1uKHBhcnRzLCAxLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSArIFwiIGluXCIsIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5fZmluZEludGVycG9sYXRpb25FcnJvckNvbHVtbiA9IGZ1bmN0aW9uIChwYXJ0cywgcGFydEluRXJySWR4LCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHZhciBlcnJMb2NhdGlvbiA9ICcnO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRJbkVycklkeDsgaisrKSB7XG4gICAgICAgICAgICBlcnJMb2NhdGlvbiArPSBqICUgMiA9PT0gMCA/XG4gICAgICAgICAgICAgICAgcGFydHNbal0gOlxuICAgICAgICAgICAgICAgIFwiXCIgKyBpbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0ICsgcGFydHNbal0gKyBpbnRlcnBvbGF0aW9uQ29uZmlnLmVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyTG9jYXRpb24ubGVuZ3RoO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlcjtcbn0oKSk7XG52YXIgX1BhcnNlQVNUID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0b2tlbnMsIGlucHV0TGVuZ3RoLCBwYXJzZUFjdGlvbiwgZXJyb3JzLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMuYWJzb2x1dGVPZmZzZXQgPSBhYnNvbHV0ZU9mZnNldDtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIHRoaXMuaW5wdXRMZW5ndGggPSBpbnB1dExlbmd0aDtcbiAgICAgICAgdGhpcy5wYXJzZUFjdGlvbiA9IHBhcnNlQWN0aW9uO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkID0gMDtcbiAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZCA9IDA7XG4gICAgICAgIHRoaXMucmJyYWNlc0V4cGVjdGVkID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmluZGV4ICsgb2Zmc2V0O1xuICAgICAgICByZXR1cm4gaSA8IHRoaXMudG9rZW5zLmxlbmd0aCA/IHRoaXMudG9rZW5zW2ldIDogRU9GO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9QYXJzZUFTVC5wcm90b3R5cGUsIFwibmV4dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wZWVrKDApOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX1BhcnNlQVNULnByb3RvdHlwZSwgXCJpbnB1dEluZGV4XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpID8gdGhpcy5uZXh0LmluZGV4ICsgdGhpcy5vZmZzZXQgOlxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRMZW5ndGggKyB0aGlzLm9mZnNldDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5zcGFuID0gZnVuY3Rpb24gKHN0YXJ0KSB7IHJldHVybiBuZXcgUGFyc2VTcGFuKHN0YXJ0LCB0aGlzLmlucHV0SW5kZXgpOyB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pbmRleCsrOyB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUub3B0aW9uYWxDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKGNvZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBlZWtLZXl3b3JkTGV0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5uZXh0LmlzS2V5d29yZExldCgpOyB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGVla0tleXdvcmRBcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubmV4dC5pc0tleXdvcmRBcygpOyB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0Q2hhcmFjdGVyID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoY29kZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZXJyb3IoXCJNaXNzaW5nIGV4cGVjdGVkIFwiICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLm9wdGlvbmFsT3BlcmF0b3IgPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC5pc09wZXJhdG9yKG9wKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RPcGVyYXRvciA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKG9wZXJhdG9yKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5lcnJvcihcIk1pc3NpbmcgZXhwZWN0ZWQgb3BlcmF0b3IgXCIgKyBvcGVyYXRvcik7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5uZXh0O1xuICAgICAgICBpZiAoIW4uaXNJZGVudGlmaWVyKCkgJiYgIW4uaXNLZXl3b3JkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgbiArIFwiLCBleHBlY3RlZCBpZGVudGlmaWVyIG9yIGtleXdvcmRcIik7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmRPclN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLm5leHQ7XG4gICAgICAgIGlmICghbi5pc0lkZW50aWZpZXIoKSAmJiAhbi5pc0tleXdvcmQoKSAmJiAhbi5pc1N0cmluZygpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIG4gKyBcIiwgZXhwZWN0ZWQgaWRlbnRpZmllciwga2V5d29yZCwgb3Igc3RyaW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gbi50b1N0cmluZygpO1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXhwcnMgPSBbXTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgZXhwcnMucHVzaChleHByKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRTRU1JQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ0JpbmRpbmcgZXhwcmVzc2lvbiBjYW5ub3QgY29udGFpbiBjaGFpbmVkIGV4cHJlc3Npb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJFNFTUlDT0xPTikpIHtcbiAgICAgICAgICAgICAgICB9IC8vIHJlYWQgYWxsIHNlbWljb2xvbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiAnXCIgKyB0aGlzLm5leHQgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cHJzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgIGlmIChleHBycy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBleHByc1swXTtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFpbih0aGlzLnNwYW4oc3RhcnQpLCBleHBycyk7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlUGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJ3wnKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdDYW5ub3QgaGF2ZSBhIHBpcGUgaW4gYW4gYWN0aW9uIGV4cHJlc3Npb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkKCk7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmRpbmdQaXBlKHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIHJlc3VsdCwgbmFtZV8xLCBhcmdzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignfCcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoKTsgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VMb2dpY2FsT3IoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPycpKSB7XG4gICAgICAgICAgICB2YXIgeWVzID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgIHZhciBubyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJDb25kaXRpb25hbCBleHByZXNzaW9uIFwiICsgZXhwcmVzc2lvbiArIFwiIHJlcXVpcmVzIGFsbCAzIGV4cHJlc3Npb25zXCIpO1xuICAgICAgICAgICAgICAgIG5vID0gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWwodGhpcy5zcGFuKHN0YXJ0KSwgcmVzdWx0LCB5ZXMsIG5vKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VMb2dpY2FsT3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICd8fCdcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VMb2dpY2FsQW5kKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJ3x8JykpIHtcbiAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VMb2dpY2FsQW5kKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksICd8fCcsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTG9naWNhbEFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gJyYmJ1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZUVxdWFsaXR5KCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJyYmJykpIHtcbiAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VFcXVhbGl0eSgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCAnJiYnLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUVxdWFsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAnPT0nLCchPScsJz09PScsJyE9PSdcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VSZWxhdGlvbmFsKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUkMS5PcGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgICAgICBjYXNlICchPT0nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZVJlbGF0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VSZWxhdGlvbmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAnPCcsICc+JywgJzw9JywgJz49J1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZUFkZGl0aXZlKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUkMS5PcGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlQWRkaXRpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VBZGRpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gJysnLCAnLSdcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VNdWx0aXBsaWNhdGl2ZSgpO1xuICAgICAgICB3aGlsZSAodGhpcy5uZXh0LnR5cGUgPT0gVG9rZW5UeXBlJDEuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMubmV4dC5zdHJWYWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VNdWx0aXBsaWNhdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIG9wZXJhdG9yLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZU11bHRpcGxpY2F0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAnKicsICclJywgJy8nXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUkMS5PcGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIG9wZXJhdG9yLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZSQxLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeSh0aGlzLnNwYW4oc3RhcnQpLCAnLScsIHJlc3VsdCwgbmV3IExpdGVyYWxQcmltaXRpdmUobmV3IFBhcnNlU3BhbihzdGFydCwgc3RhcnQpLCAwKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5KHRoaXMuc3BhbihzdGFydCksIG9wZXJhdG9yLCBuZXcgTGl0ZXJhbFByaW1pdGl2ZShuZXcgUGFyc2VTcGFuKHN0YXJ0LCBzdGFydCksIDApLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByZWZpeE5vdCh0aGlzLnNwYW4oc3RhcnQpLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2FsbENoYWluKCk7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ2FsbENoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVByaW1hcnkoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRQRVJJT0QpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUFjY2Vzc01lbWJlck9yTWV0aG9kQ2FsbChyZXN1bHQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPy4nKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwocmVzdWx0LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJExCUkFDS0VUKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQrKztcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkLS07XG4gICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJCUkFDS0VUKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBLZXllZFdyaXRlKHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgS2V5ZWRSZWFkKHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIHJlc3VsdCwga2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRMUEFSRU4pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMucGFyc2VDYWxsQXJndW1lbnRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUlBBUkVOKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgRnVuY3Rpb25DYWxsKHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIHJlc3VsdCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJyEnKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBOb25OdWxsQXNzZXJ0KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlUHJpbWFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTFBBUkVOKSkge1xuICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSUEFSRU4pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkTnVsbCgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkVW5kZWZpbmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZFRydWUoKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZEZhbHNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkVGhpcygpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1wbGljaXRSZWNlaXZlcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRMQlJBQ0tFVCkpIHtcbiAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMucGFyc2VFeHByZXNzaW9uTGlzdCgkUkJSQUNLRVQpO1xuICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJCUkFDS0VUKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5KHRoaXMuc3BhbihzdGFydCksIGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIoJExCUkFDRSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwobmV3IEltcGxpY2l0UmVjZWl2ZXIodGhpcy5zcGFuKHN0YXJ0KSksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNOdW1iZXIoKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5uZXh0LnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIHZhciBsaXRlcmFsVmFsdWUgPSB0aGlzLm5leHQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIGxpdGVyYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBleHByZXNzaW9uOiBcIiArIHRoaXMuaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIHRoaXMubmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb25MaXN0ID0gZnVuY3Rpb24gKHRlcm1pbmF0b3IpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoIXRoaXMubmV4dC5pc0NoYXJhY3Rlcih0ZXJtaW5hdG9yKSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucGFyc2VQaXBlKCkpO1xuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09NTUEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUxpdGVyYWxNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkTEJSQUNFKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRSQlJBQ0UpKSB7XG4gICAgICAgICAgICB0aGlzLnJicmFjZXNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciBxdW90ZWQgPSB0aGlzLm5leHQuaXNTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goeyBrZXk6IGtleSwgcXVvdGVkOiBxdW90ZWQgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJENPTE9OKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKSk7XG4gICAgICAgICAgICB0aGlzLnJicmFjZXNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJCUkFDRSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwKHRoaXMuc3BhbihzdGFydCksIGtleXMsIHZhbHVlcyk7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsID0gZnVuY3Rpb24gKHJlY2VpdmVyLCBpc1NhZmUpIHtcbiAgICAgICAgaWYgKGlzU2FmZSA9PT0gdm9pZCAwKSB7IGlzU2FmZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBzdGFydCA9IHJlY2VpdmVyLnNwYW4uc3RhcnQ7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTFBBUkVOKSkge1xuICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5wYXJzZUNhbGxBcmd1bWVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSUEFSRU4pO1xuICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgIHZhciBzcGFuID0gdGhpcy5zcGFuKHN0YXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBpc1NhZmUgPyBuZXcgU2FmZU1ldGhvZENhbGwoc3BhbiwgcmVjZWl2ZXIsIGlkLCBhcmdzKSA6XG4gICAgICAgICAgICAgICAgbmV3IE1ldGhvZENhbGwoc3BhbiwgcmVjZWl2ZXIsIGlkLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1NhZmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignVGhlIFxcJz8uXFwnIG9wZXJhdG9yIGNhbm5vdCBiZSB1c2VkIGluIHRoZSBhc3NpZ25tZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTYWZlUHJvcGVydHlSZWFkKHRoaXMuc3BhbihzdGFydCksIHJlY2VpdmVyLCBpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYXJzZUFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignQmluZGluZ3MgY2Fubm90IGNvbnRhaW4gYXNzaWdubWVudHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGFyc2VDb25kaXRpb25hbCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5V3JpdGUodGhpcy5zcGFuKHN0YXJ0KSwgcmVjZWl2ZXIsIGlkLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5UmVhZCh0aGlzLnNwYW4oc3RhcnQpLCByZWNlaXZlciwgaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNhbGxBcmd1bWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIoJFJQQVJFTikpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHZhciBwb3NpdGlvbmFscyA9IFtdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBwb3NpdGlvbmFscy5wdXNoKHRoaXMucGFyc2VQaXBlKCkpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT01NQSkpO1xuICAgICAgICByZXR1cm4gcG9zaXRpb25hbHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbiBpZGVudGlmaWVyLCBhIGtleXdvcmQsIGEgc3RyaW5nIHdpdGggYW4gb3B0aW9uYWwgYC1gIGluIGJldHdlZW4uXG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIG9wZXJhdG9yRm91bmQgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZE9yU3RyaW5nKCk7XG4gICAgICAgICAgICBvcGVyYXRvckZvdW5kID0gdGhpcy5vcHRpb25hbE9wZXJhdG9yKCctJyk7XG4gICAgICAgICAgICBpZiAob3BlcmF0b3JGb3VuZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG9wZXJhdG9yRm91bmQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICAvLyBQYXJzZXMgdGhlIEFTVCBmb3IgYDxzb21lLXRhZyAqdHBsS2V5PUFTVD5gXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlQmluZGluZ3MgPSBmdW5jdGlvbiAodHBsS2V5KSB7XG4gICAgICAgIHZhciBmaXJzdEJpbmRpbmcgPSB0cnVlO1xuICAgICAgICB2YXIgYmluZGluZ3MgPSBbXTtcbiAgICAgICAgdmFyIHdhcm5pbmdzID0gW107XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgIHZhciByYXdLZXkgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIga2V5ID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGlzVmFyID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZmlyc3RCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgcmF3S2V5ID0ga2V5ID0gdHBsS2V5O1xuICAgICAgICAgICAgICAgIGZpcnN0QmluZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNWYXIgPSB0aGlzLnBlZWtLZXl3b3JkTGV0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFyKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICByYXdLZXkgPSB0aGlzLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSgpO1xuICAgICAgICAgICAgICAgIGtleSA9IGlzVmFyID8gcmF3S2V5IDogdHBsS2V5ICsgcmF3S2V5WzBdLnRvVXBwZXJDYXNlKCkgKyByYXdLZXkuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTE9OKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuYW1lXzIgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlzVmFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVfMiA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuYW1lXzIgPSAnXFwkaW1wbGljaXQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVla0tleXdvcmRBcygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIGNvbnN1bWUgYGFzYFxuICAgICAgICAgICAgICAgIG5hbWVfMiA9IHJhd0tleTtcbiAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSgpOyAvLyByZWFkIGxvY2FsIHZhciBuYW1lXG4gICAgICAgICAgICAgICAgaXNWYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0ICE9PSBFT0YgJiYgIXRoaXMucGVla0tleXdvcmRMZXQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydF8xID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgIHZhciBhc3QgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydF8xIC0gdGhpcy5vZmZzZXQsIHRoaXMuaW5wdXRJbmRleCAtIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID1cbiAgICAgICAgICAgICAgICAgICAgbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBzb3VyY2UsIHRoaXMubG9jYXRpb24sIHRoaXMuYWJzb2x1dGVPZmZzZXQsIHRoaXMuZXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpbmRpbmdzLnB1c2gobmV3IFRlbXBsYXRlQmluZGluZyh0aGlzLnNwYW4oc3RhcnQpLCBrZXksIGlzVmFyLCBuYW1lXzIsIGV4cHJlc3Npb24pKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWtLZXl3b3JkQXMoKSAmJiAhaXNWYXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGV0U3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIGNvbnN1bWUgYGFzYFxuICAgICAgICAgICAgICAgIHZhciBsZXROYW1lID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTsgLy8gcmVhZCBsb2NhbCB2YXIgbmFtZVxuICAgICAgICAgICAgICAgIGJpbmRpbmdzLnB1c2gobmV3IFRlbXBsYXRlQmluZGluZyh0aGlzLnNwYW4obGV0U3RhcnQpLCBsZXROYW1lLCB0cnVlLCBrZXksIG51bGwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcigkU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQoYmluZGluZ3MsIHdhcm5pbmdzLCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gbnVsbDsgfVxuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzZXJFcnJvcihtZXNzYWdlLCB0aGlzLmlucHV0LCB0aGlzLmxvY2F0aW9uVGV4dChpbmRleCksIHRoaXMubG9jYXRpb24pKTtcbiAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmxvY2F0aW9uVGV4dCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IG51bGw7IH1cbiAgICAgICAgaWYgKGluZGV4ID09IG51bGwpXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHJldHVybiAoaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpID8gXCJhdCBjb2x1bW4gXCIgKyAodGhpcy50b2tlbnNbaW5kZXhdLmluZGV4ICsgMSkgKyBcIiBpblwiIDpcbiAgICAgICAgICAgIFwiYXQgdGhlIGVuZCBvZiB0aGUgZXhwcmVzc2lvblwiO1xuICAgIH07XG4gICAgLy8gRXJyb3IgcmVjb3Zlcnkgc2hvdWxkIHNraXAgdG9rZW5zIHVudGlsIGl0IGVuY291bnRlcnMgYSByZWNvdmVyeSBwb2ludC4gc2tpcCgpIHRyZWF0c1xuICAgIC8vIHRoZSBlbmQgb2YgaW5wdXQgYW5kIGEgJzsnIGFzIHVuY29uZGl0aW9uYWxseSBhIHJlY292ZXJ5IHBvaW50LiBJdCBhbHNvIHRyZWF0cyAnKScsXG4gICAgLy8gJ30nIGFuZCAnXScgYXMgY29uZGl0aW9uYWwgcmVjb3ZlcnkgcG9pbnRzIGlmIG9uZSBvZiBjYWxsaW5nIHByb2R1Y3Rpb25zIGlzIGV4cGVjdGluZ1xuICAgIC8vIG9uZSBvZiB0aGVzZSBzeW1ib2xzLiBUaGlzIGFsbG93cyBza2lwKCkgdG8gcmVjb3ZlciBmcm9tIGVycm9ycyBzdWNoIGFzICcoYS4pICsgMScgYWxsb3dpbmdcbiAgICAvLyBtb3JlIG9mIHRoZSBBU1QgdG8gYmUgcmV0YWluZWQgKGl0IGRvZXNuJ3Qgc2tpcCBhbnkgdG9rZW5zIGFzIHRoZSAnKScgaXMgcmV0YWluZWQgYmVjYXVzZVxuICAgIC8vIG9mIHRoZSAnKCcgYmVnaW5zIGFuICcoJyA8ZXhwcj4gJyknIHByb2R1Y3Rpb24pLiBUaGUgcmVjb3ZlcnkgcG9pbnRzIG9mIGdyb3VwaW5nIHN5bWJvbHNcbiAgICAvLyBtdXN0IGJlIGNvbmRpdGlvbmFsIGFzIHRoZXkgbXVzdCBiZSBza2lwcGVkIGlmIG5vbmUgb2YgdGhlIGNhbGxpbmcgcHJvZHVjdGlvbnMgYXJlIG5vdFxuICAgIC8vIGV4cGVjdGluZyB0aGUgY2xvc2luZyB0b2tlbiBlbHNlIHdlIHdpbGwgbmV2ZXIgbWFrZSBwcm9ncmVzcyBpbiB0aGUgY2FzZSBvZiBhblxuICAgIC8vIGV4dHJhbmVvdXMgZ3JvdXAgY2xvc2luZyBzeW1ib2wgKHN1Y2ggYXMgYSBzdHJheSAnKScpLiBUaGlzIGlzIG5vdCB0aGUgY2FzZSBmb3IgJzsnIGJlY2F1c2VcbiAgICAvLyBwYXJzZUNoYWluKCkgaXMgYWx3YXlzIHRoZSByb290IHByb2R1Y3Rpb24gYW5kIGl0IGV4cGVjdHMgYSAnOycuXG4gICAgLy8gSWYgYSBwcm9kdWN0aW9uIGV4cGVjdHMgb25lIG9mIHRoZXNlIHRva2VuIGl0IGluY3JlbWVudHMgdGhlIGNvcnJlc3BvbmRpbmcgbmVzdGluZyBjb3VudCxcbiAgICAvLyBhbmQgdGhlbiBkZWNyZW1lbnRzIGl0IGp1c3QgcHJpb3IgdG8gY2hlY2tpbmcgaWYgdGhlIHRva2VuIGlzIGluIHRoZSBpbnB1dC5cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5uZXh0O1xuICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCAmJiAhbi5pc0NoYXJhY3RlcigkU0VNSUNPTE9OKSAmJlxuICAgICAgICAgICAgKHRoaXMucnBhcmVuc0V4cGVjdGVkIDw9IDAgfHwgIW4uaXNDaGFyYWN0ZXIoJFJQQVJFTikpICYmXG4gICAgICAgICAgICAodGhpcy5yYnJhY2VzRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUkJSQUNFKSkgJiZcbiAgICAgICAgICAgICh0aGlzLnJicmFja2V0c0V4cGVjdGVkIDw9IDAgfHwgIW4uaXNDaGFyYWN0ZXIoJFJCUkFDS0VUKSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQuaXNFcnJvcigpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2VyRXJyb3IodGhpcy5uZXh0LnRvU3RyaW5nKCksIHRoaXMuaW5wdXQsIHRoaXMubG9jYXRpb25UZXh0KCksIHRoaXMubG9jYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIF9QYXJzZUFTVDtcbn0oKSk7XG52YXIgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgfVxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLmNoZWNrID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICB2YXIgcyA9IG5ldyBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlcigpO1xuICAgICAgICBhc3QudmlzaXQocyk7XG4gICAgICAgIHJldHVybiBzLmVycm9ycztcbiAgICB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0TWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRTYWZlTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucyk7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy52aXNpdEFsbChhc3QudmFsdWVzKTsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UHJlZml4Tm90ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdE5vbk51bGxBc3NlcnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy5lcnJvcnMucHVzaCgncGlwZXMnKTsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gYXN0cy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KTtcbiAgICB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFF1b3RlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIHJldHVybiBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09IFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgPT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyAgICAgICAgRE8gTk9UIEVESVQgVEhJUyBMSVNUIE9GIFNFQ1VSSVRZIFNFTlNJVElWRSBQUk9QRVJUSUVTIFdJVEhPVVQgQSBTRUNVUklUWSBSRVZJRVchXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjaCBvdXQgdG8gbXByb2JzdCBmb3IgZGV0YWlscy5cbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vKiogTWFwIGZyb20gdGFnTmFtZXxwcm9wZXJ0eU5hbWUgU2VjdXJpdHlDb250ZXh0LiBQcm9wZXJ0aWVzIGFwcGx5aW5nIHRvIGFsbCB0YWdzIHVzZSAnKicuICovXG52YXIgX1NFQ1VSSVRZX1NDSEVNQTtcbmZ1bmN0aW9uIFNFQ1VSSVRZX1NDSEVNQSgpIHtcbiAgICBpZiAoIV9TRUNVUklUWV9TQ0hFTUEpIHtcbiAgICAgICAgX1NFQ1VSSVRZX1NDSEVNQSA9IHt9O1xuICAgICAgICAvLyBDYXNlIGlzIGluc2lnbmlmaWNhbnQgYmVsb3csIGFsbCBlbGVtZW50IGFuZCBhdHRyaWJ1dGUgbmFtZXMgYXJlIGxvd2VyLWNhc2VkIGZvciBsb29rdXAuXG4gICAgICAgIHJlZ2lzdGVyQ29udGV4dChTZWN1cml0eUNvbnRleHQuSFRNTCwgW1xuICAgICAgICAgICAgJ2lmcmFtZXxzcmNkb2MnLFxuICAgICAgICAgICAgJyp8aW5uZXJIVE1MJyxcbiAgICAgICAgICAgICcqfG91dGVySFRNTCcsXG4gICAgICAgIF0pO1xuICAgICAgICByZWdpc3RlckNvbnRleHQoU2VjdXJpdHlDb250ZXh0LlNUWUxFLCBbJyp8c3R5bGUnXSk7XG4gICAgICAgIC8vIE5COiBubyBTQ1JJUFQgY29udGV4dHMgaGVyZSwgdGhleSBhcmUgbmV2ZXIgYWxsb3dlZCBkdWUgdG8gdGhlIHBhcnNlciBzdHJpcHBpbmcgdGhlbS5cbiAgICAgICAgcmVnaXN0ZXJDb250ZXh0KFNlY3VyaXR5Q29udGV4dC5VUkwsIFtcbiAgICAgICAgICAgICcqfGZvcm1BY3Rpb24nLCAnYXJlYXxocmVmJywgJ2FyZWF8cGluZycsICdhdWRpb3xzcmMnLCAnYXxocmVmJyxcbiAgICAgICAgICAgICdhfHBpbmcnLCAnYmxvY2txdW90ZXxjaXRlJywgJ2JvZHl8YmFja2dyb3VuZCcsICdkZWx8Y2l0ZScsICdmb3JtfGFjdGlvbicsXG4gICAgICAgICAgICAnaW1nfHNyYycsICdpbWd8c3Jjc2V0JywgJ2lucHV0fHNyYycsICdpbnN8Y2l0ZScsICdxfGNpdGUnLFxuICAgICAgICAgICAgJ3NvdXJjZXxzcmMnLCAnc291cmNlfHNyY3NldCcsICd0cmFja3xzcmMnLCAndmlkZW98cG9zdGVyJywgJ3ZpZGVvfHNyYycsXG4gICAgICAgIF0pO1xuICAgICAgICByZWdpc3RlckNvbnRleHQoU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTCwgW1xuICAgICAgICAgICAgJ2FwcGxldHxjb2RlJyxcbiAgICAgICAgICAgICdhcHBsZXR8Y29kZWJhc2UnLFxuICAgICAgICAgICAgJ2Jhc2V8aHJlZicsXG4gICAgICAgICAgICAnZW1iZWR8c3JjJyxcbiAgICAgICAgICAgICdmcmFtZXxzcmMnLFxuICAgICAgICAgICAgJ2hlYWR8cHJvZmlsZScsXG4gICAgICAgICAgICAnaHRtbHxtYW5pZmVzdCcsXG4gICAgICAgICAgICAnaWZyYW1lfHNyYycsXG4gICAgICAgICAgICAnbGlua3xocmVmJyxcbiAgICAgICAgICAgICdtZWRpYXxzcmMnLFxuICAgICAgICAgICAgJ29iamVjdHxjb2RlYmFzZScsXG4gICAgICAgICAgICAnb2JqZWN0fGRhdGEnLFxuICAgICAgICAgICAgJ3NjcmlwdHxzcmMnLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgcmV0dXJuIF9TRUNVUklUWV9TQ0hFTUE7XG59XG5mdW5jdGlvbiByZWdpc3RlckNvbnRleHQoY3R4LCBzcGVjcykge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIHNwZWNzXzEgPSBfX3ZhbHVlcyhzcGVjcyksIHNwZWNzXzFfMSA9IHNwZWNzXzEubmV4dCgpOyAhc3BlY3NfMV8xLmRvbmU7IHNwZWNzXzFfMSA9IHNwZWNzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgc3BlYyA9IHNwZWNzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIF9TRUNVUklUWV9TQ0hFTUFbc3BlYy50b0xvd2VyQ2FzZSgpXSA9IGN0eDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHNwZWNzXzFfMSAmJiAhc3BlY3NfMV8xLmRvbmUgJiYgKF9hID0gc3BlY3NfMS5yZXR1cm4pKSBfYS5jYWxsKHNwZWNzXzEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBFbGVtZW50U2NoZW1hUmVnaXN0cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCkge1xuICAgIH1cbiAgICByZXR1cm4gRWxlbWVudFNjaGVtYVJlZ2lzdHJ5O1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEJPT0xFQU4gPSAnYm9vbGVhbic7XG52YXIgTlVNQkVSID0gJ251bWJlcic7XG52YXIgU1RSSU5HID0gJ3N0cmluZyc7XG52YXIgT0JKRUNUID0gJ29iamVjdCc7XG4vKipcbiAqIFRoaXMgYXJyYXkgcmVwcmVzZW50cyB0aGUgRE9NIHNjaGVtYS4gSXQgZW5jb2RlcyBpbmhlcml0YW5jZSwgcHJvcGVydGllcywgYW5kIGV2ZW50cy5cbiAqXG4gKiAjIyBPdmVydmlld1xuICpcbiAqIEVhY2ggbGluZSByZXByZXNlbnRzIG9uZSBraW5kIG9mIGVsZW1lbnQuIFRoZSBgZWxlbWVudF9pbmhlcml0YW5jZWAgYW5kIHByb3BlcnRpZXMgYXJlIGpvaW5lZFxuICogdXNpbmcgYGVsZW1lbnRfaW5oZXJpdGFuY2V8cHJvcGVydGllc2Agc3ludGF4LlxuICpcbiAqICMjIEVsZW1lbnQgSW5oZXJpdGFuY2VcbiAqXG4gKiBUaGUgYGVsZW1lbnRfaW5oZXJpdGFuY2VgIGNhbiBiZSBmdXJ0aGVyIHN1YmRpdmlkZWQgYXMgYGVsZW1lbnQxLGVsZW1lbnQyLC4uLl5wYXJlbnRFbGVtZW50YC5cbiAqIEhlcmUgdGhlIGluZGl2aWR1YWwgZWxlbWVudHMgYXJlIHNlcGFyYXRlZCBieSBgLGAgKGNvbW1hcykuIEV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGxpc3RcbiAqIGhhcyBpZGVudGljYWwgcHJvcGVydGllcy5cbiAqXG4gKiBBbiBgZWxlbWVudGAgbWF5IGluaGVyaXQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGZyb20gYHBhcmVudEVsZW1lbnRgIElmIG5vIGBecGFyZW50RWxlbWVudGAgaXNcbiAqIHNwZWNpZmllZCB0aGVuIGBcIlwiYCAoYmxhbmspIGVsZW1lbnQgaXMgYXNzdW1lZC5cbiAqXG4gKiBOT1RFOiBUaGUgYmxhbmsgZWxlbWVudCBpbmhlcml0cyBmcm9tIHJvb3QgYFtFbGVtZW50XWAgZWxlbWVudCwgdGhlIHN1cGVyIGVsZW1lbnQgb2YgYWxsXG4gKiBlbGVtZW50cy5cbiAqXG4gKiBOT1RFIGFuIGVsZW1lbnQgcHJlZml4IHN1Y2ggYXMgYDpzdmc6YCBoYXMgbm8gc3BlY2lhbCBtZWFuaW5nIHRvIHRoZSBzY2hlbWEuXG4gKlxuICogIyMgUHJvcGVydGllc1xuICpcbiAqIEVhY2ggZWxlbWVudCBoYXMgYSBzZXQgb2YgcHJvcGVydGllcyBzZXBhcmF0ZWQgYnkgYCxgIChjb21tYXMpLiBFYWNoIHByb3BlcnR5IGNhbiBiZSBwcmVmaXhlZFxuICogYnkgYSBzcGVjaWFsIGNoYXJhY3RlciBkZXNpZ25hdGluZyBpdHMgdHlwZTpcbiAqXG4gKiAtIChubyBwcmVmaXgpOiBwcm9wZXJ0eSBpcyBhIHN0cmluZy5cbiAqIC0gYCpgOiBwcm9wZXJ0eSByZXByZXNlbnRzIGFuIGV2ZW50LlxuICogLSBgIWA6IHByb3BlcnR5IGlzIGEgYm9vbGVhbi5cbiAqIC0gYCNgOiBwcm9wZXJ0eSBpcyBhIG51bWJlci5cbiAqIC0gYCVgOiBwcm9wZXJ0eSBpcyBhbiBvYmplY3QuXG4gKlxuICogIyMgUXVlcnlcbiAqXG4gKiBUaGUgY2xhc3MgY3JlYXRlcyBhbiBpbnRlcm5hbCBzcXVhcyByZXByZXNlbnRhdGlvbiB3aGljaCBhbGxvd3MgdG8gZWFzaWx5IGFuc3dlciB0aGUgcXVlcnkgb2ZcbiAqIGlmIGEgZ2l2ZW4gcHJvcGVydHkgZXhpc3Qgb24gYSBnaXZlbiBlbGVtZW50LlxuICpcbiAqIE5PVEU6IFdlIGRvbid0IHlldCBzdXBwb3J0IHF1ZXJ5aW5nIGZvciB0eXBlcyBvciBldmVudHMuXG4gKiBOT1RFOiBUaGlzIHNjaGVtYSBpcyBhdXRvIGV4dHJhY3RlZCBmcm9tIGBzY2hlbWFfZXh0cmFjdG9yLnRzYCBsb2NhdGVkIGluIHRoZSB0ZXN0IGZvbGRlcixcbiAqICAgICAgIHNlZSBkb21fZWxlbWVudF9zY2hlbWFfcmVnaXN0cnlfc3BlYy50c1xuICovXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PSBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgID09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gICAgICAgICAgICAgICAgICAgICAgIERPIE5PVCBFRElUIFRISVMgRE9NIFNDSEVNQSBXSVRIT1VUIEEgU0VDVVJJVFkgUkVWSUVXIVxuLy9cbi8vIE5ld2x5IGFkZGVkIHByb3BlcnRpZXMgbXVzdCBiZSBzZWN1cml0eSByZXZpZXdlZCBhbmQgYXNzaWduZWQgYW4gYXBwcm9wcmlhdGUgU2VjdXJpdHlDb250ZXh0IGluXG4vLyBkb21fc2VjdXJpdHlfc2NoZW1hLnRzLiBSZWFjaCBvdXQgdG8gbXByb2JzdCAmIHJqYW1ldCBmb3IgZGV0YWlscy5cbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG52YXIgU0NIRU1BID0gW1xuICAgICdbRWxlbWVudF18dGV4dENvbnRlbnQsJWNsYXNzTGlzdCxjbGFzc05hbWUsaWQsaW5uZXJIVE1MLCpiZWZvcmVjb3B5LCpiZWZvcmVjdXQsKmJlZm9yZXBhc3RlLCpjb3B5LCpjdXQsKnBhc3RlLCpzZWFyY2gsKnNlbGVjdHN0YXJ0LCp3ZWJraXRmdWxsc2NyZWVuY2hhbmdlLCp3ZWJraXRmdWxsc2NyZWVuZXJyb3IsKndoZWVsLG91dGVySFRNTCwjc2Nyb2xsTGVmdCwjc2Nyb2xsVG9wLHNsb3QnICtcbiAgICAgICAgLyogYWRkZWQgbWFudWFsbHkgdG8gYXZvaWQgYnJlYWtpbmcgY2hhbmdlcyAqL1xuICAgICAgICAnLCptZXNzYWdlLCptb3pmdWxsc2NyZWVuY2hhbmdlLCptb3pmdWxsc2NyZWVuZXJyb3IsKm1venBvaW50ZXJsb2NrY2hhbmdlLCptb3pwb2ludGVybG9ja2Vycm9yLCp3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yLCp3ZWJnbGNvbnRleHRsb3N0LCp3ZWJnbGNvbnRleHRyZXN0b3JlZCcsXG4gICAgJ1tIVE1MRWxlbWVudF1eW0VsZW1lbnRdfGFjY2Vzc0tleSxjb250ZW50RWRpdGFibGUsZGlyLCFkcmFnZ2FibGUsIWhpZGRlbixpbm5lclRleHQsbGFuZywqYWJvcnQsKmF1eGNsaWNrLCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmN1ZWNoYW5nZSwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqZ290cG9pbnRlcmNhcHR1cmUsKmlucHV0LCppbnZhbGlkLCprZXlkb3duLCprZXlwcmVzcywqa2V5dXAsKmxvYWQsKmxvYWRlZGRhdGEsKmxvYWRlZG1ldGFkYXRhLCpsb2Fkc3RhcnQsKmxvc3Rwb2ludGVyY2FwdHVyZSwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwb2ludGVyY2FuY2VsLCpwb2ludGVyZG93biwqcG9pbnRlcmVudGVyLCpwb2ludGVybGVhdmUsKnBvaW50ZXJtb3ZlLCpwb2ludGVyb3V0LCpwb2ludGVyb3ZlciwqcG9pbnRlcnVwLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZyxvdXRlclRleHQsIXNwZWxsY2hlY2ssJXN0eWxlLCN0YWJJbmRleCx0aXRsZSwhdHJhbnNsYXRlJyxcbiAgICAnYWJicixhZGRyZXNzLGFydGljbGUsYXNpZGUsYixiZGksYmRvLGNpdGUsY29kZSxkZCxkZm4sZHQsZW0sZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGhlYWRlcixpLGtiZCxtYWluLG1hcmssbmF2LG5vc2NyaXB0LHJiLHJwLHJ0LHJ0YyxydWJ5LHMsc2FtcCxzZWN0aW9uLHNtYWxsLHN0cm9uZyxzdWIsc3VwLHUsdmFyLHdicl5bSFRNTEVsZW1lbnRdfGFjY2Vzc0tleSxjb250ZW50RWRpdGFibGUsZGlyLCFkcmFnZ2FibGUsIWhpZGRlbixpbm5lclRleHQsbGFuZywqYWJvcnQsKmF1eGNsaWNrLCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmN1ZWNoYW5nZSwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqZ290cG9pbnRlcmNhcHR1cmUsKmlucHV0LCppbnZhbGlkLCprZXlkb3duLCprZXlwcmVzcywqa2V5dXAsKmxvYWQsKmxvYWRlZGRhdGEsKmxvYWRlZG1ldGFkYXRhLCpsb2Fkc3RhcnQsKmxvc3Rwb2ludGVyY2FwdHVyZSwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwb2ludGVyY2FuY2VsLCpwb2ludGVyZG93biwqcG9pbnRlcmVudGVyLCpwb2ludGVybGVhdmUsKnBvaW50ZXJtb3ZlLCpwb2ludGVyb3V0LCpwb2ludGVyb3ZlciwqcG9pbnRlcnVwLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZyxvdXRlclRleHQsIXNwZWxsY2hlY2ssJXN0eWxlLCN0YWJJbmRleCx0aXRsZSwhdHJhbnNsYXRlJyxcbiAgICAnbWVkaWFeW0hUTUxFbGVtZW50XXwhYXV0b3BsYXksIWNvbnRyb2xzLCVjb250cm9sc0xpc3QsJWNyb3NzT3JpZ2luLCNjdXJyZW50VGltZSwhZGVmYXVsdE11dGVkLCNkZWZhdWx0UGxheWJhY2tSYXRlLCFkaXNhYmxlUmVtb3RlUGxheWJhY2ssIWxvb3AsIW11dGVkLCplbmNyeXB0ZWQsKndhaXRpbmdmb3JrZXksI3BsYXliYWNrUmF0ZSxwcmVsb2FkLHNyYywlc3JjT2JqZWN0LCN2b2x1bWUnLFxuICAgICc6c3ZnOl5bSFRNTEVsZW1lbnRdfCphYm9ydCwqYXV4Y2xpY2ssKmJsdXIsKmNhbmNlbCwqY2FucGxheSwqY2FucGxheXRocm91Z2gsKmNoYW5nZSwqY2xpY2ssKmNsb3NlLCpjb250ZXh0bWVudSwqY3VlY2hhbmdlLCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCpnb3Rwb2ludGVyY2FwdHVyZSwqaW5wdXQsKmludmFsaWQsKmtleWRvd24sKmtleXByZXNzLCprZXl1cCwqbG9hZCwqbG9hZGVkZGF0YSwqbG9hZGVkbWV0YWRhdGEsKmxvYWRzdGFydCwqbG9zdHBvaW50ZXJjYXB0dXJlLCptb3VzZWRvd24sKm1vdXNlZW50ZXIsKm1vdXNlbGVhdmUsKm1vdXNlbW92ZSwqbW91c2VvdXQsKm1vdXNlb3ZlciwqbW91c2V1cCwqbW91c2V3aGVlbCwqcGF1c2UsKnBsYXksKnBsYXlpbmcsKnBvaW50ZXJjYW5jZWwsKnBvaW50ZXJkb3duLCpwb2ludGVyZW50ZXIsKnBvaW50ZXJsZWF2ZSwqcG9pbnRlcm1vdmUsKnBvaW50ZXJvdXQsKnBvaW50ZXJvdmVyLCpwb2ludGVydXAsKnByb2dyZXNzLCpyYXRlY2hhbmdlLCpyZXNldCwqcmVzaXplLCpzY3JvbGwsKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzaG93LCpzdGFsbGVkLCpzdWJtaXQsKnN1c3BlbmQsKnRpbWV1cGRhdGUsKnRvZ2dsZSwqdm9sdW1lY2hhbmdlLCp3YWl0aW5nLCVzdHlsZSwjdGFiSW5kZXgnLFxuICAgICc6c3ZnOmdyYXBoaWNzXjpzdmc6fCcsXG4gICAgJzpzdmc6YW5pbWF0aW9uXjpzdmc6fCpiZWdpbiwqZW5kLCpyZXBlYXQnLFxuICAgICc6c3ZnOmdlb21ldHJ5Xjpzdmc6fCcsXG4gICAgJzpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbl46c3ZnOnwnLFxuICAgICc6c3ZnOmdyYWRpZW50Xjpzdmc6fCcsXG4gICAgJzpzdmc6dGV4dENvbnRlbnReOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOnRleHRQb3NpdGlvbmluZ146c3ZnOnRleHRDb250ZW50fCcsXG4gICAgJ2FeW0hUTUxFbGVtZW50XXxjaGFyc2V0LGNvb3Jkcyxkb3dubG9hZCxoYXNoLGhvc3QsaG9zdG5hbWUsaHJlZixocmVmbGFuZyxuYW1lLHBhc3N3b3JkLHBhdGhuYW1lLHBpbmcscG9ydCxwcm90b2NvbCxyZWZlcnJlclBvbGljeSxyZWwscmV2LHNlYXJjaCxzaGFwZSx0YXJnZXQsdGV4dCx0eXBlLHVzZXJuYW1lJyxcbiAgICAnYXJlYV5bSFRNTEVsZW1lbnRdfGFsdCxjb29yZHMsZG93bmxvYWQsaGFzaCxob3N0LGhvc3RuYW1lLGhyZWYsIW5vSHJlZixwYXNzd29yZCxwYXRobmFtZSxwaW5nLHBvcnQscHJvdG9jb2wscmVmZXJyZXJQb2xpY3kscmVsLHNlYXJjaCxzaGFwZSx0YXJnZXQsdXNlcm5hbWUnLFxuICAgICdhdWRpb15tZWRpYXwnLFxuICAgICdicl5bSFRNTEVsZW1lbnRdfGNsZWFyJyxcbiAgICAnYmFzZV5bSFRNTEVsZW1lbnRdfGhyZWYsdGFyZ2V0JyxcbiAgICAnYm9keV5bSFRNTEVsZW1lbnRdfGFMaW5rLGJhY2tncm91bmQsYmdDb2xvcixsaW5rLCpiZWZvcmV1bmxvYWQsKmJsdXIsKmVycm9yLCpmb2N1cywqaGFzaGNoYW5nZSwqbGFuZ3VhZ2VjaGFuZ2UsKmxvYWQsKm1lc3NhZ2UsKm9mZmxpbmUsKm9ubGluZSwqcGFnZWhpZGUsKnBhZ2VzaG93LCpwb3BzdGF0ZSwqcmVqZWN0aW9uaGFuZGxlZCwqcmVzaXplLCpzY3JvbGwsKnN0b3JhZ2UsKnVuaGFuZGxlZHJlamVjdGlvbiwqdW5sb2FkLHRleHQsdkxpbmsnLFxuICAgICdidXR0b25eW0hUTUxFbGVtZW50XXwhYXV0b2ZvY3VzLCFkaXNhYmxlZCxmb3JtQWN0aW9uLGZvcm1FbmN0eXBlLGZvcm1NZXRob2QsIWZvcm1Ob1ZhbGlkYXRlLGZvcm1UYXJnZXQsbmFtZSx0eXBlLHZhbHVlJyxcbiAgICAnY2FudmFzXltIVE1MRWxlbWVudF18I2hlaWdodCwjd2lkdGgnLFxuICAgICdjb250ZW50XltIVE1MRWxlbWVudF18c2VsZWN0JyxcbiAgICAnZGxeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ2RhdGFsaXN0XltIVE1MRWxlbWVudF18JyxcbiAgICAnZGV0YWlsc15bSFRNTEVsZW1lbnRdfCFvcGVuJyxcbiAgICAnZGlhbG9nXltIVE1MRWxlbWVudF18IW9wZW4scmV0dXJuVmFsdWUnLFxuICAgICdkaXJeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ2Rpdl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAnZW1iZWReW0hUTUxFbGVtZW50XXxhbGlnbixoZWlnaHQsbmFtZSxzcmMsdHlwZSx3aWR0aCcsXG4gICAgJ2ZpZWxkc2V0XltIVE1MRWxlbWVudF18IWRpc2FibGVkLG5hbWUnLFxuICAgICdmb250XltIVE1MRWxlbWVudF18Y29sb3IsZmFjZSxzaXplJyxcbiAgICAnZm9ybV5bSFRNTEVsZW1lbnRdfGFjY2VwdENoYXJzZXQsYWN0aW9uLGF1dG9jb21wbGV0ZSxlbmNvZGluZyxlbmN0eXBlLG1ldGhvZCxuYW1lLCFub1ZhbGlkYXRlLHRhcmdldCcsXG4gICAgJ2ZyYW1lXltIVE1MRWxlbWVudF18ZnJhbWVCb3JkZXIsbG9uZ0Rlc2MsbWFyZ2luSGVpZ2h0LG1hcmdpbldpZHRoLG5hbWUsIW5vUmVzaXplLHNjcm9sbGluZyxzcmMnLFxuICAgICdmcmFtZXNldF5bSFRNTEVsZW1lbnRdfGNvbHMsKmJlZm9yZXVubG9hZCwqYmx1ciwqZXJyb3IsKmZvY3VzLCpoYXNoY2hhbmdlLCpsYW5ndWFnZWNoYW5nZSwqbG9hZCwqbWVzc2FnZSwqb2ZmbGluZSwqb25saW5lLCpwYWdlaGlkZSwqcGFnZXNob3csKnBvcHN0YXRlLCpyZWplY3Rpb25oYW5kbGVkLCpyZXNpemUsKnNjcm9sbCwqc3RvcmFnZSwqdW5oYW5kbGVkcmVqZWN0aW9uLCp1bmxvYWQscm93cycsXG4gICAgJ2hyXltIVE1MRWxlbWVudF18YWxpZ24sY29sb3IsIW5vU2hhZGUsc2l6ZSx3aWR0aCcsXG4gICAgJ2hlYWReW0hUTUxFbGVtZW50XXwnLFxuICAgICdoMSxoMixoMyxoNCxoNSxoNl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAnaHRtbF5bSFRNTEVsZW1lbnRdfHZlcnNpb24nLFxuICAgICdpZnJhbWVeW0hUTUxFbGVtZW50XXxhbGlnbiwhYWxsb3dGdWxsc2NyZWVuLGZyYW1lQm9yZGVyLGhlaWdodCxsb25nRGVzYyxtYXJnaW5IZWlnaHQsbWFyZ2luV2lkdGgsbmFtZSxyZWZlcnJlclBvbGljeSwlc2FuZGJveCxzY3JvbGxpbmcsc3JjLHNyY2RvYyx3aWR0aCcsXG4gICAgJ2ltZ15bSFRNTEVsZW1lbnRdfGFsaWduLGFsdCxib3JkZXIsJWNyb3NzT3JpZ2luLCNoZWlnaHQsI2hzcGFjZSwhaXNNYXAsbG9uZ0Rlc2MsbG93c3JjLG5hbWUscmVmZXJyZXJQb2xpY3ksc2l6ZXMsc3JjLHNyY3NldCx1c2VNYXAsI3ZzcGFjZSwjd2lkdGgnLFxuICAgICdpbnB1dF5bSFRNTEVsZW1lbnRdfGFjY2VwdCxhbGlnbixhbHQsYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLCFhdXRvZm9jdXMsIWNoZWNrZWQsIWRlZmF1bHRDaGVja2VkLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwlZmlsZXMsZm9ybUFjdGlvbixmb3JtRW5jdHlwZSxmb3JtTWV0aG9kLCFmb3JtTm9WYWxpZGF0ZSxmb3JtVGFyZ2V0LCNoZWlnaHQsIWluY3JlbWVudGFsLCFpbmRldGVybWluYXRlLG1heCwjbWF4TGVuZ3RoLG1pbiwjbWluTGVuZ3RoLCFtdWx0aXBsZSxuYW1lLHBhdHRlcm4scGxhY2Vob2xkZXIsIXJlYWRPbmx5LCFyZXF1aXJlZCxzZWxlY3Rpb25EaXJlY3Rpb24sI3NlbGVjdGlvbkVuZCwjc2VsZWN0aW9uU3RhcnQsI3NpemUsc3JjLHN0ZXAsdHlwZSx1c2VNYXAsdmFsdWUsJXZhbHVlQXNEYXRlLCN2YWx1ZUFzTnVtYmVyLCN3aWR0aCcsXG4gICAgJ2xpXltIVE1MRWxlbWVudF18dHlwZSwjdmFsdWUnLFxuICAgICdsYWJlbF5bSFRNTEVsZW1lbnRdfGh0bWxGb3InLFxuICAgICdsZWdlbmReW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgJ2xpbmteW0hUTUxFbGVtZW50XXxhcyxjaGFyc2V0LCVjcm9zc09yaWdpbiwhZGlzYWJsZWQsaHJlZixocmVmbGFuZyxpbnRlZ3JpdHksbWVkaWEscmVmZXJyZXJQb2xpY3kscmVsLCVyZWxMaXN0LHJldiwlc2l6ZXMsdGFyZ2V0LHR5cGUnLFxuICAgICdtYXBeW0hUTUxFbGVtZW50XXxuYW1lJyxcbiAgICAnbWFycXVlZV5bSFRNTEVsZW1lbnRdfGJlaGF2aW9yLGJnQ29sb3IsZGlyZWN0aW9uLGhlaWdodCwjaHNwYWNlLCNsb29wLCNzY3JvbGxBbW91bnQsI3Njcm9sbERlbGF5LCF0cnVlU3BlZWQsI3ZzcGFjZSx3aWR0aCcsXG4gICAgJ21lbnVeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ21ldGFeW0hUTUxFbGVtZW50XXxjb250ZW50LGh0dHBFcXVpdixuYW1lLHNjaGVtZScsXG4gICAgJ21ldGVyXltIVE1MRWxlbWVudF18I2hpZ2gsI2xvdywjbWF4LCNtaW4sI29wdGltdW0sI3ZhbHVlJyxcbiAgICAnaW5zLGRlbF5bSFRNTEVsZW1lbnRdfGNpdGUsZGF0ZVRpbWUnLFxuICAgICdvbF5bSFRNTEVsZW1lbnRdfCFjb21wYWN0LCFyZXZlcnNlZCwjc3RhcnQsdHlwZScsXG4gICAgJ29iamVjdF5bSFRNTEVsZW1lbnRdfGFsaWduLGFyY2hpdmUsYm9yZGVyLGNvZGUsY29kZUJhc2UsY29kZVR5cGUsZGF0YSwhZGVjbGFyZSxoZWlnaHQsI2hzcGFjZSxuYW1lLHN0YW5kYnksdHlwZSx1c2VNYXAsI3ZzcGFjZSx3aWR0aCcsXG4gICAgJ29wdGdyb3VwXltIVE1MRWxlbWVudF18IWRpc2FibGVkLGxhYmVsJyxcbiAgICAnb3B0aW9uXltIVE1MRWxlbWVudF18IWRlZmF1bHRTZWxlY3RlZCwhZGlzYWJsZWQsbGFiZWwsIXNlbGVjdGVkLHRleHQsdmFsdWUnLFxuICAgICdvdXRwdXReW0hUTUxFbGVtZW50XXxkZWZhdWx0VmFsdWUsJWh0bWxGb3IsbmFtZSx2YWx1ZScsXG4gICAgJ3BeW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgJ3BhcmFtXltIVE1MRWxlbWVudF18bmFtZSx0eXBlLHZhbHVlLHZhbHVlVHlwZScsXG4gICAgJ3BpY3R1cmVeW0hUTUxFbGVtZW50XXwnLFxuICAgICdwcmVeW0hUTUxFbGVtZW50XXwjd2lkdGgnLFxuICAgICdwcm9ncmVzc15bSFRNTEVsZW1lbnRdfCNtYXgsI3ZhbHVlJyxcbiAgICAncSxibG9ja3F1b3RlLGNpdGVeW0hUTUxFbGVtZW50XXwnLFxuICAgICdzY3JpcHReW0hUTUxFbGVtZW50XXwhYXN5bmMsY2hhcnNldCwlY3Jvc3NPcmlnaW4sIWRlZmVyLGV2ZW50LGh0bWxGb3IsaW50ZWdyaXR5LHNyYyx0ZXh0LHR5cGUnLFxuICAgICdzZWxlY3ReW0hUTUxFbGVtZW50XXwhYXV0b2ZvY3VzLCFkaXNhYmxlZCwjbGVuZ3RoLCFtdWx0aXBsZSxuYW1lLCFyZXF1aXJlZCwjc2VsZWN0ZWRJbmRleCwjc2l6ZSx2YWx1ZScsXG4gICAgJ3NoYWRvd15bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ3Nsb3ReW0hUTUxFbGVtZW50XXxuYW1lJyxcbiAgICAnc291cmNlXltIVE1MRWxlbWVudF18bWVkaWEsc2l6ZXMsc3JjLHNyY3NldCx0eXBlJyxcbiAgICAnc3Bhbl5bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ3N0eWxlXltIVE1MRWxlbWVudF18IWRpc2FibGVkLG1lZGlhLHR5cGUnLFxuICAgICdjYXB0aW9uXltIVE1MRWxlbWVudF18YWxpZ24nLFxuICAgICd0aCx0ZF5bSFRNTEVsZW1lbnRdfGFiYnIsYWxpZ24sYXhpcyxiZ0NvbG9yLGNoLGNoT2ZmLCNjb2xTcGFuLGhlYWRlcnMsaGVpZ2h0LCFub1dyYXAsI3Jvd1NwYW4sc2NvcGUsdkFsaWduLHdpZHRoJyxcbiAgICAnY29sLGNvbGdyb3VwXltIVE1MRWxlbWVudF18YWxpZ24sY2gsY2hPZmYsI3NwYW4sdkFsaWduLHdpZHRoJyxcbiAgICAndGFibGVeW0hUTUxFbGVtZW50XXxhbGlnbixiZ0NvbG9yLGJvcmRlciwlY2FwdGlvbixjZWxsUGFkZGluZyxjZWxsU3BhY2luZyxmcmFtZSxydWxlcyxzdW1tYXJ5LCV0Rm9vdCwldEhlYWQsd2lkdGgnLFxuICAgICd0cl5bSFRNTEVsZW1lbnRdfGFsaWduLGJnQ29sb3IsY2gsY2hPZmYsdkFsaWduJyxcbiAgICAndGZvb3QsdGhlYWQsdGJvZHleW0hUTUxFbGVtZW50XXxhbGlnbixjaCxjaE9mZix2QWxpZ24nLFxuICAgICd0ZW1wbGF0ZV5bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ3RleHRhcmVhXltIVE1MRWxlbWVudF18YXV0b2NhcGl0YWxpemUsIWF1dG9mb2N1cywjY29scyxkZWZhdWx0VmFsdWUsZGlyTmFtZSwhZGlzYWJsZWQsI21heExlbmd0aCwjbWluTGVuZ3RoLG5hbWUscGxhY2Vob2xkZXIsIXJlYWRPbmx5LCFyZXF1aXJlZCwjcm93cyxzZWxlY3Rpb25EaXJlY3Rpb24sI3NlbGVjdGlvbkVuZCwjc2VsZWN0aW9uU3RhcnQsdmFsdWUsd3JhcCcsXG4gICAgJ3RpdGxlXltIVE1MRWxlbWVudF18dGV4dCcsXG4gICAgJ3RyYWNrXltIVE1MRWxlbWVudF18IWRlZmF1bHQsa2luZCxsYWJlbCxzcmMsc3JjbGFuZycsXG4gICAgJ3VsXltIVE1MRWxlbWVudF18IWNvbXBhY3QsdHlwZScsXG4gICAgJ3Vua25vd25eW0hUTUxFbGVtZW50XXwnLFxuICAgICd2aWRlb15tZWRpYXwjaGVpZ2h0LHBvc3Rlciwjd2lkdGgnLFxuICAgICc6c3ZnOmFeOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmFuaW1hdGVeOnN2ZzphbmltYXRpb258JyxcbiAgICAnOnN2ZzphbmltYXRlTW90aW9uXjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgJzpzdmc6YW5pbWF0ZVRyYW5zZm9ybV46c3ZnOmFuaW1hdGlvbnwnLFxuICAgICc6c3ZnOmNpcmNsZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6Y2xpcFBhdGheOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmRlZnNeOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmRlc2NeOnN2Zzp8JyxcbiAgICAnOnN2ZzpkaXNjYXJkXjpzdmc6fCcsXG4gICAgJzpzdmc6ZWxsaXBzZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6ZmVCbGVuZF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlQ29sb3JNYXRyaXheOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUNvbXBvbmVudFRyYW5zZmVyXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVDb21wb3NpdGVeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUNvbnZvbHZlTWF0cml4Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVEaWZmdXNlTGlnaHRpbmdeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZURpc3BsYWNlbWVudE1hcF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlRGlzdGFudExpZ2h0Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVEcm9wU2hhZG93Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVGbG9vZF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlRnVuY0FeOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgJzpzdmc6ZmVGdW5jQl46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAnOnN2ZzpmZUZ1bmNHXjpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICc6c3ZnOmZlRnVuY1JeOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgJzpzdmc6ZmVHYXVzc2lhbkJsdXJeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUltYWdlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVNZXJnZV46c3ZnOnwnLFxuICAgICc6c3ZnOmZlTWVyZ2VOb2RlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVNb3JwaG9sb2d5Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVPZmZzZXReOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZVBvaW50TGlnaHReOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZVNwZWN1bGFyTGlnaHRpbmdeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZVNwb3RMaWdodF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlVGlsZV46c3ZnOnwnLFxuICAgICc6c3ZnOmZlVHVyYnVsZW5jZV46c3ZnOnwnLFxuICAgICc6c3ZnOmZpbHRlcl46c3ZnOnwnLFxuICAgICc6c3ZnOmZvcmVpZ25PYmplY3ReOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmdeOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmltYWdlXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAnOnN2ZzpsaW5lXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpsaW5lYXJHcmFkaWVudF46c3ZnOmdyYWRpZW50fCcsXG4gICAgJzpzdmc6bXBhdGheOnN2Zzp8JyxcbiAgICAnOnN2ZzptYXJrZXJeOnN2Zzp8JyxcbiAgICAnOnN2ZzptYXNrXjpzdmc6fCcsXG4gICAgJzpzdmc6bWV0YWRhdGFeOnN2Zzp8JyxcbiAgICAnOnN2ZzpwYXRoXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpwYXR0ZXJuXjpzdmc6fCcsXG4gICAgJzpzdmc6cG9seWdvbl46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6cG9seWxpbmVeOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOnJhZGlhbEdyYWRpZW50Xjpzdmc6Z3JhZGllbnR8JyxcbiAgICAnOnN2ZzpyZWN0Xjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpzdmdeOnN2ZzpncmFwaGljc3wjY3VycmVudFNjYWxlLCN6b29tQW5kUGFuJyxcbiAgICAnOnN2ZzpzY3JpcHReOnN2Zzp8dHlwZScsXG4gICAgJzpzdmc6c2V0Xjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgJzpzdmc6c3RvcF46c3ZnOnwnLFxuICAgICc6c3ZnOnN0eWxlXjpzdmc6fCFkaXNhYmxlZCxtZWRpYSx0aXRsZSx0eXBlJyxcbiAgICAnOnN2Zzpzd2l0Y2heOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOnN5bWJvbF46c3ZnOnwnLFxuICAgICc6c3ZnOnRzcGFuXjpzdmc6dGV4dFBvc2l0aW9uaW5nfCcsXG4gICAgJzpzdmc6dGV4dF46c3ZnOnRleHRQb3NpdGlvbmluZ3wnLFxuICAgICc6c3ZnOnRleHRQYXRoXjpzdmc6dGV4dENvbnRlbnR8JyxcbiAgICAnOnN2Zzp0aXRsZV46c3ZnOnwnLFxuICAgICc6c3ZnOnVzZV46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6dmlld146c3ZnOnwjem9vbUFuZFBhbicsXG4gICAgJ2RhdGFeW0hUTUxFbGVtZW50XXx2YWx1ZScsXG4gICAgJ2tleWdlbl5bSFRNTEVsZW1lbnRdfCFhdXRvZm9jdXMsY2hhbGxlbmdlLCFkaXNhYmxlZCxmb3JtLGtleXR5cGUsbmFtZScsXG4gICAgJ21lbnVpdGVtXltIVE1MRWxlbWVudF18dHlwZSxsYWJlbCxpY29uLCFkaXNhYmxlZCwhY2hlY2tlZCxyYWRpb2dyb3VwLCFkZWZhdWx0JyxcbiAgICAnc3VtbWFyeV5bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ3RpbWVeW0hUTUxFbGVtZW50XXxkYXRlVGltZScsXG4gICAgJzpzdmc6Y3Vyc29yXjpzdmc6fCcsXG5dO1xudmFyIF9BVFRSX1RPX1BST1AgPSB7XG4gICAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gICAgJ2Zvcic6ICdodG1sRm9yJyxcbiAgICAnZm9ybWFjdGlvbic6ICdmb3JtQWN0aW9uJyxcbiAgICAnaW5uZXJIdG1sJzogJ2lubmVySFRNTCcsXG4gICAgJ3JlYWRvbmx5JzogJ3JlYWRPbmx5JyxcbiAgICAndGFiaW5kZXgnOiAndGFiSW5kZXgnLFxufTtcbnZhciBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9zY2hlbWEgPSB7fTtcbiAgICAgICAgU0NIRU1BLmZvckVhY2goZnVuY3Rpb24gKGVuY29kZWRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHt9O1xuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKGVuY29kZWRUeXBlLnNwbGl0KCd8JyksIDIpLCBzdHJUeXBlID0gX2FbMF0sIHN0clByb3BlcnRpZXMgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gc3RyUHJvcGVydGllcy5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKHN0clR5cGUuc3BsaXQoJ14nKSwgMiksIHR5cGVOYW1lcyA9IF9iWzBdLCBzdXBlck5hbWUgPSBfYlsxXTtcbiAgICAgICAgICAgIHR5cGVOYW1lcy5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gX3RoaXMuX3NjaGVtYVt0YWcudG9Mb3dlckNhc2UoKV0gPSB0eXBlOyB9KTtcbiAgICAgICAgICAgIHZhciBzdXBlclR5cGUgPSBzdXBlck5hbWUgJiYgX3RoaXMuX3NjaGVtYVtzdXBlck5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICBpZiAoc3VwZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3VwZXJUeXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHR5cGVbcHJvcF0gPSBzdXBlclR5cGVbcHJvcF07IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcGVydHlbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHlldCBzdXBwb3J0IGV2ZW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBldmVyIGFsbG93aW5nIHRvIGJpbmQgdG8gZXZlbnRzLCBHTyBUSFJPVUdIIEEgU0VDVVJJVFkgUkVWSUVXLCBhbGxvd2luZyBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxtb3N0IGNlcnRhaW5seSBpbnRyb2R1Y2UgYmFkIFhTUyB2dWxuZXJhYmlsaXRpZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gRVZFTlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBCT09MRUFOO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gTlVNQkVSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gT0JKRUNUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5XSA9IFNUUklORztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmhhc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BOYW1lLCBzY2hlbWFNZXRhcykge1xuICAgICAgICBpZiAoc2NoZW1hTWV0YXMuc29tZShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEubmFtZSA9PT0gTk9fRVJST1JTX1NDSEVNQS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChpc05nQ29udGFpbmVyKHRhZ05hbWUpIHx8IGlzTmdDb250ZW50KHRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hLm5hbWUgPT09IENVU1RPTV9FTEVNRU5UU19TQ0hFTUEubmFtZTsgfSkpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW4ndCB0ZWxsIG5vdyBhcyB3ZSBkb24ndCBrbm93IHdoaWNoIHByb3BlcnRpZXMgYSBjdXN0b20gZWxlbWVudCB3aWxsIGdldFxuICAgICAgICAgICAgICAgIC8vIG9uY2UgaXQgaXMgaW5zdGFudGlhdGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnRQcm9wZXJ0aWVzID0gdGhpcy5fc2NoZW1hW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0gfHwgdGhpcy5fc2NoZW1hWyd1bmtub3duJ107XG4gICAgICAgIHJldHVybiAhIWVsZW1lbnRQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICB9O1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuaGFzRWxlbWVudCA9IGZ1bmN0aW9uICh0YWdOYW1lLCBzY2hlbWFNZXRhcykge1xuICAgICAgICBpZiAoc2NoZW1hTWV0YXMuc29tZShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEubmFtZSA9PT0gTk9fRVJST1JTX1NDSEVNQS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChpc05nQ29udGFpbmVyKHRhZ05hbWUpIHx8IGlzTmdDb250ZW50KHRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NoZW1hTWV0YXMuc29tZShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEubmFtZSA9PT0gQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgICAgIC8vIEFsbG93IGFueSBjdXN0b20gZWxlbWVudHNcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISF0aGlzLl9zY2hlbWFbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHNlY3VyaXR5Q29udGV4dCByZXR1cm5zIHRoZSBzZWN1cml0eSBjb250ZXh0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgb24gdGhlIGdpdmVuIERPTSB0YWcuXG4gICAgICpcbiAgICAgKiBUYWcgYW5kIHByb3BlcnR5IG5hbWUgYXJlIHN0YXRpY2FsbHkga25vd24gYW5kIGNhbm5vdCBjaGFuZ2UgYXQgcnVudGltZSwgaS5lLiBpdCBpcyBub3RcbiAgICAgKiBwb3NzaWJsZSB0byBiaW5kIGEgdmFsdWUgaW50byBhIGNoYW5naW5nIGF0dHJpYnV0ZSBvciB0YWcgbmFtZS5cbiAgICAgKlxuICAgICAqIFRoZSBmaWx0ZXJpbmcgaXMgYmFzZWQgb24gYSBsaXN0IG9mIGFsbG93ZWQgdGFnc3xhdHRyaWJ1dGVzLiBBbGwgYXR0cmlidXRlcyBpbiB0aGUgc2NoZW1hXG4gICAgICogYWJvdmUgYXJlIGFzc3VtZWQgdG8gaGF2ZSB0aGUgJ05PTkUnIHNlY3VyaXR5IGNvbnRleHQsIGkuZS4gdGhhdCB0aGV5IGFyZSBzYWZlIGluZXJ0XG4gICAgICogc3RyaW5nIHZhbHVlcy4gT25seSBzcGVjaWZpYyB3ZWxsIGtub3duIGF0dGFjayB2ZWN0b3JzIGFyZSBhc3NpZ25lZCB0aGVpciBhcHByb3ByaWF0ZSBjb250ZXh0LlxuICAgICAqL1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuc2VjdXJpdHlDb250ZXh0ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BOYW1lLCBpc0F0dHJpYnV0ZSkge1xuICAgICAgICBpZiAoaXNBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIC8vIE5COiBGb3Igc2VjdXJpdHkgcHVycG9zZXMsIHVzZSB0aGUgbWFwcGVkIHByb3BlcnR5IG5hbWUsIG5vdCB0aGUgYXR0cmlidXRlIG5hbWUuXG4gICAgICAgICAgICBwcm9wTmFtZSA9IHRoaXMuZ2V0TWFwcGVkUHJvcE5hbWUocHJvcE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBjb21wYXJpc29ucyBhcmUgY2FzZSBpbnNlbnNpdGl2ZSwgc28gdGhhdCBjYXNlIGRpZmZlcmVuY2VzIGJldHdlZW4gYXR0cmlidXRlIGFuZFxuICAgICAgICAvLyBwcm9wZXJ0eSBuYW1lcyBkbyBub3QgaGF2ZSBhIHNlY3VyaXR5IGltcGFjdC5cbiAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcHJvcE5hbWUgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgY3R4ID0gU0VDVVJJVFlfU0NIRU1BKClbdGFnTmFtZSArICd8JyArIHByb3BOYW1lXTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfVxuICAgICAgICBjdHggPSBTRUNVUklUWV9TQ0hFTUEoKVsnKnwnICsgcHJvcE5hbWVdO1xuICAgICAgICByZXR1cm4gY3R4ID8gY3R4IDogU2VjdXJpdHlDb250ZXh0Lk5PTkU7XG4gICAgfTtcbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmdldE1hcHBlZFByb3BOYW1lID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7IHJldHVybiBfQVRUUl9UT19QUk9QW3Byb3BOYW1lXSB8fCBwcm9wTmFtZTsgfTtcbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmdldERlZmF1bHRDb21wb25lbnRFbGVtZW50TmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICduZy1jb21wb25lbnQnOyB9O1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUudmFsaWRhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnb24nKSkge1xuICAgICAgICAgICAgdmFyIG1zZyA9IFwiQmluZGluZyB0byBldmVudCBwcm9wZXJ0eSAnXCIgKyBuYW1lICsgXCInIGlzIGRpc2FsbG93ZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJwbGVhc2UgdXNlIChcIiArIG5hbWUuc2xpY2UoMikgKyBcIik9Li4uXCIpICtcbiAgICAgICAgICAgICAgICAoXCJcXG5JZiAnXCIgKyBuYW1lICsgXCInIGlzIGEgZGlyZWN0aXZlIGlucHV0LCBtYWtlIHN1cmUgdGhlIGRpcmVjdGl2ZSBpcyBpbXBvcnRlZCBieSB0aGVcIikgK1xuICAgICAgICAgICAgICAgIFwiIGN1cnJlbnQgbW9kdWxlLlwiO1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIG1zZzogbXNnIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS52YWxpZGF0ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnb24nKSkge1xuICAgICAgICAgICAgdmFyIG1zZyA9IFwiQmluZGluZyB0byBldmVudCBhdHRyaWJ1dGUgJ1wiICsgbmFtZSArIFwiJyBpcyBkaXNhbGxvd2VkIGZvciBzZWN1cml0eSByZWFzb25zLCBcIiArXG4gICAgICAgICAgICAgICAgKFwicGxlYXNlIHVzZSAoXCIgKyBuYW1lLnNsaWNlKDIpICsgXCIpPS4uLlwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCBtc2c6IG1zZyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuYWxsS25vd25FbGVtZW50TmFtZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zY2hlbWEpOyB9O1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUubm9ybWFsaXplQW5pbWF0aW9uU3R5bGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICByZXR1cm4gZGFzaENhc2VUb0NhbWVsQ2FzZShwcm9wTmFtZSk7XG4gICAgfTtcbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLm5vcm1hbGl6ZUFuaW1hdGlvblN0eWxlVmFsdWUgPSBmdW5jdGlvbiAoY2FtZWxDYXNlUHJvcCwgdXNlclByb3ZpZGVkUHJvcCwgdmFsKSB7XG4gICAgICAgIHZhciB1bml0ID0gJyc7XG4gICAgICAgIHZhciBzdHJWYWwgPSB2YWwudG9TdHJpbmcoKS50cmltKCk7XG4gICAgICAgIHZhciBlcnJvck1zZyA9IG51bGw7XG4gICAgICAgIGlmIChfaXNQaXhlbERpbWVuc2lvblN0eWxlKGNhbWVsQ2FzZVByb3ApICYmIHZhbCAhPT0gMCAmJiB2YWwgIT09ICcwJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9ICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsQW5kU3VmZml4TWF0Y2ggPSB2YWwubWF0Y2goL15bKy1dP1tcXGRcXC5dKyhbYS16XSopJC8pO1xuICAgICAgICAgICAgICAgIGlmICh2YWxBbmRTdWZmaXhNYXRjaCAmJiB2YWxBbmRTdWZmaXhNYXRjaFsxXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1zZyA9IFwiUGxlYXNlIHByb3ZpZGUgYSBDU1MgdW5pdCB2YWx1ZSBmb3IgXCIgKyB1c2VyUHJvdmlkZWRQcm9wICsgXCI6XCIgKyB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGVycm9yOiBlcnJvck1zZywgdmFsdWU6IHN0clZhbCArIHVuaXQgfTtcbiAgICB9O1xuICAgIHJldHVybiBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnk7XG59KEVsZW1lbnRTY2hlbWFSZWdpc3RyeSkpO1xuZnVuY3Rpb24gX2lzUGl4ZWxEaW1lbnNpb25TdHlsZShwcm9wKSB7XG4gICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgY2FzZSAnbWluV2lkdGgnOlxuICAgICAgICBjYXNlICdtaW5IZWlnaHQnOlxuICAgICAgICBjYXNlICdtYXhXaWR0aCc6XG4gICAgICAgIGNhc2UgJ21heEhlaWdodCc6XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGNhc2UgJ2ZvbnRTaXplJzpcbiAgICAgICAgY2FzZSAnb3V0bGluZVdpZHRoJzpcbiAgICAgICAgY2FzZSAnb3V0bGluZU9mZnNldCc6XG4gICAgICAgIGNhc2UgJ3BhZGRpbmdUb3AnOlxuICAgICAgICBjYXNlICdwYWRkaW5nTGVmdCc6XG4gICAgICAgIGNhc2UgJ3BhZGRpbmdCb3R0b20nOlxuICAgICAgICBjYXNlICdwYWRkaW5nUmlnaHQnOlxuICAgICAgICBjYXNlICdtYXJnaW5Ub3AnOlxuICAgICAgICBjYXNlICdtYXJnaW5MZWZ0JzpcbiAgICAgICAgY2FzZSAnbWFyZ2luQm90dG9tJzpcbiAgICAgICAgY2FzZSAnbWFyZ2luUmlnaHQnOlxuICAgICAgICBjYXNlICdib3JkZXJSYWRpdXMnOlxuICAgICAgICBjYXNlICdib3JkZXJXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlclRvcFdpZHRoJzpcbiAgICAgICAgY2FzZSAnYm9yZGVyTGVmdFdpZHRoJzpcbiAgICAgICAgY2FzZSAnYm9yZGVyUmlnaHRXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlckJvdHRvbVdpZHRoJzpcbiAgICAgICAgY2FzZSAndGV4dEluZGVudCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBCSU5EX05BTUVfUkVHRVhQJDEgPSAvXig/Oig/Oig/OihiaW5kLSl8KGxldC0pfChyZWYtfCMpfChvbi0pfChiaW5kb24tKXwoQCkpKC4rKSl8XFxbXFwoKFteXFwpXSspXFwpXFxdfFxcWyhbXlxcXV0rKVxcXXxcXCgoW15cXCldKylcXCkpJC87XG4vLyBHcm91cCAxID0gXCJiaW5kLVwiXG52YXIgS1dfQklORF9JRFgkMSA9IDE7XG4vLyBHcm91cCAyID0gXCJsZXQtXCJcbnZhciBLV19MRVRfSURYJDEgPSAyO1xuLy8gR3JvdXAgMyA9IFwicmVmLS8jXCJcbnZhciBLV19SRUZfSURYJDEgPSAzO1xuLy8gR3JvdXAgNCA9IFwib24tXCJcbnZhciBLV19PTl9JRFgkMSA9IDQ7XG4vLyBHcm91cCA1ID0gXCJiaW5kb24tXCJcbnZhciBLV19CSU5ET05fSURYJDEgPSA1O1xuLy8gR3JvdXAgNiA9IFwiQFwiXG52YXIgS1dfQVRfSURYJDEgPSA2O1xuLy8gR3JvdXAgNyA9IHRoZSBpZGVudGlmaWVyIGFmdGVyIFwiYmluZC1cIiwgXCJsZXQtXCIsIFwicmVmLS8jXCIsIFwib24tXCIsIFwiYmluZG9uLVwiIG9yIFwiQFwiXG52YXIgSURFTlRfS1dfSURYJDEgPSA3O1xuLy8gR3JvdXAgOCA9IGlkZW50aWZpZXIgaW5zaWRlIFsoKV1cbnZhciBJREVOVF9CQU5BTkFfQk9YX0lEWCQxID0gODtcbi8vIEdyb3VwIDkgPSBpZGVudGlmaWVyIGluc2lkZSBbXVxudmFyIElERU5UX1BST1BFUlRZX0lEWCQxID0gOTtcbi8vIEdyb3VwIDEwID0gaWRlbnRpZmllciBpbnNpZGUgKClcbnZhciBJREVOVF9FVkVOVF9JRFgkMSA9IDEwO1xudmFyIFRFTVBMQVRFX0FUVFJfUFJFRklYJDEgPSAnKic7XG5mdW5jdGlvbiBodG1sQXN0VG9SZW5kZXIzQXN0KGh0bWxOb2RlcywgYmluZGluZ1BhcnNlcikge1xuICAgIHZhciB0cmFuc2Zvcm1lciA9IG5ldyBIdG1sQXN0VG9JdnlBc3QoYmluZGluZ1BhcnNlcik7XG4gICAgdmFyIGl2eU5vZGVzID0gdmlzaXRBbGwkMSh0cmFuc2Zvcm1lciwgaHRtbE5vZGVzKTtcbiAgICAvLyBFcnJvcnMgbWlnaHQgb3JpZ2luYXRlIGluIGVpdGhlciB0aGUgYmluZGluZyBwYXJzZXIgb3IgdGhlIGh0bWwgdG8gaXZ5IHRyYW5zZm9ybWVyXG4gICAgdmFyIGFsbEVycm9ycyA9IGJpbmRpbmdQYXJzZXIuZXJyb3JzLmNvbmNhdCh0cmFuc2Zvcm1lci5lcnJvcnMpO1xuICAgIHZhciBlcnJvcnMgPSBhbGxFcnJvcnMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmxldmVsID09PSBQYXJzZUVycm9yTGV2ZWwuRVJST1I7IH0pO1xuICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgZXJyb3JTdHJpbmcgPSBlcnJvcnMuam9pbignXFxuJyk7XG4gICAgICAgIHRocm93IHN5bnRheEVycm9yKFwiVGVtcGxhdGUgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JTdHJpbmcsIGVycm9ycyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVzOiBpdnlOb2RlcyxcbiAgICAgICAgZXJyb3JzOiBhbGxFcnJvcnMsXG4gICAgICAgIHN0eWxlVXJsczogdHJhbnNmb3JtZXIuc3R5bGVVcmxzLFxuICAgICAgICBzdHlsZXM6IHRyYW5zZm9ybWVyLnN0eWxlcyxcbiAgICB9O1xufVxudmFyIEh0bWxBc3RUb0l2eUFzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sQXN0VG9JdnlBc3QoYmluZGluZ1BhcnNlcikge1xuICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIgPSBiaW5kaW5nUGFyc2VyO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IFtdO1xuICAgIH1cbiAgICAvLyBIVE1MIHZpc2l0b3JcbiAgICBIdG1sQXN0VG9JdnlBc3QucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJlcGFyc2VkRWxlbWVudCA9IHByZXBhcnNlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudHMgPSB0ZXh0Q29udGVudHMoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoY29udGVudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlcy5wdXNoKGNvbnRlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVCAmJlxuICAgICAgICAgICAgaXNTdHlsZVVybFJlc29sdmFibGUocHJlcGFyc2VkRWxlbWVudC5ocmVmQXR0cikpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVVcmxzLnB1c2gocHJlcGFyc2VkRWxlbWVudC5ocmVmQXR0cik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIGEgYDxuZy10ZW1wbGF0ZT5gXG4gICAgICAgIHZhciBpc1RlbXBsYXRlRWxlbWVudCA9IGlzTmdUZW1wbGF0ZShlbGVtZW50Lm5hbWUpO1xuICAgICAgICB2YXIgcGFyc2VkUHJvcGVydGllcyA9IFtdO1xuICAgICAgICB2YXIgYm91bmRFdmVudHMgPSBbXTtcbiAgICAgICAgdmFyIHZhcmlhYmxlcyA9IFtdO1xuICAgICAgICB2YXIgcmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IFtdO1xuICAgICAgICB2YXIgaTE4bkF0dHJzTWV0YSA9IHt9O1xuICAgICAgICB2YXIgdGVtcGxhdGVQYXJzZWRQcm9wZXJ0aWVzID0gW107XG4gICAgICAgIHZhciB0ZW1wbGF0ZVZhcmlhYmxlcyA9IFtdO1xuICAgICAgICAvLyBXaGV0aGVyIHRoZSBlbGVtZW50IGhhcyBhbnkgKi1hdHRyaWJ1dGVcbiAgICAgICAgdmFyIGVsZW1lbnRIYXNJbmxpbmVUZW1wbGF0ZSA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhlbGVtZW50LmF0dHJzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgaGFzQmluZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIGAqYXR0cmAgZGVmaW5lcyB0ZW1wbGF0ZSBiaW5kaW5nc1xuICAgICAgICAgICAgICAgIHZhciBpc1RlbXBsYXRlQmluZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUuaTE4bikge1xuICAgICAgICAgICAgICAgICAgICBpMThuQXR0cnNNZXRhW2F0dHJpYnV0ZS5uYW1lXSA9IGF0dHJpYnV0ZS5pMThuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZE5hbWUuc3RhcnRzV2l0aChURU1QTEFURV9BVFRSX1BSRUZJWCQxKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAqLWF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRIYXNJbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihcIkNhbid0IGhhdmUgbXVsdGlwbGUgdGVtcGxhdGUgYmluZGluZ3Mgb24gb25lIGVsZW1lbnQuIFVzZSBvbmx5IG9uZSBhdHRyaWJ1dGUgcHJlZml4ZWQgd2l0aCAqXCIsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc1RlbXBsYXRlQmluZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRIYXNJbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVLZXkgPSBub3JtYWxpemVkTmFtZS5zdWJzdHJpbmcoVEVNUExBVEVfQVRUUl9QUkVGSVgkMS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkVmFyaWFibGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBhYnNvbHV0ZU9mZnNldCA9IGF0dHJpYnV0ZS52YWx1ZVNwYW4gPyBhdHRyaWJ1dGUudmFsdWVTcGFuLnN0YXJ0Lm9mZnNldCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuc291cmNlU3Bhbi5zdGFydC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyh0ZW1wbGF0ZUtleSwgdGVtcGxhdGVWYWx1ZSwgYXR0cmlidXRlLnNvdXJjZVNwYW4sIGFic29sdXRlT2Zmc2V0LCBbXSwgdGVtcGxhdGVQYXJzZWRQcm9wZXJ0aWVzLCBwYXJzZWRWYXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVZhcmlhYmxlcy5wdXNoLmFwcGx5KHRlbXBsYXRlVmFyaWFibGVzLCBfX3NwcmVhZChwYXJzZWRWYXJpYWJsZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgVmFyaWFibGUodi5uYW1lLCB2LnZhbHVlLCB2LnNvdXJjZVNwYW4pOyB9KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHZhcmlhYmxlcywgZXZlbnRzLCBwcm9wZXJ0eSBiaW5kaW5ncywgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgICAgICAgICBoYXNCaW5kaW5nID0gdGhpcy5wYXJzZUF0dHJpYnV0ZShpc1RlbXBsYXRlRWxlbWVudCwgYXR0cmlidXRlLCBbXSwgcGFyc2VkUHJvcGVydGllcywgYm91bmRFdmVudHMsIHZhcmlhYmxlcywgcmVmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaGFzQmluZGluZyAmJiAhaXNUZW1wbGF0ZUJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgaW5jbHVkZSB0aGUgYmluZGluZ3MgYXMgYXR0cmlidXRlcyBhcyB3ZWxsIGluIHRoZSBBU1RcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5wdXNoKHRoaXMudmlzaXRBdHRyaWJ1dGUoYXR0cmlidXRlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdmlzaXRBbGwkMShwcmVwYXJzZWRFbGVtZW50Lm5vbkJpbmRhYmxlID8gTk9OX0JJTkRBQkxFX1ZJU0lUT1IkMSA6IHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgICB2YXIgcGFyc2VkRWxlbWVudDtcbiAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuTkdfQ09OVEVOVCkge1xuICAgICAgICAgICAgLy8gYDxuZy1jb250ZW50PmBcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmNoaWxkcmVuICYmXG4gICAgICAgICAgICAgICAgIWVsZW1lbnQuY2hpbGRyZW4uZXZlcnkoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGlzRW1wdHlUZXh0Tm9kZShub2RlKSB8fCBpc0NvbW1lbnROb2RlKG5vZGUpOyB9KSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoXCI8bmctY29udGVudD4gZWxlbWVudCBjYW5ub3QgaGF2ZSBjb250ZW50LlwiLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gcHJlcGFyc2VkRWxlbWVudC5zZWxlY3RBdHRyO1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gZWxlbWVudC5hdHRycy5tYXAoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIF90aGlzLnZpc2l0QXR0cmlidXRlKGF0dHIpOyB9KTtcbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgQ29udGVudChzZWxlY3RvciwgYXR0cnMsIGVsZW1lbnQuc291cmNlU3BhbiwgZWxlbWVudC5pMThuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1RlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gYDxuZy10ZW1wbGF0ZT5gXG4gICAgICAgICAgICB2YXIgYXR0cnMgPSB0aGlzLmV4dHJhY3RBdHRyaWJ1dGVzKGVsZW1lbnQubmFtZSwgcGFyc2VkUHJvcGVydGllcywgaTE4bkF0dHJzTWV0YSk7XG4gICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IFRlbXBsYXRlKGVsZW1lbnQubmFtZSwgYXR0cmlidXRlcywgYXR0cnMuYm91bmQsIGJvdW5kRXZlbnRzLCBbIC8qIG5vIHRlbXBsYXRlIGF0dHJpYnV0ZXMgKi9dLCBjaGlsZHJlbiwgcmVmZXJlbmNlcywgdmFyaWFibGVzLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4sIGVsZW1lbnQuaTE4bik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSB0aGlzLmV4dHJhY3RBdHRyaWJ1dGVzKGVsZW1lbnQubmFtZSwgcGFyc2VkUHJvcGVydGllcywgaTE4bkF0dHJzTWV0YSk7XG4gICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IEVsZW1lbnQoZWxlbWVudC5uYW1lLCBhdHRyaWJ1dGVzLCBhdHRycy5ib3VuZCwgYm91bmRFdmVudHMsIGNoaWxkcmVuLCByZWZlcmVuY2VzLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4sIGVsZW1lbnQuaTE4bik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnRIYXNJbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBub2RlIGlzIGFuIGlubGluZS10ZW1wbGF0ZSAoZS5nLiBoYXMgKm5nRm9yKSB0aGVuIHdlIG5lZWQgdG8gY3JlYXRlIGEgdGVtcGxhdGVcbiAgICAgICAgICAgIC8vIG5vZGUgdGhhdCBjb250YWlucyB0aGlzIG5vZGUuXG4gICAgICAgICAgICAvLyBNb3Jlb3ZlciwgaWYgdGhlIG5vZGUgaXMgYW4gZWxlbWVudCwgdGhlbiB3ZSBuZWVkIHRvIGhvaXN0IGl0cyBhdHRyaWJ1dGVzIHRvIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgICAgLy8gbm9kZSBmb3IgbWF0Y2hpbmcgYWdhaW5zdCBjb250ZW50IHByb2plY3Rpb24gc2VsZWN0b3JzLlxuICAgICAgICAgICAgdmFyIGF0dHJzID0gdGhpcy5leHRyYWN0QXR0cmlidXRlcygnbmctdGVtcGxhdGUnLCB0ZW1wbGF0ZVBhcnNlZFByb3BlcnRpZXMsIGkxOG5BdHRyc01ldGEpO1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlQXR0cnNfMSA9IFtdO1xuICAgICAgICAgICAgYXR0cnMubGl0ZXJhbC5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiB0ZW1wbGF0ZUF0dHJzXzEucHVzaChhdHRyKTsgfSk7XG4gICAgICAgICAgICBhdHRycy5ib3VuZC5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiB0ZW1wbGF0ZUF0dHJzXzEucHVzaChhdHRyKTsgfSk7XG4gICAgICAgICAgICB2YXIgaG9pc3RlZEF0dHJzID0gcGFyc2VkRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQgP1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogcGFyc2VkRWxlbWVudC5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IHBhcnNlZEVsZW1lbnQuaW5wdXRzLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBwYXJzZWRFbGVtZW50Lm91dHB1dHMsXG4gICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgeyBhdHRyaWJ1dGVzOiBbXSwgaW5wdXRzOiBbXSwgb3V0cHV0czogW10gfTtcbiAgICAgICAgICAgIC8vIFRPRE8ocGspOiB0ZXN0IGZvciB0aGlzIGNhc2VcbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgVGVtcGxhdGUocGFyc2VkRWxlbWVudC5uYW1lLCBob2lzdGVkQXR0cnMuYXR0cmlidXRlcywgaG9pc3RlZEF0dHJzLmlucHV0cywgaG9pc3RlZEF0dHJzLm91dHB1dHMsIHRlbXBsYXRlQXR0cnNfMSwgW3BhcnNlZEVsZW1lbnRdLCBbIC8qIG5vIHJlZmVyZW5jZXMgKi9dLCB0ZW1wbGF0ZVZhcmlhYmxlcywgZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LnN0YXJ0U291cmNlU3BhbiwgZWxlbWVudC5lbmRTb3VyY2VTcGFuLCBlbGVtZW50LmkxOG4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWRFbGVtZW50O1xuICAgIH07XG4gICAgSHRtbEFzdFRvSXZ5QXN0LnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0QXR0cmlidXRlKGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuLCBhdHRyaWJ1dGUudmFsdWVTcGFuLCBhdHRyaWJ1dGUuaTE4bik7XG4gICAgfTtcbiAgICBIdG1sQXN0VG9JdnlBc3QucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdFRleHRXaXRoSW50ZXJwb2xhdGlvbih0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4sIHRleHQuaTE4bik7XG4gICAgfTtcbiAgICBIdG1sQXN0VG9JdnlBc3QucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWV0YSA9IGV4cGFuc2lvbi5pMThuO1xuICAgICAgICAvLyBkbyBub3QgZ2VuZXJhdGUgSWN1IGluIGNhc2UgaXQgd2FzIGNyZWF0ZWRcbiAgICAgICAgLy8gb3V0c2lkZSBvZiBpMThuIGJsb2NrIGluIGEgdGVtcGxhdGVcbiAgICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFycyA9IHt9O1xuICAgICAgICB2YXIgcGxhY2Vob2xkZXJzID0ge307XG4gICAgICAgIC8vIGV4dHJhY3QgVkFScyBmcm9tIElDVXMgLSB3ZSBwcm9jZXNzIHRoZW0gc2VwYXJhdGVseSB3aGlsZVxuICAgICAgICAvLyBhc3NlbWJsaW5nIHJlc3VsdGluZyBtZXNzYWdlIHZpYSBnb29nLmdldE1zZyBmdW5jdGlvbiwgc2luY2VcbiAgICAgICAgLy8gd2UgbmVlZCB0byBwYXNzIHRoZW0gdG8gdG9wLWxldmVsIGdvb2cuZ2V0TXNnIGNhbGxcbiAgICAgICAgT2JqZWN0LmtleXMobWV0YS5wbGFjZWhvbGRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbWV0YS5wbGFjZWhvbGRlcnNba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChJMThOX0lDVV9WQVJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSBfdGhpcy5iaW5kaW5nUGFyc2VyLmludGVycG9sYXRpb25Db25maWc7XG4gICAgICAgICAgICAgICAgLy8gSUNVIGV4cHJlc3Npb24gaXMgYSBwbGFpbiBzdHJpbmcsIG5vdCB3cmFwcGVkIGludG8gc3RhcnRcbiAgICAgICAgICAgICAgICAvLyBhbmQgZW5kIHRhZ3MsIHNvIHdlIHdyYXAgaXQgYmVmb3JlIHBhc3NpbmcgdG8gYmluZGluZyBwYXJzZXJcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZCA9IFwiXCIgKyBjb25maWcuc3RhcnQgKyB2YWx1ZSArIGNvbmZpZy5lbmQ7XG4gICAgICAgICAgICAgICAgdmFyc1trZXldID0gX3RoaXMuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uKHdyYXBwZWQsIGV4cGFuc2lvbi5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyc1trZXldID0gX3RoaXMuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uKHZhbHVlLCBleHBhbnNpb24uc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEljdSh2YXJzLCBwbGFjZWhvbGRlcnMsIGV4cGFuc2lvbi5zb3VyY2VTcGFuLCBtZXRhKTtcbiAgICB9O1xuICAgIEh0bWxBc3RUb0l2eUFzdC5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgSHRtbEFzdFRvSXZ5QXN0LnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvLyBjb252ZXJ0IHZpZXcgZW5naW5lIGBQYXJzZWRQcm9wZXJ0eWAgdG8gYSBmb3JtYXQgc3VpdGFibGUgZm9yIElWWVxuICAgIEh0bWxBc3RUb0l2eUFzdC5wcm90b3R5cGUuZXh0cmFjdEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIHByb3BlcnRpZXMsIGkxOG5Qcm9wc01ldGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGJvdW5kID0gW107XG4gICAgICAgIHZhciBsaXRlcmFsID0gW107XG4gICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIGkxOG4gPSBpMThuUHJvcHNNZXRhW3Byb3AubmFtZV07XG4gICAgICAgICAgICBpZiAocHJvcC5pc0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBsaXRlcmFsLnB1c2gobmV3IFRleHRBdHRyaWJ1dGUocHJvcC5uYW1lLCBwcm9wLmV4cHJlc3Npb24uc291cmNlIHx8ICcnLCBwcm9wLnNvdXJjZVNwYW4sIHVuZGVmaW5lZCwgaTE4bikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHZhbGlkYXRpb24gaXMgc2tpcHBlZCBhbmQgcHJvcGVydHkgbWFwcGluZyBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgICAgIC8vIGR1ZSB0byB0aGUgZmFjdCB0aGF0IHdlIG5lZWQgdG8gbWFrZSBzdXJlIGEgZ2l2ZW4gcHJvcCBpcyBub3QgYW5cbiAgICAgICAgICAgICAgICAvLyBpbnB1dCBvZiBhIGRpcmVjdGl2ZSBhbmQgZGlyZWN0aXZlIG1hdGNoaW5nIGhhcHBlbnMgYXQgcnVudGltZS5cbiAgICAgICAgICAgICAgICB2YXIgYmVwID0gX3RoaXMuYmluZGluZ1BhcnNlci5jcmVhdGVCb3VuZEVsZW1lbnRQcm9wZXJ0eShlbGVtZW50TmFtZSwgcHJvcCwgLyogc2tpcFZhbGlkYXRpb24gKi8gdHJ1ZSwgLyogbWFwUHJvcGVydHlOYW1lICovIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBib3VuZC5wdXNoKEJvdW5kQXR0cmlidXRlLmZyb21Cb3VuZEVsZW1lbnRQcm9wZXJ0eShiZXAsIGkxOG4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGJvdW5kOiBib3VuZCwgbGl0ZXJhbDogbGl0ZXJhbCB9O1xuICAgIH07XG4gICAgSHRtbEFzdFRvSXZ5QXN0LnByb3RvdHlwZS5wYXJzZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChpc1RlbXBsYXRlRWxlbWVudCwgYXR0cmlidXRlLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBwYXJzZWRQcm9wZXJ0aWVzLCBib3VuZEV2ZW50cywgdmFyaWFibGVzLCByZWZlcmVuY2VzKSB7XG4gICAgICAgIHZhciBuYW1lID0gbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcbiAgICAgICAgdmFyIHNyY1NwYW4gPSBhdHRyaWJ1dGUuc291cmNlU3BhbjtcbiAgICAgICAgdmFyIGFic29sdXRlT2Zmc2V0ID0gYXR0cmlidXRlLnZhbHVlU3BhbiA/IGF0dHJpYnV0ZS52YWx1ZVNwYW4uc3RhcnQub2Zmc2V0IDogc3JjU3Bhbi5zdGFydC5vZmZzZXQ7XG4gICAgICAgIHZhciBiaW5kUGFydHMgPSBuYW1lLm1hdGNoKEJJTkRfTkFNRV9SRUdFWFAkMSk7XG4gICAgICAgIHZhciBoYXNCaW5kaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChiaW5kUGFydHMpIHtcbiAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGJpbmRQYXJ0c1tLV19CSU5EX0lEWCQxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlCaW5kaW5nKGJpbmRQYXJ0c1tJREVOVF9LV19JRFgkMV0sIHZhbHVlLCBmYWxzZSwgc3JjU3BhbiwgYWJzb2x1dGVPZmZzZXQsIGF0dHJpYnV0ZS52YWx1ZVNwYW4sIG1hdGNoYWJsZUF0dHJpYnV0ZXMsIHBhcnNlZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX0xFVF9JRFgkMV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBiaW5kUGFydHNbSURFTlRfS1dfSURYJDFdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVmFyaWFibGUoaWRlbnRpZmllciwgdmFsdWUsIHNyY1NwYW4sIGF0dHJpYnV0ZS52YWx1ZVNwYW4sIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKFwiXFxcImxldC1cXFwiIGlzIG9ubHkgc3VwcG9ydGVkIG9uIG5nLXRlbXBsYXRlIGVsZW1lbnRzLlwiLCBzcmNTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfUkVGX0lEWCQxXSkge1xuICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gYmluZFBhcnRzW0lERU5UX0tXX0lEWCQxXTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlUmVmZXJlbmNlKGlkZW50aWZpZXIsIHZhbHVlLCBzcmNTcGFuLCBhdHRyaWJ1dGUudmFsdWVTcGFuLCByZWZlcmVuY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19PTl9JRFgkMV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlRXZlbnQoYmluZFBhcnRzW0lERU5UX0tXX0lEWCQxXSwgdmFsdWUsIHNyY1NwYW4sIGF0dHJpYnV0ZS52YWx1ZVNwYW4gfHwgc3JjU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgZXZlbnRzKTtcbiAgICAgICAgICAgICAgICBhZGRFdmVudHMoZXZlbnRzLCBib3VuZEV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfQklORE9OX0lEWCQxXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhiaW5kUGFydHNbSURFTlRfS1dfSURYJDFdLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIGFic29sdXRlT2Zmc2V0LCBhdHRyaWJ1dGUudmFsdWVTcGFuLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBwYXJzZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQXNzaWdubWVudEV2ZW50KGJpbmRQYXJ0c1tJREVOVF9LV19JRFgkMV0sIHZhbHVlLCBzcmNTcGFuLCBhdHRyaWJ1dGUudmFsdWVTcGFuLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBib3VuZEV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfQVRfSURYJDFdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlTGl0ZXJhbEF0dHIobmFtZSwgdmFsdWUsIHNyY1NwYW4sIGFic29sdXRlT2Zmc2V0LCBhdHRyaWJ1dGUudmFsdWVTcGFuLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBwYXJzZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tJREVOVF9CQU5BTkFfQk9YX0lEWCQxXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhiaW5kUGFydHNbSURFTlRfQkFOQU5BX0JPWF9JRFgkMV0sIHZhbHVlLCBmYWxzZSwgc3JjU3BhbiwgYWJzb2x1dGVPZmZzZXQsIGF0dHJpYnV0ZS52YWx1ZVNwYW4sIG1hdGNoYWJsZUF0dHJpYnV0ZXMsIHBhcnNlZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBc3NpZ25tZW50RXZlbnQoYmluZFBhcnRzW0lERU5UX0JBTkFOQV9CT1hfSURYJDFdLCB2YWx1ZSwgc3JjU3BhbiwgYXR0cmlidXRlLnZhbHVlU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgYm91bmRFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0lERU5UX1BST1BFUlRZX0lEWCQxXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhiaW5kUGFydHNbSURFTlRfUFJPUEVSVFlfSURYJDFdLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIGFic29sdXRlT2Zmc2V0LCBhdHRyaWJ1dGUudmFsdWVTcGFuLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBwYXJzZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tJREVOVF9FVkVOVF9JRFgkMV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlRXZlbnQoYmluZFBhcnRzW0lERU5UX0VWRU5UX0lEWCQxXSwgdmFsdWUsIHNyY1NwYW4sIGF0dHJpYnV0ZS52YWx1ZVNwYW4gfHwgc3JjU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgZXZlbnRzKTtcbiAgICAgICAgICAgICAgICBhZGRFdmVudHMoZXZlbnRzLCBib3VuZEV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYXNCaW5kaW5nID0gdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlJbnRlcnBvbGF0aW9uKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCBhdHRyaWJ1dGUudmFsdWVTcGFuLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBwYXJzZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzQmluZGluZztcbiAgICB9O1xuICAgIEh0bWxBc3RUb0l2eUFzdC5wcm90b3R5cGUuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBzb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIHZhciB2YWx1ZU5vTmdzcCA9IHJlcGxhY2VOZ3NwKHZhbHVlKTtcbiAgICAgICAgdmFyIGV4cHIgPSB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlTm9OZ3NwLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgcmV0dXJuIGV4cHIgPyBuZXcgQm91bmRUZXh0KGV4cHIsIHNvdXJjZVNwYW4sIGkxOG4pIDogbmV3IFRleHQodmFsdWVOb05nc3AsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgSHRtbEFzdFRvSXZ5QXN0LnByb3RvdHlwZS5wYXJzZVZhcmlhYmxlID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4sIHZhcmlhYmxlcykge1xuICAgICAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihcIlxcXCItXFxcIiBpcyBub3QgYWxsb3dlZCBpbiB2YXJpYWJsZSBuYW1lc1wiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICB2YXJpYWJsZXMucHVzaChuZXcgVmFyaWFibGUoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4sIHZhbHVlU3BhbikpO1xuICAgIH07XG4gICAgSHRtbEFzdFRvSXZ5QXN0LnByb3RvdHlwZS5wYXJzZVJlZmVyZW5jZSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbiwgdmFsdWVTcGFuLCByZWZlcmVuY2VzKSB7XG4gICAgICAgIGlmIChpZGVudGlmaWVyLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKFwiXFxcIi1cXFwiIGlzIG5vdCBhbGxvd2VkIGluIHJlZmVyZW5jZSBuYW1lc1wiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZWZlcmVuY2VzLnB1c2gobmV3IFJlZmVyZW5jZShpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbiwgdmFsdWVTcGFuKSk7XG4gICAgfTtcbiAgICBIdG1sQXN0VG9JdnlBc3QucHJvdG90eXBlLnBhcnNlQXNzaWdubWVudEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIGJvdW5kRXZlbnRzKSB7XG4gICAgICAgIHZhciBldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlRXZlbnQobmFtZSArIFwiQ2hhbmdlXCIsIGV4cHJlc3Npb24gKyBcIj0kZXZlbnRcIiwgc291cmNlU3BhbiwgdmFsdWVTcGFuIHx8IHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCBldmVudHMpO1xuICAgICAgICBhZGRFdmVudHMoZXZlbnRzLCBib3VuZEV2ZW50cyk7XG4gICAgfTtcbiAgICBIdG1sQXN0VG9JdnlBc3QucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNvdXJjZVNwYW4sIGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gUGFyc2VFcnJvckxldmVsLkVSUk9SOyB9XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlRXJyb3Ioc291cmNlU3BhbiwgbWVzc2FnZSwgbGV2ZWwpKTtcbiAgICB9O1xuICAgIHJldHVybiBIdG1sQXN0VG9JdnlBc3Q7XG59KCkpO1xudmFyIE5vbkJpbmRhYmxlVmlzaXRvciQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vbkJpbmRhYmxlVmlzaXRvcigpIHtcbiAgICB9XG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgIHZhciBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGFzdCk7XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRSB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUKSB7XG4gICAgICAgICAgICAvLyBTa2lwcGluZyA8c2NyaXB0PiBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHN0eWxlPiBhbmQgc3R5bGVzaGVldHMgYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxuICAgICAgICAgICAgLy8gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHZpc2l0QWxsJDEodGhpcywgYXN0LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGFzdC5uYW1lLCB2aXNpdEFsbCQxKHRoaXMsIGFzdC5hdHRycyksIFxuICAgICAgICAvKiBpbnB1dHMgKi8gW10sIC8qIG91dHB1dHMgKi8gW10sIGNoaWxkcmVuLCAvKiByZWZlcmVuY2VzICovIFtdLCBhc3Quc291cmNlU3BhbiwgYXN0LnN0YXJ0U291cmNlU3BhbiwgYXN0LmVuZFNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHRBdHRyaWJ1dGUoYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZS52YWx1ZSwgYXR0cmlidXRlLnNvdXJjZVNwYW4sIHVuZGVmaW5lZCwgYXR0cmlidXRlLmkxOG4pO1xuICAgIH07XG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCkgeyByZXR1cm4gbmV3IFRleHQodGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTsgfTtcbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbikgeyByZXR1cm4gbnVsbDsgfTtcbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlKSB7IHJldHVybiBudWxsOyB9O1xuICAgIHJldHVybiBOb25CaW5kYWJsZVZpc2l0b3I7XG59KCkpO1xudmFyIE5PTl9CSU5EQUJMRV9WSVNJVE9SJDEgPSBuZXcgTm9uQmluZGFibGVWaXNpdG9yJDEoKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gL15kYXRhLS9pLnRlc3QoYXR0ck5hbWUpID8gYXR0ck5hbWUuc3Vic3RyaW5nKDUpIDogYXR0ck5hbWU7XG59XG5mdW5jdGlvbiBhZGRFdmVudHMoZXZlbnRzLCBib3VuZEV2ZW50cykge1xuICAgIGJvdW5kRXZlbnRzLnB1c2guYXBwbHkoYm91bmRFdmVudHMsIF9fc3ByZWFkKGV2ZW50cy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIEJvdW5kRXZlbnQuZnJvbVBhcnNlZEV2ZW50KGUpOyB9KSkpO1xufVxuZnVuY3Rpb24gaXNFbXB0eVRleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRleHQkMyAmJiBub2RlLnZhbHVlLnRyaW0oKS5sZW5ndGggPT0gMDtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgQ29tbWVudDtcbn1cbmZ1bmN0aW9uIHRleHRDb250ZW50cyhub2RlKSB7XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8ICEobm9kZS5jaGlsZHJlblswXSBpbnN0YW5jZW9mIFRleHQkMykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlblswXS52YWx1ZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUYWdUeXBlO1xuKGZ1bmN0aW9uIChUYWdUeXBlKSB7XG4gICAgVGFnVHlwZVtUYWdUeXBlW1wiRUxFTUVOVFwiXSA9IDBdID0gXCJFTEVNRU5UXCI7XG4gICAgVGFnVHlwZVtUYWdUeXBlW1wiVEVNUExBVEVcIl0gPSAxXSA9IFwiVEVNUExBVEVcIjtcbiAgICBUYWdUeXBlW1RhZ1R5cGVbXCJQUk9KRUNUSU9OXCJdID0gMl0gPSBcIlBST0pFQ1RJT05cIjtcbn0pKFRhZ1R5cGUgfHwgKFRhZ1R5cGUgPSB7fSkpO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gb2JqZWN0IHRoYXQgaXMgdXNlZCBhcyBhIHNoYXJlZCBzdGF0ZSBiZXR3ZWVuIHBhcmVudCBhbmQgYWxsIGNoaWxkIGNvbnRleHRzLlxuICovXG5mdW5jdGlvbiBzZXR1cFJlZ2lzdHJ5KCkge1xuICAgIHJldHVybiB7IGdldFVuaXF1ZUlkOiBnZXRTZXFOdW1iZXJHZW5lcmF0b3IoKSwgaWN1czogbmV3IE1hcCgpIH07XG59XG4vKipcbiAqIEkxOG5Db250ZXh0IGlzIGEgaGVscGVyIGNsYXNzIHdoaWNoIGtlZXBzIHRyYWNrIG9mIGFsbCBpMThuLXJlbGF0ZWQgYXNwZWN0c1xuICogKGFjY3VtdWxhdGVzIHBsYWNlaG9sZGVycywgYmluZGluZ3MsIGV0YykgYmV0d2VlbiBpMThuU3RhcnQgYW5kIGkxOG5FbmQgaW5zdHJ1Y3Rpb25zLlxuICpcbiAqIFdoZW4gd2UgZW50ZXIgYSBuZXN0ZWQgdGVtcGxhdGUsIHRoZSB0b3AtbGV2ZWwgY29udGV4dCBpcyBiZWluZyBwYXNzZWQgZG93blxuICogdG8gdGhlIG5lc3RlZCBjb21wb25lbnQsIHdoaWNoIHVzZXMgdGhpcyBjb250ZXh0IHRvIGdlbmVyYXRlIGEgY2hpbGQgaW5zdGFuY2VcbiAqIG9mIEkxOG5Db250ZXh0IGNsYXNzICh0byBoYW5kbGUgbmVzdGVkIHRlbXBsYXRlKSBhbmQgYXQgdGhlIGVuZCwgcmVjb25jaWxlcyBpdCBiYWNrXG4gKiB3aXRoIHRoZSBwYXJlbnQgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0gaW5kZXggSW5zdHJ1Y3Rpb24gaW5kZXggb2YgaTE4blN0YXJ0LCB3aGljaCBpbml0aWF0ZXMgdGhpcyBjb250ZXh0XG4gKiBAcGFyYW0gcmVmIFJlZmVyZW5jZSB0byBhIHRyYW5zbGF0aW9uIGNvbnN0IHRoYXQgcmVwcmVzZW50cyB0aGUgY29udGVudCBpZiB0aHVzIGNvbnRleHRcbiAqIEBwYXJhbSBsZXZlbCBOZXN0bmcgbGV2ZWwgZGVmaW5lZCBmb3IgY2hpbGQgY29udGV4dHNcbiAqIEBwYXJhbSB0ZW1wbGF0ZUluZGV4IEluc3RydWN0aW9uIGluZGV4IG9mIGEgdGVtcGxhdGUgd2hpY2ggdGhpcyBjb250ZXh0IGJlbG9uZ3MgdG9cbiAqIEBwYXJhbSBtZXRhIE1ldGEgaW5mb3JtYXRpb24gKGlkLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgZXRjKSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb250ZXh0XG4gKi9cbnZhciBJMThuQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJMThuQ29udGV4dChpbmRleCwgcmVmLCBsZXZlbCwgdGVtcGxhdGVJbmRleCwgbWV0YSwgcmVnaXN0cnkpIHtcbiAgICAgICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsgbGV2ZWwgPSAwOyB9XG4gICAgICAgIGlmICh0ZW1wbGF0ZUluZGV4ID09PSB2b2lkIDApIHsgdGVtcGxhdGVJbmRleCA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnJlZiA9IHJlZjtcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLnRlbXBsYXRlSW5kZXggPSB0ZW1wbGF0ZUluZGV4O1xuICAgICAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0gcmVnaXN0cnk7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmlzRW1pdHRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl91bnJlc29sdmVkQ3R4Q291bnQgPSAwO1xuICAgICAgICB0aGlzLl9yZWdpc3RyeSA9IHJlZ2lzdHJ5IHx8IHNldHVwUmVnaXN0cnkoKTtcbiAgICAgICAgdGhpcy5pZCA9IHRoaXMuX3JlZ2lzdHJ5LmdldFVuaXF1ZUlkKCk7XG4gICAgfVxuICAgIEkxOG5Db250ZXh0LnByb3RvdHlwZS5hcHBlbmRUYWcgPSBmdW5jdGlvbiAodHlwZSwgbm9kZSwgaW5kZXgsIGNsb3NlZCkge1xuICAgICAgICBpZiAobm9kZS5pc1ZvaWQgJiYgY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGlnbm9yZSBcImNsb3NlXCIgZm9yIHZvaWQgdGFnc1xuICAgICAgICB9XG4gICAgICAgIHZhciBwaCA9IG5vZGUuaXNWb2lkIHx8ICFjbG9zZWQgPyBub2RlLnN0YXJ0TmFtZSA6IG5vZGUuY2xvc2VOYW1lO1xuICAgICAgICB2YXIgY29udGVudCA9IHsgdHlwZTogdHlwZSwgaW5kZXg6IGluZGV4LCBjdHg6IHRoaXMuaWQsIGlzVm9pZDogbm9kZS5pc1ZvaWQsIGNsb3NlZDogY2xvc2VkIH07XG4gICAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyTWFwKHRoaXMucGxhY2Vob2xkZXJzLCBwaCwgY29udGVudCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSTE4bkNvbnRleHQucHJvdG90eXBlLCBcImljdXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JlZ2lzdHJ5LmljdXM7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJMThuQ29udGV4dC5wcm90b3R5cGUsIFwiaXNSb290XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmxldmVsID09PSAwOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSTE4bkNvbnRleHQucHJvdG90eXBlLCBcImlzUmVzb2x2ZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3VucmVzb2x2ZWRDdHhDb3VudCA9PT0gMDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgSTE4bkNvbnRleHQucHJvdG90eXBlLmdldFNlcmlhbGl6ZWRQbGFjZWhvbGRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlcywga2V5KSB7IHJldHVybiByZXN1bHQuc2V0KGtleSwgdmFsdWVzLm1hcChzZXJpYWxpemVQbGFjZWhvbGRlclZhbHVlKSk7IH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLy8gcHVibGljIEFQSSB0byBhY2N1bXVsYXRlIGkxOG4tcmVsYXRlZCBjb250ZW50XG4gICAgSTE4bkNvbnRleHQucHJvdG90eXBlLmFwcGVuZEJpbmRpbmcgPSBmdW5jdGlvbiAoYmluZGluZykgeyB0aGlzLmJpbmRpbmdzLmFkZChiaW5kaW5nKTsgfTtcbiAgICBJMThuQ29udGV4dC5wcm90b3R5cGUuYXBwZW5kSWN1ID0gZnVuY3Rpb24gKG5hbWUsIHJlZikge1xuICAgICAgICB1cGRhdGVQbGFjZWhvbGRlck1hcCh0aGlzLl9yZWdpc3RyeS5pY3VzLCBuYW1lLCByZWYpO1xuICAgIH07XG4gICAgSTE4bkNvbnRleHQucHJvdG90eXBlLmFwcGVuZEJvdW5kVGV4dCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwaHMgPSBhc3NlbWJsZUJvdW5kVGV4dFBsYWNlaG9sZGVycyhub2RlLCB0aGlzLmJpbmRpbmdzLnNpemUsIHRoaXMuaWQpO1xuICAgICAgICBwaHMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWVzLCBrZXkpIHsgcmV0dXJuIHVwZGF0ZVBsYWNlaG9sZGVyTWFwLmFwcGx5KHZvaWQgMCwgX19zcHJlYWQoW190aGlzLnBsYWNlaG9sZGVycywga2V5XSwgdmFsdWVzKSk7IH0pO1xuICAgIH07XG4gICAgSTE4bkNvbnRleHQucHJvdG90eXBlLmFwcGVuZFRlbXBsYXRlID0gZnVuY3Rpb24gKG5vZGUsIGluZGV4KSB7XG4gICAgICAgIC8vIGFkZCBvcGVuIGFuZCBjbG9zZSB0YWdzIGF0IHRoZSBzYW1lIHRpbWUsXG4gICAgICAgIC8vIHNpbmNlIHdlIHByb2Nlc3MgbmVzdGVkIHRlbXBsYXRlcyBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuYXBwZW5kVGFnKFRhZ1R5cGUuVEVNUExBVEUsIG5vZGUsIGluZGV4LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuYXBwZW5kVGFnKFRhZ1R5cGUuVEVNUExBVEUsIG5vZGUsIGluZGV4LCB0cnVlKTtcbiAgICAgICAgdGhpcy5fdW5yZXNvbHZlZEN0eENvdW50Kys7XG4gICAgfTtcbiAgICBJMThuQ29udGV4dC5wcm90b3R5cGUuYXBwZW5kRWxlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBpbmRleCwgY2xvc2VkKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kVGFnKFRhZ1R5cGUuRUxFTUVOVCwgbm9kZSwgaW5kZXgsIGNsb3NlZCk7XG4gICAgfTtcbiAgICBJMThuQ29udGV4dC5wcm90b3R5cGUuYXBwZW5kUHJvamVjdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBpbmRleCkge1xuICAgICAgICAvLyBhZGQgb3BlbiBhbmQgY2xvc2UgdGFncyBhdCB0aGUgc2FtZSB0aW1lLFxuICAgICAgICAvLyBzaW5jZSB3ZSBwcm9jZXNzIHByb2plY3RlZCBjb250ZW50IHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5hcHBlbmRUYWcoVGFnVHlwZS5QUk9KRUNUSU9OLCBub2RlLCBpbmRleCwgZmFsc2UpO1xuICAgICAgICB0aGlzLmFwcGVuZFRhZyhUYWdUeXBlLlBST0pFQ1RJT04sIG5vZGUsIGluZGV4LCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBpbnN0YW5jZSBvZiBhIGNoaWxkIGNvbnRleHQgYmFzZWQgb24gdGhlIHJvb3Qgb25lLFxuICAgICAqIHdoZW4gd2UgZW50ZXIgYSBuZXN0ZWQgdGVtcGxhdGUgd2l0aGluIEkxOG4gc2VjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCBJbnN0cnVjdGlvbiBpbmRleCBvZiBjb3JyZXNwb25kaW5nIGkxOG5TdGFydCwgd2hpY2ggaW5pdGlhdGVzIHRoaXMgY29udGV4dFxuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZUluZGV4IEluc3RydWN0aW9uIGluZGV4IG9mIGEgdGVtcGxhdGUgd2hpY2ggdGhpcyBjb250ZXh0IGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0gbWV0YSBNZXRhIGluZm9ybWF0aW9uIChpZCwgbWVhbmluZywgZGVzY3JpcHRpb24sIGV0YykgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29udGV4dFxuICAgICAqXG4gICAgICogQHJldHVybnMgSTE4bkNvbnRleHQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBJMThuQ29udGV4dC5wcm90b3R5cGUuZm9ya0NoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIChpbmRleCwgdGVtcGxhdGVJbmRleCwgbWV0YSkge1xuICAgICAgICByZXR1cm4gbmV3IEkxOG5Db250ZXh0KGluZGV4LCB0aGlzLnJlZiwgdGhpcy5sZXZlbCArIDEsIHRlbXBsYXRlSW5kZXgsIG1ldGEsIHRoaXMuX3JlZ2lzdHJ5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlY29uY2lsZXMgY2hpbGQgY29udGV4dCBpbnRvIHBhcmVudCBvbmUgb25jZSB0aGUgZW5kIG9mIHRoZSBpMThuIGJsb2NrIGlzIHJlYWNoZWQgKGkxOG5FbmQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRleHQgQ2hpbGQgSTE4bkNvbnRleHQgaW5zdGFuY2UgdG8gYmUgcmVjb25jaWxlZCB3aXRoIHBhcmVudCBjb250ZXh0LlxuICAgICAqL1xuICAgIEkxOG5Db250ZXh0LnByb3RvdHlwZS5yZWNvbmNpbGVDaGlsZENvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBzZXQgdGhlIHJpZ2h0IGNvbnRleHQgaWQgZm9yIG9wZW4gYW5kIGNsb3NlXG4gICAgICAgIC8vIHRlbXBsYXRlIHRhZ3MsIHNvIHdlIGNhbiB1c2UgaXQgYXMgc3ViLWJsb2NrIGlkc1xuICAgICAgICBbJ3N0YXJ0JywgJ2Nsb3NlJ10uZm9yRWFjaChmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjb250ZXh0Lm1ldGFbb3AgKyBcIk5hbWVcIl07XG4gICAgICAgICAgICB2YXIgcGhzID0gX3RoaXMucGxhY2Vob2xkZXJzLmdldChrZXkpIHx8IFtdO1xuICAgICAgICAgICAgdmFyIHRhZyA9IHBocy5maW5kKGZpbmRUZW1wbGF0ZUZuKF90aGlzLmlkLCBjb250ZXh0LnRlbXBsYXRlSW5kZXgpKTtcbiAgICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgICAgICB0YWcuY3R4ID0gY29udGV4dC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHJlY29uY2lsZSBwbGFjZWhvbGRlcnNcbiAgICAgICAgdmFyIGNoaWxkUGhzID0gY29udGV4dC5wbGFjZWhvbGRlcnM7XG4gICAgICAgIGNoaWxkUGhzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlcywga2V5KSB7XG4gICAgICAgICAgICB2YXIgcGhzID0gX3RoaXMucGxhY2Vob2xkZXJzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKCFwaHMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wbGFjZWhvbGRlcnMuc2V0KGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cnkgdG8gZmluZCBtYXRjaGluZyB0ZW1wbGF0ZS4uLlxuICAgICAgICAgICAgdmFyIHRtcGxJZHggPSBmaW5kSW5kZXgocGhzLCBmaW5kVGVtcGxhdGVGbihjb250ZXh0LmlkLCBjb250ZXh0LnRlbXBsYXRlSW5kZXgpKTtcbiAgICAgICAgICAgIGlmICh0bXBsSWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyAuLi4gaWYgZm91bmQgLSByZXBsYWNlIGl0IHdpdGggbmVzdGVkIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICB2YXIgaXNDbG9zZVRhZyA9IGtleS5zdGFydHNXaXRoKCdDTE9TRScpO1xuICAgICAgICAgICAgICAgIHZhciBpc1RlbXBsYXRlVGFnID0ga2V5LmVuZHNXaXRoKCdORy1URU1QTEFURScpO1xuICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgdGVtcGxhdGUncyBjb250ZW50IGlzIHBsYWNlZCBiZWZvcmUgb3IgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyZW50IHRlbXBsYXRlIHRhZywgZGVwZW5kaW5nIG9uIHRoZSBvcGVuL2Nsb3NlIGF0cnJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICBwaHMuc3BsaWNlLmFwcGx5KHBocywgX19zcHJlYWQoW3RtcGxJZHggKyAoaXNDbG9zZVRhZyA/IDAgOiAxKSwgMF0sIHZhbHVlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IGlzQ2xvc2VUYWcgPyB2YWx1ZXMubGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpZHhdLnRtcGwgPSBwaHNbdG1wbElkeF07XG4gICAgICAgICAgICAgICAgICAgIHBocy5zcGxpY2UuYXBwbHkocGhzLCBfX3NwcmVhZChbdG1wbElkeCwgMV0sIHZhbHVlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIC4uLiBvdGhlcndpc2UganVzdCBhcHBlbmQgY29udGVudCB0byBwbGFjZWhvbGRlciB2YWx1ZVxuICAgICAgICAgICAgICAgIHBocy5wdXNoLmFwcGx5KHBocywgX19zcHJlYWQodmFsdWVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5wbGFjZWhvbGRlcnMuc2V0KGtleSwgcGhzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VucmVzb2x2ZWRDdHhDb3VudC0tO1xuICAgIH07XG4gICAgcmV0dXJuIEkxOG5Db250ZXh0O1xufSgpKTtcbi8vXG4vLyBIZWxwZXIgbWV0aG9kc1xuLy9cbmZ1bmN0aW9uIHdyYXAoc3ltYm9sLCBpbmRleCwgY29udGV4dElkLCBjbG9zZWQpIHtcbiAgICB2YXIgc3RhdGUgPSBjbG9zZWQgPyAnLycgOiAnJztcbiAgICByZXR1cm4gd3JhcEkxOG5QbGFjZWhvbGRlcihcIlwiICsgc3RhdGUgKyBzeW1ib2wgKyBpbmRleCwgY29udGV4dElkKTtcbn1cbmZ1bmN0aW9uIHdyYXBUYWcoc3ltYm9sLCBfYSwgY2xvc2VkKSB7XG4gICAgdmFyIGluZGV4ID0gX2EuaW5kZXgsIGN0eCA9IF9hLmN0eCwgaXNWb2lkID0gX2EuaXNWb2lkO1xuICAgIHJldHVybiBpc1ZvaWQgPyB3cmFwKHN5bWJvbCwgaW5kZXgsIGN0eCkgKyB3cmFwKHN5bWJvbCwgaW5kZXgsIGN0eCwgdHJ1ZSkgOlxuICAgICAgICB3cmFwKHN5bWJvbCwgaW5kZXgsIGN0eCwgY2xvc2VkKTtcbn1cbmZ1bmN0aW9uIGZpbmRUZW1wbGF0ZUZuKGN0eCwgdGVtcGxhdGVJbmRleCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHR5cGVvZiB0b2tlbiA9PT0gJ29iamVjdCcgJiYgdG9rZW4udHlwZSA9PT0gVGFnVHlwZS5URU1QTEFURSAmJlxuICAgICAgICB0b2tlbi5pbmRleCA9PT0gdGVtcGxhdGVJbmRleCAmJiB0b2tlbi5jdHggPT09IGN0eDsgfTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVBsYWNlaG9sZGVyVmFsdWUodmFsdWUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhLCBjbG9zZWQpIHsgcmV0dXJuIHdyYXBUYWcoJyMnLCBkYXRhLCBjbG9zZWQpOyB9O1xuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBjbG9zZWQpIHsgcmV0dXJuIHdyYXBUYWcoJyonLCBkYXRhLCBjbG9zZWQpOyB9O1xuICAgIHZhciBwcm9qZWN0aW9uID0gZnVuY3Rpb24gKGRhdGEsIGNsb3NlZCkgeyByZXR1cm4gd3JhcFRhZygnIScsIGRhdGEsIGNsb3NlZCk7IH07XG4gICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgVGFnVHlwZS5FTEVNRU5UOlxuICAgICAgICAgICAgLy8gY2xvc2UgZWxlbWVudCB0YWdcbiAgICAgICAgICAgIGlmICh2YWx1ZS5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudCh2YWx1ZSwgdHJ1ZSkgKyAodmFsdWUudG1wbCA/IHRlbXBsYXRlKHZhbHVlLnRtcGwsIHRydWUpIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3BlbiBlbGVtZW50IHRhZyB0aGF0IGFsc28gaW5pdGlhdGVzIGEgdGVtcGxhdGVcbiAgICAgICAgICAgIGlmICh2YWx1ZS50bXBsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlKHZhbHVlLnRtcGwpICsgZWxlbWVudCh2YWx1ZSkgK1xuICAgICAgICAgICAgICAgICAgICAodmFsdWUuaXNWb2lkID8gdGVtcGxhdGUodmFsdWUudG1wbCwgdHJ1ZSkgOiAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgVGFnVHlwZS5URU1QTEFURTpcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZSh2YWx1ZSwgdmFsdWUuY2xvc2VkKTtcbiAgICAgICAgY2FzZSBUYWdUeXBlLlBST0pFQ1RJT046XG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdGlvbih2YWx1ZSwgdmFsdWUuY2xvc2VkKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVMgPSB7XG4gICAgJ0EnOiAnTElOSycsXG4gICAgJ0InOiAnQk9MRF9URVhUJyxcbiAgICAnQlInOiAnTElORV9CUkVBSycsXG4gICAgJ0VNJzogJ0VNUEhBU0lTRURfVEVYVCcsXG4gICAgJ0gxJzogJ0hFQURJTkdfTEVWRUwxJyxcbiAgICAnSDInOiAnSEVBRElOR19MRVZFTDInLFxuICAgICdIMyc6ICdIRUFESU5HX0xFVkVMMycsXG4gICAgJ0g0JzogJ0hFQURJTkdfTEVWRUw0JyxcbiAgICAnSDUnOiAnSEVBRElOR19MRVZFTDUnLFxuICAgICdINic6ICdIRUFESU5HX0xFVkVMNicsXG4gICAgJ0hSJzogJ0hPUklaT05UQUxfUlVMRScsXG4gICAgJ0knOiAnSVRBTElDX1RFWFQnLFxuICAgICdMSSc6ICdMSVNUX0lURU0nLFxuICAgICdMSU5LJzogJ01FRElBX0xJTksnLFxuICAgICdPTCc6ICdPUkRFUkVEX0xJU1QnLFxuICAgICdQJzogJ1BBUkFHUkFQSCcsXG4gICAgJ1EnOiAnUVVPVEFUSU9OJyxcbiAgICAnUyc6ICdTVFJJS0VUSFJPVUdIX1RFWFQnLFxuICAgICdTTUFMTCc6ICdTTUFMTF9URVhUJyxcbiAgICAnU1VCJzogJ1NVQlNUUklQVCcsXG4gICAgJ1NVUCc6ICdTVVBFUlNDUklQVCcsXG4gICAgJ1RCT0RZJzogJ1RBQkxFX0JPRFknLFxuICAgICdURCc6ICdUQUJMRV9DRUxMJyxcbiAgICAnVEZPT1QnOiAnVEFCTEVfRk9PVEVSJyxcbiAgICAnVEgnOiAnVEFCTEVfSEVBREVSX0NFTEwnLFxuICAgICdUSEVBRCc6ICdUQUJMRV9IRUFERVInLFxuICAgICdUUic6ICdUQUJMRV9ST1cnLFxuICAgICdUVCc6ICdNT05PU1BBQ0VEX1RFWFQnLFxuICAgICdVJzogJ1VOREVSTElORURfVEVYVCcsXG4gICAgJ1VMJzogJ1VOT1JERVJFRF9MSVNUJyxcbn07XG4vKipcbiAqIENyZWF0ZXMgdW5pcXVlIG5hbWVzIGZvciBwbGFjZWhvbGRlciB3aXRoIGRpZmZlcmVudCBjb250ZW50LlxuICpcbiAqIFJldHVybnMgdGhlIHNhbWUgcGxhY2Vob2xkZXIgbmFtZSB3aGVuIHRoZSBjb250ZW50IGlzIGlkZW50aWNhbC5cbiAqL1xudmFyIFBsYWNlaG9sZGVyUmVnaXN0cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGxhY2Vob2xkZXJSZWdpc3RyeSgpIHtcbiAgICAgICAgLy8gQ291bnQgdGhlIG9jY3VycmVuY2Ugb2YgdGhlIGJhc2UgbmFtZSB0b3AgZ2VuZXJhdGUgYSB1bmlxdWUgbmFtZVxuICAgICAgICB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHMgPSB7fTtcbiAgICAgICAgLy8gTWFwcyBzaWduYXR1cmUgdG8gcGxhY2Vob2xkZXIgbmFtZXNcbiAgICAgICAgdGhpcy5fc2lnbmF0dXJlVG9OYW1lID0ge307XG4gICAgfVxuICAgIFBsYWNlaG9sZGVyUmVnaXN0cnkucHJvdG90eXBlLmdldFN0YXJ0VGFnUGxhY2Vob2xkZXJOYW1lID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGlzVm9pZCkge1xuICAgICAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5faGFzaFRhZyh0YWcsIGF0dHJzLCBpc1ZvaWQpO1xuICAgICAgICBpZiAodGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXBwZXJUYWcgPSB0YWcudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdmFyIGJhc2VOYW1lID0gVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTW3VwcGVyVGFnXSB8fCBcIlRBR19cIiArIHVwcGVyVGFnO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuX2dlbmVyYXRlVW5pcXVlTmFtZShpc1ZvaWQgPyBiYXNlTmFtZSA6IFwiU1RBUlRfXCIgKyBiYXNlTmFtZSk7XG4gICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZSA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMuX2hhc2hDbG9zaW5nVGFnKHRhZyk7XG4gICAgICAgIGlmICh0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cHBlclRhZyA9IHRhZy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB2YXIgYmFzZU5hbWUgPSBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVNbdXBwZXJUYWddIHx8IFwiVEFHX1wiICsgdXBwZXJUYWc7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5fZ2VuZXJhdGVVbmlxdWVOYW1lKFwiQ0xPU0VfXCIgKyBiYXNlTmFtZSk7XG4gICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRQbGFjZWhvbGRlck5hbWUgPSBmdW5jdGlvbiAobmFtZSwgY29udGVudCkge1xuICAgICAgICB2YXIgdXBwZXJOYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB2YXIgc2lnbmF0dXJlID0gXCJQSDogXCIgKyB1cHBlck5hbWUgKyBcIj1cIiArIGNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1bmlxdWVOYW1lID0gdGhpcy5fZ2VuZXJhdGVVbmlxdWVOYW1lKHVwcGVyTmFtZSk7XG4gICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdID0gdW5pcXVlTmFtZTtcbiAgICAgICAgcmV0dXJuIHVuaXF1ZU5hbWU7XG4gICAgfTtcbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRVbmlxdWVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUobmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9O1xuICAgIC8vIEdlbmVyYXRlIGEgaGFzaCBmb3IgYSB0YWcgLSBkb2VzIG5vdCB0YWtlIGF0dHJpYnV0ZSBvcmRlciBpbnRvIGFjY291bnRcbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5faGFzaFRhZyA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBpc1ZvaWQpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gXCI8XCIgKyB0YWc7XG4gICAgICAgIHZhciBzdHJBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKS5zb3J0KCkubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBcIiBcIiArIG5hbWUgKyBcIj1cIiArIGF0dHJzW25hbWVdOyB9KS5qb2luKCcnKTtcbiAgICAgICAgdmFyIGVuZCA9IGlzVm9pZCA/ICcvPicgOiBcIj48L1wiICsgdGFnICsgXCI+XCI7XG4gICAgICAgIHJldHVybiBzdGFydCArIHN0ckF0dHJzICsgZW5kO1xuICAgIH07XG4gICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuX2hhc2hDbG9zaW5nVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGhpcy5faGFzaFRhZyhcIi9cIiArIHRhZywge30sIGZhbHNlKTsgfTtcbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5fZ2VuZXJhdGVVbmlxdWVOYW1lID0gZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgdmFyIHNlZW4gPSB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHMuaGFzT3duUHJvcGVydHkoYmFzZSk7XG4gICAgICAgIGlmICghc2Vlbikge1xuICAgICAgICAgICAgdGhpcy5fcGxhY2VIb2xkZXJOYW1lQ291bnRzW2Jhc2VdID0gMTtcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZCA9IHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50c1tiYXNlXTtcbiAgICAgICAgdGhpcy5fcGxhY2VIb2xkZXJOYW1lQ291bnRzW2Jhc2VdID0gaWQgKyAxO1xuICAgICAgICByZXR1cm4gYmFzZSArIFwiX1wiICsgaWQ7XG4gICAgfTtcbiAgICByZXR1cm4gUGxhY2Vob2xkZXJSZWdpc3RyeTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfZXhwUGFyc2VyID0gbmV3IFBhcnNlciQxKG5ldyBMZXhlcigpKTtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIGNvbnZlcnRpbmcgaHRtbCBub2RlcyB0byBhbiBpMThuIE1lc3NhZ2UgZ2l2ZW4gYW4gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICovXG5mdW5jdGlvbiBjcmVhdGVJMThuTWVzc2FnZUZhY3RvcnkoaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgIHZhciB2aXNpdG9yID0gbmV3IF9JMThuVmlzaXRvcihfZXhwUGFyc2VyLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGVzLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQsIHZpc2l0Tm9kZUZuKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnRvSTE4bk1lc3NhZ2Uobm9kZXMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCwgdmlzaXROb2RlRm4pO1xuICAgIH07XG59XG52YXIgX0kxOG5WaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9JMThuVmlzaXRvcihfZXhwcmVzc2lvblBhcnNlciwgX2ludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdGhpcy5fZXhwcmVzc2lvblBhcnNlciA9IF9leHByZXNzaW9uUGFyc2VyO1xuICAgICAgICB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnID0gX2ludGVycG9sYXRpb25Db25maWc7XG4gICAgfVxuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudG9JMThuTWVzc2FnZSA9IGZ1bmN0aW9uIChub2RlcywgbWVhbmluZywgZGVzY3JpcHRpb24sIGlkLCB2aXNpdE5vZGVGbikge1xuICAgICAgICB0aGlzLl9pc0ljdSA9IG5vZGVzLmxlbmd0aCA9PSAxICYmIG5vZGVzWzBdIGluc3RhbmNlb2YgRXhwYW5zaW9uO1xuICAgICAgICB0aGlzLl9pY3VEZXB0aCA9IDA7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyUmVnaXN0cnkgPSBuZXcgUGxhY2Vob2xkZXJSZWdpc3RyeSgpO1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudCA9IHt9O1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvTWVzc2FnZSA9IHt9O1xuICAgICAgICB0aGlzLl92aXNpdE5vZGVGbiA9IHZpc2l0Tm9kZUZuO1xuICAgICAgICB2YXIgaTE4bm9kZXMgPSB2aXNpdEFsbCQxKHRoaXMsIG5vZGVzLCB7fSk7XG4gICAgICAgIHJldHVybiBuZXcgTWVzc2FnZShpMThub2RlcywgdGhpcy5fcGxhY2Vob2xkZXJUb0NvbnRlbnQsIHRoaXMuX3BsYWNlaG9sZGVyVG9NZXNzYWdlLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQpO1xuICAgIH07XG4gICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS5fdmlzaXROb2RlID0gZnVuY3Rpb24gKGh0bWwsIGkxOG4pIHtcbiAgICAgICAgaWYgKHRoaXMuX3Zpc2l0Tm9kZUZuKSB7XG4gICAgICAgICAgICB0aGlzLl92aXNpdE5vZGVGbihodG1sLCBpMThuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTE4bjtcbiAgICB9O1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHZpc2l0QWxsJDEodGhpcywgZWwuY2hpbGRyZW4pO1xuICAgICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgICAgZWwuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgLy8gRG8gbm90IHZpc2l0IHRoZSBhdHRyaWJ1dGVzLCB0cmFuc2xhdGFibGUgb25lcyBhcmUgdG9wLWxldmVsIEFTVHNcbiAgICAgICAgICAgIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlzVm9pZCA9IGdldEh0bWxUYWdEZWZpbml0aW9uKGVsLm5hbWUpLmlzVm9pZDtcbiAgICAgICAgdmFyIHN0YXJ0UGhOYW1lID0gdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRTdGFydFRhZ1BsYWNlaG9sZGVyTmFtZShlbC5uYW1lLCBhdHRycywgaXNWb2lkKTtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJUb0NvbnRlbnRbc3RhcnRQaE5hbWVdID0gZWwuc291cmNlU3Bhbi50b1N0cmluZygpO1xuICAgICAgICB2YXIgY2xvc2VQaE5hbWUgPSAnJztcbiAgICAgICAgaWYgKCFpc1ZvaWQpIHtcbiAgICAgICAgICAgIGNsb3NlUGhOYW1lID0gdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZShlbC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50W2Nsb3NlUGhOYW1lXSA9IFwiPC9cIiArIGVsLm5hbWUgKyBcIj5cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IG5ldyBUYWdQbGFjZWhvbGRlcihlbC5uYW1lLCBhdHRycywgc3RhcnRQaE5hbWUsIGNsb3NlUGhOYW1lLCBjaGlsZHJlbiwgaXNWb2lkLCBlbC5zb3VyY2VTcGFuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0Tm9kZShlbCwgbm9kZSk7XG4gICAgfTtcbiAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uKGF0dHJpYnV0ZS52YWx1ZSwgYXR0cmlidXRlLnNvdXJjZVNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXROb2RlKGF0dHJpYnV0ZSwgbm9kZSk7XG4gICAgfTtcbiAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24odGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0Tm9kZSh0ZXh0LCBub2RlKTtcbiAgICB9O1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5faWN1RGVwdGgrKztcbiAgICAgICAgdmFyIGkxOG5JY3VDYXNlcyA9IHt9O1xuICAgICAgICB2YXIgaTE4bkljdSA9IG5ldyBJY3UkMShpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBpMThuSWN1Q2FzZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgaWN1LmNhc2VzLmZvckVhY2goZnVuY3Rpb24gKGNhemUpIHtcbiAgICAgICAgICAgIGkxOG5JY3VDYXNlc1tjYXplLnZhbHVlXSA9IG5ldyBDb250YWluZXIoY2F6ZS5leHByZXNzaW9uLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcywge30pOyB9KSwgY2F6ZS5leHBTb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2ljdURlcHRoLS07XG4gICAgICAgIGlmICh0aGlzLl9pc0ljdSB8fCB0aGlzLl9pY3VEZXB0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgYW4gSUNVIG5vZGUgd2hlbjpcbiAgICAgICAgICAgIC8vIC0gdGhlIG1lc3NhZ2UgKHZzIGEgcGFydCBvZiB0aGUgbWVzc2FnZSkgaXMgYW4gSUNVIG1lc3NhZ2UsIG9yXG4gICAgICAgICAgICAvLyAtIHRoZSBJQ1UgbWVzc2FnZSBpcyBuZXN0ZWQuXG4gICAgICAgICAgICB2YXIgZXhwUGggPSB0aGlzLl9wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldFVuaXF1ZVBsYWNlaG9sZGVyKFwiVkFSX1wiICsgaWN1LnR5cGUpO1xuICAgICAgICAgICAgaTE4bkljdS5leHByZXNzaW9uUGxhY2Vob2xkZXIgPSBleHBQaDtcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50W2V4cFBoXSA9IGljdS5zd2l0Y2hWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aXNpdE5vZGUoaWN1LCBpMThuSWN1KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbHNlIHJldHVybnMgYSBwbGFjZWhvbGRlclxuICAgICAgICAvLyBJQ1UgcGxhY2Vob2xkZXJzIHNob3VsZCBub3QgYmUgcmVwbGFjZWQgd2l0aCB0aGVpciBvcmlnaW5hbCBjb250ZW50IGJ1dCB3aXRoIHRoZSB0aGVpclxuICAgICAgICAvLyB0cmFuc2xhdGlvbnMuIFdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IHZpc2l0b3IgKHRoZXkgYXJlIG5vdCByZS1lbnRyYW50KSB0byBjb21wdXRlIHRoZVxuICAgICAgICAvLyBtZXNzYWdlIGlkLlxuICAgICAgICAvLyBUT0RPKHZpY2IpOiBhZGQgYSBodG1sLk5vZGUgLT4gaTE4bi5NZXNzYWdlIGNhY2hlIHRvIGF2b2lkIGhhdmluZyB0byByZS1jcmVhdGUgdGhlIG1zZ1xuICAgICAgICB2YXIgcGhOYW1lID0gdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRQbGFjZWhvbGRlck5hbWUoJ0lDVScsIGljdS5zb3VyY2VTcGFuLnRvU3RyaW5nKCkpO1xuICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBfSTE4blZpc2l0b3IodGhpcy5fZXhwcmVzc2lvblBhcnNlciwgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9NZXNzYWdlW3BoTmFtZV0gPSB2aXNpdG9yLnRvSTE4bk1lc3NhZ2UoW2ljdV0sICcnLCAnJywgJycpO1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBJY3VQbGFjZWhvbGRlcihpMThuSWN1LCBwaE5hbWUsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0Tm9kZShpY3UsIG5vZGUpO1xuICAgIH07XG4gICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoaWN1Q2FzZSwgY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICB9O1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHRleHQsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIHNwbGl0SW50ZXJwb2xhdGlvbiA9IHRoaXMuX2V4cHJlc3Npb25QYXJzZXIuc3BsaXRJbnRlcnBvbGF0aW9uKHRleHQsIHNvdXJjZVNwYW4uc3RhcnQudG9TdHJpbmcoKSwgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIGlmICghc3BsaXRJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAvLyBObyBleHByZXNzaW9uLCByZXR1cm4gYSBzaW5nbGUgdGV4dFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0JDEodGV4dCwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGEgZ3JvdXAgb2YgdGV4dCArIGV4cHJlc3Npb25zXG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbmV3IENvbnRhaW5lcihub2Rlcywgc291cmNlU3Bhbik7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX2ludGVycG9sYXRpb25Db25maWcsIHNEZWxpbWl0ZXIgPSBfYS5zdGFydCwgZURlbGltaXRlciA9IF9hLmVuZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGxpdEludGVycG9sYXRpb24uc3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gc3BsaXRJbnRlcnBvbGF0aW9uLmV4cHJlc3Npb25zW2ldO1xuICAgICAgICAgICAgdmFyIGJhc2VOYW1lID0gX2V4dHJhY3RQbGFjZWhvbGRlck5hbWUoZXhwcmVzc2lvbikgfHwgJ0lOVEVSUE9MQVRJT04nO1xuICAgICAgICAgICAgdmFyIHBoTmFtZSA9IHRoaXMuX3BsYWNlaG9sZGVyUmVnaXN0cnkuZ2V0UGxhY2Vob2xkZXJOYW1lKGJhc2VOYW1lLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChzcGxpdEludGVycG9sYXRpb24uc3RyaW5nc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGFkZCBlbXB0eSBzdHJpbmdzXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQxKHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzW2ldLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBQbGFjZWhvbGRlcihleHByZXNzaW9uLCBwaE5hbWUsIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50W3BoTmFtZV0gPSBzRGVsaW1pdGVyICsgZXhwcmVzc2lvbiArIGVEZWxpbWl0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGxhc3QgaW5kZXggY29udGFpbnMgbm8gZXhwcmVzc2lvblxuICAgICAgICB2YXIgbGFzdFN0cmluZ0lkeCA9IHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChzcGxpdEludGVycG9sYXRpb24uc3RyaW5nc1tsYXN0U3RyaW5nSWR4XS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IFRleHQkMShzcGxpdEludGVycG9sYXRpb24uc3RyaW5nc1tsYXN0U3RyaW5nSWR4XSwgc291cmNlU3BhbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfTtcbiAgICByZXR1cm4gX0kxOG5WaXNpdG9yO1xufSgpKTtcbnZhciBfQ1VTVE9NX1BIX0VYUCA9IC9cXC9cXC9bXFxzXFxTXSppMThuW1xcc1xcU10qXFwoW1xcc1xcU10qcGhbXFxzXFxTXSo9W1xcc1xcU10qKFwifCcpKFtcXHNcXFNdKj8pXFwxW1xcc1xcU10qXFwpL2c7XG5mdW5jdGlvbiBfZXh0cmFjdFBsYWNlaG9sZGVyTmFtZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5zcGxpdChfQ1VTVE9NX1BIX0VYUClbMl07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIHNldEkxOG5SZWZzKGh0bWwsIGkxOG4pIHtcbiAgICBodG1sLmkxOG4gPSBpMThuO1xufVxuLyoqXG4gKiBUaGlzIHZpc2l0b3Igd2Fsa3Mgb3ZlciBIVE1MIHBhcnNlIHRyZWUgYW5kIGNvbnZlcnRzIGluZm9ybWF0aW9uIHN0b3JlZCBpblxuICogaTE4bi1yZWxhdGVkIGF0dHJpYnV0ZXMgKFwiaTE4blwiIGFuZCBcImkxOG4tKlwiKSBpbnRvIGkxOG4gbWV0YSBvYmplY3QgdGhhdCBpc1xuICogc3RvcmVkIHdpdGggb3RoZXIgZWxlbWVudCdzIGFuZCBhdHRyaWJ1dGUncyBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIEkxOG5NZXRhVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJMThuTWV0YVZpc2l0b3IoaW50ZXJwb2xhdGlvbkNvbmZpZywga2VlcEkxOG5BdHRycykge1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIGlmIChrZWVwSTE4bkF0dHJzID09PSB2b2lkIDApIHsga2VlcEkxOG5BdHRycyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbkNvbmZpZyA9IGludGVycG9sYXRpb25Db25maWc7XG4gICAgICAgIHRoaXMua2VlcEkxOG5BdHRycyA9IGtlZXBJMThuQXR0cnM7XG4gICAgICAgIC8vIGkxOG4gbWVzc2FnZSBnZW5lcmF0aW9uIGZhY3RvcnlcbiAgICAgICAgdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UgPSBjcmVhdGVJMThuTWVzc2FnZUZhY3RvcnkoaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIEkxOG5NZXRhVmlzaXRvci5wcm90b3R5cGUuX2dlbmVyYXRlSTE4bk1lc3NhZ2UgPSBmdW5jdGlvbiAobm9kZXMsIG1ldGEsIHZpc2l0Tm9kZUZuKSB7XG4gICAgICAgIGlmIChtZXRhID09PSB2b2lkIDApIHsgbWV0YSA9ICcnOyB9XG4gICAgICAgIHZhciBwYXJzZWQgPSB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgPyBwYXJzZUkxOG5NZXRhKG1ldGEpIDogbWV0YUZyb21JMThuTWVzc2FnZShtZXRhKTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLl9jcmVhdGVJMThuTWVzc2FnZShub2RlcywgcGFyc2VkLm1lYW5pbmcgfHwgJycsIHBhcnNlZC5kZXNjcmlwdGlvbiB8fCAnJywgcGFyc2VkLmlkIHx8ICcnLCB2aXNpdE5vZGVGbik7XG4gICAgICAgIGlmICghbWVzc2FnZS5pZCkge1xuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgKG9yIHJlc3RvcmUpIG1lc3NhZ2UgaWQgaWYgbm90IHNwZWNpZmllZCBpbiB0ZW1wbGF0ZVxuICAgICAgICAgICAgbWVzc2FnZS5pZCA9IHR5cGVvZiBtZXRhICE9PSAnc3RyaW5nJyAmJiBtZXRhLmlkIHx8IGRlY2ltYWxEaWdlc3QobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcbiAgICBJMThuTWV0YVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iO1xuICAgICAgICBpZiAoaGFzSTE4bkF0dHJzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBhdHRyc01ldGEgPSB7fTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhlbGVtZW50LmF0dHJzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ci5uYW1lID09PSBJMThOX0FUVFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvb3QgJ2kxOG4nIG5vZGUgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaTE4bl8xID0gZWxlbWVudC5pMThuIHx8IGF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuX2dlbmVyYXRlSTE4bk1lc3NhZ2UoZWxlbWVudC5jaGlsZHJlbiwgaTE4bl8xLCBzZXRJMThuUmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgYXNzaWduIGVtcHR5IGkxOG4gbWV0YVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pMThuID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUuc3RhcnRzV2l0aChJMThOX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ2kxOG4tKicgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGF0dHIubmFtZS5zbGljZShJMThOX0FUVFJfUFJFRklYLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyc01ldGFba2V5XSA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub24taTE4biBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRycy5wdXNoKGF0dHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IGkxOG4gbWV0YSBmb3IgYXR0cmlidXRlc1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJzTWV0YSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYXR0cnNfMSA9IF9fdmFsdWVzKGF0dHJzKSwgYXR0cnNfMV8xID0gYXR0cnNfMS5uZXh0KCk7ICFhdHRyc18xXzEuZG9uZTsgYXR0cnNfMV8xID0gYXR0cnNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gYXR0cnNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGEgPSBhdHRyc01ldGFbYXR0ci5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBjcmVhdGUgdHJhbnNsYXRpb24gZm9yIGVtcHR5IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhICE9PSB1bmRlZmluZWQgJiYgYXR0ci52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIuaTE4biA9IHRoaXMuX2dlbmVyYXRlSTE4bk1lc3NhZ2UoW2F0dHJdLCBhdHRyLmkxOG4gfHwgbWV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyc18xXzEgJiYgIWF0dHJzXzFfMS5kb25lICYmIChfYiA9IGF0dHJzXzEucmV0dXJuKSkgX2IuY2FsbChhdHRyc18xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmtlZXBJMThuQXR0cnMpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZWxlbWVudCdzIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8ga2VlcGluZyBvbmx5IG5vbi1pMThuIHJlbGF0ZWQgb25lc1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cnMgPSBhdHRycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuICAgIEkxOG5NZXRhVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoZXhwYW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICB2YXIgbWV0YSA9IGV4cGFuc2lvbi5pMThuO1xuICAgICAgICBpZiAobWV0YSBpbnN0YW5jZW9mIEljdVBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAvLyBzZXQgSUNVIHBsYWNlaG9sZGVyIG5hbWUgKGUuZy4gXCJJQ1VfMVwiKSxcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlZCB3aGlsZSBwcm9jZXNzaW5nIHJvb3QgZWxlbWVudCBjb250ZW50cyxcbiAgICAgICAgICAgIC8vIHNvIHdlIGNhbiByZWZlcmVuY2UgaXQgd2hlbiB3ZSBvdXRwdXQgdHJhbnNsYXRpb25cbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBtZXRhLm5hbWU7XG4gICAgICAgICAgICBtZXNzYWdlID0gdGhpcy5fZ2VuZXJhdGVJMThuTWVzc2FnZShbZXhwYW5zaW9uXSwgbWV0YSk7XG4gICAgICAgICAgICB2YXIgaWN1ID0gaWN1RnJvbUkxOG5NZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWN1Lm5hbWUgPSBuYW1lXzE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3aGVuIElDVSBpcyBhIHJvb3QgbGV2ZWwgdHJhbnNsYXRpb25cbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLl9nZW5lcmF0ZUkxOG5NZXNzYWdlKFtleHBhbnNpb25dLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBleHBhbnNpb24uaTE4biA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBleHBhbnNpb247XG4gICAgfTtcbiAgICBJMThuTWV0YVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiB0ZXh0OyB9O1xuICAgIEkxOG5NZXRhVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IHJldHVybiBhdHRyaWJ1dGU7IH07XG4gICAgSTE4bk1ldGFWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyByZXR1cm4gY29tbWVudDsgfTtcbiAgICBJMThuTWV0YVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7IHJldHVybiBleHBhbnNpb25DYXNlOyB9O1xuICAgIHJldHVybiBJMThuTWV0YVZpc2l0b3I7XG59KCkpO1xuZnVuY3Rpb24gcHJvY2Vzc0kxOG5NZXRhKGh0bWxBc3RXaXRoRXJyb3JzLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHZpc2l0QWxsJDEobmV3IEkxOG5NZXRhVmlzaXRvcihpbnRlcnBvbGF0aW9uQ29uZmlnLCAvKiBrZWVwSTE4bkF0dHJzICovIGZhbHNlKSwgaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzKSwgaHRtbEFzdFdpdGhFcnJvcnMuZXJyb3JzKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBUaGlzIHZpc2l0b3Igd2Fsa3Mgb3ZlciBpMThuIHRyZWUgYW5kIGdlbmVyYXRlcyBpdHMgc3RyaW5nIHJlcHJlc2VudGF0aW9uLCBpbmNsdWRpbmcgSUNVcyBhbmRcbiAqIHBsYWNlaG9sZGVycyBpbiBgeyRwbGFjZWhvbGRlcn1gIChmb3IgcGxhaW4gbWVzc2FnZXMpIG9yIGB7UExBQ0VIT0xERVJ9YCAoaW5zaWRlIElDVXMpIGZvcm1hdC5cbiAqL1xudmFyIFNlcmlhbGl6ZXJWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcmlhbGl6ZXJWaXNpdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgSUNVIG5lc3RpbmcgbGV2ZWwsIGFsbG93aW5nIHRvIGRldGVjdCB0aGF0IHdlIGFyZSBwcm9jZXNzaW5nIGVsZW1lbnRzIG9mIGFuIElDVS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBuZWVkZWQgZHVlIHRvIHRoZSBmYWN0IHRoYXQgcGxhY2Vob2xkZXJzIGluIElDVXMgYW5kIGluIG90aGVyIG1lc3NhZ2VzIGFyZSByZXByZXNlbnRlZFxuICAgICAgICAgKiBkaWZmZXJlbnRseSBpbiBDbG9zdXJlOlxuICAgICAgICAgKiAtIHskcGxhY2Vob2xkZXJ9IGluIG5vbi1JQ1UgY2FzZVxuICAgICAgICAgKiAtIHtQTEFDRUhPTERFUn0gaW5zaWRlIElDVVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pY3VOZXN0aW5nTGV2ZWwgPSAwO1xuICAgIH1cbiAgICBTZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUuZm9ybWF0UGggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGlzSW5zaWRlSWN1ID0gdGhpcy5pY3VOZXN0aW5nTGV2ZWwgPiAwO1xuICAgICAgICB2YXIgZm9ybWF0dGVkID0gZm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZSh2YWx1ZSwgLyogdXNlQ2FtZWxDYXNlICovICFpc0luc2lkZUljdSk7XG4gICAgICAgIHJldHVybiBpc0luc2lkZUljdSA/IFwie1wiICsgZm9ybWF0dGVkICsgXCJ9XCIgOiBcInskXCIgKyBmb3JtYXR0ZWQgKyBcIn1cIjtcbiAgICB9O1xuICAgIFNlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gdGV4dC52YWx1ZTsgfTtcbiAgICBTZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMpOyB9KS5qb2luKCcnKTtcbiAgICB9O1xuICAgIFNlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pY3VOZXN0aW5nTGV2ZWwrKztcbiAgICAgICAgdmFyIHN0ckNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGsgKyBcIiB7XCIgKyBpY3UuY2FzZXNba10udmlzaXQoX3RoaXMpICsgXCJ9XCI7IH0pO1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJ7XCIgKyBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIgKyBzdHJDYXNlcy5qb2luKCcgJykgKyBcIn1cIjtcbiAgICAgICAgdGhpcy5pY3VOZXN0aW5nTGV2ZWwtLTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFNlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBwaC5pc1ZvaWQgP1xuICAgICAgICAgICAgdGhpcy5mb3JtYXRQaChwaC5zdGFydE5hbWUpIDpcbiAgICAgICAgICAgIFwiXCIgKyB0aGlzLmZvcm1hdFBoKHBoLnN0YXJ0TmFtZSkgKyBwaC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC52aXNpdChfdGhpcyk7IH0pLmpvaW4oJycpICsgdGhpcy5mb3JtYXRQaChwaC5jbG9zZU5hbWUpO1xuICAgIH07XG4gICAgU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHsgcmV0dXJuIHRoaXMuZm9ybWF0UGgocGgubmFtZSk7IH07XG4gICAgU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0UGgocGgubmFtZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VyaWFsaXplclZpc2l0b3I7XG59KCkpO1xudmFyIHNlcmlhbGl6ZXJWaXNpdG9yJDEgPSBuZXcgU2VyaWFsaXplclZpc2l0b3IoKTtcbmZ1bmN0aW9uIGdldFNlcmlhbGl6ZWRJMThuQ29udGVudChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2Uubm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KHNlcmlhbGl6ZXJWaXNpdG9yJDEsIG51bGwpOyB9KS5qb2luKCcnKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gU2VsZWN0b3IgYXR0cmlidXRlIG5hbWUgb2YgYDxuZy1jb250ZW50PmBcbnZhciBOR19DT05URU5UX1NFTEVDVF9BVFRSJDEgPSAnc2VsZWN0Jztcbi8vIEF0dHJpYnV0ZSBuYW1lIG9mIGBuZ1Byb2plY3RBc2AuXG52YXIgTkdfUFJPSkVDVF9BU19BVFRSX05BTUUgPSAnbmdQcm9qZWN0QXMnO1xuLy8gTGlzdCBvZiBzdXBwb3J0ZWQgZ2xvYmFsIHRhcmdldHMgZm9yIGV2ZW50IGxpc3RlbmVyc1xudmFyIEdMT0JBTF9UQVJHRVRfUkVTT0xWRVJTID0gbmV3IE1hcChbWyd3aW5kb3cnLCBJZGVudGlmaWVycyQxLnJlc29sdmVXaW5kb3ddLCBbJ2RvY3VtZW50JywgSWRlbnRpZmllcnMkMS5yZXNvbHZlRG9jdW1lbnRdLCBbJ2JvZHknLCBJZGVudGlmaWVycyQxLnJlc29sdmVCb2R5XV0pO1xudmFyIExFQURJTkdfVFJJVklBX0NIQVJTID0gWycgJywgJ1xcbicsICdcXHInLCAnXFx0J107XG4vLyAgaWYgKHJmICYgZmxhZ3MpIHsgLi4gfVxuZnVuY3Rpb24gcmVuZGVyRmxhZ0NoZWNrSWZTdG10KGZsYWdzLCBzdGF0ZW1lbnRzKSB7XG4gICAgcmV0dXJuIGlmU3RtdCh2YXJpYWJsZShSRU5ERVJfRkxBR1MpLmJpdHdpc2VBbmQobGl0ZXJhbChmbGFncyksIG51bGwsIGZhbHNlKSwgc3RhdGVtZW50cyk7XG59XG5mdW5jdGlvbiBwcmVwYXJlRXZlbnRMaXN0ZW5lclBhcmFtZXRlcnMoZXZlbnRBc3QsIGhhbmRsZXJOYW1lLCBzY29wZSkge1xuICAgIGlmIChoYW5kbGVyTmFtZSA9PT0gdm9pZCAwKSB7IGhhbmRsZXJOYW1lID0gbnVsbDsgfVxuICAgIGlmIChzY29wZSA9PT0gdm9pZCAwKSB7IHNjb3BlID0gbnVsbDsgfVxuICAgIHZhciB0eXBlID0gZXZlbnRBc3QudHlwZSwgbmFtZSA9IGV2ZW50QXN0Lm5hbWUsIHRhcmdldCA9IGV2ZW50QXN0LnRhcmdldCwgcGhhc2UgPSBldmVudEFzdC5waGFzZSwgaGFuZGxlciA9IGV2ZW50QXN0LmhhbmRsZXI7XG4gICAgaWYgKHRhcmdldCAmJiAhR0xPQkFMX1RBUkdFVF9SRVNPTFZFUlMuaGFzKHRhcmdldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBnbG9iYWwgdGFyZ2V0ICdcIiArIHRhcmdldCArIFwiJyBkZWZpbmVkIGZvciAnXCIgKyBuYW1lICsgXCInIGV2ZW50LlxcbiAgICAgICAgU3VwcG9ydGVkIGxpc3Qgb2YgZ2xvYmFsIHRhcmdldHM6IFwiICsgQXJyYXkuZnJvbShHTE9CQUxfVEFSR0VUX1JFU09MVkVSUy5rZXlzKCkpICsgXCIuXCIpO1xuICAgIH1cbiAgICB2YXIgaW1wbGljaXRSZWNlaXZlckV4cHIgPSAoc2NvcGUgPT09IG51bGwgfHwgc2NvcGUuYmluZGluZ0xldmVsID09PSAwKSA/XG4gICAgICAgIHZhcmlhYmxlKENPTlRFWFRfTkFNRSkgOlxuICAgICAgICBzY29wZS5nZXRPckNyZWF0ZVNoYXJlZENvbnRleHRWYXIoMCk7XG4gICAgdmFyIGJpbmRpbmdFeHByID0gY29udmVydEFjdGlvbkJpbmRpbmcoc2NvcGUsIGltcGxpY2l0UmVjZWl2ZXJFeHByLCBoYW5kbGVyLCAnYicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yKCdVbmV4cGVjdGVkIGludGVycG9sYXRpb24nKTsgfSwgZXZlbnRBc3QuaGFuZGxlclNwYW4pO1xuICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICAgIHN0YXRlbWVudHMucHVzaC5hcHBseShzdGF0ZW1lbnRzLCBfX3NwcmVhZChzY29wZS5yZXN0b3JlVmlld1N0YXRlbWVudCgpKSk7XG4gICAgICAgIHN0YXRlbWVudHMucHVzaC5hcHBseShzdGF0ZW1lbnRzLCBfX3NwcmVhZChzY29wZS52YXJpYWJsZURlY2xhcmF0aW9ucygpKSk7XG4gICAgfVxuICAgIHN0YXRlbWVudHMucHVzaC5hcHBseShzdGF0ZW1lbnRzLCBfX3NwcmVhZChiaW5kaW5nRXhwci5yZW5kZXIzU3RtdHMpKTtcbiAgICB2YXIgZXZlbnROYW1lID0gdHlwZSA9PT0gMSAvKiBBbmltYXRpb24gKi8gPyBwcmVwYXJlU3ludGhldGljTGlzdGVuZXJOYW1lKG5hbWUsIHBoYXNlKSA6IG5hbWU7XG4gICAgdmFyIGZuTmFtZSA9IGhhbmRsZXJOYW1lICYmIHNhbml0aXplSWRlbnRpZmllcihoYW5kbGVyTmFtZSk7XG4gICAgdmFyIGZuQXJncyA9IFtuZXcgRm5QYXJhbSgnJGV2ZW50JywgRFlOQU1JQ19UWVBFKV07XG4gICAgdmFyIGhhbmRsZXJGbiA9IGZuKGZuQXJncywgc3RhdGVtZW50cywgSU5GRVJSRURfVFlQRSwgbnVsbCwgZm5OYW1lKTtcbiAgICB2YXIgcGFyYW1zID0gW2xpdGVyYWwoZXZlbnROYW1lKSwgaGFuZGxlckZuXTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKGxpdGVyYWwoZmFsc2UpLCAvLyBgdXNlQ2FwdHVyZWAgZmxhZywgZGVmYXVsdHMgdG8gYGZhbHNlYFxuICAgICAgICBpbXBvcnRFeHByKEdMT0JBTF9UQVJHRVRfUkVTT0xWRVJTLmdldCh0YXJnZXQpKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG59XG52YXIgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyKGNvbnN0YW50UG9vbCwgcGFyZW50QmluZGluZ1Njb3BlLCBsZXZlbCwgY29udGV4dE5hbWUsIGkxOG5Db250ZXh0LCB0ZW1wbGF0ZUluZGV4LCB0ZW1wbGF0ZU5hbWUsIGRpcmVjdGl2ZU1hdGNoZXIsIGRpcmVjdGl2ZXMsIHBpcGVUeXBlQnlOYW1lLCBwaXBlcywgX25hbWVzcGFjZSwgcmVsYXRpdmVDb250ZXh0RmlsZVBhdGgsIGkxOG5Vc2VFeHRlcm5hbElkcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobGV2ZWwgPT09IHZvaWQgMCkgeyBsZXZlbCA9IDA7IH1cbiAgICAgICAgdGhpcy5jb25zdGFudFBvb2wgPSBjb25zdGFudFBvb2w7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgdGhpcy5jb250ZXh0TmFtZSA9IGNvbnRleHROYW1lO1xuICAgICAgICB0aGlzLmkxOG5Db250ZXh0ID0gaTE4bkNvbnRleHQ7XG4gICAgICAgIHRoaXMudGVtcGxhdGVJbmRleCA9IHRlbXBsYXRlSW5kZXg7XG4gICAgICAgIHRoaXMudGVtcGxhdGVOYW1lID0gdGVtcGxhdGVOYW1lO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZU1hdGNoZXIgPSBkaXJlY3RpdmVNYXRjaGVyO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICB0aGlzLnBpcGVUeXBlQnlOYW1lID0gcGlwZVR5cGVCeU5hbWU7XG4gICAgICAgIHRoaXMucGlwZXMgPSBwaXBlcztcbiAgICAgICAgdGhpcy5fbmFtZXNwYWNlID0gX25hbWVzcGFjZTtcbiAgICAgICAgdGhpcy5yZWxhdGl2ZUNvbnRleHRGaWxlUGF0aCA9IHJlbGF0aXZlQ29udGV4dEZpbGVQYXRoO1xuICAgICAgICB0aGlzLmkxOG5Vc2VFeHRlcm5hbElkcyA9IGkxOG5Vc2VFeHRlcm5hbElkcztcbiAgICAgICAgdGhpcy5fZGF0YUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fYmluZGluZ0NvbnRleHQgPSAwO1xuICAgICAgICB0aGlzLl9wcmVmaXhDb2RlID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIGNhbGxiYWNrcyB0byBnZW5lcmF0ZSBjcmVhdGlvbiBtb2RlIGluc3RydWN0aW9ucy4gV2Ugc3RvcmUgdGhlbSBoZXJlIGFzIHdlIHByb2Nlc3NcbiAgICAgICAgICogdGhlIHRlbXBsYXRlIHNvIGJpbmRpbmdzIGluIGxpc3RlbmVycyBhcmUgcmVzb2x2ZWQgb25seSBvbmNlIGFsbCBub2RlcyBoYXZlIGJlZW4gdmlzaXRlZC5cbiAgICAgICAgICogVGhpcyBlbnN1cmVzIGFsbCBsb2NhbCByZWZzIGFuZCBjb250ZXh0IHZhcmlhYmxlcyBhcmUgYXZhaWxhYmxlIGZvciBtYXRjaGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NyZWF0aW9uQ29kZUZucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBvZiBjYWxsYmFja3MgdG8gZ2VuZXJhdGUgdXBkYXRlIG1vZGUgaW5zdHJ1Y3Rpb25zLiBXZSBzdG9yZSB0aGVtIGhlcmUgYXMgd2UgcHJvY2Vzc1xuICAgICAgICAgKiB0aGUgdGVtcGxhdGUgc28gYmluZGluZ3MgYXJlIHJlc29sdmVkIG9ubHkgb25jZSBhbGwgbm9kZXMgaGF2ZSBiZWVuIHZpc2l0ZWQuIFRoaXMgZW5zdXJlc1xuICAgICAgICAgKiBhbGwgbG9jYWwgcmVmcyBhbmQgY29udGV4dCB2YXJpYWJsZXMgYXJlIGF2YWlsYWJsZSBmb3IgbWF0Y2hpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl91cGRhdGVDb2RlRm5zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZW1vcml6ZXMgdGhlIGxhc3Qgbm9kZSBpbmRleCBmb3Igd2hpY2ggYSBzZWxlY3QgaW5zdHJ1Y3Rpb24gaGFzIGJlZW4gZ2VuZXJhdGVkLlxuICAgICAgICAgKiBXZSdyZSBpbml0aWFsaXppbmcgdGhpcyB0byAtMSB0byBlbnN1cmUgdGhlIGBzZWxlY3QoMClgIGluc3RydWN0aW9uIGlzIGdlbmVyYXRlZCBiZWZvcmUgYW55XG4gICAgICAgICAqIHJlbGV2YW50IHVwZGF0ZSBpbnN0cnVjdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXN0Tm9kZUluZGV4V2l0aEZsdXNoID0gLTE7XG4gICAgICAgIC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgZGVjbGFyYXRpb25zIGdlbmVyYXRlZCBmcm9tIHZpc2l0aW5nIHBpcGVzLCBsaXRlcmFscywgZXRjLiAqL1xuICAgICAgICB0aGlzLl90ZW1wVmFyaWFibGVzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIGNhbGxiYWNrcyB0byBidWlsZCBuZXN0ZWQgdGVtcGxhdGVzLiBOZXN0ZWQgdGVtcGxhdGVzIG11c3Qgbm90IGJlIHZpc2l0ZWQgdW50aWxcbiAgICAgICAgICogYWZ0ZXIgdGhlIHBhcmVudCB0ZW1wbGF0ZSBoYXMgZmluaXNoZWQgdmlzaXRpbmcgYWxsIG9mIGl0cyBub2Rlcy4gVGhpcyBlbnN1cmVzIHRoYXQgYWxsXG4gICAgICAgICAqIGxvY2FsIHJlZiBiaW5kaW5ncyBpbiBuZXN0ZWQgdGVtcGxhdGVzIGFyZSBhYmxlIHRvIGZpbmQgbG9jYWwgcmVmIHZhbHVlcyBpZiB0aGUgcmVmc1xuICAgICAgICAgKiBhcmUgZGVmaW5lZCBhZnRlciB0aGUgdGVtcGxhdGUgZGVjbGFyYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9uZXN0ZWRUZW1wbGF0ZUZucyA9IFtdO1xuICAgICAgICB0aGlzLl91bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuICAgICAgICAvLyBpMThuIGNvbnRleHQgbG9jYWwgdG8gdGhpcyB0ZW1wbGF0ZVxuICAgICAgICB0aGlzLmkxOG4gPSBudWxsO1xuICAgICAgICAvLyBOdW1iZXIgb2Ygc2xvdHMgdG8gcmVzZXJ2ZSBmb3IgcHVyZUZ1bmN0aW9uc1xuICAgICAgICB0aGlzLl9wdXJlRnVuY3Rpb25TbG90cyA9IDA7XG4gICAgICAgIC8vIE51bWJlciBvZiBiaW5kaW5nIHNsb3RzXG4gICAgICAgIHRoaXMuX2JpbmRpbmdTbG90cyA9IDA7XG4gICAgICAgIC8vIFByb2plY3Rpb24gc2xvdHMgZm91bmQgaW4gdGhlIHRlbXBsYXRlLiBQcm9qZWN0aW9uIHNsb3RzIGNhbiBkaXN0cmlidXRlIHByb2plY3RlZFxuICAgICAgICAvLyBub2RlcyBiYXNlZCBvbiBhIHNlbGVjdG9yLCBvciBjYW4ganVzdCB1c2UgdGhlIHdpbGRjYXJkIHNlbGVjdG9yIHRvIG1hdGNoXG4gICAgICAgIC8vIGFsbCBub2RlcyB3aGljaCBhcmVuJ3QgbWF0Y2hpbmcgYW55IHNlbGVjdG9yLlxuICAgICAgICB0aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzID0gW107XG4gICAgICAgIC8vIE51bWJlciBvZiBub24tZGVmYXVsdCBzZWxlY3RvcnMgZm91bmQgaW4gYWxsIHBhcmVudCB0ZW1wbGF0ZXMgb2YgdGhpcyB0ZW1wbGF0ZS4gV2UgbmVlZCB0b1xuICAgICAgICAvLyB0cmFjayBpdCB0byBwcm9wZXJseSBhZGp1c3QgcHJvamVjdGlvbiBzbG90IGluZGV4IGluIHRoZSBgcHJvamVjdGlvbmAgaW5zdHJ1Y3Rpb24uXG4gICAgICAgIHRoaXMuX25nQ29udGVudFNlbGVjdG9yc09mZnNldCA9IDA7XG4gICAgICAgIC8vIEV4cHJlc3Npb24gdGhhdCBzaG91bGQgYmUgdXNlZCBhcyBpbXBsaWNpdCByZWNlaXZlciB3aGVuIGNvbnZlcnRpbmcgdGVtcGxhdGVcbiAgICAgICAgLy8gZXhwcmVzc2lvbnMgdG8gb3V0cHV0IEFTVC5cbiAgICAgICAgdGhpcy5faW1wbGljaXRSZWNlaXZlckV4cHIgPSBudWxsO1xuICAgICAgICAvLyBUaGVzZSBzaG91bGQgYmUgaGFuZGxlZCBpbiB0aGUgdGVtcGxhdGUgb3IgZWxlbWVudCBkaXJlY3RseS5cbiAgICAgICAgdGhpcy52aXNpdFJlZmVyZW5jZSA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy52aXNpdFZhcmlhYmxlID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0VGV4dEF0dHJpYnV0ZSA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy52aXNpdEJvdW5kQXR0cmlidXRlID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0Qm91bmRFdmVudCA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy5fYmluZGluZ1Njb3BlID0gcGFyZW50QmluZGluZ1Njb3BlLm5lc3RlZFNjb3BlKGxldmVsKTtcbiAgICAgICAgLy8gVHVybiB0aGUgcmVsYXRpdmUgY29udGV4dCBmaWxlIHBhdGggaW50byBhbiBpZGVudGlmaWVyIGJ5IHJlcGxhY2luZyBub24tYWxwaGFudW1lcmljXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgd2l0aCB1bmRlcnNjb3Jlcy5cbiAgICAgICAgdGhpcy5maWxlQmFzZWRJMThuU3VmZml4ID0gcmVsYXRpdmVDb250ZXh0RmlsZVBhdGgucmVwbGFjZSgvW15BLVphLXowLTldL2csICdfJykgKyAnXyc7XG4gICAgICAgIHRoaXMuX3ZhbHVlQ29udmVydGVyID0gbmV3IFZhbHVlQ29udmVydGVyKGNvbnN0YW50UG9vbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYWxsb2NhdGVEYXRhU2xvdCgpOyB9LCBmdW5jdGlvbiAobnVtU2xvdHMpIHsgcmV0dXJuIF90aGlzLmFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMobnVtU2xvdHMpOyB9LCBmdW5jdGlvbiAobmFtZSwgbG9jYWxOYW1lLCBzbG90LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHBpcGVUeXBlID0gcGlwZVR5cGVCeU5hbWUuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgaWYgKHBpcGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucGlwZXMuYWRkKHBpcGVUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9iaW5kaW5nU2NvcGUuc2V0KF90aGlzLmxldmVsLCBsb2NhbE5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIF90aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24obnVsbCwgSWRlbnRpZmllcnMkMS5waXBlLCBbbGl0ZXJhbChzbG90KSwgbGl0ZXJhbChuYW1lKV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUucmVnaXN0ZXJDb250ZXh0VmFyaWFibGVzID0gZnVuY3Rpb24gKHZhcmlhYmxlJDEpIHtcbiAgICAgICAgdmFyIHNjb3BlZE5hbWUgPSB0aGlzLl9iaW5kaW5nU2NvcGUuZnJlc2hSZWZlcmVuY2VOYW1lKCk7XG4gICAgICAgIHZhciByZXRyaWV2YWxMZXZlbCA9IHRoaXMubGV2ZWw7XG4gICAgICAgIHZhciBsaHMgPSB2YXJpYWJsZSh2YXJpYWJsZSQxLm5hbWUgKyBzY29wZWROYW1lKTtcbiAgICAgICAgdGhpcy5fYmluZGluZ1Njb3BlLnNldChyZXRyaWV2YWxMZXZlbCwgdmFyaWFibGUkMS5uYW1lLCBsaHMsIDEgLyogQ09OVEVYVCAqLywgZnVuY3Rpb24gKHNjb3BlLCByZWxhdGl2ZUxldmVsKSB7XG4gICAgICAgICAgICB2YXIgcmhzO1xuICAgICAgICAgICAgaWYgKHNjb3BlLmJpbmRpbmdMZXZlbCA9PT0gcmV0cmlldmFsTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBlLmcuIGN0eFxuICAgICAgICAgICAgICAgIHJocyA9IHZhcmlhYmxlKENPTlRFWFRfTkFNRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcmVkQ3R4VmFyID0gc2NvcGUuZ2V0U2hhcmVkQ29udGV4dE5hbWUocmV0cmlldmFsTGV2ZWwpO1xuICAgICAgICAgICAgICAgIC8vIGUuZy4gY3R4X3IwICAgT1IgIHgoMik7XG4gICAgICAgICAgICAgICAgcmhzID0gc2hhcmVkQ3R4VmFyID8gc2hhcmVkQ3R4VmFyIDogZ2VuZXJhdGVOZXh0Q29udGV4dEV4cHIocmVsYXRpdmVMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlLmcuIGNvbnN0ICRpdGVtJCA9IHgoMikuJGltcGxpY2l0O1xuICAgICAgICAgICAgcmV0dXJuIFtsaHMuc2V0KHJocy5wcm9wKHZhcmlhYmxlJDEudmFsdWUgfHwgSU1QTElDSVRfUkVGRVJFTkNFKSkudG9Db25zdERlY2woKV07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuYnVpbGRUZW1wbGF0ZUZ1bmN0aW9uID0gZnVuY3Rpb24gKG5vZGVzLCB2YXJpYWJsZXMsIG5nQ29udGVudFNlbGVjdG9yc09mZnNldCwgaTE4bikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobmdDb250ZW50U2VsZWN0b3JzT2Zmc2V0ID09PSB2b2lkIDApIHsgbmdDb250ZW50U2VsZWN0b3JzT2Zmc2V0ID0gMDsgfVxuICAgICAgICB0aGlzLl9uZ0NvbnRlbnRTZWxlY3RvcnNPZmZzZXQgPSBuZ0NvbnRlbnRTZWxlY3RvcnNPZmZzZXQ7XG4gICAgICAgIGlmICh0aGlzLl9uYW1lc3BhY2UgIT09IElkZW50aWZpZXJzJDEubmFtZXNwYWNlSFRNTCkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKG51bGwsIHRoaXMuX25hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHZhcmlhYmxlIGJpbmRpbmdzXG4gICAgICAgIHZhcmlhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiBfdGhpcy5yZWdpc3RlckNvbnRleHRWYXJpYWJsZXModik7IH0pO1xuICAgICAgICAvLyBJbml0aWF0ZSBpMThuIGNvbnRleHQgaW4gY2FzZTpcbiAgICAgICAgLy8gLSB0aGlzIHRlbXBsYXRlIGhhcyBwYXJlbnQgaTE4biBjb250ZXh0XG4gICAgICAgIC8vIC0gb3IgdGhlIHRlbXBsYXRlIGhhcyBpMThuIG1ldGEgYXNzb2NpYXRlZCB3aXRoIGl0LFxuICAgICAgICAvLyAgIGJ1dCBpdCdzIG5vdCBpbml0aWF0ZWQgYnkgdGhlIEVsZW1lbnQgKGUuZy4gPG5nLXRlbXBsYXRlIGkxOG4+KVxuICAgICAgICB2YXIgaW5pdEkxOG5Db250ZXh0ID0gdGhpcy5pMThuQ29udGV4dCB8fCAoaXNJMThuUm9vdE5vZGUoaTE4bikgJiYgIWlzU2luZ2xlSTE4bkljdShpMThuKSAmJlxuICAgICAgICAgICAgIShpc1NpbmdsZUVsZW1lbnRUZW1wbGF0ZShub2RlcykgJiYgbm9kZXNbMF0uaTE4biA9PT0gaTE4bikpO1xuICAgICAgICB2YXIgc2VsZkNsb3NpbmdJMThuSW5zdHJ1Y3Rpb24gPSBoYXNUZXh0Q2hpbGRyZW5Pbmx5KG5vZGVzKTtcbiAgICAgICAgaWYgKGluaXRJMThuQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5pMThuU3RhcnQobnVsbCwgaTE4biwgc2VsZkNsb3NpbmdJMThuSW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGluaXRpYWwgcGFzcyB0aHJvdWdoIHRoZSBub2RlcyBvZiB0aGlzIHRlbXBsYXRlLiBJbiB0aGlzIHBhc3MsIHdlXG4gICAgICAgIC8vIHF1ZXVlIGFsbCBjcmVhdGlvbiBtb2RlIGFuZCB1cGRhdGUgbW9kZSBpbnN0cnVjdGlvbnMgZm9yIGdlbmVyYXRpb24gaW4gdGhlIHNlY29uZFxuICAgICAgICAvLyBwYXNzLiBJdCdzIG5lY2Vzc2FyeSB0byBzZXBhcmF0ZSB0aGUgcGFzc2VzIHRvIGVuc3VyZSBsb2NhbCByZWZzIGFyZSBkZWZpbmVkIGJlZm9yZVxuICAgICAgICAvLyByZXNvbHZpbmcgYmluZGluZ3MuIFdlIGFsc28gY291bnQgYmluZGluZ3MgaW4gdGhpcyBwYXNzIGFzIHdlIHdhbGsgYm91bmQgZXhwcmVzc2lvbnMuXG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIG5vZGVzKTtcbiAgICAgICAgLy8gQWRkIHRvdGFsIGJpbmRpbmcgY291bnQgdG8gcHVyZSBmdW5jdGlvbiBjb3VudCBzbyBwdXJlIGZ1bmN0aW9uIGluc3RydWN0aW9ucyBhcmVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIHdpdGggdGhlIGNvcnJlY3Qgc2xvdCBvZmZzZXQgd2hlbiB1cGRhdGUgaW5zdHJ1Y3Rpb25zIGFyZSBwcm9jZXNzZWQuXG4gICAgICAgIHRoaXMuX3B1cmVGdW5jdGlvblNsb3RzICs9IHRoaXMuX2JpbmRpbmdTbG90cztcbiAgICAgICAgLy8gUGlwZXMgYXJlIHdhbGtlZCBpbiB0aGUgZmlyc3QgcGFzcyAodG8gZW5xdWV1ZSBgcGlwZSgpYCBjcmVhdGlvbiBpbnN0cnVjdGlvbnMgYW5kXG4gICAgICAgIC8vIGBwaXBlQmluZGAgdXBkYXRlIGluc3RydWN0aW9ucyksIHNvIHdlIGhhdmUgdG8gdXBkYXRlIHRoZSBzbG90IG9mZnNldHMgbWFudWFsbHlcbiAgICAgICAgLy8gdG8gYWNjb3VudCBmb3IgYmluZGluZ3MuXG4gICAgICAgIHRoaXMuX3ZhbHVlQ29udmVydGVyLnVwZGF0ZVBpcGVTbG90T2Zmc2V0cyh0aGlzLl9iaW5kaW5nU2xvdHMpO1xuICAgICAgICAvLyBOZXN0ZWQgdGVtcGxhdGVzIG11c3QgYmUgcHJvY2Vzc2VkIGJlZm9yZSBjcmVhdGlvbiBpbnN0cnVjdGlvbnMgc28gdGVtcGxhdGUoKVxuICAgICAgICAvLyBpbnN0cnVjdGlvbnMgY2FuIGJlIGdlbmVyYXRlZCB3aXRoIHRoZSBjb3JyZWN0IGludGVybmFsIGNvbnN0IGNvdW50LlxuICAgICAgICB0aGlzLl9uZXN0ZWRUZW1wbGF0ZUZucy5mb3JFYWNoKGZ1bmN0aW9uIChidWlsZFRlbXBsYXRlRm4pIHsgcmV0dXJuIGJ1aWxkVGVtcGxhdGVGbigpOyB9KTtcbiAgICAgICAgLy8gT3V0cHV0IHRoZSBgcHJvamVjdGlvbkRlZmAgaW5zdHJ1Y3Rpb24gd2hlbiBzb21lIGA8bmctY29udGVudD5gIHRhZ3MgYXJlIHByZXNlbnQuXG4gICAgICAgIC8vIFRoZSBgcHJvamVjdGlvbkRlZmAgaW5zdHJ1Y3Rpb24gaXMgb25seSBlbWl0dGVkIGZvciB0aGUgY29tcG9uZW50IHRlbXBsYXRlIGFuZFxuICAgICAgICAvLyBpcyBza2lwcGVkIGZvciBuZXN0ZWQgdGVtcGxhdGVzICg8bmctdGVtcGxhdGU+IHRhZ3MpLlxuICAgICAgICBpZiAodGhpcy5sZXZlbCA9PT0gMCAmJiB0aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQgdGhlIGBwcm9qZWN0aW9uRGVmYCBpbnN0cnVjdGlvbnMgY3JlYXRlcyBvbmUgc2xvdCBmb3IgdGhlIHdpbGRjYXJkXG4gICAgICAgICAgICAvLyBzZWxlY3RvciBpZiBubyBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQuIFRoZXJlZm9yZSB3ZSBvbmx5IHdhbnQgdG8gYWxsb2NhdGUgYSBuZXdcbiAgICAgICAgICAgIC8vIGFycmF5IGZvciB0aGUgcHJvamVjdGlvbiBzbG90cyBpZiB0aGUgZGVmYXVsdCBwcm9qZWN0aW9uIHNsb3QgaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cy5sZW5ndGggPiAxIHx8IHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHNbMF0gIT09ICcqJykge1xuICAgICAgICAgICAgICAgIHZhciByM1Jlc2VydmVkU2xvdHMgPSB0aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcyAhPT0gJyonID8gcGFyc2VTZWxlY3RvclRvUjNTZWxlY3RvcihzKSA6IHM7IH0pO1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaCh0aGlzLmNvbnN0YW50UG9vbC5nZXRDb25zdExpdGVyYWwoYXNMaXRlcmFsKHIzUmVzZXJ2ZWRTbG90cyksIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGFjY3VtdWxhdGUgbmdDb250ZW50IHNlbGVjdG9ycyB3aGlsZSBwcm9jZXNzaW5nIHRlbXBsYXRlIGVsZW1lbnRzLFxuICAgICAgICAgICAgLy8gd2UgKnByZXBlbmQqIGBwcm9qZWN0aW9uRGVmYCB0byBjcmVhdGlvbiBpbnN0cnVjdGlvbnMgYmxvY2ssIHRvIHB1dCBpdCBiZWZvcmVcbiAgICAgICAgICAgIC8vIGFueSBgcHJvamVjdGlvbmAgaW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24obnVsbCwgSWRlbnRpZmllcnMkMS5wcm9qZWN0aW9uRGVmLCBwYXJhbWV0ZXJzLCAvKiBwcmVwZW5kICovIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0STE4bkNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuaTE4bkVuZChudWxsLCBzZWxmQ2xvc2luZ0kxOG5JbnN0cnVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2VuZXJhdGUgYWxsIHRoZSBjcmVhdGlvbiBtb2RlIGluc3RydWN0aW9ucyAoZS5nLiByZXNvbHZlIGJpbmRpbmdzIGluIGxpc3RlbmVycylcbiAgICAgICAgdmFyIGNyZWF0aW9uU3RhdGVtZW50cyA9IHRoaXMuX2NyZWF0aW9uQ29kZUZucy5tYXAoZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICAgICAgLy8gR2VuZXJhdGUgYWxsIHRoZSB1cGRhdGUgbW9kZSBpbnN0cnVjdGlvbnMgKGUuZy4gcmVzb2x2ZSBwcm9wZXJ0eSBvciB0ZXh0IGJpbmRpbmdzKVxuICAgICAgICB2YXIgdXBkYXRlU3RhdGVtZW50cyA9IHRoaXMuX3VwZGF0ZUNvZGVGbnMubWFwKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgIC8vICBWYXJpYWJsZSBkZWNsYXJhdGlvbiBtdXN0IG9jY3VyIGFmdGVyIGJpbmRpbmcgcmVzb2x1dGlvbiBzbyB3ZSBjYW4gZ2VuZXJhdGUgY29udGV4dFxuICAgICAgICAvLyAgaW5zdHJ1Y3Rpb25zIHRoYXQgYnVpbGQgb24gZWFjaCBvdGhlci5cbiAgICAgICAgLy8gZS5nLiBjb25zdCBiID0gbmV4dENvbnRleHQoKS4kaW1wbGljaXQoKTsgY29uc3QgYiA9IG5leHRDb250ZXh0KCk7XG4gICAgICAgIHZhciBjcmVhdGlvblZhcmlhYmxlcyA9IHRoaXMuX2JpbmRpbmdTY29wZS52aWV3U25hcHNob3RTdGF0ZW1lbnRzKCk7XG4gICAgICAgIHZhciB1cGRhdGVWYXJpYWJsZXMgPSB0aGlzLl9iaW5kaW5nU2NvcGUudmFyaWFibGVEZWNsYXJhdGlvbnMoKS5jb25jYXQodGhpcy5fdGVtcFZhcmlhYmxlcyk7XG4gICAgICAgIHZhciBjcmVhdGlvbkJsb2NrID0gY3JlYXRpb25TdGF0ZW1lbnRzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgW3JlbmRlckZsYWdDaGVja0lmU3RtdCgxIC8qIENyZWF0ZSAqLywgY3JlYXRpb25WYXJpYWJsZXMuY29uY2F0KGNyZWF0aW9uU3RhdGVtZW50cykpXSA6XG4gICAgICAgICAgICBbXTtcbiAgICAgICAgdmFyIHVwZGF0ZUJsb2NrID0gdXBkYXRlU3RhdGVtZW50cy5sZW5ndGggPiAwID9cbiAgICAgICAgICAgIFtyZW5kZXJGbGFnQ2hlY2tJZlN0bXQoMiAvKiBVcGRhdGUgKi8sIHVwZGF0ZVZhcmlhYmxlcy5jb25jYXQodXBkYXRlU3RhdGVtZW50cykpXSA6XG4gICAgICAgICAgICBbXTtcbiAgICAgICAgcmV0dXJuIGZuKFxuICAgICAgICAvLyBpLmUuIChyZjogUmVuZGVyRmxhZ3MsIGN0eDogYW55KVxuICAgICAgICBbbmV3IEZuUGFyYW0oUkVOREVSX0ZMQUdTLCBOVU1CRVJfVFlQRSksIG5ldyBGblBhcmFtKENPTlRFWFRfTkFNRSwgbnVsbCldLCBfX3NwcmVhZCh0aGlzLl9wcmVmaXhDb2RlLCBjcmVhdGlvbkJsb2NrLCB1cGRhdGVCbG9jayksIElORkVSUkVEX1RZUEUsIG51bGwsIHRoaXMudGVtcGxhdGVOYW1lKTtcbiAgICB9O1xuICAgIC8vIExvY2FsUmVzb2x2ZXJcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5nZXRMb2NhbCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0aGlzLl9iaW5kaW5nU2NvcGUuZ2V0KG5hbWUpOyB9O1xuICAgIC8vIExvY2FsUmVzb2x2ZXJcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5ub3RpZnlJbXBsaWNpdFJlY2VpdmVyVXNlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9iaW5kaW5nU2NvcGUubm90aWZ5SW1wbGljaXRSZWNlaXZlclVzZSgpOyB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmkxOG5UcmFuc2xhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSwgcGFyYW1zLCByZWYsIHRyYW5zZm9ybUZuKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XG4gICAgICAgIHZhciBfcmVmID0gcmVmIHx8IHZhcmlhYmxlKHRoaXMuY29uc3RhbnRQb29sLnVuaXF1ZU5hbWUoVFJBTlNMQVRJT05fUFJFRklYKSk7XG4gICAgICAgIC8vIENsb3N1cmUgQ29tcGlsZXIgcmVxdWlyZXMgY29uc3QgbmFtZXMgdG8gc3RhcnQgd2l0aCBgTVNHX2AgYnV0IGRpc2FsbG93cyBhbnkgb3RoZXIgY29uc3QgdG9cbiAgICAgICAgLy8gc3RhcnQgd2l0aCBgTVNHX2AuIFdlIGRlZmluZSBhIHZhcmlhYmxlIHN0YXJ0aW5nIHdpdGggYE1TR19gIGp1c3QgZm9yIHRoZSBgZ29vZy5nZXRNc2dgIGNhbGxcbiAgICAgICAgdmFyIGNsb3N1cmVWYXIgPSB0aGlzLmkxOG5HZW5lcmF0ZUNsb3N1cmVWYXIobWVzc2FnZS5pZCk7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRQYXJhbXMgPSB0aGlzLmkxOG5Gb3JtYXRQbGFjZWhvbGRlck5hbWVzKHBhcmFtcywgLyogdXNlQ2FtZWxDYXNlICovIHRydWUpO1xuICAgICAgICB2YXIgbWV0YSA9IG1ldGFGcm9tSTE4bk1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHZhciBjb250ZW50ID0gZ2V0U2VyaWFsaXplZEkxOG5Db250ZW50KG1lc3NhZ2UpO1xuICAgICAgICB2YXIgc3RhdGVtZW50cyA9IGdldFRyYW5zbGF0aW9uRGVjbFN0bXRzKF9yZWYsIGNsb3N1cmVWYXIsIGNvbnRlbnQsIG1ldGEsIGZvcm1hdHRlZFBhcmFtcywgdHJhbnNmb3JtRm4pO1xuICAgICAgICAoX2EgPSB0aGlzLmNvbnN0YW50UG9vbC5zdGF0ZW1lbnRzKS5wdXNoLmFwcGx5KF9hLCBfX3NwcmVhZChzdGF0ZW1lbnRzKSk7XG4gICAgICAgIHJldHVybiBfcmVmO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuaTE4bkZvcm1hdFBsYWNlaG9sZGVyTmFtZXMgPSBmdW5jdGlvbiAocGFyYW1zLCB1c2VDYW1lbENhc2UpIHtcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XG4gICAgICAgIHZhciBfcGFyYW1zID0ge307XG4gICAgICAgIGlmIChwYXJhbXMgJiYgT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBfcGFyYW1zW2Zvcm1hdEkxOG5QbGFjZWhvbGRlck5hbWUoa2V5LCB1c2VDYW1lbENhc2UpXSA9IHBhcmFtc1trZXldOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3BhcmFtcztcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmkxOG5BcHBlbmRCaW5kaW5ncyA9IGZ1bmN0aW9uIChleHByZXNzaW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZXhwcmVzc2lvbikgeyByZXR1cm4gX3RoaXMuaTE4bi5hcHBlbmRCaW5kaW5nKGV4cHJlc3Npb24pOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuaTE4bkJpbmRQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYm91bmQgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1trZXldO1xuICAgICAgICAgICAgaWYgKHByb3AgaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgICAgICAgICAgYm91bmRba2V5XSA9IGxpdGVyYWwocHJvcC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9wLnZhbHVlLnZpc2l0KF90aGlzLl92YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWxsb2NhdGVCaW5kaW5nU2xvdHModmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmluZ3MgPSB2YWx1ZS5zdHJpbmdzLCBleHByZXNzaW9ucyA9IHZhbHVlLmV4cHJlc3Npb25zO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5pMThuLCBpZCA9IF9hLmlkLCBiaW5kaW5ncyA9IF9hLmJpbmRpbmdzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBhc3NlbWJsZUkxOG5Cb3VuZFN0cmluZyhzdHJpbmdzLCBiaW5kaW5ncy5zaXplLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmkxOG5BcHBlbmRCaW5kaW5ncyhleHByZXNzaW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kW2tleV0gPSBsaXRlcmFsKGxhYmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5pMThuR2VuZXJhdGVDbG9zdXJlVmFyID0gZnVuY3Rpb24gKG1lc3NhZ2VJZCkge1xuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgdmFyIHN1ZmZpeCA9IHRoaXMuZmlsZUJhc2VkSTE4blN1ZmZpeC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAodGhpcy5pMThuVXNlRXh0ZXJuYWxJZHMpIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBnZXRUcmFuc2xhdGlvbkNvbnN0UHJlZml4KFwiRVhURVJOQUxfXCIpO1xuICAgICAgICAgICAgdmFyIHVuaXF1ZVN1ZmZpeCA9IHRoaXMuY29uc3RhbnRQb29sLnVuaXF1ZU5hbWUoc3VmZml4KTtcbiAgICAgICAgICAgIG5hbWUgPSBcIlwiICsgcHJlZml4ICsgc2FuaXRpemVJZGVudGlmaWVyKG1lc3NhZ2VJZCkgKyBcIiQkXCIgKyB1bmlxdWVTdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gZ2V0VHJhbnNsYXRpb25Db25zdFByZWZpeChzdWZmaXgpO1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMuY29uc3RhbnRQb29sLnVuaXF1ZU5hbWUocHJlZml4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFyaWFibGUobmFtZSk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5pMThuVXBkYXRlUmVmID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGljdXMgPSBjb250ZXh0LmljdXMsIG1ldGEgPSBjb250ZXh0Lm1ldGEsIGlzUm9vdCA9IGNvbnRleHQuaXNSb290LCBpc1Jlc29sdmVkID0gY29udGV4dC5pc1Jlc29sdmVkLCBpc0VtaXR0ZWQgPSBjb250ZXh0LmlzRW1pdHRlZDtcbiAgICAgICAgaWYgKGlzUm9vdCAmJiBpc1Jlc29sdmVkICYmICFpc0VtaXR0ZWQgJiYgIWlzU2luZ2xlSTE4bkljdShtZXRhKSkge1xuICAgICAgICAgICAgY29udGV4dC5pc0VtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVycyA9IGNvbnRleHQuZ2V0U2VyaWFsaXplZFBsYWNlaG9sZGVycygpO1xuICAgICAgICAgICAgdmFyIGljdU1hcHBpbmdfMSA9IHt9O1xuICAgICAgICAgICAgdmFyIHBhcmFtc18xID0gcGxhY2Vob2xkZXJzLnNpemUgPyBwbGFjZWhvbGRlcnNUb1BhcmFtcyhwbGFjZWhvbGRlcnMpIDoge307XG4gICAgICAgICAgICBpZiAoaWN1cy5zaXplKSB7XG4gICAgICAgICAgICAgICAgaWN1cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWZzLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIG9uZSBJQ1UgZGVmaW5lZCBmb3IgYSBnaXZlblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXIgLSBqdXN0IG91dHB1dCBpdHMgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNfMVtrZXldID0gcmVmc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLiBvdGhlcndpc2Ugd2UgbmVlZCB0byBhY3RpdmF0ZSBwb3N0LXByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHJlcGxhY2UgSUNVIHBsYWNlaG9sZGVycyB3aXRoIHByb3BlciB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHdyYXBJMThuUGxhY2Vob2xkZXIoXCJcIiArIEkxOE5fSUNVX01BUFBJTkdfUFJFRklYICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc18xW2tleV0gPSBsaXRlcmFsKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGljdU1hcHBpbmdfMVtrZXldID0gbGl0ZXJhbEFycihyZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJhbnNsYXRpb24gcmVxdWlyZXMgcG9zdCBwcm9jZXNzaW5nIGluIDIgY2FzZXM6XG4gICAgICAgICAgICAvLyAtIGlmIHdlIGhhdmUgcGxhY2Vob2xkZXJzIHdpdGggbXVsdGlwbGUgdmFsdWVzIChleC4gYFNUQVJUX0RJVmA6IFvvv70jMe+/vSwg77+9IzLvv70sIC4uLl0pXG4gICAgICAgICAgICAvLyAtIGlmIHdlIGhhdmUgbXVsdGlwbGUgSUNVcyB0aGF0IHJlZmVyIHRvIHRoZSBzYW1lIHBsYWNlaG9sZGVyIG5hbWVcbiAgICAgICAgICAgIHZhciBuZWVkc1Bvc3Rwcm9jZXNzaW5nID0gQXJyYXkuZnJvbShwbGFjZWhvbGRlcnMudmFsdWVzKCkpLnNvbWUoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS5sZW5ndGggPiAxOyB9KSB8fFxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGljdU1hcHBpbmdfMSkubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybUZuID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKG5lZWRzUG9zdHByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1GbiA9IGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbcmF3XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGljdU1hcHBpbmdfMSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2gobWFwTGl0ZXJhbChpY3VNYXBwaW5nXzEsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb24obnVsbCwgSWRlbnRpZmllcnMkMS5pMThuUG9zdHByb2Nlc3MsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmkxOG5UcmFuc2xhdGUobWV0YSwgcGFyYW1zXzEsIGNvbnRleHQucmVmLCB0cmFuc2Zvcm1Gbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmkxOG5TdGFydCA9IGZ1bmN0aW9uIChzcGFuLCBtZXRhLCBzZWxmQ2xvc2luZykge1xuICAgICAgICBpZiAoc3BhbiA9PT0gdm9pZCAwKSB7IHNwYW4gPSBudWxsOyB9XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuYWxsb2NhdGVEYXRhU2xvdCgpO1xuICAgICAgICBpZiAodGhpcy5pMThuQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5pMThuID0gdGhpcy5pMThuQ29udGV4dC5mb3JrQ2hpbGRDb250ZXh0KGluZGV4LCB0aGlzLnRlbXBsYXRlSW5kZXgsIG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlZl8xID0gdmFyaWFibGUodGhpcy5jb25zdGFudFBvb2wudW5pcXVlTmFtZShUUkFOU0xBVElPTl9QUkVGSVgpKTtcbiAgICAgICAgICAgIHRoaXMuaTE4biA9IG5ldyBJMThuQ29udGV4dChpbmRleCwgcmVmXzEsIDAsIHRoaXMudGVtcGxhdGVJbmRleCwgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2VuZXJhdGUgaTE4blN0YXJ0IGluc3RydWN0aW9uXG4gICAgICAgIHZhciBfYSA9IHRoaXMuaTE4biwgaWQgPSBfYS5pZCwgcmVmID0gX2EucmVmO1xuICAgICAgICB2YXIgcGFyYW1zID0gW2xpdGVyYWwoaW5kZXgpLCByZWZdO1xuICAgICAgICBpZiAoaWQgPiAwKSB7XG4gICAgICAgICAgICAvLyBkbyBub3QgcHVzaCAzcmQgYXJndW1lbnQgKHN1Yi1ibG9jayBpZClcbiAgICAgICAgICAgIC8vIGludG8gaTE4blN0YXJ0IGNhbGwgZm9yIHRvcCBsZXZlbCBpMThuIGNvbnRleHRcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGxpdGVyYWwoaWQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oc3Bhbiwgc2VsZkNsb3NpbmcgPyBJZGVudGlmaWVycyQxLmkxOG4gOiBJZGVudGlmaWVycyQxLmkxOG5TdGFydCwgcGFyYW1zKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmkxOG5FbmQgPSBmdW5jdGlvbiAoc3Bhbiwgc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHNwYW4gPT09IHZvaWQgMCkgeyBzcGFuID0gbnVsbDsgfVxuICAgICAgICBpZiAoIXRoaXMuaTE4bikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpMThuRW5kIGlzIGV4ZWN1dGVkIHdpdGggbm8gaTE4biBjb250ZXh0IHByZXNlbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pMThuQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5pMThuQ29udGV4dC5yZWNvbmNpbGVDaGlsZENvbnRleHQodGhpcy5pMThuKTtcbiAgICAgICAgICAgIHRoaXMuaTE4blVwZGF0ZVJlZih0aGlzLmkxOG5Db250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaTE4blVwZGF0ZVJlZih0aGlzLmkxOG4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldHVwIGFjY3VtdWxhdGVkIGJpbmRpbmdzXG4gICAgICAgIHZhciBfYSA9IHRoaXMuaTE4biwgaW5kZXggPSBfYS5pbmRleCwgYmluZGluZ3MgPSBfYS5iaW5kaW5ncztcbiAgICAgICAgaWYgKGJpbmRpbmdzLnNpemUpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbkJpbmRpbmdzXzEgPSBbXTtcbiAgICAgICAgICAgIGJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBjaGFpbkJpbmRpbmdzXzEucHVzaCh7IHNvdXJjZVNwYW46IHNwYW4sIHZhbHVlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKGJpbmRpbmcpOyB9IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uQ2hhaW4oaW5kZXgsIElkZW50aWZpZXJzJDEuaTE4bkV4cCwgY2hhaW5CaW5kaW5nc18xKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb24oaW5kZXgsIHNwYW4sIElkZW50aWZpZXJzJDEuaTE4bkFwcGx5LCBbbGl0ZXJhbChpbmRleCldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oc3BhbiwgSWRlbnRpZmllcnMkMS5pMThuRW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmkxOG4gPSBudWxsOyAvLyByZXNldCBsb2NhbCBpMThuIGNvbnRleHRcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLnZpc2l0Q29udGVudCA9IGZ1bmN0aW9uIChuZ0NvbnRlbnQpIHtcbiAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmFsbG9jYXRlRGF0YVNsb3QoKTtcbiAgICAgICAgdmFyIHByb2plY3Rpb25TbG90SWR4ID0gdGhpcy5fbmdDb250ZW50U2VsZWN0b3JzT2Zmc2V0ICsgdGhpcy5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cy5sZW5ndGg7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0gW2xpdGVyYWwoc2xvdCldO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IFtdO1xuICAgICAgICB0aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzLnB1c2gobmdDb250ZW50LnNlbGVjdG9yKTtcbiAgICAgICAgbmdDb250ZW50LmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lLCB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSBOR19QUk9KRUNUX0FTX0FUVFJfTkFNRSkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaC5hcHBseShhdHRyaWJ1dGVzLCBfX3NwcmVhZChnZXROZ1Byb2plY3RBc0xpdGVyYWwoYXR0cmlidXRlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZS50b0xvd2VyQ2FzZSgpICE9PSBOR19DT05URU5UX1NFTEVDVF9BVFRSJDEpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnB1c2gobGl0ZXJhbChuYW1lKSwgbGl0ZXJhbCh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5wdXNoKGxpdGVyYWwocHJvamVjdGlvblNsb3RJZHgpLCBsaXRlcmFsQXJyKGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0aW9uU2xvdElkeCAhPT0gMCkge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5wdXNoKGxpdGVyYWwocHJvamVjdGlvblNsb3RJZHgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24obmdDb250ZW50LnNvdXJjZVNwYW4sIElkZW50aWZpZXJzJDEucHJvamVjdGlvbiwgcGFyYW1ldGVycyk7XG4gICAgICAgIGlmICh0aGlzLmkxOG4pIHtcbiAgICAgICAgICAgIHRoaXMuaTE4bi5hcHBlbmRQcm9qZWN0aW9uKG5nQ29udGVudC5pMThuLCBzbG90KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuZ2V0TmFtZXNwYWNlSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAobmFtZXNwYWNlS2V5KSB7XG4gICAgICAgIHN3aXRjaCAobmFtZXNwYWNlS2V5KSB7XG4gICAgICAgICAgICBjYXNlICdtYXRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5uYW1lc3BhY2VNYXRoTUw7XG4gICAgICAgICAgICBjYXNlICdzdmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLm5hbWVzcGFjZVNWRztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEubmFtZXNwYWNlSFRNTDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuYWRkTmFtZXNwYWNlSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAobnNJbnN0cnVjdGlvbiwgZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9uYW1lc3BhY2UgPSBuc0luc3RydWN0aW9uO1xuICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudC5zb3VyY2VTcGFuLCBuc0luc3RydWN0aW9uKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZWxlbWVudEluZGV4ID0gdGhpcy5hbGxvY2F0ZURhdGFTbG90KCk7XG4gICAgICAgIHZhciBzdHlsaW5nQnVpbGRlciA9IG5ldyBTdHlsaW5nQnVpbGRlcihsaXRlcmFsKGVsZW1lbnRJbmRleCksIG51bGwpO1xuICAgICAgICB2YXIgaXNOb25CaW5kYWJsZU1vZGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGlzSTE4blJvb3RFbGVtZW50ID0gaXNJMThuUm9vdE5vZGUoZWxlbWVudC5pMThuKSAmJiAhaXNTaW5nbGVJMThuSWN1KGVsZW1lbnQuaTE4bik7XG4gICAgICAgIGlmIChpc0kxOG5Sb290RWxlbWVudCAmJiB0aGlzLmkxOG4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBtYXJrIGFuIGVsZW1lbnQgYXMgdHJhbnNsYXRhYmxlIGluc2lkZSBvZiBhIHRyYW5zbGF0YWJsZSBzZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpMThuQXR0cnMgPSBbXTtcbiAgICAgICAgdmFyIG91dHB1dEF0dHJzID0gW107XG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChzcGxpdE5zTmFtZShlbGVtZW50Lm5hbWUpLCAyKSwgbmFtZXNwYWNlS2V5ID0gX2JbMF0sIGVsZW1lbnROYW1lID0gX2JbMV07XG4gICAgICAgIHZhciBpc05nQ29udGFpbmVyJDEgPSBpc05nQ29udGFpbmVyKGVsZW1lbnQubmFtZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgc3R5bGluZywgaTE4biwgbmdOb25CaW5kYWJsZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKGVsZW1lbnQuYXR0cmlidXRlcyksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBhdHRyLm5hbWUsIHZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZV8xID09PSBOT05fQklOREFCTEVfQVRUUikge1xuICAgICAgICAgICAgICAgICAgICBpc05vbkJpbmRhYmxlTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWVfMSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgICAgICBzdHlsaW5nQnVpbGRlci5yZWdpc3RlclN0eWxlQXR0cih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWVfMSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgICAgICBzdHlsaW5nQnVpbGRlci5yZWdpc3RlckNsYXNzQXR0cih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ci5pMThuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQbGFjZSBhdHRyaWJ1dGVzIGludG8gYSBzZXBhcmF0ZSBhcnJheSBmb3IgaTE4biBwcm9jZXNzaW5nLCBidXQgYWxzbyBrZWVwIHN1Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZXMgaW4gdGhlIG1haW4gbGlzdCB0byBtYWtlIHRoZW0gYXZhaWxhYmxlIGZvciBkaXJlY3RpdmUgbWF0Y2hpbmcgYXQgcnVudGltZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oRlctMTI0OCk6IHByZXZlbnQgYXR0cmlidXRlcyBkdXBsaWNhdGlvbiBpbiBgaTE4bkF0dHJpYnV0ZXNgIGFuZCBgZWxlbWVudFN0YXJ0YFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpMThuQXR0cnMucHVzaChhdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEF0dHJzLnB1c2goYXR0cik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYXRjaCBkaXJlY3RpdmVzIG9uIG5vbiBpMThuIGF0dHJpYnV0ZXNcbiAgICAgICAgdGhpcy5tYXRjaERpcmVjdGl2ZXMoZWxlbWVudC5uYW1lLCBlbGVtZW50KTtcbiAgICAgICAgLy8gUmVndWxhciBlbGVtZW50IG9yIG5nLWNvbnRhaW5lciBjcmVhdGlvbiBtb2RlXG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0gW2xpdGVyYWwoZWxlbWVudEluZGV4KV07XG4gICAgICAgIGlmICghaXNOZ0NvbnRhaW5lciQxKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2gobGl0ZXJhbChlbGVtZW50TmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgYXR0cmlidXRlc1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IFtdO1xuICAgICAgICB2YXIgYWxsT3RoZXJJbnB1dHMgPSBbXTtcbiAgICAgICAgZWxlbWVudC5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBzdHlsaW5nSW5wdXRXYXNTZXQgPSBzdHlsaW5nQnVpbGRlci5yZWdpc3RlckJvdW5kSW5wdXQoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKCFzdHlsaW5nSW5wdXRXYXNTZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQudHlwZSA9PT0gMCAvKiBQcm9wZXJ0eSAqLyAmJiBpbnB1dC5pMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlIGF0dHJpYnV0ZXMgaW50byBhIHNlcGFyYXRlIGFycmF5IGZvciBpMThuIHByb2Nlc3NpbmcsIGJ1dCBhbHNvIGtlZXAgc3VjaFxuICAgICAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGVzIGluIHRoZSBtYWluIGxpc3QgdG8gbWFrZSB0aGVtIGF2YWlsYWJsZSBmb3IgZGlyZWN0aXZlIG1hdGNoaW5nIGF0IHJ1bnRpbWUuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oRlctMTI0OCk6IHByZXZlbnQgYXR0cmlidXRlcyBkdXBsaWNhdGlvbiBpbiBgaTE4bkF0dHJpYnV0ZXNgIGFuZCBgZWxlbWVudFN0YXJ0YFxuICAgICAgICAgICAgICAgICAgICAvLyBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgaTE4bkF0dHJzLnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsT3RoZXJJbnB1dHMucHVzaChpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0QXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgaWYgKGF0dHIubmFtZSA9PT0gTkdfUFJPSkVDVF9BU19BVFRSX05BTUUpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnB1c2guYXBwbHkoYXR0cmlidXRlcywgX19zcHJlYWQoZ2V0TmdQcm9qZWN0QXNMaXRlcmFsKGF0dHIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnB1c2guYXBwbHkoYXR0cmlidXRlcywgX19zcHJlYWQoZ2V0QXR0cmlidXRlTmFtZUxpdGVyYWxzKGF0dHIubmFtZSksIFtsaXRlcmFsKGF0dHIudmFsdWUpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gYWRkIGF0dHJpYnV0ZXMgZm9yIGRpcmVjdGl2ZSBhbmQgcHJvamVjdGlvbiBtYXRjaGluZyBwdXJwb3Nlc1xuICAgICAgICBhdHRyaWJ1dGVzLnB1c2guYXBwbHkoYXR0cmlidXRlcywgX19zcHJlYWQodGhpcy5wcmVwYXJlTm9uUmVuZGVyQXR0cnMoYWxsT3RoZXJJbnB1dHMsIGVsZW1lbnQub3V0cHV0cywgc3R5bGluZ0J1aWxkZXIsIFtdLCBpMThuQXR0cnMpKSk7XG4gICAgICAgIHBhcmFtZXRlcnMucHVzaCh0aGlzLnRvQXR0cnNQYXJhbShhdHRyaWJ1dGVzKSk7XG4gICAgICAgIC8vIGxvY2FsIHJlZnMgKGV4LjogPGRpdiAjZm9vICNiYXI9XCJiYXpcIj4pXG4gICAgICAgIHBhcmFtZXRlcnMucHVzaCh0aGlzLnByZXBhcmVSZWZzUGFyYW1ldGVyKGVsZW1lbnQucmVmZXJlbmNlcykpO1xuICAgICAgICB2YXIgd2FzSW5OYW1lc3BhY2UgPSB0aGlzLl9uYW1lc3BhY2U7XG4gICAgICAgIHZhciBjdXJyZW50TmFtZXNwYWNlID0gdGhpcy5nZXROYW1lc3BhY2VJbnN0cnVjdGlvbihuYW1lc3BhY2VLZXkpO1xuICAgICAgICAvLyBJZiB0aGUgbmFtZXNwYWNlIGlzIGNoYW5naW5nIG5vdywgaW5jbHVkZSBhbiBpbnN0cnVjdGlvbiB0byBjaGFuZ2UgaXRcbiAgICAgICAgLy8gZHVyaW5nIGVsZW1lbnQgY3JlYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50TmFtZXNwYWNlICE9PSB3YXNJbk5hbWVzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5hZGROYW1lc3BhY2VJbnN0cnVjdGlvbihjdXJyZW50TmFtZXNwYWNlLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pMThuKSB7XG4gICAgICAgICAgICB0aGlzLmkxOG4uYXBwZW5kRWxlbWVudChlbGVtZW50LmkxOG4sIGVsZW1lbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGRvIG5vdCBhcHBlbmQgdGV4dCBub2RlIGluc3RydWN0aW9ucyBhbmQgSUNVcyBpbnNpZGUgaTE4biBzZWN0aW9uLFxuICAgICAgICAvLyBzbyB3ZSBleGNsdWRlIHRoZW0gd2hpbGUgY2FsY3VsYXRpbmcgd2hldGhlciBjdXJyZW50IGVsZW1lbnQgaGFzIGNoaWxkcmVuXG4gICAgICAgIHZhciBoYXNDaGlsZHJlbiA9ICghaXNJMThuUm9vdEVsZW1lbnQgJiYgdGhpcy5pMThuKSA/ICFoYXNUZXh0Q2hpbGRyZW5Pbmx5KGVsZW1lbnQuY2hpbGRyZW4pIDpcbiAgICAgICAgICAgIGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgICAgICAgdmFyIGNyZWF0ZVNlbGZDbG9zaW5nSW5zdHJ1Y3Rpb24gPSAhc3R5bGluZ0J1aWxkZXIuaGFzQmluZGluZ3MgJiZcbiAgICAgICAgICAgIGVsZW1lbnQub3V0cHV0cy5sZW5ndGggPT09IDAgJiYgaTE4bkF0dHJzLmxlbmd0aCA9PT0gMCAmJiAhaGFzQ2hpbGRyZW47XG4gICAgICAgIHZhciBjcmVhdGVTZWxmQ2xvc2luZ0kxOG5JbnN0cnVjdGlvbiA9ICFjcmVhdGVTZWxmQ2xvc2luZ0luc3RydWN0aW9uICYmXG4gICAgICAgICAgICAhc3R5bGluZ0J1aWxkZXIuaGFzQmluZGluZ3MgJiYgaGFzVGV4dENoaWxkcmVuT25seShlbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgICAgaWYgKGNyZWF0ZVNlbGZDbG9zaW5nSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihlbGVtZW50LnNvdXJjZVNwYW4sIGlzTmdDb250YWluZXIkMSA/IElkZW50aWZpZXJzJDEuZWxlbWVudENvbnRhaW5lciA6IElkZW50aWZpZXJzJDEuZWxlbWVudCwgdHJpbVRyYWlsaW5nTnVsbHMocGFyYW1ldGVycykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKGVsZW1lbnQuc291cmNlU3BhbiwgaXNOZ0NvbnRhaW5lciQxID8gSWRlbnRpZmllcnMkMS5lbGVtZW50Q29udGFpbmVyU3RhcnQgOiBJZGVudGlmaWVycyQxLmVsZW1lbnRTdGFydCwgdHJpbVRyYWlsaW5nTnVsbHMocGFyYW1ldGVycykpO1xuICAgICAgICAgICAgaWYgKGlzTm9uQmluZGFibGVNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKGVsZW1lbnQuc291cmNlU3BhbiwgSWRlbnRpZmllcnMkMS5kaXNhYmxlQmluZGluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJvY2VzcyBpMThuIGVsZW1lbnQgYXR0cmlidXRlc1xuICAgICAgICAgICAgaWYgKGkxOG5BdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzQmluZGluZ3NfMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBpMThuQXR0ckFyZ3NfMSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nc18xID0gW107XG4gICAgICAgICAgICAgICAgaTE4bkF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBhdHRyLmkxOG47XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyIGluc3RhbmNlb2YgVGV4dEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaTE4bkF0dHJBcmdzXzEucHVzaChsaXRlcmFsKGF0dHIubmFtZSksIF90aGlzLmkxOG5UcmFuc2xhdGUobWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRlZCA9IGF0dHIudmFsdWUudmlzaXQoX3RoaXMuX3ZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFsbG9jYXRlQmluZGluZ1Nsb3RzKGNvbnZlcnRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udmVydGVkIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlcnMgPSBhc3NlbWJsZUJvdW5kVGV4dFBsYWNlaG9sZGVycyhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gcGxhY2Vob2xkZXJzVG9QYXJhbXMocGxhY2Vob2xkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpMThuQXR0ckFyZ3NfMS5wdXNoKGxpdGVyYWwoYXR0ci5uYW1lKSwgX3RoaXMuaTE4blRyYW5zbGF0ZShtZXNzYWdlLCBwYXJhbXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0ZWQuZXhwcmVzc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNCaW5kaW5nc18xID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZ3NfMS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGVsZW1lbnQuc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb252ZXJ0RXhwcmVzc2lvbkJpbmRpbmcoZXhwcmVzc2lvbik7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoYmluZGluZ3NfMS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbkNoYWluKGVsZW1lbnRJbmRleCwgSWRlbnRpZmllcnMkMS5pMThuRXhwLCBiaW5kaW5nc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkxOG5BdHRyQXJnc18xLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBsaXRlcmFsKHRoaXMuYWxsb2NhdGVEYXRhU2xvdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLmNvbnN0YW50UG9vbC5nZXRDb25zdExpdGVyYWwobGl0ZXJhbEFycihpMThuQXR0ckFyZ3NfMSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudC5zb3VyY2VTcGFuLCBJZGVudGlmaWVycyQxLmkxOG5BdHRyaWJ1dGVzLCBbaW5kZXgsIGFyZ3NdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0JpbmRpbmdzXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb24oZWxlbWVudEluZGV4LCBlbGVtZW50LnNvdXJjZVNwYW4sIElkZW50aWZpZXJzJDEuaTE4bkFwcGx5LCBbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBzdHlsZSBiaW5kaW5ncyBjb2RlIGlzIHBsYWNlZCBpbnRvIHR3byBkaXN0aW5jdCBibG9ja3Mgd2l0aGluIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvbiBBT1RcbiAgICAgICAgICAgIC8vIGNvZGU6IGNyZWF0aW9uIGFuZCB1cGRhdGUuIFRoZSBjcmVhdGlvbiBjb2RlIGNvbnRhaW5zIHRoZSBgc3R5bGluZ2AgaW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICAvLyB3aGljaCB3aWxsIGFwcGx5IHRoZSBjb2xsZWN0ZWQgYmluZGluZyB2YWx1ZXMgdG8gdGhlIGVsZW1lbnQuIGBzdHlsaW5nYCBpc1xuICAgICAgICAgICAgLy8gZGVzaWduZWQgdG8gcnVuIGluc2lkZSBvZiBgZWxlbWVudFN0YXJ0YCBhbmQgYGVsZW1lbnRFbmRgLiBUaGUgdXBkYXRlIGluc3RydWN0aW9uc1xuICAgICAgICAgICAgLy8gKHRoaW5ncyBsaWtlIGBzdHlsZVByb3BgLCBgY2xhc3NQcm9wYCwgZXRjLi4pIGFyZSBhcHBsaWVkIGxhdGVyIG9uIGluIHRoaXNcbiAgICAgICAgICAgIC8vIGZpbGVcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1N0eWxpbmdJbnN0cnVjdGlvbihlbGVtZW50SW5kZXgsIHN0eWxpbmdCdWlsZGVyLmJ1aWxkU3R5bGluZ0luc3RydWN0aW9uKGVsZW1lbnQuc291cmNlU3BhbiwgdGhpcy5jb25zdGFudFBvb2wpLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIExpc3RlbmVycyAob3V0cHV0cylcbiAgICAgICAgICAgIGVsZW1lbnQub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChvdXRwdXRBc3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKG91dHB1dEFzdC5zb3VyY2VTcGFuLCBJZGVudGlmaWVycyQxLmxpc3RlbmVyLCBfdGhpcy5wcmVwYXJlTGlzdGVuZXJQYXJhbWV0ZXIoZWxlbWVudC5uYW1lLCBvdXRwdXRBc3QsIGVsZW1lbnRJbmRleCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBOb3RlOiBpdCdzIGltcG9ydGFudCB0byBrZWVwIGkxOG4vaTE4blN0YXJ0IGluc3RydWN0aW9ucyBhZnRlciBpMThuQXR0cmlidXRlcyBhbmRcbiAgICAgICAgICAgIC8vIGxpc3RlbmVycywgdG8gbWFrZSBzdXJlIGkxOG5BdHRyaWJ1dGVzIGluc3RydWN0aW9uIHRhcmdldHMgY3VycmVudCBlbGVtZW50IGF0IHJ1bnRpbWUuXG4gICAgICAgICAgICBpZiAoaXNJMThuUm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmkxOG5TdGFydChlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuaTE4biwgY3JlYXRlU2VsZkNsb3NpbmdJMThuSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBjb2RlIGhlcmUgd2lsbCBjb2xsZWN0IGFsbCB1cGRhdGUtbGV2ZWwgc3R5bGluZyBpbnN0cnVjdGlvbnMgYW5kIGFkZCB0aGVtIHRvIHRoZVxuICAgICAgICAvLyB1cGRhdGUgYmxvY2sgb2YgdGhlIHRlbXBsYXRlIGZ1bmN0aW9uIEFPVCBjb2RlLiBJbnN0cnVjdGlvbnMgbGlrZSBgc3R5bGVQcm9wYCxcbiAgICAgICAgLy8gYHN0eWxlTWFwYCwgYGNsYXNzTWFwYCwgYGNsYXNzUHJvcGAgYW5kIGBzdHlsaW5nQXBwbHlgXG4gICAgICAgIC8vIGFyZSBhbGwgZ2VuZXJhdGVkIGFuZCBhc3NpZ25lZCBpbiB0aGUgY29kZSBiZWxvdy5cbiAgICAgICAgdmFyIHN0eWxpbmdJbnN0cnVjdGlvbnMgPSBzdHlsaW5nQnVpbGRlci5idWlsZFVwZGF0ZUxldmVsSW5zdHJ1Y3Rpb25zKHRoaXMuX3ZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgdmFyIGxpbWl0ID0gc3R5bGluZ0luc3RydWN0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsaW1pdDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5zdHJ1Y3Rpb25fMSA9IHN0eWxpbmdJbnN0cnVjdGlvbnNbaV07XG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5nU2xvdHMgKz0gaW5zdHJ1Y3Rpb25fMS5hbGxvY2F0ZUJpbmRpbmdTbG90cztcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1N0eWxpbmdJbnN0cnVjdGlvbihlbGVtZW50SW5kZXgsIGluc3RydWN0aW9uXzEsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgcmVhc29uIHdoeSBgdW5kZWZpbmVkYCBpcyB1c2VkIGlzIGJlY2F1c2UgdGhlIHJlbmRlcmVyIHVuZGVyc3RhbmRzIHRoaXMgYXMgYVxuICAgICAgICAvLyBzcGVjaWFsIHZhbHVlIHRvIHN5bWJvbGl6ZSB0aGF0IHRoZXJlIGlzIG5vIFJIUyB0byB0aGlzIGJpbmRpbmdcbiAgICAgICAgLy8gVE9ETyAobWF0c2tvKTogcmV2aXNpdCB0aGlzIG9uY2UgRlctOTU5IGlzIGFwcHJvYWNoZWRcbiAgICAgICAgdmFyIGVtcHR5VmFsdWVCaW5kSW5zdHJ1Y3Rpb24gPSBsaXRlcmFsKHVuZGVmaW5lZCk7XG4gICAgICAgIHZhciBwcm9wZXJ0eUJpbmRpbmdzID0gW107XG4gICAgICAgIHZhciBhdHRyaWJ1dGVCaW5kaW5ncyA9IFtdO1xuICAgICAgICAvLyBHZW5lcmF0ZSBlbGVtZW50IGlucHV0IGJpbmRpbmdzXG4gICAgICAgIGFsbE90aGVySW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRUeXBlID0gaW5wdXQudHlwZTtcbiAgICAgICAgICAgIGlmIChpbnB1dFR5cGUgPT09IDQgLyogQW5pbWF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlXzEgPSBpbnB1dC52YWx1ZS52aXNpdChfdGhpcy5fdmFsdWVDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgICAgIC8vIGFuaW1hdGlvbiBiaW5kaW5ncyBjYW4gYmUgcHJlc2VudGVkIGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0czpcbiAgICAgICAgICAgICAgICAvLyAxLiBbQGJpbmRpbmddPVwiZm9vRXhwXCJcbiAgICAgICAgICAgICAgICAvLyAyLiBbQGJpbmRpbmddPVwie3ZhbHVlOmZvb0V4cCwgcGFyYW1zOnsuLi59fVwiXG4gICAgICAgICAgICAgICAgLy8gMy4gW0BiaW5kaW5nXVxuICAgICAgICAgICAgICAgIC8vIDQuIEBiaW5kaW5nXG4gICAgICAgICAgICAgICAgLy8gQWxsIGZvcm1hdHMgd2lsbCBiZSB2YWxpZCBmb3Igd2hlbiBhIHN5bnRoZXRpYyBiaW5kaW5nIGlzIGNyZWF0ZWQuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlYXNvbmluZyBmb3IgdGhpcyBpcyBiZWNhdXNlIHRoZSByZW5kZXJlciBzaG91bGQgZ2V0IGVhY2hcbiAgICAgICAgICAgICAgICAvLyBzeW50aGV0aWMgYmluZGluZyB2YWx1ZSBpbiB0aGUgb3JkZXIgb2YgdGhlIGFycmF5IHRoYXQgdGhleSBhcmVcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmVkIGluLi4uXG4gICAgICAgICAgICAgICAgdmFyIGhhc1ZhbHVlXzEgPSB2YWx1ZV8xIGluc3RhbmNlb2YgTGl0ZXJhbFByaW1pdGl2ZSA/ICEhdmFsdWVfMS52YWx1ZSA6IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWxsb2NhdGVCaW5kaW5nU2xvdHModmFsdWVfMSk7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlCaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcHJlcGFyZVN5bnRoZXRpY1Byb3BlcnR5TmFtZShpbnB1dC5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU3BhbjogaW5wdXQuc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc1ZhbHVlXzEgPyBfdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZhbHVlXzEpIDogZW1wdHlWYWx1ZUJpbmRJbnN0cnVjdGlvbjsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgbXVzdCBza2lwIGF0dHJpYnV0ZXMgd2l0aCBhc3NvY2lhdGVkIGkxOG4gY29udGV4dCwgc2luY2UgdGhlc2UgYXR0cmlidXRlcyBhcmUgaGFuZGxlZFxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRlbHkgYW5kIGNvcnJlc3BvbmRpbmcgYGkxOG5FeHBgIGFuZCBgaTE4bkFwcGx5YCBpbnN0cnVjdGlvbnMgd2lsbCBiZSBnZW5lcmF0ZWRcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuaTE4bilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZV8yID0gaW5wdXQudmFsdWUudmlzaXQoX3RoaXMuX3ZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVfMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXNfMiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoc3BsaXROc05hbWUoaW5wdXQubmFtZSksIDIpLCBhdHRyTmFtZXNwYWNlID0gX2FbMF0sIGF0dHJOYW1lXzEgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzQXR0cmlidXRlQmluZGluZyA9IGlucHV0VHlwZSA9PT0gMSAvKiBBdHRyaWJ1dGUgKi87XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYW5pdGl6YXRpb25SZWYgPSByZXNvbHZlU2FuaXRpemF0aW9uRm4oaW5wdXQuc2VjdXJpdHlDb250ZXh0LCBpc0F0dHJpYnV0ZUJpbmRpbmcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2FuaXRpemF0aW9uUmVmKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zXzIucHVzaChzYW5pdGl6YXRpb25SZWYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ck5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVzcGFjZUxpdGVyYWwgPSBsaXRlcmFsKGF0dHJOYW1lc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNhbml0aXphdGlvblJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc18yLnB1c2gobmFtZXNwYWNlTGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXNuJ3QgYSBzYW5pdGl6YXRpb24gcmVmLCB3ZSBuZWVkIHRvIGFkZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuIGV4dHJhIHBhcmFtIHNvIHRoYXQgd2UgY2FuIHBhc3MgaW4gdGhlIG5hbWVzcGFjZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNfMi5wdXNoKGxpdGVyYWwobnVsbCksIG5hbWVzcGFjZUxpdGVyYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFsbG9jYXRlQmluZGluZ1Nsb3RzKHZhbHVlXzIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRUeXBlID09PSAwIC8qIFByb3BlcnR5ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVfMiBpbnN0YW5jZW9mIEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wPVwie3t2YWx1ZX19XCIgYW5kIGZyaWVuZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnRlcnBvbGF0ZWRVcGRhdGVJbnN0cnVjdGlvbihnZXRQcm9wZXJ0eUludGVycG9sYXRpb25FeHByZXNzaW9uKHZhbHVlXzIpLCBlbGVtZW50SW5kZXgsIGF0dHJOYW1lXzEsIGlucHV0LCB2YWx1ZV8yLCBwYXJhbXNfMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBbcHJvcF09XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGVjdCBhbGwgdGhlIHByb3BlcnRpZXMgc28gdGhhdCB3ZSBjYW4gY2hhaW4gaW50byBhIHNpbmdsZSBmdW5jdGlvbiBhdCB0aGUgZW5kLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5QmluZGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJOYW1lXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGlucHV0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZhbHVlXzIpOyB9LCBwYXJhbXM6IHBhcmFtc18yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXRUeXBlID09PSAxIC8qIEF0dHJpYnV0ZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlXzIgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uICYmIGdldEludGVycG9sYXRpb25BcmdzTGVuZ3RoKHZhbHVlXzIpID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0dHIubmFtZT1cInRleHR7e3ZhbHVlfX1cIiBhbmQgZnJpZW5kc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmludGVycG9sYXRlZFVwZGF0ZUluc3RydWN0aW9uKGdldEF0dHJpYnV0ZUludGVycG9sYXRpb25FeHByZXNzaW9uKHZhbHVlXzIpLCBlbGVtZW50SW5kZXgsIGF0dHJOYW1lXzEsIGlucHV0LCB2YWx1ZV8yLCBwYXJhbXNfMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRWYWx1ZV8xID0gdmFsdWVfMiBpbnN0YW5jZW9mIEludGVycG9sYXRpb24gPyB2YWx1ZV8yLmV4cHJlc3Npb25zWzBdIDogdmFsdWVfMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBbYXR0ci5uYW1lXT1cInZhbHVlXCIgb3IgYXR0ci5uYW1lPVwie3t2YWx1ZX19XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb2xsZWN0IHRoZSBhdHRyaWJ1dGUgYmluZGluZ3Mgc28gdGhhdCB0aGV5IGNhbiBiZSBjaGFpbmVkIGF0IHRoZSBlbmQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlQmluZGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJOYW1lXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGlucHV0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKGJvdW5kVmFsdWVfMSk7IH0sIHBhcmFtczogcGFyYW1zXzJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsYXNzIHByb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZUluc3RydWN0aW9uKGVsZW1lbnRJbmRleCwgaW5wdXQuc291cmNlU3BhbiwgSWRlbnRpZmllcnMkMS5jbGFzc1Byb3AsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19zcHJlYWQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXRlcmFsKGVsZW1lbnRJbmRleCksIGxpdGVyYWwoYXR0ck5hbWVfMSksIF90aGlzLmNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcodmFsdWVfMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLCBwYXJhbXNfMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm9wZXJ0eUJpbmRpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb25DaGFpbihlbGVtZW50SW5kZXgsIElkZW50aWZpZXJzJDEucHJvcGVydHksIHByb3BlcnR5QmluZGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGVCaW5kaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uQ2hhaW4oZWxlbWVudEluZGV4LCBJZGVudGlmaWVycyQxLmF0dHJpYnV0ZSwgYXR0cmlidXRlQmluZGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyYXZlcnNlIGVsZW1lbnQgY2hpbGQgbm9kZXNcbiAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgIGlmICghaXNJMThuUm9vdEVsZW1lbnQgJiYgdGhpcy5pMThuKSB7XG4gICAgICAgICAgICB0aGlzLmkxOG4uYXBwZW5kRWxlbWVudChlbGVtZW50LmkxOG4sIGVsZW1lbnRJbmRleCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjcmVhdGVTZWxmQ2xvc2luZ0luc3RydWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBGaW5pc2ggZWxlbWVudCBjb25zdHJ1Y3Rpb24gbW9kZS5cbiAgICAgICAgICAgIHZhciBzcGFuID0gZWxlbWVudC5lbmRTb3VyY2VTcGFuIHx8IGVsZW1lbnQuc291cmNlU3BhbjtcbiAgICAgICAgICAgIGlmIChpc0kxOG5Sb290RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaTE4bkVuZChzcGFuLCBjcmVhdGVTZWxmQ2xvc2luZ0kxOG5JbnN0cnVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOb25CaW5kYWJsZU1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oc3BhbiwgSWRlbnRpZmllcnMkMS5lbmFibGVCaW5kaW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oc3BhbiwgaXNOZ0NvbnRhaW5lciQxID8gSWRlbnRpZmllcnMkMS5lbGVtZW50Q29udGFpbmVyRW5kIDogSWRlbnRpZmllcnMkMS5lbGVtZW50RW5kKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiB1cGRhdGUgaW5zdHJ1Y3Rpb24gZm9yIGFuIGludGVycG9sYXRlZCBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUsIHN1Y2ggYXNcbiAgICAgKiBgcHJvcD1cInt7dmFsdWV9fVwiYCBvciBgYXR0ci50aXRsZT1cInt7dmFsdWV9fVwiYFxuICAgICAqL1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmludGVycG9sYXRlZFVwZGF0ZUluc3RydWN0aW9uID0gZnVuY3Rpb24gKGluc3RydWN0aW9uLCBlbGVtZW50SW5kZXgsIGF0dHJOYW1lLCBpbnB1dCwgdmFsdWUsIHBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uKGVsZW1lbnRJbmRleCwgaW5wdXQuc291cmNlU3BhbiwgaW5zdHJ1Y3Rpb24sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fc3ByZWFkKFtsaXRlcmFsKGF0dHJOYW1lKV0sIF90aGlzLmdldFVwZGF0ZUluc3RydWN0aW9uQXJndW1lbnRzKHZhbHVlKSwgcGFyYW1zKTsgfSk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdFRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBOR19URU1QTEFURV9UQUdfTkFNRSA9ICduZy10ZW1wbGF0ZSc7XG4gICAgICAgIHZhciB0ZW1wbGF0ZUluZGV4ID0gdGhpcy5hbGxvY2F0ZURhdGFTbG90KCk7XG4gICAgICAgIGlmICh0aGlzLmkxOG4pIHtcbiAgICAgICAgICAgIHRoaXMuaTE4bi5hcHBlbmRUZW1wbGF0ZSh0ZW1wbGF0ZS5pMThuLCB0ZW1wbGF0ZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFnTmFtZSA9IHNhbml0aXplSWRlbnRpZmllcih0ZW1wbGF0ZS50YWdOYW1lIHx8ICcnKTtcbiAgICAgICAgdmFyIGNvbnRleHROYW1lID0gXCJcIiArIHRoaXMuY29udGV4dE5hbWUgKyAodGFnTmFtZSA/ICdfJyArIHRhZ05hbWUgOiAnJykgKyBcIl9cIiArIHRlbXBsYXRlSW5kZXg7XG4gICAgICAgIHZhciB0ZW1wbGF0ZU5hbWUgPSBjb250ZXh0TmFtZSArIFwiX1RlbXBsYXRlXCI7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgbGl0ZXJhbCh0ZW1wbGF0ZUluZGV4KSxcbiAgICAgICAgICAgIHZhcmlhYmxlKHRlbXBsYXRlTmFtZSksXG4gICAgICAgICAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IHRoZSB0YWcncyBuYW1lc3BhY2UgaGVyZSwgYmVjYXVzZSB3ZSBpbmZlclxuICAgICAgICAgICAgLy8gaXQgYmFzZWQgb24gdGhlIHBhcmVudCBub2RlcyBpbnNpZGUgdGhlIHRlbXBsYXRlIGluc3RydWN0aW9uLlxuICAgICAgICAgICAgbGl0ZXJhbCh0ZW1wbGF0ZS50YWdOYW1lID8gc3BsaXROc05hbWUodGVtcGxhdGUudGFnTmFtZSlbMV0gOiB0ZW1wbGF0ZS50YWdOYW1lKSxcbiAgICAgICAgXTtcbiAgICAgICAgLy8gZmluZCBkaXJlY3RpdmVzIG1hdGNoaW5nIG9uIGEgZ2l2ZW4gPG5nLXRlbXBsYXRlPiBub2RlXG4gICAgICAgIHRoaXMubWF0Y2hEaXJlY3RpdmVzKE5HX1RFTVBMQVRFX1RBR19OQU1FLCB0ZW1wbGF0ZSk7XG4gICAgICAgIC8vIHByZXBhcmUgYXR0cmlidXRlcyBwYXJhbWV0ZXIgKGluY2x1ZGluZyBhdHRyaWJ1dGVzIHVzZWQgZm9yIGRpcmVjdGl2ZSBtYXRjaGluZylcbiAgICAgICAgdmFyIGF0dHJzRXhwcnMgPSBbXTtcbiAgICAgICAgdGVtcGxhdGUuYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7IGF0dHJzRXhwcnMucHVzaChhc0xpdGVyYWwoYS5uYW1lKSwgYXNMaXRlcmFsKGEudmFsdWUpKTsgfSk7XG4gICAgICAgIGF0dHJzRXhwcnMucHVzaC5hcHBseShhdHRyc0V4cHJzLCBfX3NwcmVhZCh0aGlzLnByZXBhcmVOb25SZW5kZXJBdHRycyh0ZW1wbGF0ZS5pbnB1dHMsIHRlbXBsYXRlLm91dHB1dHMsIHVuZGVmaW5lZCwgdGVtcGxhdGUudGVtcGxhdGVBdHRycykpKTtcbiAgICAgICAgcGFyYW1ldGVycy5wdXNoKHRoaXMudG9BdHRyc1BhcmFtKGF0dHJzRXhwcnMpKTtcbiAgICAgICAgLy8gbG9jYWwgcmVmcyAoZXguOiA8bmctdGVtcGxhdGUgI2Zvbz4pXG4gICAgICAgIGlmICh0ZW1wbGF0ZS5yZWZlcmVuY2VzICYmIHRlbXBsYXRlLnJlZmVyZW5jZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2godGhpcy5wcmVwYXJlUmVmc1BhcmFtZXRlcih0ZW1wbGF0ZS5yZWZlcmVuY2VzKSk7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2goaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLnRlbXBsYXRlUmVmRXh0cmFjdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvblxuICAgICAgICB2YXIgdGVtcGxhdGVWaXNpdG9yID0gbmV3IFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIodGhpcy5jb25zdGFudFBvb2wsIHRoaXMuX2JpbmRpbmdTY29wZSwgdGhpcy5sZXZlbCArIDEsIGNvbnRleHROYW1lLCB0aGlzLmkxOG4sIHRlbXBsYXRlSW5kZXgsIHRlbXBsYXRlTmFtZSwgdGhpcy5kaXJlY3RpdmVNYXRjaGVyLCB0aGlzLmRpcmVjdGl2ZXMsIHRoaXMucGlwZVR5cGVCeU5hbWUsIHRoaXMucGlwZXMsIHRoaXMuX25hbWVzcGFjZSwgdGhpcy5maWxlQmFzZWRJMThuU3VmZml4LCB0aGlzLmkxOG5Vc2VFeHRlcm5hbElkcyk7XG4gICAgICAgIC8vIE5lc3RlZCB0ZW1wbGF0ZXMgbXVzdCBub3QgYmUgdmlzaXRlZCB1bnRpbCBhZnRlciB0aGVpciBwYXJlbnQgdGVtcGxhdGVzIGhhdmUgY29tcGxldGVkXG4gICAgICAgIC8vIHByb2Nlc3NpbmcsIHNvIHRoZXkgYXJlIHF1ZXVlZCBoZXJlIHVudGlsIGFmdGVyIHRoZSBpbml0aWFsIHBhc3MuIE90aGVyd2lzZSwgd2Ugd291bGRuJ3RcbiAgICAgICAgLy8gYmUgYWJsZSB0byBzdXBwb3J0IGJpbmRpbmdzIGluIG5lc3RlZCB0ZW1wbGF0ZXMgdG8gbG9jYWwgcmVmcyB0aGF0IG9jY3VyIGFmdGVyIHRoZVxuICAgICAgICAvLyB0ZW1wbGF0ZSBkZWZpbml0aW9uLiBlLmcuIDxkaXYgKm5nSWY9XCJzaG93aW5nXCI+e3sgZm9vIH19PC9kaXY+ICA8ZGl2ICNmb28+PC9kaXY+XG4gICAgICAgIHRoaXMuX25lc3RlZFRlbXBsYXRlRm5zLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlRnVuY3Rpb25FeHByID0gdGVtcGxhdGVWaXNpdG9yLmJ1aWxkVGVtcGxhdGVGdW5jdGlvbih0ZW1wbGF0ZS5jaGlsZHJlbiwgdGVtcGxhdGUudmFyaWFibGVzLCBfdGhpcy5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cy5sZW5ndGggKyBfdGhpcy5fbmdDb250ZW50U2VsZWN0b3JzT2Zmc2V0LCB0ZW1wbGF0ZS5pMThuKTtcbiAgICAgICAgICAgIF90aGlzLmNvbnN0YW50UG9vbC5zdGF0ZW1lbnRzLnB1c2godGVtcGxhdGVGdW5jdGlvbkV4cHIudG9EZWNsU3RtdCh0ZW1wbGF0ZU5hbWUsIG51bGwpKTtcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZVZpc2l0b3IuX25nQ29udGVudFJlc2VydmVkU2xvdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgKF9hID0gX3RoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMpLnB1c2guYXBwbHkoX2EsIF9fc3ByZWFkKHRlbXBsYXRlVmlzaXRvci5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZS5nLiB0ZW1wbGF0ZSgxLCBNeUNvbXBfVGVtcGxhdGVfMSlcbiAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKHRlbXBsYXRlLnNvdXJjZVNwYW4sIElkZW50aWZpZXJzJDEudGVtcGxhdGVDcmVhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuc3BsaWNlKDIsIDAsIGxpdGVyYWwodGVtcGxhdGVWaXNpdG9yLmdldENvbnN0Q291bnQoKSksIGxpdGVyYWwodGVtcGxhdGVWaXNpdG9yLmdldFZhckNvdW50KCkpKTtcbiAgICAgICAgICAgIHJldHVybiB0cmltVHJhaWxpbmdOdWxscyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGhhbmRsZSBwcm9wZXJ0eSBiaW5kaW5ncyBlLmcuIMm1ybVwcm9wZXJ0eSgnbmdGb3JPZicsIGN0eC5pdGVtcyksIGV0IGFsO1xuICAgICAgICB0aGlzLnRlbXBsYXRlUHJvcGVydHlCaW5kaW5ncyh0ZW1wbGF0ZUluZGV4LCB0ZW1wbGF0ZS50ZW1wbGF0ZUF0dHJzKTtcbiAgICAgICAgLy8gT25seSBhZGQgbm9ybWFsIGlucHV0L291dHB1dCBiaW5kaW5nIGluc3RydWN0aW9ucyBvbiBleHBsaWNpdCBuZy10ZW1wbGF0ZSBlbGVtZW50cy5cbiAgICAgICAgaWYgKHRlbXBsYXRlLnRhZ05hbWUgPT09IE5HX1RFTVBMQVRFX1RBR19OQU1FKSB7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGlucHV0IGJpbmRpbmdzXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlUHJvcGVydHlCaW5kaW5ncyh0ZW1wbGF0ZUluZGV4LCB0ZW1wbGF0ZS5pbnB1dHMpO1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgbGlzdGVuZXJzIGZvciBkaXJlY3RpdmUgb3V0cHV0XG4gICAgICAgICAgICB0ZW1wbGF0ZS5vdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dEFzdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24ob3V0cHV0QXN0LnNvdXJjZVNwYW4sIElkZW50aWZpZXJzJDEubGlzdGVuZXIsIF90aGlzLnByZXBhcmVMaXN0ZW5lclBhcmFtZXRlcignbmdfdGVtcGxhdGUnLCBvdXRwdXRBc3QsIHRlbXBsYXRlSW5kZXgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdEJvdW5kVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmkxOG4pIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZV8zID0gdGV4dC52YWx1ZS52aXNpdCh0aGlzLl92YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgICAgICB0aGlzLmFsbG9jYXRlQmluZGluZ1Nsb3RzKHZhbHVlXzMpO1xuICAgICAgICAgICAgaWYgKHZhbHVlXzMgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pMThuLmFwcGVuZEJvdW5kVGV4dCh0ZXh0LmkxOG4pO1xuICAgICAgICAgICAgICAgIHRoaXMuaTE4bkFwcGVuZEJpbmRpbmdzKHZhbHVlXzMuZXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlSW5kZXggPSB0aGlzLmFsbG9jYXRlRGF0YVNsb3QoKTtcbiAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKHRleHQuc291cmNlU3BhbiwgSWRlbnRpZmllcnMkMS50ZXh0LCBbbGl0ZXJhbChub2RlSW5kZXgpXSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRleHQudmFsdWUudmlzaXQodGhpcy5fdmFsdWVDb252ZXJ0ZXIpO1xuICAgICAgICB0aGlzLmFsbG9jYXRlQmluZGluZ1Nsb3RzKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbihub2RlSW5kZXgsIHRleHQuc291cmNlU3BhbiwgZ2V0VGV4dEludGVycG9sYXRpb25FeHByZXNzaW9uKHZhbHVlKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2V0VXBkYXRlSW5zdHJ1Y3Rpb25Bcmd1bWVudHModmFsdWUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb24obm9kZUluZGV4LCB0ZXh0LnNvdXJjZVNwYW4sIElkZW50aWZpZXJzJDEudGV4dEJpbmRpbmcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtfdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZhbHVlKV07IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAvLyB3aGVuIGEgdGV4dCBlbGVtZW50IGlzIGxvY2F0ZWQgd2l0aGluIGEgdHJhbnNsYXRhYmxlXG4gICAgICAgIC8vIGJsb2NrLCB3ZSBleGNsdWRlIHRoaXMgdGV4dCBlbGVtZW50IGZyb20gaW5zdHJ1Y3Rpb25zIHNldCxcbiAgICAgICAgLy8gc2luY2UgaXQgd2lsbCBiZSBjYXB0dXJlZCBpbiBpMThuIGNvbnRlbnQgYW5kIHByb2Nlc3NlZCBhdCBydW50aW1lXG4gICAgICAgIGlmICghdGhpcy5pMThuKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24odGV4dC5zb3VyY2VTcGFuLCBJZGVudGlmaWVycyQxLnRleHQsIFtsaXRlcmFsKHRoaXMuYWxsb2NhdGVEYXRhU2xvdCgpKSwgbGl0ZXJhbCh0ZXh0LnZhbHVlKV0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGluaXRXYXNJbnZva2VkID0gZmFsc2U7XG4gICAgICAgIC8vIGlmIGFuIElDVSB3YXMgY3JlYXRlZCBvdXRzaWRlIG9mIGkxOG4gYmxvY2ssIHdlIHN0aWxsIHRyZWF0XG4gICAgICAgIC8vIGl0IGFzIGEgdHJhbnNsYXRhYmxlIGVudGl0eSBhbmQgaW52b2tlIGkxOG5TdGFydCBhbmQgaTE4bkVuZFxuICAgICAgICAvLyB0byBnZW5lcmF0ZSBpMThuIGNvbnRleHQgYW5kIHRoZSBuZWNlc3NhcnkgaW5zdHJ1Y3Rpb25zXG4gICAgICAgIGlmICghdGhpcy5pMThuKSB7XG4gICAgICAgICAgICBpbml0V2FzSW52b2tlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmkxOG5TdGFydChudWxsLCBpY3UuaTE4biwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkxOG4gPSB0aGlzLmkxOG47XG4gICAgICAgIHZhciB2YXJzID0gdGhpcy5pMThuQmluZFByb3BzKGljdS52YXJzKTtcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVycyA9IHRoaXMuaTE4bkJpbmRQcm9wcyhpY3UucGxhY2Vob2xkZXJzKTtcbiAgICAgICAgLy8gb3V0cHV0IElDVSBkaXJlY3RseSBhbmQga2VlcCBJQ1UgcmVmZXJlbmNlIGluIGNvbnRleHRcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBpY3UuaTE4bjtcbiAgICAgICAgLy8gd2UgYWx3YXlzIG5lZWQgcG9zdC1wcm9jZXNzaW5nIGZ1bmN0aW9uIGZvciBJQ1VzLCB0byBtYWtlIHN1cmUgdGhhdDpcbiAgICAgICAgLy8gLSBhbGwgcGxhY2Vob2xkZXJzIGluIGEgZm9ybSBvZiB7UExBQ0VIT0xERVJ9IGFyZSByZXBsYWNlZCB3aXRoIGFjdHVhbCB2YWx1ZXMgKG5vdGU6XG4gICAgICAgIC8vIGBnb29nLmdldE1zZ2AgZG9lcyBub3QgcHJvY2VzcyBJQ1VzIGFuZCB1c2VzIHRoZSBge1BMQUNFSE9MREVSfWAgZm9ybWF0IGZvciBwbGFjZWhvbGRlcnNcbiAgICAgICAgLy8gaW5zaWRlIElDVXMpXG4gICAgICAgIC8vIC0gYWxsIElDVSB2YXJzIChzdWNoIGFzIGBWQVJfU0VMRUNUYCBvciBgVkFSX1BMVVJBTGApIGFyZSByZXBsYWNlZCB3aXRoIGNvcnJlY3QgdmFsdWVzXG4gICAgICAgIHZhciB0cmFuc2Zvcm1GbiA9IGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBfX2Fzc2lnbih7fSwgdmFycywgcGxhY2Vob2xkZXJzKTtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWQgPSBfdGhpcy5pMThuRm9ybWF0UGxhY2Vob2xkZXJOYW1lcyhwYXJhbXMsIC8qIHVzZUNhbWVsQ2FzZSAqLyBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb24obnVsbCwgSWRlbnRpZmllcnMkMS5pMThuUG9zdHByb2Nlc3MsIFtyYXcsIG1hcExpdGVyYWwoZm9ybWF0dGVkLCB0cnVlKV0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSB3aG9sZSBpMThuIG1lc3NhZ2UgaXMgYSBzaW5nbGUgSUNVIC0gd2UgZG8gbm90IG5lZWQgdG9cbiAgICAgICAgLy8gY3JlYXRlIGEgc2VwYXJhdGUgdG9wLWxldmVsIHRyYW5zbGF0aW9uLCB3ZSBjYW4gdXNlIHRoZSByb290IHJlZiBpbnN0ZWFkXG4gICAgICAgIC8vIGFuZCBtYWtlIHRoaXMgSUNVIGEgdG9wLWxldmVsIHRyYW5zbGF0aW9uXG4gICAgICAgIC8vIG5vdGU6IElDVSBwbGFjZWhvbGRlcnMgYXJlIHJlcGxhY2VkIHdpdGggYWN0dWFsIHZhbHVlcyBpbiBgaTE4blBvc3Rwcm9jZXNzYCBmdW5jdGlvblxuICAgICAgICAvLyBzZXBhcmF0ZWx5LCBzbyB3ZSBkbyBub3QgcGFzcyBwbGFjZWhvbGRlcnMgaW50byBgaTE4blRyYW5zbGF0ZWAgZnVuY3Rpb24uXG4gICAgICAgIGlmIChpc1NpbmdsZUkxOG5JY3UoaTE4bi5tZXRhKSkge1xuICAgICAgICAgICAgdGhpcy5pMThuVHJhbnNsYXRlKG1lc3NhZ2UsIC8qIHBsYWNlaG9sZGVycyAqLyB7fSwgaTE4bi5yZWYsIHRyYW5zZm9ybUZuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG91dHB1dCBJQ1UgZGlyZWN0bHkgYW5kIGtlZXAgSUNVIHJlZmVyZW5jZSBpbiBjb250ZXh0XG4gICAgICAgICAgICB2YXIgcmVmID0gdGhpcy5pMThuVHJhbnNsYXRlKG1lc3NhZ2UsIC8qIHBsYWNlaG9sZGVycyAqLyB7fSwgLyogcmVmICovIHVuZGVmaW5lZCwgdHJhbnNmb3JtRm4pO1xuICAgICAgICAgICAgaTE4bi5hcHBlbmRJY3UoaWN1RnJvbUkxOG5NZXNzYWdlKG1lc3NhZ2UpLm5hbWUsIHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRXYXNJbnZva2VkKSB7XG4gICAgICAgICAgICB0aGlzLmkxOG5FbmQobnVsbCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5hbGxvY2F0ZURhdGFTbG90ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YUluZGV4Kys7IH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuZ2V0Q29uc3RDb3VudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGFJbmRleDsgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5nZXRWYXJDb3VudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3B1cmVGdW5jdGlvblNsb3RzOyB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmdldE5nQ29udGVudFNlbGVjdG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMubGVuZ3RoID9cbiAgICAgICAgICAgIHRoaXMuY29uc3RhbnRQb29sLmdldENvbnN0TGl0ZXJhbChhc0xpdGVyYWwodGhpcy5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cyksIHRydWUpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5iaW5kaW5nQ29udGV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiXCIgKyB0aGlzLl9iaW5kaW5nQ29udGV4dCsrOyB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLnRlbXBsYXRlUHJvcGVydHlCaW5kaW5ncyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZUluZGV4LCBhdHRycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvcGVydHlCaW5kaW5ncyA9IFtdO1xuICAgICAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQm91bmRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVfNCA9IGlucHV0LnZhbHVlLnZpc2l0KF90aGlzLl92YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlXzQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hbGxvY2F0ZUJpbmRpbmdTbG90cyh2YWx1ZV80KTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlCaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGlucHV0Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBpbnB1dC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcodmFsdWVfNCk7IH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb3BlcnR5QmluZGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbkNoYWluKHRlbXBsYXRlSW5kZXgsIElkZW50aWZpZXJzJDEucHJvcGVydHksIHByb3BlcnR5QmluZGluZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCaW5kaW5ncyBtdXN0IG9ubHkgYmUgcmVzb2x2ZWQgYWZ0ZXIgYWxsIGxvY2FsIHJlZnMgaGF2ZSBiZWVuIHZpc2l0ZWQsIHNvIGFsbFxuICAgIC8vIGluc3RydWN0aW9ucyBhcmUgcXVldWVkIGluIGNhbGxiYWNrcyB0aGF0IGV4ZWN1dGUgb25jZSB0aGUgaW5pdGlhbCBwYXNzIGhhcyBjb21wbGV0ZWQuXG4gICAgLy8gT3RoZXJ3aXNlLCB3ZSB3b3VsZG4ndCBiZSBhYmxlIHRvIHN1cHBvcnQgbG9jYWwgcmVmcyB0aGF0IGFyZSBkZWZpbmVkIGFmdGVyIHRoZWlyXG4gICAgLy8gYmluZGluZ3MuIGUuZy4ge3sgZm9vIH19IDxkaXYgI2Zvbz48L2Rpdj5cbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5pbnN0cnVjdGlvbkZuID0gZnVuY3Rpb24gKGZucywgc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXNPckZuLCBwcmVwZW5kKSB7XG4gICAgICAgIGlmIChwcmVwZW5kID09PSB2b2lkIDApIHsgcHJlcGVuZCA9IGZhbHNlOyB9XG4gICAgICAgIGZuc1twcmVwZW5kID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gQXJyYXkuaXNBcnJheShwYXJhbXNPckZuKSA/IHBhcmFtc09yRm4gOiBwYXJhbXNPckZuKCk7XG4gICAgICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb24oc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXMpLnRvU3RtdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLnByb2Nlc3NTdHlsaW5nSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAoZWxlbWVudEluZGV4LCBpbnN0cnVjdGlvbiwgY3JlYXRlTW9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChjcmVhdGVNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uLnNvdXJjZVNwYW4sIGluc3RydWN0aW9uLnJlZmVyZW5jZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb24ucGFyYW1zKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gX3RoaXMuY29udmVydFByb3BlcnR5QmluZGluZyh2YWx1ZSk7IH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbihlbGVtZW50SW5kZXgsIGluc3RydWN0aW9uLnNvdXJjZVNwYW4sIGluc3RydWN0aW9uLnJlZmVyZW5jZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC5wYXJhbXMoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGluc3RydWN0aW9uLnN1cHBvcnRzSW50ZXJwb2xhdGlvbiAmJiB2YWx1ZSBpbnN0YW5jZW9mIEludGVycG9sYXRpb24pID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZXRVcGRhdGVJbnN0cnVjdGlvbkFyZ3VtZW50cyh2YWx1ZSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuY3JlYXRpb25JbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIChzcGFuLCByZWZlcmVuY2UsIHBhcmFtc09yRm4sIHByZXBlbmQpIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbkZuKHRoaXMuX2NyZWF0aW9uQ29kZUZucywgc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXNPckZuIHx8IFtdLCBwcmVwZW5kKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLnVwZGF0ZUluc3RydWN0aW9uID0gZnVuY3Rpb24gKG5vZGVJbmRleCwgc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXNPckZuKSB7XG4gICAgICAgIHRoaXMuYWRkU2VsZWN0SW5zdHJ1Y3Rpb25JZk5lY2Vzc2FyeShub2RlSW5kZXgsIHNwYW4pO1xuICAgICAgICB0aGlzLmluc3RydWN0aW9uRm4odGhpcy5fdXBkYXRlQ29kZUZucywgc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXNPckZuIHx8IFtdKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLnVwZGF0ZUluc3RydWN0aW9uQ2hhaW4gPSBmdW5jdGlvbiAobm9kZUluZGV4LCByZWZlcmVuY2UsIGJpbmRpbmdzKSB7XG4gICAgICAgIHZhciBzcGFuID0gYmluZGluZ3MubGVuZ3RoID8gYmluZGluZ3NbMF0uc291cmNlU3BhbiA6IG51bGw7XG4gICAgICAgIHRoaXMuYWRkU2VsZWN0SW5zdHJ1Y3Rpb25JZk5lY2Vzc2FyeShub2RlSW5kZXgsIHNwYW4pO1xuICAgICAgICB0aGlzLl91cGRhdGVDb2RlRm5zLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNhbGxzID0gYmluZGluZ3MubWFwKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBmblBhcmFtcyA9IF9fc3ByZWFkKFtwcm9wZXJ0eS52YWx1ZSgpXSwgKHByb3BlcnR5LnBhcmFtcyB8fCBbXSkpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuUGFyYW1zLnVuc2hpZnQobGl0ZXJhbChwcm9wZXJ0eS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmblBhcmFtcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNoYWluZWRJbnN0cnVjdGlvbihyZWZlcmVuY2UsIGNhbGxzLCBzcGFuKS50b1N0bXQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5hZGRTZWxlY3RJbnN0cnVjdGlvbklmTmVjZXNzYXJ5ID0gZnVuY3Rpb24gKG5vZGVJbmRleCwgc3Bhbikge1xuICAgICAgICBpZiAodGhpcy5fbGFzdE5vZGVJbmRleFdpdGhGbHVzaCA8IG5vZGVJbmRleCkge1xuICAgICAgICAgICAgaWYgKG5vZGVJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RydWN0aW9uRm4odGhpcy5fdXBkYXRlQ29kZUZucywgc3BhbiwgSWRlbnRpZmllcnMkMS5zZWxlY3QsIFtsaXRlcmFsKG5vZGVJbmRleCldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xhc3ROb2RlSW5kZXhXaXRoRmx1c2ggPSBub2RlSW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMgPSBmdW5jdGlvbiAobnVtU2xvdHMpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsU2xvdHMgPSB0aGlzLl9wdXJlRnVuY3Rpb25TbG90cztcbiAgICAgICAgdGhpcy5fcHVyZUZ1bmN0aW9uU2xvdHMgKz0gbnVtU2xvdHM7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFNsb3RzO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuYWxsb2NhdGVCaW5kaW5nU2xvdHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZ1Nsb3RzICs9IHZhbHVlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbiA/IHZhbHVlLmV4cHJlc3Npb25zLmxlbmd0aCA6IDE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGFuIGV4cHJlc3Npb24gdGhhdCByZWZlcnMgdG8gdGhlIGltcGxpY2l0IHJlY2VpdmVyLiBUaGUgaW1wbGljaXRcbiAgICAgKiByZWNlaXZlciBpcyBhbHdheXMgdGhlIHJvb3QgbGV2ZWwgY29udGV4dC5cbiAgICAgKi9cbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5nZXRJbXBsaWNpdFJlY2VpdmVyRXhwciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXJFeHByKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW1wbGljaXRSZWNlaXZlckV4cHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXJFeHByID0gdGhpcy5sZXZlbCA9PT0gMCA/XG4gICAgICAgICAgICB2YXJpYWJsZShDT05URVhUX05BTUUpIDpcbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdTY29wZS5nZXRPckNyZWF0ZVNoYXJlZENvbnRleHRWYXIoMCk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5jb252ZXJ0RXhwcmVzc2lvbkJpbmRpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbnZlcnRlZFByb3BlcnR5QmluZGluZyA9IGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcodGhpcywgdGhpcy5nZXRJbXBsaWNpdFJlY2VpdmVyRXhwcigpLCB2YWx1ZSwgdGhpcy5iaW5kaW5nQ29udGV4dCgpLCBCaW5kaW5nRm9ybS5UcnlTaW1wbGUpO1xuICAgICAgICByZXR1cm4gY29udmVydGVkUHJvcGVydHlCaW5kaW5nLmN1cnJWYWxFeHByO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuY29udmVydFByb3BlcnR5QmluZGluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBjb252ZXJ0ZWRQcm9wZXJ0eUJpbmRpbmcgPSBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKHRoaXMsIHRoaXMuZ2V0SW1wbGljaXRSZWNlaXZlckV4cHIoKSwgdmFsdWUsIHRoaXMuYmluZGluZ0NvbnRleHQoKSwgQmluZGluZ0Zvcm0uVHJ5U2ltcGxlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcignVW5leHBlY3RlZCBpbnRlcnBvbGF0aW9uJyk7IH0pO1xuICAgICAgICB2YXIgdmFsRXhwciA9IGNvbnZlcnRlZFByb3BlcnR5QmluZGluZy5jdXJyVmFsRXhwcjtcbiAgICAgICAgKF9hID0gdGhpcy5fdGVtcFZhcmlhYmxlcykucHVzaC5hcHBseShfYSwgX19zcHJlYWQoY29udmVydGVkUHJvcGVydHlCaW5kaW5nLnN0bXRzKSk7XG4gICAgICAgIHJldHVybiB2YWxFeHByO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgYXJndW1lbnQgZXhwcmVzc2lvbnMgdG8gcGFzcyB0byBhbiB1cGRhdGUgaW5zdHJ1Y3Rpb24gZXhwcmVzc2lvbi4gQWxzbyB1cGRhdGVzXG4gICAgICogdGhlIHRlbXAgdmFyaWFibGVzIHN0YXRlIHdpdGggdGVtcCB2YXJpYWJsZXMgdGhhdCB3ZXJlIGlkZW50aWZpZWQgYXMgbmVlZGluZyB0byBiZSBjcmVhdGVkXG4gICAgICogd2hpbGUgdmlzaXRpbmcgdGhlIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG9yaWdpbmFsIGV4cHJlc3Npb24gd2Ugd2lsbCBiZSByZXNvbHZpbmcgYW4gYXJndW1lbnRzIGxpc3QgZnJvbS5cbiAgICAgKi9cbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5nZXRVcGRhdGVJbnN0cnVjdGlvbkFyZ3VtZW50cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfYiA9IGNvbnZlcnRVcGRhdGVBcmd1bWVudHModGhpcywgdGhpcy5nZXRJbXBsaWNpdFJlY2VpdmVyRXhwcigpLCB2YWx1ZSwgdGhpcy5iaW5kaW5nQ29udGV4dCgpKSwgYXJncyA9IF9iLmFyZ3MsIHN0bXRzID0gX2Iuc3RtdHM7XG4gICAgICAgIChfYSA9IHRoaXMuX3RlbXBWYXJpYWJsZXMpLnB1c2guYXBwbHkoX2EsIF9fc3ByZWFkKHN0bXRzKSk7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUubWF0Y2hEaXJlY3RpdmVzID0gZnVuY3Rpb24gKHRhZ05hbWUsIGVsT3JUcGwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlTWF0Y2hlcikge1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gY3JlYXRlQ3NzU2VsZWN0b3IodGFnTmFtZSwgZ2V0QXR0cnNGb3JEaXJlY3RpdmVNYXRjaGluZyhlbE9yVHBsKSk7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZU1hdGNoZXIubWF0Y2goc2VsZWN0b3IsIGZ1bmN0aW9uIChjc3NTZWxlY3Rvciwgc3RhdGljVHlwZSkgeyBfdGhpcy5kaXJlY3RpdmVzLmFkZChzdGF0aWNUeXBlKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGFsbCBhdHRyaWJ1dGUgZXhwcmVzc2lvbiB2YWx1ZXMgZm9yIHRoZSBgVEF0dHJpYnV0ZXNgIGFycmF5LlxuICAgICAqXG4gICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBwcm9wZXJseSBjb25zdHJ1Y3QgYW4gYXR0cmlidXRlcyBhcnJheSB0aGF0XG4gICAgICogaXMgcGFzc2VkIGludG8gdGhlIGBlbGVtZW50U3RhcnRgIChvciBqdXN0IGBlbGVtZW50YCkgZnVuY3Rpb25zLiBCZWNhdXNlIHRoZXJlXG4gICAgICogYXJlIG1hbnkgZGlmZmVyZW50IHR5cGVzIG9mIGF0dHJpYnV0ZXMsIHRoZSBhcnJheSBuZWVkcyB0byBiZSBjb25zdHJ1Y3RlZCBpbiBhXG4gICAgICogc3BlY2lhbCB3YXkgc28gdGhhdCBgZWxlbWVudFN0YXJ0YCBjYW4gcHJvcGVybHkgZXZhbHVhdGUgdGhlbS5cbiAgICAgKlxuICAgICAqIFRoZSBmb3JtYXQgbG9va3MgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogYXR0cnMgPSBbcHJvcCwgdmFsdWUsIHByb3AyLCB2YWx1ZTIsXG4gICAgICogICBDTEFTU0VTLCBjbGFzczEsIGNsYXNzMixcbiAgICAgKiAgIFNUWUxFUywgc3R5bGUxLCB2YWx1ZTEsIHN0eWxlMiwgdmFsdWUyLFxuICAgICAqICAgQklORElOR1MsIG5hbWUxLCBuYW1lMiwgbmFtZTMsXG4gICAgICogICBURU1QTEFURSwgbmFtZTQsIG5hbWU1LCBuYW1lNixcbiAgICAgKiAgIEkxOE4sIG5hbWU3LCBuYW1lOCwgLi4uXVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCBmdWxseSBpZ25vcmUgYWxsIHN5bnRoZXRpYyAoQGZvbykgYXR0cmlidXRlIHZhbHVlc1xuICAgICAqIGJlY2F1c2UgdGhvc2UgdmFsdWVzIGFyZSBpbnRlbmRlZCB0byBhbHdheXMgYmUgZ2VuZXJhdGVkIGFzIHByb3BlcnR5IGluc3RydWN0aW9ucy5cbiAgICAgKi9cbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5wcmVwYXJlTm9uUmVuZGVyQXR0cnMgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXRzLCBzdHlsZXMsIHRlbXBsYXRlQXR0cnMsIGkxOG5BdHRycykge1xuICAgICAgICBpZiAodGVtcGxhdGVBdHRycyA9PT0gdm9pZCAwKSB7IHRlbXBsYXRlQXR0cnMgPSBbXTsgfVxuICAgICAgICBpZiAoaTE4bkF0dHJzID09PSB2b2lkIDApIHsgaTE4bkF0dHJzID0gW107IH1cbiAgICAgICAgdmFyIGFscmVhZHlTZWVuID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgYXR0ckV4cHJzID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGFkZEF0dHJFeHByKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICghYWxyZWFkeVNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ckV4cHJzLnB1c2guYXBwbHkoYXR0ckV4cHJzLCBfX3NwcmVhZChnZXRBdHRyaWJ1dGVOYW1lTGl0ZXJhbHMoa2V5KSkpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGF0dHJFeHBycy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYWxyZWFkeVNlZW4uYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0ckV4cHJzLnB1c2gobGl0ZXJhbChrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpdCdzIGltcG9ydGFudCB0aGF0IHRoaXMgb2NjdXJzIGJlZm9yZSBCSU5ESU5HUyBhbmQgVEVNUExBVEUgYmVjYXVzZSBvbmNlIGBlbGVtZW50U3RhcnRgXG4gICAgICAgIC8vIGNvbWVzIGFjcm9zcyB0aGUgQklORElOR1Mgb3IgVEVNUExBVEUgbWFya2VycyB0aGVuIGl0IHdpbGwgY29udGludWUgcmVhZGluZyBlYWNoIHZhbHVlIGFzXG4gICAgICAgIC8vIGFzIHNpbmdsZSBwcm9wZXJ0eSB2YWx1ZSBjZWxsIGJ5IGNlbGwuXG4gICAgICAgIGlmIChzdHlsZXMpIHtcbiAgICAgICAgICAgIHN0eWxlcy5wb3B1bGF0ZUluaXRpYWxTdHlsaW5nQXR0cnMoYXR0ckV4cHJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCB8fCBvdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGF0dHJzTGVuZ3RoQmVmb3JlSW5wdXRzID0gYXR0ckV4cHJzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdGhlIGFuaW1hdGlvbiBhbmQgYXR0cmlidXRlIGJpbmRpbmdzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZXMgYXJyYXkgc2luY2UgdGhleSBhcmVuJ3QgdXNlZCBmb3IgZGlyZWN0aXZlIG1hdGNoaW5nLlxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC50eXBlICE9PSA0IC8qIEFuaW1hdGlvbiAqLyAmJiBpbnB1dC50eXBlICE9PSAxIC8qIEF0dHJpYnV0ZSAqLykge1xuICAgICAgICAgICAgICAgICAgICBhZGRBdHRyRXhwcihpbnB1dC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gb3V0cHV0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0LnR5cGUgIT09IDEgLyogQW5pbWF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEF0dHJFeHByKG91dHB1dC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgY2hlYXAgd2F5IG9mIGFkZGluZyB0aGUgbWFya2VyIG9ubHkgYWZ0ZXIgYWxsIHRoZSBpbnB1dC9vdXRwdXRcbiAgICAgICAgICAgIC8vIHZhbHVlcyBoYXZlIGJlZW4gZmlsdGVyZWQgKGJ5IG5vdCBpbmNsdWRpbmcgdGhlIGFuaW1hdGlvbiBvbmVzKSBhbmQgYWRkZWRcbiAgICAgICAgICAgIC8vIHRvIHRoZSBleHByZXNzaW9ucy4gVGhlIG1hcmtlciBpcyBpbXBvcnRhbnQgYmVjYXVzZSBpdCB0ZWxscyB0aGUgcnVudGltZVxuICAgICAgICAgICAgLy8gY29kZSB0aGF0IHRoaXMgaXMgd2hlcmUgYXR0cmlidXRlcyB3aXRob3V0IHZhbHVlcyBzdGFydC4uLlxuICAgICAgICAgICAgaWYgKGF0dHJFeHBycy5sZW5ndGggIT09IGF0dHJzTGVuZ3RoQmVmb3JlSW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgYXR0ckV4cHJzLnNwbGljZShhdHRyc0xlbmd0aEJlZm9yZUlucHV0cywgMCwgbGl0ZXJhbCgzIC8qIEJpbmRpbmdzICovKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlbXBsYXRlQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhdHRyRXhwcnMucHVzaChsaXRlcmFsKDQgLyogVGVtcGxhdGUgKi8pKTtcbiAgICAgICAgICAgIHRlbXBsYXRlQXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYWRkQXR0ckV4cHIoYXR0ci5uYW1lKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkxOG5BdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF0dHJFeHBycy5wdXNoKGxpdGVyYWwoNiAvKiBJMThuICovKSk7XG4gICAgICAgICAgICBpMThuQXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYWRkQXR0ckV4cHIoYXR0ci5uYW1lKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJFeHBycztcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLnRvQXR0cnNQYXJhbSA9IGZ1bmN0aW9uIChhdHRyc0V4cHJzKSB7XG4gICAgICAgIHJldHVybiBhdHRyc0V4cHJzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgdGhpcy5jb25zdGFudFBvb2wuZ2V0Q29uc3RMaXRlcmFsKGxpdGVyYWxBcnIoYXR0cnNFeHBycyksIHRydWUpIDpcbiAgICAgICAgICAgIFRZUEVEX05VTExfRVhQUjtcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLnByZXBhcmVSZWZzUGFyYW1ldGVyID0gZnVuY3Rpb24gKHJlZmVyZW5jZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFyZWZlcmVuY2VzIHx8IHJlZmVyZW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gVFlQRURfTlVMTF9FWFBSO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWZzUGFyYW0gPSBmbGF0dGVuKHJlZmVyZW5jZXMubWFwKGZ1bmN0aW9uIChyZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIHZhciBzbG90ID0gX3RoaXMuYWxsb2NhdGVEYXRhU2xvdCgpO1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgdGhlIHVwZGF0ZSB0ZW1wb3JhcnkuXG4gICAgICAgICAgICB2YXIgdmFyaWFibGVOYW1lID0gX3RoaXMuX2JpbmRpbmdTY29wZS5mcmVzaFJlZmVyZW5jZU5hbWUoKTtcbiAgICAgICAgICAgIHZhciByZXRyaWV2YWxMZXZlbCA9IF90aGlzLmxldmVsO1xuICAgICAgICAgICAgdmFyIGxocyA9IHZhcmlhYmxlKHZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICBfdGhpcy5fYmluZGluZ1Njb3BlLnNldChyZXRyaWV2YWxMZXZlbCwgcmVmZXJlbmNlLm5hbWUsIGxocywgMCAvKiBERUZBVUxUICovLCBmdW5jdGlvbiAoc2NvcGUsIHJlbGF0aXZlTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBlLmcuIG5leHRDb250ZXh0KDIpO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0Q29udGV4dFN0bXQgPSByZWxhdGl2ZUxldmVsID4gMCA/IFtnZW5lcmF0ZU5leHRDb250ZXh0RXhwcihyZWxhdGl2ZUxldmVsKS50b1N0bXQoKV0gOiBbXTtcbiAgICAgICAgICAgICAgICAvLyBlLmcuIGNvbnN0ICRmb28kID0gcmVmZXJlbmNlKDEpO1xuICAgICAgICAgICAgICAgIHZhciByZWZFeHByID0gbGhzLnNldChpbXBvcnRFeHByKElkZW50aWZpZXJzJDEucmVmZXJlbmNlKS5jYWxsRm4oW2xpdGVyYWwoc2xvdCldKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRDb250ZXh0U3RtdC5jb25jYXQocmVmRXhwci50b0NvbnN0RGVjbCgpKTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIFtyZWZlcmVuY2UubmFtZSwgcmVmZXJlbmNlLnZhbHVlXTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdGFudFBvb2wuZ2V0Q29uc3RMaXRlcmFsKGFzTGl0ZXJhbChyZWZzUGFyYW0pLCB0cnVlKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLnByZXBhcmVMaXN0ZW5lclBhcmFtZXRlciA9IGZ1bmN0aW9uICh0YWdOYW1lLCBvdXRwdXRBc3QsIGluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gb3V0cHV0QXN0Lm5hbWU7XG4gICAgICAgICAgICB2YXIgYmluZGluZ0ZuTmFtZSA9IG91dHB1dEFzdC50eXBlID09PSAxIC8qIEFuaW1hdGlvbiAqLyA/XG4gICAgICAgICAgICAgICAgLy8gc3ludGhldGljIEBsaXN0ZW5lci5mb28gdmFsdWVzIGFyZSB0cmVhdGVkIHRoZSBleGFjdCBzYW1lIGFzIGFyZSBzdGFuZGFyZCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICBwcmVwYXJlU3ludGhldGljTGlzdGVuZXJGdW5jdGlvbk5hbWUoZXZlbnROYW1lLCBvdXRwdXRBc3QucGhhc2UpIDpcbiAgICAgICAgICAgICAgICBzYW5pdGl6ZUlkZW50aWZpZXIoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyTmFtZSA9IF90aGlzLnRlbXBsYXRlTmFtZSArIFwiX1wiICsgdGFnTmFtZSArIFwiX1wiICsgYmluZGluZ0ZuTmFtZSArIFwiX1wiICsgaW5kZXggKyBcIl9saXN0ZW5lclwiO1xuICAgICAgICAgICAgdmFyIHNjb3BlID0gX3RoaXMuX2JpbmRpbmdTY29wZS5uZXN0ZWRTY29wZShfdGhpcy5fYmluZGluZ1Njb3BlLmJpbmRpbmdMZXZlbCk7XG4gICAgICAgICAgICByZXR1cm4gcHJlcGFyZUV2ZW50TGlzdGVuZXJQYXJhbWV0ZXJzKG91dHB1dEFzdCwgaGFuZGxlck5hbWUsIHNjb3BlKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyO1xufSgpKTtcbnZhciBWYWx1ZUNvbnZlcnRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmFsdWVDb252ZXJ0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmFsdWVDb252ZXJ0ZXIoY29uc3RhbnRQb29sLCBhbGxvY2F0ZVNsb3QsIGFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMsIGRlZmluZVBpcGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uc3RhbnRQb29sID0gY29uc3RhbnRQb29sO1xuICAgICAgICBfdGhpcy5hbGxvY2F0ZVNsb3QgPSBhbGxvY2F0ZVNsb3Q7XG4gICAgICAgIF90aGlzLmFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMgPSBhbGxvY2F0ZVB1cmVGdW5jdGlvblNsb3RzO1xuICAgICAgICBfdGhpcy5kZWZpbmVQaXBlID0gZGVmaW5lUGlwZTtcbiAgICAgICAgX3RoaXMuX3BpcGVCaW5kRXhwcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lclxuICAgIFZhbHVlQ29udmVydGVyLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAocGlwZSwgY29udGV4dCkge1xuICAgICAgICAvLyBBbGxvY2F0ZSBhIHNsb3QgdG8gY3JlYXRlIHRoZSBwaXBlXG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5hbGxvY2F0ZVNsb3QoKTtcbiAgICAgICAgdmFyIHNsb3RQc2V1ZG9Mb2NhbCA9IFwiUElQRTpcIiArIHNsb3Q7XG4gICAgICAgIC8vIEFsbG9jYXRlIG9uZSBzbG90IGZvciB0aGUgcmVzdWx0IHBsdXMgb25lIHNsb3QgcGVyIHBpcGUgYXJndW1lbnRcbiAgICAgICAgdmFyIHB1cmVGdW5jdGlvblNsb3QgPSB0aGlzLmFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMoMiArIHBpcGUuYXJncy5sZW5ndGgpO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gbmV3IFByb3BlcnR5UmVhZChwaXBlLnNwYW4sIG5ldyBJbXBsaWNpdFJlY2VpdmVyKHBpcGUuc3BhbiksIHNsb3RQc2V1ZG9Mb2NhbCk7XG4gICAgICAgIHZhciBfYSA9IHBpcGVCaW5kaW5nQ2FsbEluZm8ocGlwZS5hcmdzKSwgaWRlbnRpZmllciA9IF9hLmlkZW50aWZpZXIsIGlzVmFyTGVuZ3RoID0gX2EuaXNWYXJMZW5ndGg7XG4gICAgICAgIHRoaXMuZGVmaW5lUGlwZShwaXBlLm5hbWUsIHNsb3RQc2V1ZG9Mb2NhbCwgc2xvdCwgaW1wb3J0RXhwcihpZGVudGlmaWVyKSk7XG4gICAgICAgIHZhciBhcmdzID0gX19zcHJlYWQoW3BpcGUuZXhwXSwgcGlwZS5hcmdzKTtcbiAgICAgICAgdmFyIGNvbnZlcnRlZEFyZ3MgPSBpc1Zhckxlbmd0aCA/IHRoaXMudmlzaXRBbGwoW25ldyBMaXRlcmFsQXJyYXkocGlwZS5zcGFuLCBhcmdzKV0pIDogdGhpcy52aXNpdEFsbChhcmdzKTtcbiAgICAgICAgdmFyIHBpcGVCaW5kRXhwciA9IG5ldyBGdW5jdGlvbkNhbGwocGlwZS5zcGFuLCB0YXJnZXQsIF9fc3ByZWFkKFtcbiAgICAgICAgICAgIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHBpcGUuc3Bhbiwgc2xvdCksXG4gICAgICAgICAgICBuZXcgTGl0ZXJhbFByaW1pdGl2ZShwaXBlLnNwYW4sIHB1cmVGdW5jdGlvblNsb3QpXG4gICAgICAgIF0sIGNvbnZlcnRlZEFyZ3MpKTtcbiAgICAgICAgdGhpcy5fcGlwZUJpbmRFeHBycy5wdXNoKHBpcGVCaW5kRXhwcik7XG4gICAgICAgIHJldHVybiBwaXBlQmluZEV4cHI7XG4gICAgfTtcbiAgICBWYWx1ZUNvbnZlcnRlci5wcm90b3R5cGUudXBkYXRlUGlwZVNsb3RPZmZzZXRzID0gZnVuY3Rpb24gKGJpbmRpbmdTbG90cykge1xuICAgICAgICB0aGlzLl9waXBlQmluZEV4cHJzLmZvckVhY2goZnVuY3Rpb24gKHBpcGUpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgc2xvdCBvZmZzZXQgYXJnIChpbmRleCAxKSB0byBhY2NvdW50IGZvciBiaW5kaW5nIHNsb3RzXG4gICAgICAgICAgICB2YXIgc2xvdE9mZnNldCA9IHBpcGUuYXJnc1sxXTtcbiAgICAgICAgICAgIHNsb3RPZmZzZXQudmFsdWUgKz0gYmluZGluZ1Nsb3RzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFZhbHVlQ29udmVydGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEJ1aWx0aW5GdW5jdGlvbkNhbGwoYXJyYXkuc3BhbiwgdGhpcy52aXNpdEFsbChhcnJheS5leHByZXNzaW9ucyksIGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBsaXRlcmFsIGhhcyBjYWxjdWxhdGVkIChub24tbGl0ZXJhbCkgZWxlbWVudHMgdHJhbnNmb3JtIGl0IGludG9cbiAgICAgICAgICAgIC8vIGNhbGxzIHRvIGxpdGVyYWwgZmFjdG9yaWVzIHRoYXQgY29tcG9zZSB0aGUgbGl0ZXJhbCBhbmQgd2lsbCBjYWNoZSBpbnRlcm1lZGlhdGVcbiAgICAgICAgICAgIC8vIHZhbHVlcy4gT3RoZXJ3aXNlLCBqdXN0IHJldHVybiBhbiBsaXRlcmFsIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHZhbHVlcy5cbiAgICAgICAgICAgIHZhciBsaXRlcmFsID0gbGl0ZXJhbEFycih2YWx1ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5ldmVyeShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5pc0NvbnN0YW50KCk7IH0pID9cbiAgICAgICAgICAgICAgICBfdGhpcy5jb25zdGFudFBvb2wuZ2V0Q29uc3RMaXRlcmFsKGxpdGVyYWwsIHRydWUpIDpcbiAgICAgICAgICAgICAgICBnZXRMaXRlcmFsRmFjdG9yeShfdGhpcy5jb25zdGFudFBvb2wsIGxpdGVyYWwsIF90aGlzLmFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFZhbHVlQ29udmVydGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAobWFwLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgQnVpbHRpbkZ1bmN0aW9uQ2FsbChtYXAuc3BhbiwgdGhpcy52aXNpdEFsbChtYXAudmFsdWVzKSwgZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGxpdGVyYWwgaGFzIGNhbGN1bGF0ZWQgKG5vbi1saXRlcmFsKSBlbGVtZW50cyAgdHJhbnNmb3JtIGl0IGludG9cbiAgICAgICAgICAgIC8vIGNhbGxzIHRvIGxpdGVyYWwgZmFjdG9yaWVzIHRoYXQgY29tcG9zZSB0aGUgbGl0ZXJhbCBhbmQgd2lsbCBjYWNoZSBpbnRlcm1lZGlhdGVcbiAgICAgICAgICAgIC8vIHZhbHVlcy4gT3RoZXJ3aXNlLCBqdXN0IHJldHVybiBhbiBsaXRlcmFsIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHZhbHVlcy5cbiAgICAgICAgICAgIHZhciBsaXRlcmFsID0gbGl0ZXJhbE1hcCh2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHsgcmV0dXJuICh7IGtleTogbWFwLmtleXNbaW5kZXhdLmtleSwgdmFsdWU6IHZhbHVlLCBxdW90ZWQ6IG1hcC5rZXlzW2luZGV4XS5xdW90ZWQgfSk7IH0pKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXMuZXZlcnkoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEuaXNDb25zdGFudCgpOyB9KSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuY29uc3RhbnRQb29sLmdldENvbnN0TGl0ZXJhbChsaXRlcmFsLCB0cnVlKSA6XG4gICAgICAgICAgICAgICAgZ2V0TGl0ZXJhbEZhY3RvcnkoX3RoaXMuY29uc3RhbnRQb29sLCBsaXRlcmFsLCBfdGhpcy5hbGxvY2F0ZVB1cmVGdW5jdGlvblNsb3RzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVmFsdWVDb252ZXJ0ZXI7XG59KEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyKSk7XG4vLyBQaXBlcyBhbHdheXMgaGF2ZSBhdCBsZWFzdCBvbmUgcGFyYW1ldGVyLCB0aGUgdmFsdWUgdGhleSBvcGVyYXRlIG9uXG52YXIgcGlwZUJpbmRpbmdJZGVudGlmaWVycyA9IFtJZGVudGlmaWVycyQxLnBpcGVCaW5kMSwgSWRlbnRpZmllcnMkMS5waXBlQmluZDIsIElkZW50aWZpZXJzJDEucGlwZUJpbmQzLCBJZGVudGlmaWVycyQxLnBpcGVCaW5kNF07XG5mdW5jdGlvbiBwaXBlQmluZGluZ0NhbGxJbmZvKGFyZ3MpIHtcbiAgICB2YXIgaWRlbnRpZmllciA9IHBpcGVCaW5kaW5nSWRlbnRpZmllcnNbYXJncy5sZW5ndGhdO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIgfHwgSWRlbnRpZmllcnMkMS5waXBlQmluZFYsXG4gICAgICAgIGlzVmFyTGVuZ3RoOiAhaWRlbnRpZmllcixcbiAgICB9O1xufVxudmFyIHB1cmVGdW5jdGlvbklkZW50aWZpZXJzID0gW1xuICAgIElkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uMCwgSWRlbnRpZmllcnMkMS5wdXJlRnVuY3Rpb24xLCBJZGVudGlmaWVycyQxLnB1cmVGdW5jdGlvbjIsIElkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uMywgSWRlbnRpZmllcnMkMS5wdXJlRnVuY3Rpb240LFxuICAgIElkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uNSwgSWRlbnRpZmllcnMkMS5wdXJlRnVuY3Rpb242LCBJZGVudGlmaWVycyQxLnB1cmVGdW5jdGlvbjcsIElkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uOFxuXTtcbmZ1bmN0aW9uIHB1cmVGdW5jdGlvbkNhbGxJbmZvKGFyZ3MpIHtcbiAgICB2YXIgaWRlbnRpZmllciA9IHB1cmVGdW5jdGlvbklkZW50aWZpZXJzW2FyZ3MubGVuZ3RoXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyIHx8IElkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uVixcbiAgICAgICAgaXNWYXJMZW5ndGg6ICFpZGVudGlmaWVyLFxuICAgIH07XG59XG5mdW5jdGlvbiBpbnN0cnVjdGlvbihzcGFuLCByZWZlcmVuY2UsIHBhcmFtcykge1xuICAgIHJldHVybiBpbXBvcnRFeHByKHJlZmVyZW5jZSwgbnVsbCwgc3BhbikuY2FsbEZuKHBhcmFtcywgc3Bhbik7XG59XG4vLyBlLmcuIHgoMik7XG5mdW5jdGlvbiBnZW5lcmF0ZU5leHRDb250ZXh0RXhwcihyZWxhdGl2ZUxldmVsRGlmZikge1xuICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEubmV4dENvbnRleHQpXG4gICAgICAgIC5jYWxsRm4ocmVsYXRpdmVMZXZlbERpZmYgPiAxID8gW2xpdGVyYWwocmVsYXRpdmVMZXZlbERpZmYpXSA6IFtdKTtcbn1cbmZ1bmN0aW9uIGdldExpdGVyYWxGYWN0b3J5KGNvbnN0YW50UG9vbCwgbGl0ZXJhbCQxLCBhbGxvY2F0ZVNsb3RzKSB7XG4gICAgdmFyIF9hID0gY29uc3RhbnRQb29sLmdldExpdGVyYWxGYWN0b3J5KGxpdGVyYWwkMSksIGxpdGVyYWxGYWN0b3J5ID0gX2EubGl0ZXJhbEZhY3RvcnksIGxpdGVyYWxGYWN0b3J5QXJndW1lbnRzID0gX2EubGl0ZXJhbEZhY3RvcnlBcmd1bWVudHM7XG4gICAgLy8gQWxsb2NhdGUgMSBzbG90IGZvciB0aGUgcmVzdWx0IHBsdXMgMSBwZXIgYXJndW1lbnRcbiAgICB2YXIgc3RhcnRTbG90ID0gYWxsb2NhdGVTbG90cygxICsgbGl0ZXJhbEZhY3RvcnlBcmd1bWVudHMubGVuZ3RoKTtcbiAgICBsaXRlcmFsRmFjdG9yeUFyZ3VtZW50cy5sZW5ndGggPiAwIHx8IGVycm9yKFwiRXhwZWN0ZWQgYXJndW1lbnRzIHRvIGEgbGl0ZXJhbCBmYWN0b3J5IGZ1bmN0aW9uXCIpO1xuICAgIHZhciBfYiA9IHB1cmVGdW5jdGlvbkNhbGxJbmZvKGxpdGVyYWxGYWN0b3J5QXJndW1lbnRzKSwgaWRlbnRpZmllciA9IF9iLmlkZW50aWZpZXIsIGlzVmFyTGVuZ3RoID0gX2IuaXNWYXJMZW5ndGg7XG4gICAgLy8gTGl0ZXJhbCBmYWN0b3JpZXMgYXJlIHB1cmUgZnVuY3Rpb25zIHRoYXQgb25seSBuZWVkIHRvIGJlIHJlLWludm9rZWQgd2hlbiB0aGUgcGFyYW1ldGVyc1xuICAgIC8vIGNoYW5nZS5cbiAgICB2YXIgYXJncyA9IFtcbiAgICAgICAgbGl0ZXJhbChzdGFydFNsb3QpLFxuICAgICAgICBsaXRlcmFsRmFjdG9yeSxcbiAgICBdO1xuICAgIGlmIChpc1Zhckxlbmd0aCkge1xuICAgICAgICBhcmdzLnB1c2gobGl0ZXJhbEFycihsaXRlcmFsRmFjdG9yeUFyZ3VtZW50cykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIF9fc3ByZWFkKGxpdGVyYWxGYWN0b3J5QXJndW1lbnRzKSk7XG4gICAgfVxuICAgIHJldHVybiBpbXBvcnRFeHByKGlkZW50aWZpZXIpLmNhbGxGbihhcmdzKTtcbn1cbi8qKlxuICogR2V0cyBhbiBhcnJheSBvZiBsaXRlcmFscyB0aGF0IGNhbiBiZSBhZGRlZCB0byBhbiBleHByZXNzaW9uXG4gKiB0byByZXByZXNlbnQgdGhlIG5hbWUgYW5kIG5hbWVzcGFjZSBvZiBhbiBhdHRyaWJ1dGUuIEUuZy5cbiAqIGA6eGxpbms6aHJlZmAgdHVybnMgaW50byBgW0F0dHJpYnV0ZU1hcmtlci5OYW1lc3BhY2VVUkksICd4bGluaycsICdocmVmJ11gLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSwgaW5jbHVkaW5nIHRoZSBuYW1lc3BhY2UuXG4gKi9cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZU5hbWVMaXRlcmFscyhuYW1lKSB7XG4gICAgdmFyIF9hID0gX19yZWFkKHNwbGl0TnNOYW1lKG5hbWUpLCAyKSwgYXR0cmlidXRlTmFtZXNwYWNlID0gX2FbMF0sIGF0dHJpYnV0ZU5hbWUgPSBfYVsxXTtcbiAgICB2YXIgbmFtZUxpdGVyYWwgPSBsaXRlcmFsKGF0dHJpYnV0ZU5hbWUpO1xuICAgIGlmIChhdHRyaWJ1dGVOYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGxpdGVyYWwoMCAvKiBOYW1lc3BhY2VVUkkgKi8pLCBsaXRlcmFsKGF0dHJpYnV0ZU5hbWVzcGFjZSksIG5hbWVMaXRlcmFsXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbbmFtZUxpdGVyYWxdO1xufVxuLyoqIFRoZSBwcmVmaXggdXNlZCB0byBnZXQgYSBzaGFyZWQgY29udGV4dCBpbiBCaW5kaW5nU2NvcGUncyBtYXAuICovXG52YXIgU0hBUkVEX0NPTlRFWFRfS0VZID0gJyQkc2hhcmVkX2N0eCQkJztcbnZhciBCaW5kaW5nU2NvcGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmluZGluZ1Njb3BlKGJpbmRpbmdMZXZlbCwgcGFyZW50KSB7XG4gICAgICAgIGlmIChiaW5kaW5nTGV2ZWwgPT09IHZvaWQgMCkgeyBiaW5kaW5nTGV2ZWwgPSAwOyB9XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuYmluZGluZ0xldmVsID0gYmluZGluZ0xldmVsO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgLyoqIEtlZXBzIGEgbWFwIGZyb20gbG9jYWwgdmFyaWFibGVzIHRvIHRoZWlyIEJpbmRpbmdEYXRhLiAqL1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VOYW1lSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnJlc3RvcmVWaWV3VmFyaWFibGUgPSBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmluZGluZ1Njb3BlLCBcIlJPT1RfU0NPUEVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghQmluZGluZ1Njb3BlLl9ST09UX1NDT1BFKSB7XG4gICAgICAgICAgICAgICAgQmluZGluZ1Njb3BlLl9ST09UX1NDT1BFID0gbmV3IEJpbmRpbmdTY29wZSgpLnNldCgwLCAnJGV2ZW50JywgdmFyaWFibGUoJyRldmVudCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBCaW5kaW5nU2NvcGUuX1JPT1RfU0NPUEU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEJpbmRpbmdTY29wZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY3VycmVudC5tYXAuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgbG9jYWwgY29weSBhbmQgcmVzZXQgdGhlIGBkZWNsYXJlYCBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJpZXZhbExldmVsOiB2YWx1ZS5yZXRyaWV2YWxMZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxoczogdmFsdWUubGhzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyZUxvY2FsQ2FsbGJhY2s6IHZhbHVlLmRlY2xhcmVMb2NhbENhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogdmFsdWUucHJpb3JpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFJlZjogdmFsdWUubG9jYWxSZWZcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIHZhbHVlIGxvY2FsbHkuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBvc3NpYmx5IGdlbmVyYXRlIGEgc2hhcmVkIGNvbnRleHQgdmFyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF5YmVHZW5lcmF0ZVNoYXJlZENvbnRleHRWYXIodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heWJlUmVzdG9yZVZpZXcodmFsdWUucmV0cmlldmFsTGV2ZWwsIHZhbHVlLmxvY2FsUmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmRlY2xhcmVMb2NhbENhbGxiYWNrICYmICF2YWx1ZS5kZWNsYXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUubGhzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGdldCB0byB0aGlzIHBvaW50LCB3ZSBhcmUgbG9va2luZyBmb3IgYSBwcm9wZXJ0eSBvbiB0aGUgdG9wIGxldmVsIGNvbXBvbmVudFxuICAgICAgICAvLyAtIElmIGxldmVsID09PSAwLCB3ZSBhcmUgb24gdGhlIHRvcCBhbmQgZG9uJ3QgbmVlZCB0byByZS1kZWNsYXJlIGBjdHhgLlxuICAgICAgICAvLyAtIElmIGxldmVsID4gMCwgd2UgYXJlIGluIGFuIGVtYmVkZGVkIHZpZXcuIFdlIG5lZWQgdG8gcmV0cmlldmUgdGhlIG5hbWUgb2YgdGhlXG4gICAgICAgIC8vIGxvY2FsIHZhciB3ZSB1c2VkIHRvIHN0b3JlIHRoZSBjb21wb25lbnQgY29udGV4dCwgZS5nLiBjb25zdCAkY29tcCQgPSB4KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmdMZXZlbCA9PT0gMCA/IG51bGwgOiB0aGlzLmdldENvbXBvbmVudFByb3BlcnR5KG5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbG9jYWwgdmFyaWFibGUgZm9yIGxhdGVyIHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXRyaWV2YWxMZXZlbCBUaGUgbGV2ZWwgZnJvbSB3aGljaCB0aGlzIHZhbHVlIGNhbiBiZSByZXRyaWV2ZWRcbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSB2YXJpYWJsZS5cbiAgICAgKiBAcGFyYW0gbGhzIEFTVCByZXByZXNlbnRpbmcgdGhlIGxlZnQgaGFuZCBzaWRlIG9mIHRoZSBgbGV0IGxocyA9IHJocztgLlxuICAgICAqIEBwYXJhbSBwcmlvcml0eSBUaGUgc29ydGluZyBwcmlvcml0eSBvZiB0aGlzIHZhclxuICAgICAqIEBwYXJhbSBkZWNsYXJlTG9jYWxDYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gZGVjbGFyaW5nIHRoaXMgbG9jYWwgdmFyXG4gICAgICogQHBhcmFtIGxvY2FsUmVmIFdoZXRoZXIgb3Igbm90IHRoaXMgaXMgYSBsb2NhbCByZWZcbiAgICAgKi9cbiAgICBCaW5kaW5nU2NvcGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChyZXRyaWV2YWxMZXZlbCwgbmFtZSwgbGhzLCBwcmlvcml0eSwgZGVjbGFyZUxvY2FsQ2FsbGJhY2ssIGxvY2FsUmVmKSB7XG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gdm9pZCAwKSB7IHByaW9yaXR5ID0gMCAvKiBERUZBVUxUICovOyB9XG4gICAgICAgIGlmICh0aGlzLm1hcC5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbFJlZikge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCB0aHJvdyBhbiBlcnJvciBpZiBpdCdzIGEgbG9jYWwgcmVmIGFuZCBkbyBub3QgdXBkYXRlIGV4aXN0aW5nIHZhbHVlLFxuICAgICAgICAgICAgICAgIC8vIHNvIHRoZSBmaXJzdCBkZWZpbmVkIHJlZiBpcyBhbHdheXMgcmV0dXJuZWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcihcIlRoZSBuYW1lIFwiICsgbmFtZSArIFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBzY29wZSB0byBiZSBcIiArIHRoaXMubWFwLmdldChuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXAuc2V0KG5hbWUsIHtcbiAgICAgICAgICAgIHJldHJpZXZhbExldmVsOiByZXRyaWV2YWxMZXZlbCxcbiAgICAgICAgICAgIGxoczogbGhzLFxuICAgICAgICAgICAgZGVjbGFyZTogZmFsc2UsXG4gICAgICAgICAgICBkZWNsYXJlTG9jYWxDYWxsYmFjazogZGVjbGFyZUxvY2FsQ2FsbGJhY2ssXG4gICAgICAgICAgICBwcmlvcml0eTogcHJpb3JpdHksXG4gICAgICAgICAgICBsb2NhbFJlZjogbG9jYWxSZWYgfHwgZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBMb2NhbFJlc29sdmVyLlxuICAgIEJpbmRpbmdTY29wZS5wcm90b3R5cGUuZ2V0TG9jYWwgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdGhpcy5nZXQobmFtZSk7IH07XG4gICAgLy8gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBMb2NhbFJlc29sdmVyLlxuICAgIEJpbmRpbmdTY29wZS5wcm90b3R5cGUubm90aWZ5SW1wbGljaXRSZWNlaXZlclVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmluZGluZ0xldmVsICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgaW1wbGljaXQgcmVjZWl2ZXIgaXMgYWNjZXNzZWQgaW4gYW4gZW1iZWRkZWQgdmlldywgd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgd2UgZGVjbGFyZSBhIHNoYXJlZCBjb250ZXh0IHZhcmlhYmxlIGZvciB0aGUgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAgICAgICAgLy8gaW4gdGhlIHVwZGF0ZSB2YXJpYWJsZXMuXG4gICAgICAgICAgICB0aGlzLm1hcC5nZXQoU0hBUkVEX0NPTlRFWFRfS0VZICsgMCkuZGVjbGFyZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJpbmRpbmdTY29wZS5wcm90b3R5cGUubmVzdGVkU2NvcGUgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgdmFyIG5ld1Njb3BlID0gbmV3IEJpbmRpbmdTY29wZShsZXZlbCwgdGhpcyk7XG4gICAgICAgIGlmIChsZXZlbCA+IDApXG4gICAgICAgICAgICBuZXdTY29wZS5nZW5lcmF0ZVNoYXJlZENvbnRleHRWYXIoMCk7XG4gICAgICAgIHJldHVybiBuZXdTY29wZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgb3IgY3JlYXRlcyBhIHNoYXJlZCBjb250ZXh0IHZhcmlhYmxlIGFuZCByZXR1cm5zIGl0cyBleHByZXNzaW9uLiBOb3RlIHRoYXRcbiAgICAgKiB0aGlzIGRvZXMgbm90IG1lYW4gdGhhdCB0aGUgc2hhcmVkIHZhcmlhYmxlIHdpbGwgYmUgZGVjbGFyZWQuIFZhcmlhYmxlcyBpbiB0aGVcbiAgICAgKiBiaW5kaW5nIHNjb3BlIHdpbGwgYmUgb25seSBkZWNsYXJlZCBpZiB0aGV5IGFyZSB1c2VkLlxuICAgICAqL1xuICAgIEJpbmRpbmdTY29wZS5wcm90b3R5cGUuZ2V0T3JDcmVhdGVTaGFyZWRDb250ZXh0VmFyID0gZnVuY3Rpb24gKHJldHJpZXZhbExldmVsKSB7XG4gICAgICAgIHZhciBiaW5kaW5nS2V5ID0gU0hBUkVEX0NPTlRFWFRfS0VZICsgcmV0cmlldmFsTGV2ZWw7XG4gICAgICAgIGlmICghdGhpcy5tYXAuaGFzKGJpbmRpbmdLZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlU2hhcmVkQ29udGV4dFZhcihyZXRyaWV2YWxMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hhcmVkIGNvbnRleHQgdmFyaWFibGVzIGFyZSBhbHdheXMgZ2VuZXJhdGVkIGFzIFwiUmVhZFZhckV4cHJcIi5cbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldChiaW5kaW5nS2V5KS5saHM7XG4gICAgfTtcbiAgICBCaW5kaW5nU2NvcGUucHJvdG90eXBlLmdldFNoYXJlZENvbnRleHROYW1lID0gZnVuY3Rpb24gKHJldHJpZXZhbExldmVsKSB7XG4gICAgICAgIHZhciBzaGFyZWRDdHhPYmogPSB0aGlzLm1hcC5nZXQoU0hBUkVEX0NPTlRFWFRfS0VZICsgcmV0cmlldmFsTGV2ZWwpO1xuICAgICAgICAvLyBTaGFyZWQgY29udGV4dCB2YXJpYWJsZXMgYXJlIGFsd2F5cyBnZW5lcmF0ZWQgYXMgXCJSZWFkVmFyRXhwclwiLlxuICAgICAgICByZXR1cm4gc2hhcmVkQ3R4T2JqICYmIHNoYXJlZEN0eE9iai5kZWNsYXJlID8gc2hhcmVkQ3R4T2JqLmxocyA6IG51bGw7XG4gICAgfTtcbiAgICBCaW5kaW5nU2NvcGUucHJvdG90eXBlLm1heWJlR2VuZXJhdGVTaGFyZWRDb250ZXh0VmFyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZS5wcmlvcml0eSA9PT0gMSAvKiBDT05URVhUICovICYmXG4gICAgICAgICAgICB2YWx1ZS5yZXRyaWV2YWxMZXZlbCA8IHRoaXMuYmluZGluZ0xldmVsKSB7XG4gICAgICAgICAgICB2YXIgc2hhcmVkQ3R4T2JqID0gdGhpcy5tYXAuZ2V0KFNIQVJFRF9DT05URVhUX0tFWSArIHZhbHVlLnJldHJpZXZhbExldmVsKTtcbiAgICAgICAgICAgIGlmIChzaGFyZWRDdHhPYmopIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRDdHhPYmouZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlU2hhcmVkQ29udGV4dFZhcih2YWx1ZS5yZXRyaWV2YWxMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJpbmRpbmdTY29wZS5wcm90b3R5cGUuZ2VuZXJhdGVTaGFyZWRDb250ZXh0VmFyID0gZnVuY3Rpb24gKHJldHJpZXZhbExldmVsKSB7XG4gICAgICAgIHZhciBsaHMgPSB2YXJpYWJsZShDT05URVhUX05BTUUgKyB0aGlzLmZyZXNoUmVmZXJlbmNlTmFtZSgpKTtcbiAgICAgICAgdGhpcy5tYXAuc2V0KFNIQVJFRF9DT05URVhUX0tFWSArIHJldHJpZXZhbExldmVsLCB7XG4gICAgICAgICAgICByZXRyaWV2YWxMZXZlbDogcmV0cmlldmFsTGV2ZWwsXG4gICAgICAgICAgICBsaHM6IGxocyxcbiAgICAgICAgICAgIGRlY2xhcmVMb2NhbENhbGxiYWNrOiBmdW5jdGlvbiAoc2NvcGUsIHJlbGF0aXZlTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBjdHhfcjAgPSBuZXh0Q29udGV4dCgyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2xocy5zZXQoZ2VuZXJhdGVOZXh0Q29udGV4dEV4cHIocmVsYXRpdmVMZXZlbCkpLnRvQ29uc3REZWNsKCldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY2xhcmU6IGZhbHNlLFxuICAgICAgICAgICAgcHJpb3JpdHk6IDIgLyogU0hBUkVEX0NPTlRFWFQgKi8sXG4gICAgICAgICAgICBsb2NhbFJlZjogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCaW5kaW5nU2NvcGUucHJvdG90eXBlLmdldENvbXBvbmVudFByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudFZhbHVlID0gdGhpcy5tYXAuZ2V0KFNIQVJFRF9DT05URVhUX0tFWSArIDApO1xuICAgICAgICBjb21wb25lbnRWYWx1ZS5kZWNsYXJlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXliZVJlc3RvcmVWaWV3KDAsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFZhbHVlLmxocy5wcm9wKG5hbWUpO1xuICAgIH07XG4gICAgQmluZGluZ1Njb3BlLnByb3RvdHlwZS5tYXliZVJlc3RvcmVWaWV3ID0gZnVuY3Rpb24gKHJldHJpZXZhbExldmVsLCBsb2NhbFJlZkxvb2t1cCkge1xuICAgICAgICAvLyBXZSB3YW50IHRvIHJlc3RvcmUgdGhlIGN1cnJlbnQgdmlldyBpbiBsaXN0ZW5lciBmbnMgaWY6XG4gICAgICAgIC8vIDEgLSB3ZSBhcmUgYWNjZXNzaW5nIGEgdmFsdWUgaW4gYSBwYXJlbnQgdmlldywgd2hpY2ggcmVxdWlyZXMgd2Fsa2luZyB0aGUgdmlldyB0cmVlIHJhdGhlclxuICAgICAgICAvLyB0aGFuIHVzaW5nIHRoZSBjdHggYXJnLiBJbiB0aGlzIGNhc2UsIHRoZSByZXRyaWV2YWwgYW5kIGJpbmRpbmcgbGV2ZWwgd2lsbCBiZSBkaWZmZXJlbnQuXG4gICAgICAgIC8vIDIgLSB3ZSBhcmUgbG9va2luZyB1cCBhIGxvY2FsIHJlZiwgd2hpY2ggcmVxdWlyZXMgcmVzdG9yaW5nIHRoZSB2aWV3IHdoZXJlIHRoZSBsb2NhbFxuICAgICAgICAvLyByZWYgaXMgc3RvcmVkXG4gICAgICAgIGlmICh0aGlzLmlzTGlzdGVuZXJTY29wZSgpICYmIChyZXRyaWV2YWxMZXZlbCA8IHRoaXMuYmluZGluZ0xldmVsIHx8IGxvY2FsUmVmTG9va3VwKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudC5yZXN0b3JlVmlld1ZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IHNhdmVzIHZhcmlhYmxlIHRvIGdlbmVyYXRlIGEgc2hhcmVkIGBjb25zdCAkcyQgPSBnZXRDdXJyZW50VmlldygpO2AgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5yZXN0b3JlVmlld1ZhcmlhYmxlID0gdmFyaWFibGUodGhpcy5wYXJlbnQuZnJlc2hSZWZlcmVuY2VOYW1lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlVmlld1ZhcmlhYmxlID0gdGhpcy5wYXJlbnQucmVzdG9yZVZpZXdWYXJpYWJsZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmluZGluZ1Njb3BlLnByb3RvdHlwZS5yZXN0b3JlVmlld1N0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcmVzdG9yZVZpZXcoJHN0YXRlJCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3RvcmVWaWV3VmFyaWFibGUgP1xuICAgICAgICAgICAgW2luc3RydWN0aW9uKG51bGwsIElkZW50aWZpZXJzJDEucmVzdG9yZVZpZXcsIFt0aGlzLnJlc3RvcmVWaWV3VmFyaWFibGVdKS50b1N0bXQoKV0gOlxuICAgICAgICAgICAgW107XG4gICAgfTtcbiAgICBCaW5kaW5nU2NvcGUucHJvdG90eXBlLnZpZXdTbmFwc2hvdFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNvbnN0ICRzdGF0ZSQgPSBnZXRDdXJyZW50VmlldygpO1xuICAgICAgICB2YXIgZ2V0Q3VycmVudFZpZXdJbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uKG51bGwsIElkZW50aWZpZXJzJDEuZ2V0Q3VycmVudFZpZXcsIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdG9yZVZpZXdWYXJpYWJsZSA/XG4gICAgICAgICAgICBbdGhpcy5yZXN0b3JlVmlld1ZhcmlhYmxlLnNldChnZXRDdXJyZW50Vmlld0luc3RydWN0aW9uKS50b0NvbnN0RGVjbCgpXSA6XG4gICAgICAgICAgICBbXTtcbiAgICB9O1xuICAgIEJpbmRpbmdTY29wZS5wcm90b3R5cGUuaXNMaXN0ZW5lclNjb3BlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuYmluZGluZ0xldmVsID09PSB0aGlzLmJpbmRpbmdMZXZlbDsgfTtcbiAgICBCaW5kaW5nU2NvcGUucHJvdG90eXBlLnZhcmlhYmxlRGVjbGFyYXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY3VycmVudENvbnRleHRMZXZlbCA9IDA7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubWFwLnZhbHVlcygpKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlLmRlY2xhcmU7IH0pXG4gICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYi5yZXRyaWV2YWxMZXZlbCAtIGEucmV0cmlldmFsTGV2ZWwgfHwgYi5wcmlvcml0eSAtIGEucHJpb3JpdHk7IH0pXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChzdG10cywgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbERpZmYgPSBfdGhpcy5iaW5kaW5nTGV2ZWwgLSB2YWx1ZS5yZXRyaWV2YWxMZXZlbDtcbiAgICAgICAgICAgIHZhciBjdXJyU3RtdHMgPSB2YWx1ZS5kZWNsYXJlTG9jYWxDYWxsYmFjayhfdGhpcywgbGV2ZWxEaWZmIC0gY3VycmVudENvbnRleHRMZXZlbCk7XG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dExldmVsID0gbGV2ZWxEaWZmO1xuICAgICAgICAgICAgcmV0dXJuIHN0bXRzLmNvbmNhdChjdXJyU3RtdHMpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfTtcbiAgICBCaW5kaW5nU2NvcGUucHJvdG90eXBlLmZyZXNoUmVmZXJlbmNlTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICAvLyBGaW5kIHRoZSB0b3Agc2NvcGUgYXMgaXQgbWFpbnRhaW5zIHRoZSBnbG9iYWwgcmVmZXJlbmNlIGNvdW50XG4gICAgICAgIHdoaWxlIChjdXJyZW50LnBhcmVudClcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgdmFyIHJlZiA9IFwiXCIgKyBSRUZFUkVOQ0VfUFJFRklYICsgY3VycmVudC5yZWZlcmVuY2VOYW1lSW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICB9O1xuICAgIHJldHVybiBCaW5kaW5nU2NvcGU7XG59KCkpO1xuLyoqXG4gKiBDcmVhdGVzIGEgYENzc1NlbGVjdG9yYCBnaXZlbiBhIHRhZyBuYW1lIGFuZCBhIG1hcCBvZiBhdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNzc1NlbGVjdG9yKHRhZywgYXR0cmlidXRlcykge1xuICAgIHZhciBjc3NTZWxlY3RvciA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgIGNzc1NlbGVjdG9yLnNldEVsZW1lbnQodGFnKTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGNzc1NlbGVjdG9yLmFkZEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzID0gdmFsdWUudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICBjbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gY3NzU2VsZWN0b3IuYWRkQ2xhc3NOYW1lKGNsYXNzTmFtZSk7IH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNzc1NlbGVjdG9yO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGV4cHJlc3Npb25zIG91dCBvZiBhbiBgbmdQcm9qZWN0QXNgIGF0dHJpYnV0ZXNcbiAqIHdoaWNoIGNhbiBiZSBhZGRlZCB0byB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1ldGVycy5cbiAqL1xuZnVuY3Rpb24gZ2V0TmdQcm9qZWN0QXNMaXRlcmFsKGF0dHJpYnV0ZSkge1xuICAgIC8vIFBhcnNlIHRoZSBhdHRyaWJ1dGUgdmFsdWUgaW50byBhIENzc1NlbGVjdG9yTGlzdC4gTm90ZSB0aGF0IHdlIG9ubHkgdGFrZSB0aGVcbiAgICAvLyBmaXJzdCBzZWxlY3RvciwgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IG11bHRpcGxlIHNlbGVjdG9ycyBpbiBuZ1Byb2plY3RBcy5cbiAgICB2YXIgcGFyc2VkUjNTZWxlY3RvciA9IHBhcnNlU2VsZWN0b3JUb1IzU2VsZWN0b3IoYXR0cmlidXRlLnZhbHVlKVswXTtcbiAgICByZXR1cm4gW2xpdGVyYWwoNSAvKiBQcm9qZWN0QXMgKi8pLCBhc0xpdGVyYWwocGFyc2VkUjNTZWxlY3RvcildO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBpbnN0cnVjdGlvbiB0byBnZW5lcmF0ZSBmb3IgYW4gaW50ZXJwb2xhdGVkIHByb3BlcnR5XG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBJbnRlcnBvbGF0aW9uIEFTVFxuICovXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eUludGVycG9sYXRpb25FeHByZXNzaW9uKGludGVycG9sYXRpb24pIHtcbiAgICBzd2l0Y2ggKGdldEludGVycG9sYXRpb25BcmdzTGVuZ3RoKGludGVycG9sYXRpb24pKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnByb3BlcnR5SW50ZXJwb2xhdGU7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnByb3BlcnR5SW50ZXJwb2xhdGUxO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlMjtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEucHJvcGVydHlJbnRlcnBvbGF0ZTM7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnByb3BlcnR5SW50ZXJwb2xhdGU0O1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEucHJvcGVydHlJbnRlcnBvbGF0ZTU7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlNjtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnByb3BlcnR5SW50ZXJwb2xhdGU3O1xuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEucHJvcGVydHlJbnRlcnBvbGF0ZTg7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlVjtcbiAgICB9XG59XG4vKipcbiAqIEdldHMgdGhlIGluc3RydWN0aW9uIHRvIGdlbmVyYXRlIGZvciBhbiBpbnRlcnBvbGF0ZWQgYXR0cmlidXRlXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBJbnRlcnBvbGF0aW9uIEFTVFxuICovXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihpbnRlcnBvbGF0aW9uKSB7XG4gICAgc3dpdGNoIChnZXRJbnRlcnBvbGF0aW9uQXJnc0xlbmd0aChpbnRlcnBvbGF0aW9uKSkge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTE7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLmF0dHJpYnV0ZUludGVycG9sYXRlMjtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuYXR0cmlidXRlSW50ZXJwb2xhdGUzO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTQ7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTU7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTY7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTc7XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTg7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZVY7XG4gICAgfVxufVxuLyoqXG4gKiBHZXRzIHRoZSBpbnN0cnVjdGlvbiB0byBnZW5lcmF0ZSBmb3IgaW50ZXJwb2xhdGVkIHRleHQuXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBJbnRlcnBvbGF0aW9uIEFTVFxuICovXG5mdW5jdGlvbiBnZXRUZXh0SW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oaW50ZXJwb2xhdGlvbikge1xuICAgIHN3aXRjaCAoZ2V0SW50ZXJwb2xhdGlvbkFyZ3NMZW5ndGgoaW50ZXJwb2xhdGlvbikpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEudGV4dEludGVycG9sYXRlO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGUxO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGUyO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGUzO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGU0O1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEudGV4dEludGVycG9sYXRlNTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnRleHRJbnRlcnBvbGF0ZTY7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGU3O1xuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEudGV4dEludGVycG9sYXRlODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnRleHRJbnRlcnBvbGF0ZVY7XG4gICAgfVxufVxuLyoqXG4gKiBQYXJzZSBhIHRlbXBsYXRlIGludG8gcmVuZGVyMyBgTm9kZWBzIGFuZCBhZGRpdGlvbmFsIG1ldGFkYXRhLCB3aXRoIG5vIG90aGVyIGRlcGVuZGVuY2llcy5cbiAqXG4gKiBAcGFyYW0gdGVtcGxhdGUgdGV4dCBvZiB0aGUgdGVtcGxhdGUgdG8gcGFyc2VcbiAqIEBwYXJhbSB0ZW1wbGF0ZVVybCBVUkwgdG8gdXNlIGZvciBzb3VyY2UgbWFwcGluZyBvZiB0aGUgcGFyc2VkIHRlbXBsYXRlXG4gKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zIHRvIG1vZGlmeSBob3cgdGhlIHRlbXBsYXRlIGlzIHBhcnNlZFxuICovXG5mdW5jdGlvbiBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGludGVycG9sYXRpb25Db25maWcgPSBvcHRpb25zLmludGVycG9sYXRpb25Db25maWcsIHByZXNlcnZlV2hpdGVzcGFjZXMgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZXM7XG4gICAgdmFyIGJpbmRpbmdQYXJzZXIgPSBtYWtlQmluZGluZ1BhcnNlcihpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICB2YXIgaHRtbFBhcnNlciA9IG5ldyBIdG1sUGFyc2VyKCk7XG4gICAgdmFyIHBhcnNlUmVzdWx0ID0gaHRtbFBhcnNlci5wYXJzZSh0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwsIF9fYXNzaWduKHsgbGVhZGluZ1RyaXZpYUNoYXJzOiBMRUFESU5HX1RSSVZJQV9DSEFSUyB9LCBvcHRpb25zLCB7IHRva2VuaXplRXhwYW5zaW9uRm9ybXM6IHRydWUgfSkpO1xuICAgIGlmIChwYXJzZVJlc3VsdC5lcnJvcnMgJiYgcGFyc2VSZXN1bHQuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBwYXJzZVJlc3VsdC5lcnJvcnMsIG5vZGVzOiBbXSwgc3R5bGVVcmxzOiBbXSwgc3R5bGVzOiBbXSB9O1xuICAgIH1cbiAgICB2YXIgcm9vdE5vZGVzID0gcGFyc2VSZXN1bHQucm9vdE5vZGVzO1xuICAgIC8vIHByb2Nlc3MgaTE4biBtZXRhIGluZm9ybWF0aW9uIChzY2FuIGF0dHJpYnV0ZXMsIGdlbmVyYXRlIGlkcylcbiAgICAvLyBiZWZvcmUgd2UgcnVuIHdoaXRlc3BhY2UgcmVtb3ZhbCBwcm9jZXNzLCBiZWNhdXNlIGV4aXN0aW5nIGkxOG5cbiAgICAvLyBleHRyYWN0aW9uIHByb2Nlc3MgKG5nIHhpMThuKSByZWxpZXMgb24gYSByYXcgY29udGVudCB0byBnZW5lcmF0ZVxuICAgIC8vIG1lc3NhZ2UgaWRzXG4gICAgcm9vdE5vZGVzID1cbiAgICAgICAgdmlzaXRBbGwkMShuZXcgSTE4bk1ldGFWaXNpdG9yKGludGVycG9sYXRpb25Db25maWcsICFwcmVzZXJ2ZVdoaXRlc3BhY2VzKSwgcm9vdE5vZGVzKTtcbiAgICBpZiAoIXByZXNlcnZlV2hpdGVzcGFjZXMpIHtcbiAgICAgICAgcm9vdE5vZGVzID0gdmlzaXRBbGwkMShuZXcgV2hpdGVzcGFjZVZpc2l0b3IoKSwgcm9vdE5vZGVzKTtcbiAgICAgICAgLy8gcnVuIGkxOG4gbWV0YSB2aXNpdG9yIGFnYWluIGluIGNhc2Ugd2UgcmVtb3ZlIHdoaXRlc3BhY2VzLCBiZWNhdXNlXG4gICAgICAgIC8vIHRoYXQgbWlnaHQgYWZmZWN0IGdlbmVyYXRlZCBpMThuIG1lc3NhZ2UgY29udGVudC4gRHVyaW5nIHRoaXMgcGFzc1xuICAgICAgICAvLyBpMThuIElEcyBnZW5lcmF0ZWQgYXQgdGhlIGZpcnN0IHBhc3Mgd2lsbCBiZSBwcmVzZXJ2ZWQsIHNvIHdlIGNhbiBtaW1pY1xuICAgICAgICAvLyBleGlzdGluZyBleHRyYWN0aW9uIHByb2Nlc3MgKG5nIHhpMThuKVxuICAgICAgICByb290Tm9kZXMgPSB2aXNpdEFsbCQxKG5ldyBJMThuTWV0YVZpc2l0b3IoaW50ZXJwb2xhdGlvbkNvbmZpZywgLyoga2VlcEkxOG5BdHRycyAqLyBmYWxzZSksIHJvb3ROb2Rlcyk7XG4gICAgfVxuICAgIHZhciBfYSA9IGh0bWxBc3RUb1JlbmRlcjNBc3Qocm9vdE5vZGVzLCBiaW5kaW5nUGFyc2VyKSwgbm9kZXMgPSBfYS5ub2RlcywgZXJyb3JzID0gX2EuZXJyb3JzLCBzdHlsZVVybHMgPSBfYS5zdHlsZVVybHMsIHN0eWxlcyA9IF9hLnN0eWxlcztcbiAgICBpZiAoZXJyb3JzICYmIGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3JzLCBub2RlczogW10sIHN0eWxlVXJsczogW10sIHN0eWxlczogW10gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZXM6IG5vZGVzLCBzdHlsZVVybHM6IHN0eWxlVXJscywgc3R5bGVzOiBzdHlsZXMgfTtcbn1cbi8qKlxuICogQ29uc3RydWN0IGEgYEJpbmRpbmdQYXJzZXJgIHdpdGggYSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIG1ha2VCaW5kaW5nUGFyc2VyKGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgcmV0dXJuIG5ldyBCaW5kaW5nUGFyc2VyKG5ldyBQYXJzZXIkMShuZXcgTGV4ZXIoKSksIGludGVycG9sYXRpb25Db25maWcsIG5ldyBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkoKSwgbnVsbCwgW10pO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVNhbml0aXphdGlvbkZuKGNvbnRleHQsIGlzQXR0cmlidXRlKSB7XG4gICAgc3dpdGNoIChjb250ZXh0KSB7XG4gICAgICAgIGNhc2UgU2VjdXJpdHlDb250ZXh0LkhUTUw6XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLnNhbml0aXplSHRtbCk7XG4gICAgICAgIGNhc2UgU2VjdXJpdHlDb250ZXh0LlNDUklQVDpcbiAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuc2FuaXRpemVTY3JpcHQpO1xuICAgICAgICBjYXNlIFNlY3VyaXR5Q29udGV4dC5TVFlMRTpcbiAgICAgICAgICAgIC8vIHRoZSBjb21waWxlciBkb2VzIG5vdCBmaWxsIGluIGFuIGluc3RydWN0aW9uIGZvciBbc3R5bGUucHJvcD9dIGJpbmRpbmdcbiAgICAgICAgICAgIC8vIHZhbHVlcyBiZWNhdXNlIHRoZSBzdHlsZSBhbGdvcml0aG0ga25vd3MgaW50ZXJuYWxseSB3aGF0IHByb3BzIGFyZSBzdWJqZWN0XG4gICAgICAgICAgICAvLyB0byBzYW5pdGl6YXRpb24gKG9ubHkgW2F0dHIuc3R5bGVdIHZhbHVlcyBhcmUgZXhwbGljaXRseSBzYW5pdGl6ZWQpXG4gICAgICAgICAgICByZXR1cm4gaXNBdHRyaWJ1dGUgPyBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuc2FuaXRpemVTdHlsZSkgOiBudWxsO1xuICAgICAgICBjYXNlIFNlY3VyaXR5Q29udGV4dC5VUkw6XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLnNhbml0aXplVXJsKTtcbiAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMOlxuICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5zYW5pdGl6ZVJlc291cmNlVXJsKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2luZ2xlRWxlbWVudFRlbXBsYXRlKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRleHQgfHwgbm9kZSBpbnN0YW5jZW9mIEJvdW5kVGV4dCB8fCBub2RlIGluc3RhbmNlb2YgSWN1O1xufVxuZnVuY3Rpb24gaGFzVGV4dENoaWxkcmVuT25seShjaGlsZHJlbikge1xuICAgIHJldHVybiBjaGlsZHJlbi5ldmVyeShpc1RleHROb2RlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEVNUFRZX0FSUkFZID0gW107XG4vLyBUaGlzIHJlZ2V4IG1hdGNoZXMgYW55IGJpbmRpbmcgbmFtZXMgdGhhdCBjb250YWluIHRoZSBcImF0dHIuXCIgcHJlZml4LCBlLmcuIFwiYXR0ci5yZXF1aXJlZFwiXG4vLyBJZiB0aGVyZSBpcyBhIG1hdGNoLCB0aGUgZmlyc3QgbWF0Y2hpbmcgZ3JvdXAgd2lsbCBjb250YWluIHRoZSBhdHRyaWJ1dGUgbmFtZSB0byBiaW5kLlxudmFyIEFUVFJfUkVHRVggPSAvYXR0clxcLihbXlxcXV0rKS87XG5mdW5jdGlvbiBnZXRTdHlsaW5nUHJlZml4KG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZS5zdWJzdHJpbmcoMCwgNSk7IC8vIHN0eWxlIG9yIGNsYXNzXG59XG5mdW5jdGlvbiBiYXNlRGlyZWN0aXZlRmllbGRzKG1ldGEsIGNvbnN0YW50UG9vbCwgYmluZGluZ1BhcnNlcikge1xuICAgIHZhciBkZWZpbml0aW9uTWFwID0gbmV3IERlZmluaXRpb25NYXAoKTtcbiAgICAvLyBlLmcuIGB0eXBlOiBNeURpcmVjdGl2ZWBcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndHlwZScsIG1ldGEudHlwZSk7XG4gICAgLy8gZS5nLiBgc2VsZWN0b3JzOiBbWycnLCAnc29tZURpcicsICcnXV1gXG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3NlbGVjdG9ycycsIGNyZWF0ZURpcmVjdGl2ZVNlbGVjdG9yKG1ldGEuc2VsZWN0b3IpKTtcbiAgICAvLyBlLmcuIGBmYWN0b3J5OiAoKSA9PiBuZXcgTXlBcHAoZGlyZWN0aXZlSW5qZWN0KEVsZW1lbnRSZWYpKWBcbiAgICB2YXIgcmVzdWx0ID0gY29tcGlsZUZhY3RvcnlGdW5jdGlvbih7XG4gICAgICAgIG5hbWU6IG1ldGEubmFtZSxcbiAgICAgICAgdHlwZTogbWV0YS50eXBlLFxuICAgICAgICBkZXBzOiBtZXRhLmRlcHMsXG4gICAgICAgIGluamVjdEZuOiBJZGVudGlmaWVycyQxLmRpcmVjdGl2ZUluamVjdCxcbiAgICB9KTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnZmFjdG9yeScsIHJlc3VsdC5mYWN0b3J5KTtcbiAgICBpZiAobWV0YS5xdWVyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gZS5nLiBgY29udGVudFF1ZXJpZXM6IChyZiwgY3R4LCBkaXJJbmRleCkgPT4geyAuLi4gfVxuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnY29udGVudFF1ZXJpZXMnLCBjcmVhdGVDb250ZW50UXVlcmllc0Z1bmN0aW9uKG1ldGEucXVlcmllcywgY29uc3RhbnRQb29sLCBtZXRhLm5hbWUpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEudmlld1F1ZXJpZXMubGVuZ3RoKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCd2aWV3UXVlcnknLCBjcmVhdGVWaWV3UXVlcmllc0Z1bmN0aW9uKG1ldGEudmlld1F1ZXJpZXMsIGNvbnN0YW50UG9vbCwgbWV0YS5uYW1lKSk7XG4gICAgfVxuICAgIC8vIGUuZy4gYGhvc3RCaW5kaW5nczogKHJmLCBjdHgsIGVsSW5kZXgpID0+IHsgLi4uIH1cbiAgICBkZWZpbml0aW9uTWFwLnNldCgnaG9zdEJpbmRpbmdzJywgY3JlYXRlSG9zdEJpbmRpbmdzRnVuY3Rpb24obWV0YS5ob3N0LCBtZXRhLnR5cGVTb3VyY2VTcGFuLCBiaW5kaW5nUGFyc2VyLCBjb25zdGFudFBvb2wsIG1ldGEuc2VsZWN0b3IgfHwgJycsIG1ldGEubmFtZSkpO1xuICAgIC8vIGUuZyAnaW5wdXRzOiB7YTogJ2EnfWBcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnaW5wdXRzJywgY29uZGl0aW9uYWxseUNyZWF0ZU1hcE9iamVjdExpdGVyYWwobWV0YS5pbnB1dHMsIHRydWUpKTtcbiAgICAvLyBlLmcgJ291dHB1dHM6IHthOiAnYSd9YFxuICAgIGRlZmluaXRpb25NYXAuc2V0KCdvdXRwdXRzJywgY29uZGl0aW9uYWxseUNyZWF0ZU1hcE9iamVjdExpdGVyYWwobWV0YS5vdXRwdXRzKSk7XG4gICAgaWYgKG1ldGEuZXhwb3J0QXMgIT09IG51bGwpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2V4cG9ydEFzJywgbGl0ZXJhbEFycihtZXRhLmV4cG9ydEFzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gbGl0ZXJhbChlKTsgfSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZGVmaW5pdGlvbk1hcDogZGVmaW5pdGlvbk1hcCwgc3RhdGVtZW50czogcmVzdWx0LnN0YXRlbWVudHMgfTtcbn1cbi8qKlxuICogQWRkIGZlYXR1cmVzIHRvIHRoZSBkZWZpbml0aW9uIG1hcC5cbiAqL1xuZnVuY3Rpb24gYWRkRmVhdHVyZXMoZGVmaW5pdGlvbk1hcCwgbWV0YSkge1xuICAgIC8vIGUuZy4gYGZlYXR1cmVzOiBbTmdPbkNoYW5nZXNGZWF0dXJlKCldYFxuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIHZhciBwcm92aWRlcnMgPSBtZXRhLnByb3ZpZGVycztcbiAgICB2YXIgdmlld1Byb3ZpZGVycyA9IG1ldGEudmlld1Byb3ZpZGVycztcbiAgICBpZiAocHJvdmlkZXJzIHx8IHZpZXdQcm92aWRlcnMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbcHJvdmlkZXJzIHx8IG5ldyBMaXRlcmFsQXJyYXlFeHByKFtdKV07XG4gICAgICAgIGlmICh2aWV3UHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2godmlld1Byb3ZpZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZmVhdHVyZXMucHVzaChpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuUHJvdmlkZXJzRmVhdHVyZSkuY2FsbEZuKGFyZ3MpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEudXNlc0luaGVyaXRhbmNlKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLkluaGVyaXREZWZpbml0aW9uRmVhdHVyZSkpO1xuICAgIH1cbiAgICBpZiAobWV0YS5saWZlY3ljbGUudXNlc09uQ2hhbmdlcykge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5OZ09uQ2hhbmdlc0ZlYXR1cmUpLmNhbGxGbihFTVBUWV9BUlJBWSkpO1xuICAgIH1cbiAgICBpZiAoZmVhdHVyZXMubGVuZ3RoKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdmZWF0dXJlcycsIGxpdGVyYWxBcnIoZmVhdHVyZXMpKTtcbiAgICB9XG59XG4vKipcbiAqIENvbXBpbGUgYSBkaXJlY3RpdmUgZm9yIHRoZSByZW5kZXIzIHJ1bnRpbWUgYXMgZGVmaW5lZCBieSB0aGUgYFIzRGlyZWN0aXZlTWV0YWRhdGFgLlxuICovXG5mdW5jdGlvbiBjb21waWxlRGlyZWN0aXZlRnJvbU1ldGFkYXRhKG1ldGEsIGNvbnN0YW50UG9vbCwgYmluZGluZ1BhcnNlcikge1xuICAgIHZhciBfYSA9IGJhc2VEaXJlY3RpdmVGaWVsZHMobWV0YSwgY29uc3RhbnRQb29sLCBiaW5kaW5nUGFyc2VyKSwgZGVmaW5pdGlvbk1hcCA9IF9hLmRlZmluaXRpb25NYXAsIHN0YXRlbWVudHMgPSBfYS5zdGF0ZW1lbnRzO1xuICAgIGFkZEZlYXR1cmVzKGRlZmluaXRpb25NYXAsIG1ldGEpO1xuICAgIHZhciBleHByZXNzaW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmRlZmluZURpcmVjdGl2ZSkuY2FsbEZuKFtkZWZpbml0aW9uTWFwLnRvTGl0ZXJhbE1hcCgpXSk7XG4gICAgaWYgKCFtZXRhLnNlbGVjdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpcmVjdGl2ZSBcIiArIG1ldGEubmFtZSArIFwiIGhhcyBubyBzZWxlY3RvciwgcGxlYXNlIGFkZCBpdCFcIik7XG4gICAgfVxuICAgIHZhciB0eXBlID0gY3JlYXRlVHlwZUZvckRlZihtZXRhLCBJZGVudGlmaWVycyQxLkRpcmVjdGl2ZURlZldpdGhNZXRhKTtcbiAgICByZXR1cm4geyBleHByZXNzaW9uOiBleHByZXNzaW9uLCB0eXBlOiB0eXBlLCBzdGF0ZW1lbnRzOiBzdGF0ZW1lbnRzIH07XG59XG4vKipcbiAqIENvbXBpbGUgYSBiYXNlIGRlZmluaXRpb24gZm9yIHRoZSByZW5kZXIzIHJ1bnRpbWUgYXMgZGVmaW5lZCBieSB7QGxpbmsgUjNCYXNlUmVmTWV0YWRhdGF9XG4gKiBAcGFyYW0gbWV0YSB0aGUgbWV0YWRhdGEgdXNlZCBmb3IgY29tcGlsYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVCYXNlRGVmRnJvbU1ldGFkYXRhKG1ldGEsIGNvbnN0YW50UG9vbCwgYmluZGluZ1BhcnNlcikge1xuICAgIHZhciBkZWZpbml0aW9uTWFwID0gbmV3IERlZmluaXRpb25NYXAoKTtcbiAgICBpZiAobWV0YS5pbnB1dHMpIHtcbiAgICAgICAgdmFyIGlucHV0c18xID0gbWV0YS5pbnB1dHM7XG4gICAgICAgIHZhciBpbnB1dHNNYXAgPSBPYmplY3Qua2V5cyhpbnB1dHNfMSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciB2ID0gaW5wdXRzXzFba2V5XTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IEFycmF5LmlzQXJyYXkodikgPyBsaXRlcmFsQXJyKHYubWFwKGZ1bmN0aW9uICh2eCkgeyByZXR1cm4gbGl0ZXJhbCh2eCk7IH0pKSA6IGxpdGVyYWwodik7XG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGtleSwgdmFsdWU6IHZhbHVlLCBxdW90ZWQ6IGZhbHNlIH07XG4gICAgICAgIH0pO1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnaW5wdXRzJywgbGl0ZXJhbE1hcChpbnB1dHNNYXApKTtcbiAgICB9XG4gICAgaWYgKG1ldGEub3V0cHV0cykge1xuICAgICAgICB2YXIgb3V0cHV0c18xID0gbWV0YS5vdXRwdXRzO1xuICAgICAgICB2YXIgb3V0cHV0c01hcCA9IE9iamVjdC5rZXlzKG91dHB1dHNfMSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxpdGVyYWwob3V0cHV0c18xW2tleV0pO1xuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSwgcXVvdGVkOiBmYWxzZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ291dHB1dHMnLCBsaXRlcmFsTWFwKG91dHB1dHNNYXApKTtcbiAgICB9XG4gICAgaWYgKG1ldGEudmlld1F1ZXJpZXMgJiYgbWV0YS52aWV3UXVlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCd2aWV3UXVlcnknLCBjcmVhdGVWaWV3UXVlcmllc0Z1bmN0aW9uKG1ldGEudmlld1F1ZXJpZXMsIGNvbnN0YW50UG9vbCkpO1xuICAgIH1cbiAgICBpZiAobWV0YS5xdWVyaWVzICYmIG1ldGEucXVlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdjb250ZW50UXVlcmllcycsIGNyZWF0ZUNvbnRlbnRRdWVyaWVzRnVuY3Rpb24obWV0YS5xdWVyaWVzLCBjb25zdGFudFBvb2wpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuaG9zdCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnaG9zdEJpbmRpbmdzJywgY3JlYXRlSG9zdEJpbmRpbmdzRnVuY3Rpb24obWV0YS5ob3N0LCBtZXRhLnR5cGVTb3VyY2VTcGFuLCBiaW5kaW5nUGFyc2VyLCBjb25zdGFudFBvb2wsIG1ldGEubmFtZSkpO1xuICAgIH1cbiAgICB2YXIgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5kZWZpbmVCYXNlKS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldKTtcbiAgICB2YXIgdHlwZSA9IG5ldyBFeHByZXNzaW9uVHlwZShpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuQmFzZURlZiksIC8qIG1vZGlmaWVycyAqLyBudWxsLCBbZXhwcmVzc2lvblR5cGUobWV0YS50eXBlKV0pO1xuICAgIHJldHVybiB7IGV4cHJlc3Npb246IGV4cHJlc3Npb24sIHR5cGU6IHR5cGUgfTtcbn1cbi8qKlxuICogQ29tcGlsZSBhIGNvbXBvbmVudCBmb3IgdGhlIHJlbmRlcjMgcnVudGltZSBhcyBkZWZpbmVkIGJ5IHRoZSBgUjNDb21wb25lbnRNZXRhZGF0YWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVDb21wb25lbnRGcm9tTWV0YWRhdGEobWV0YSwgY29uc3RhbnRQb29sLCBiaW5kaW5nUGFyc2VyKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgdmFyIF9iID0gYmFzZURpcmVjdGl2ZUZpZWxkcyhtZXRhLCBjb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpLCBkZWZpbml0aW9uTWFwID0gX2IuZGVmaW5pdGlvbk1hcCwgc3RhdGVtZW50cyA9IF9iLnN0YXRlbWVudHM7XG4gICAgYWRkRmVhdHVyZXMoZGVmaW5pdGlvbk1hcCwgbWV0YSk7XG4gICAgdmFyIHNlbGVjdG9yID0gbWV0YS5zZWxlY3RvciAmJiBDc3NTZWxlY3Rvci5wYXJzZShtZXRhLnNlbGVjdG9yKTtcbiAgICB2YXIgZmlyc3RTZWxlY3RvciA9IHNlbGVjdG9yICYmIHNlbGVjdG9yWzBdO1xuICAgIC8vIGUuZy4gYGF0dHI6IFtcImNsYXNzXCIsIFwiLm15LmFwcFwiXWBcbiAgICAvLyBUaGlzIGlzIG9wdGlvbmFsIGFuIG9ubHkgaW5jbHVkZWQgaWYgdGhlIGZpcnN0IHNlbGVjdG9yIG9mIGEgY29tcG9uZW50IHNwZWNpZmllcyBhdHRyaWJ1dGVzLlxuICAgIGlmIChmaXJzdFNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBzZWxlY3RvckF0dHJpYnV0ZXMgPSBmaXJzdFNlbGVjdG9yLmdldEF0dHJzKCk7XG4gICAgICAgIGlmIChzZWxlY3RvckF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnYXR0cnMnLCBjb25zdGFudFBvb2wuZ2V0Q29uc3RMaXRlcmFsKGxpdGVyYWxBcnIoc2VsZWN0b3JBdHRyaWJ1dGVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlICE9IG51bGwgPyBsaXRlcmFsKHZhbHVlKSA6IGxpdGVyYWwodW5kZWZpbmVkKTsgfSkpLCBcbiAgICAgICAgICAgIC8qIGZvcmNlU2hhcmVkICovIHRydWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHZW5lcmF0ZSB0aGUgQ1NTIG1hdGNoZXIgdGhhdCByZWNvZ25pemUgZGlyZWN0aXZlXG4gICAgdmFyIGRpcmVjdGl2ZU1hdGNoZXIgPSBudWxsO1xuICAgIGlmIChtZXRhLmRpcmVjdGl2ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXMobWV0YS5kaXJlY3RpdmVzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBfZSA9IF9kLnZhbHVlLCBzZWxlY3Rvcl8xID0gX2Uuc2VsZWN0b3IsIGV4cHJlc3Npb25fMSA9IF9lLmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgbWF0Y2hlci5hZGRTZWxlY3RhYmxlcyhDc3NTZWxlY3Rvci5wYXJzZShzZWxlY3Rvcl8xKSwgZXhwcmVzc2lvbl8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIGRpcmVjdGl2ZU1hdGNoZXIgPSBtYXRjaGVyO1xuICAgIH1cbiAgICAvLyBlLmcuIGB0ZW1wbGF0ZTogZnVuY3Rpb24gTXlDb21wb25lbnRfVGVtcGxhdGUoX2N0eCwgX2NtKSB7Li4ufWBcbiAgICB2YXIgdGVtcGxhdGVUeXBlTmFtZSA9IG1ldGEubmFtZTtcbiAgICB2YXIgdGVtcGxhdGVOYW1lID0gdGVtcGxhdGVUeXBlTmFtZSA/IHRlbXBsYXRlVHlwZU5hbWUgKyBcIl9UZW1wbGF0ZVwiIDogbnVsbDtcbiAgICB2YXIgZGlyZWN0aXZlc1VzZWQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHBpcGVzVXNlZCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgY2hhbmdlRGV0ZWN0aW9uID0gbWV0YS5jaGFuZ2VEZXRlY3Rpb247XG4gICAgdmFyIHRlbXBsYXRlID0gbWV0YS50ZW1wbGF0ZTtcbiAgICB2YXIgdGVtcGxhdGVCdWlsZGVyID0gbmV3IFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIoY29uc3RhbnRQb29sLCBCaW5kaW5nU2NvcGUuUk9PVF9TQ09QRSwgMCwgdGVtcGxhdGVUeXBlTmFtZSwgbnVsbCwgbnVsbCwgdGVtcGxhdGVOYW1lLCBkaXJlY3RpdmVNYXRjaGVyLCBkaXJlY3RpdmVzVXNlZCwgbWV0YS5waXBlcywgcGlwZXNVc2VkLCBJZGVudGlmaWVycyQxLm5hbWVzcGFjZUhUTUwsIG1ldGEucmVsYXRpdmVDb250ZXh0RmlsZVBhdGgsIG1ldGEuaTE4blVzZUV4dGVybmFsSWRzKTtcbiAgICB2YXIgdGVtcGxhdGVGdW5jdGlvbkV4cHJlc3Npb24gPSB0ZW1wbGF0ZUJ1aWxkZXIuYnVpbGRUZW1wbGF0ZUZ1bmN0aW9uKHRlbXBsYXRlLm5vZGVzLCBbXSk7XG4gICAgLy8gV2UgbmVlZCB0byBwcm92aWRlIHRoaXMgc28gdGhhdCBkeW5hbWljYWxseSBnZW5lcmF0ZWQgY29tcG9uZW50cyBrbm93IHdoYXRcbiAgICAvLyBwcm9qZWN0ZWQgY29udGVudCBibG9ja3MgdG8gcGFzcyB0aHJvdWdoIHRvIHRoZSBjb21wb25lbnQgd2hlbiBpdCBpcyBpbnN0YW50aWF0ZWQuXG4gICAgdmFyIG5nQ29udGVudFNlbGVjdG9ycyA9IHRlbXBsYXRlQnVpbGRlci5nZXROZ0NvbnRlbnRTZWxlY3RvcnMoKTtcbiAgICBpZiAobmdDb250ZW50U2VsZWN0b3JzKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCduZ0NvbnRlbnRTZWxlY3RvcnMnLCBuZ0NvbnRlbnRTZWxlY3RvcnMpO1xuICAgIH1cbiAgICAvLyBlLmcuIGBjb25zdHM6IDJgXG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2NvbnN0cycsIGxpdGVyYWwodGVtcGxhdGVCdWlsZGVyLmdldENvbnN0Q291bnQoKSkpO1xuICAgIC8vIGUuZy4gYHZhcnM6IDJgXG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3ZhcnMnLCBsaXRlcmFsKHRlbXBsYXRlQnVpbGRlci5nZXRWYXJDb3VudCgpKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3RlbXBsYXRlJywgdGVtcGxhdGVGdW5jdGlvbkV4cHJlc3Npb24pO1xuICAgIC8vIGUuZy4gYGRpcmVjdGl2ZXM6IFtNeURpcmVjdGl2ZV1gXG4gICAgaWYgKGRpcmVjdGl2ZXNVc2VkLnNpemUpIHtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZXNFeHByID0gbGl0ZXJhbEFycihBcnJheS5mcm9tKGRpcmVjdGl2ZXNVc2VkKSk7XG4gICAgICAgIGlmIChtZXRhLndyYXBEaXJlY3RpdmVzQW5kUGlwZXNJbkNsb3N1cmUpIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZXNFeHByID0gZm4oW10sIFtuZXcgUmV0dXJuU3RhdGVtZW50KGRpcmVjdGl2ZXNFeHByKV0pO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdkaXJlY3RpdmVzJywgZGlyZWN0aXZlc0V4cHIpO1xuICAgIH1cbiAgICAvLyBlLmcuIGBwaXBlczogW015UGlwZV1gXG4gICAgaWYgKHBpcGVzVXNlZC5zaXplKSB7XG4gICAgICAgIHZhciBwaXBlc0V4cHIgPSBsaXRlcmFsQXJyKEFycmF5LmZyb20ocGlwZXNVc2VkKSk7XG4gICAgICAgIGlmIChtZXRhLndyYXBEaXJlY3RpdmVzQW5kUGlwZXNJbkNsb3N1cmUpIHtcbiAgICAgICAgICAgIHBpcGVzRXhwciA9IGZuKFtdLCBbbmV3IFJldHVyblN0YXRlbWVudChwaXBlc0V4cHIpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3BpcGVzJywgcGlwZXNFeHByKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuZW5jYXBzdWxhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICBtZXRhLmVuY2Fwc3VsYXRpb24gPSBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZDtcbiAgICB9XG4gICAgLy8gZS5nLiBgc3R5bGVzOiBbc3RyMSwgc3RyMl1gXG4gICAgaWYgKG1ldGEuc3R5bGVzICYmIG1ldGEuc3R5bGVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgc3R5bGVWYWx1ZXMgPSBtZXRhLmVuY2Fwc3VsYXRpb24gPT0gVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQgP1xuICAgICAgICAgICAgY29tcGlsZVN0eWxlcyhtZXRhLnN0eWxlcywgQ09OVEVOVF9BVFRSLCBIT1NUX0FUVFIpIDpcbiAgICAgICAgICAgIG1ldGEuc3R5bGVzO1xuICAgICAgICB2YXIgc3RyaW5ncyA9IHN0eWxlVmFsdWVzLm1hcChmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBsaXRlcmFsKHN0cik7IH0pO1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnc3R5bGVzJywgbGl0ZXJhbEFycihzdHJpbmdzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGEuZW5jYXBzdWxhdGlvbiA9PT0gVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gc3R5bGUsIGRvbid0IGdlbmVyYXRlIGNzcyBzZWxlY3RvcnMgb24gZWxlbWVudHNcbiAgICAgICAgbWV0YS5lbmNhcHN1bGF0aW9uID0gVmlld0VuY2Fwc3VsYXRpb24uTm9uZTtcbiAgICB9XG4gICAgLy8gT25seSBzZXQgdmlldyBlbmNhcHN1bGF0aW9uIGlmIGl0J3Mgbm90IHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgaWYgKG1ldGEuZW5jYXBzdWxhdGlvbiAhPT0gVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2VuY2Fwc3VsYXRpb24nLCBsaXRlcmFsKG1ldGEuZW5jYXBzdWxhdGlvbikpO1xuICAgIH1cbiAgICAvLyBlLmcuIGBhbmltYXRpb246IFt0cmlnZ2VyKCcxMjMnLCBbXSldYFxuICAgIGlmIChtZXRhLmFuaW1hdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RhdGEnLCBsaXRlcmFsTWFwKFt7IGtleTogJ2FuaW1hdGlvbicsIHZhbHVlOiBtZXRhLmFuaW1hdGlvbnMsIHF1b3RlZDogZmFsc2UgfV0pKTtcbiAgICB9XG4gICAgLy8gT25seSBzZXQgdGhlIGNoYW5nZSBkZXRlY3Rpb24gZmxhZyBpZiBpdCdzIGRlZmluZWQgYW5kIGl0J3Mgbm90IHRoZSBkZWZhdWx0LlxuICAgIGlmIChjaGFuZ2VEZXRlY3Rpb24gIT0gbnVsbCAmJiBjaGFuZ2VEZXRlY3Rpb24gIT09IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2NoYW5nZURldGVjdGlvbicsIGxpdGVyYWwoY2hhbmdlRGV0ZWN0aW9uKSk7XG4gICAgfVxuICAgIC8vIE9uIHRoZSB0eXBlIHNpZGUsIHJlbW92ZSBuZXdsaW5lcyBmcm9tIHRoZSBzZWxlY3RvciBhcyBpdCB3aWxsIG5lZWQgdG8gZml0IGludG8gYSBUeXBlU2NyaXB0XG4gICAgLy8gc3RyaW5nIGxpdGVyYWwsIHdoaWNoIG11c3QgYmUgb24gb25lIGxpbmUuXG4gICAgdmFyIHNlbGVjdG9yRm9yVHlwZSA9IChtZXRhLnNlbGVjdG9yIHx8ICcnKS5yZXBsYWNlKC9cXG4vZywgJycpO1xuICAgIHZhciBleHByZXNzaW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmRlZmluZUNvbXBvbmVudCkuY2FsbEZuKFtkZWZpbml0aW9uTWFwLnRvTGl0ZXJhbE1hcCgpXSk7XG4gICAgdmFyIHR5cGUgPSBjcmVhdGVUeXBlRm9yRGVmKG1ldGEsIElkZW50aWZpZXJzJDEuQ29tcG9uZW50RGVmV2l0aE1ldGEpO1xuICAgIHJldHVybiB7IGV4cHJlc3Npb246IGV4cHJlc3Npb24sIHR5cGU6IHR5cGUsIHN0YXRlbWVudHM6IHN0YXRlbWVudHMgfTtcbn1cbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCBgY29tcGlsZURpcmVjdGl2ZWAgd2hpY2ggZGVwZW5kcyBvbiByZW5kZXIyIGdsb2JhbCBhbmFseXNpcyBkYXRhIGFzIGl0cyBpbnB1dFxuICogaW5zdGVhZCBvZiB0aGUgYFIzRGlyZWN0aXZlTWV0YWRhdGFgLlxuICpcbiAqIGBSM0RpcmVjdGl2ZU1ldGFkYXRhYCBpcyBjb21wdXRlZCBmcm9tIGBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGFgIGFuZCBvdGhlciBzdGF0aWNhbGx5IHJlZmxlY3RlZFxuICogaW5mb3JtYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVEaXJlY3RpdmVGcm9tUmVuZGVyMihvdXRwdXRDdHgsIGRpcmVjdGl2ZSwgcmVmbGVjdG9yLCBiaW5kaW5nUGFyc2VyKSB7XG4gICAgdmFyIG5hbWUgPSBpZGVudGlmaWVyTmFtZShkaXJlY3RpdmUudHlwZSk7XG4gICAgbmFtZSB8fCBlcnJvcihcIkNhbm5vdCByZXNvbHZlciB0aGUgbmFtZSBvZiBcIiArIGRpcmVjdGl2ZS50eXBlKTtcbiAgICB2YXIgZGVmaW5pdGlvbkZpZWxkID0gb3V0cHV0Q3R4LmNvbnN0YW50UG9vbC5wcm9wZXJ0eU5hbWVPZigxIC8qIERpcmVjdGl2ZSAqLyk7XG4gICAgdmFyIG1ldGEgPSBkaXJlY3RpdmVNZXRhZGF0YUZyb21HbG9iYWxNZXRhZGF0YShkaXJlY3RpdmUsIG91dHB1dEN0eCwgcmVmbGVjdG9yKTtcbiAgICB2YXIgcmVzID0gY29tcGlsZURpcmVjdGl2ZUZyb21NZXRhZGF0YShtZXRhLCBvdXRwdXRDdHguY29uc3RhbnRQb29sLCBiaW5kaW5nUGFyc2VyKTtcbiAgICAvLyBDcmVhdGUgdGhlIHBhcnRpYWwgY2xhc3MgdG8gYmUgbWVyZ2VkIHdpdGggdGhlIGFjdHVhbCBjbGFzcy5cbiAgICBvdXRwdXRDdHguc3RhdGVtZW50cy5wdXNoKG5ldyBDbGFzc1N0bXQobmFtZSwgbnVsbCwgW25ldyBDbGFzc0ZpZWxkKGRlZmluaXRpb25GaWVsZCwgSU5GRVJSRURfVFlQRSwgW1N0bXRNb2RpZmllci5TdGF0aWNdLCByZXMuZXhwcmVzc2lvbildLCBbXSwgbmV3IENsYXNzTWV0aG9kKG51bGwsIFtdLCBbXSksIFtdKSk7XG59XG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgYGNvbXBpbGVDb21wb25lbnRgIHdoaWNoIGRlcGVuZHMgb24gcmVuZGVyMiBnbG9iYWwgYW5hbHlzaXMgZGF0YSBhcyBpdHMgaW5wdXRcbiAqIGluc3RlYWQgb2YgdGhlIGBSM0RpcmVjdGl2ZU1ldGFkYXRhYC5cbiAqXG4gKiBgUjNDb21wb25lbnRNZXRhZGF0YWAgaXMgY29tcHV0ZWQgZnJvbSBgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhYCBhbmQgb3RoZXIgc3RhdGljYWxseSByZWZsZWN0ZWRcbiAqIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlQ29tcG9uZW50RnJvbVJlbmRlcjIob3V0cHV0Q3R4LCBjb21wb25lbnQsIHJlbmRlcjNBc3QsIHJlZmxlY3RvciwgYmluZGluZ1BhcnNlciwgZGlyZWN0aXZlVHlwZUJ5U2VsLCBwaXBlVHlwZUJ5TmFtZSkge1xuICAgIHZhciBuYW1lID0gaWRlbnRpZmllck5hbWUoY29tcG9uZW50LnR5cGUpO1xuICAgIG5hbWUgfHwgZXJyb3IoXCJDYW5ub3QgcmVzb2x2ZXIgdGhlIG5hbWUgb2YgXCIgKyBjb21wb25lbnQudHlwZSk7XG4gICAgdmFyIGRlZmluaXRpb25GaWVsZCA9IG91dHB1dEN0eC5jb25zdGFudFBvb2wucHJvcGVydHlOYW1lT2YoMiAvKiBDb21wb25lbnQgKi8pO1xuICAgIHZhciBzdW1tYXJ5ID0gY29tcG9uZW50LnRvU3VtbWFyeSgpO1xuICAgIC8vIENvbXB1dGUgdGhlIFIzQ29tcG9uZW50TWV0YWRhdGEgZnJvbSB0aGUgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhXG4gICAgdmFyIG1ldGEgPSBfX2Fzc2lnbih7fSwgZGlyZWN0aXZlTWV0YWRhdGFGcm9tR2xvYmFsTWV0YWRhdGEoY29tcG9uZW50LCBvdXRwdXRDdHgsIHJlZmxlY3RvciksIHsgc2VsZWN0b3I6IGNvbXBvbmVudC5zZWxlY3RvciwgdGVtcGxhdGU6IHsgbm9kZXM6IHJlbmRlcjNBc3Qubm9kZXMgfSwgZGlyZWN0aXZlczogW10sIHBpcGVzOiB0eXBlTWFwVG9FeHByZXNzaW9uTWFwKHBpcGVUeXBlQnlOYW1lLCBvdXRwdXRDdHgpLCB2aWV3UXVlcmllczogcXVlcmllc0Zyb21HbG9iYWxNZXRhZGF0YShjb21wb25lbnQudmlld1F1ZXJpZXMsIG91dHB1dEN0eCksIHdyYXBEaXJlY3RpdmVzQW5kUGlwZXNJbkNsb3N1cmU6IGZhbHNlLCBzdHlsZXM6IChzdW1tYXJ5LnRlbXBsYXRlICYmIHN1bW1hcnkudGVtcGxhdGUuc3R5bGVzKSB8fCBFTVBUWV9BUlJBWSwgZW5jYXBzdWxhdGlvbjogKHN1bW1hcnkudGVtcGxhdGUgJiYgc3VtbWFyeS50ZW1wbGF0ZS5lbmNhcHN1bGF0aW9uKSB8fCBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCwgaW50ZXJwb2xhdGlvbjogREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRywgYW5pbWF0aW9uczogbnVsbCwgdmlld1Byb3ZpZGVyczogY29tcG9uZW50LnZpZXdQcm92aWRlcnMubGVuZ3RoID4gMCA/IG5ldyBXcmFwcGVkTm9kZUV4cHIoY29tcG9uZW50LnZpZXdQcm92aWRlcnMpIDogbnVsbCwgcmVsYXRpdmVDb250ZXh0RmlsZVBhdGg6ICcnLCBpMThuVXNlRXh0ZXJuYWxJZHM6IHRydWUgfSk7XG4gICAgdmFyIHJlcyA9IGNvbXBpbGVDb21wb25lbnRGcm9tTWV0YWRhdGEobWV0YSwgb3V0cHV0Q3R4LmNvbnN0YW50UG9vbCwgYmluZGluZ1BhcnNlcik7XG4gICAgLy8gQ3JlYXRlIHRoZSBwYXJ0aWFsIGNsYXNzIHRvIGJlIG1lcmdlZCB3aXRoIHRoZSBhY3R1YWwgY2xhc3MuXG4gICAgb3V0cHV0Q3R4LnN0YXRlbWVudHMucHVzaChuZXcgQ2xhc3NTdG10KG5hbWUsIG51bGwsIFtuZXcgQ2xhc3NGaWVsZChkZWZpbml0aW9uRmllbGQsIElORkVSUkVEX1RZUEUsIFtTdG10TW9kaWZpZXIuU3RhdGljXSwgcmVzLmV4cHJlc3Npb24pXSwgW10sIG5ldyBDbGFzc01ldGhvZChudWxsLCBbXSwgW10pLCBbXSkpO1xufVxuLyoqXG4gKiBDb21wdXRlIGBSM0RpcmVjdGl2ZU1ldGFkYXRhYCBnaXZlbiBgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhYCBhbmQgYSBgQ29tcGlsZVJlZmxlY3RvcmAuXG4gKi9cbmZ1bmN0aW9uIGRpcmVjdGl2ZU1ldGFkYXRhRnJvbUdsb2JhbE1ldGFkYXRhKGRpcmVjdGl2ZSwgb3V0cHV0Q3R4LCByZWZsZWN0b3IpIHtcbiAgICAvLyBUaGUgZ2xvYmFsLWFuYWx5c2lzIGJhc2VkIEl2eSBtb2RlIGluIG5nYyBpcyBubyBsb25nZXIgdXRpbGl6ZWQvc3VwcG9ydGVkLlxuICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQnKTtcbn1cbi8qKlxuICogQ29udmVydCBgQ29tcGlsZVF1ZXJ5TWV0YWRhdGFgIGludG8gYFIzUXVlcnlNZXRhZGF0YWAuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJpZXNGcm9tR2xvYmFsTWV0YWRhdGEocXVlcmllcywgb3V0cHV0Q3R4KSB7XG4gICAgcmV0dXJuIHF1ZXJpZXMubWFwKGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICB2YXIgcmVhZCA9IG51bGw7XG4gICAgICAgIGlmIChxdWVyeS5yZWFkICYmIHF1ZXJ5LnJlYWQuaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmVhZCA9IG91dHB1dEN0eC5pbXBvcnRFeHByKHF1ZXJ5LnJlYWQuaWRlbnRpZmllci5yZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IHF1ZXJ5LnByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgIGZpcnN0OiBxdWVyeS5maXJzdCxcbiAgICAgICAgICAgIHByZWRpY2F0ZTogc2VsZWN0b3JzRnJvbUdsb2JhbE1ldGFkYXRhKHF1ZXJ5LnNlbGVjdG9ycywgb3V0cHV0Q3R4KSxcbiAgICAgICAgICAgIGRlc2NlbmRhbnRzOiBxdWVyeS5kZXNjZW5kYW50cywgcmVhZDogcmVhZCxcbiAgICAgICAgICAgIHN0YXRpYzogISFxdWVyeS5zdGF0aWNcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ29udmVydCBgQ29tcGlsZVRva2VuTWV0YWRhdGFgIGZvciBxdWVyeSBzZWxlY3RvcnMgaW50byBlaXRoZXIgYW4gZXhwcmVzc2lvbiBmb3IgYSBwcmVkaWNhdGVcbiAqIHR5cGUsIG9yIGEgbGlzdCBvZiBzdHJpbmcgcHJlZGljYXRlcy5cbiAqL1xuZnVuY3Rpb24gc2VsZWN0b3JzRnJvbUdsb2JhbE1ldGFkYXRhKHNlbGVjdG9ycywgb3V0cHV0Q3R4KSB7XG4gICAgaWYgKHNlbGVjdG9ycy5sZW5ndGggPiAxIHx8IChzZWxlY3RvcnMubGVuZ3RoID09IDEgJiYgc2VsZWN0b3JzWzBdLnZhbHVlKSkge1xuICAgICAgICB2YXIgc2VsZWN0b3JTdHJpbmdzID0gc2VsZWN0b3JzLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlLnZhbHVlOyB9KTtcbiAgICAgICAgc2VsZWN0b3JTdHJpbmdzLnNvbWUoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAhdmFsdWU7IH0pICYmXG4gICAgICAgICAgICBlcnJvcignRm91bmQgYSB0eXBlIGFtb25nIHRoZSBzdHJpbmcgc2VsZWN0b3JzIGV4cGVjdGVkJyk7XG4gICAgICAgIHJldHVybiBvdXRwdXRDdHguY29uc3RhbnRQb29sLmdldENvbnN0TGl0ZXJhbChsaXRlcmFsQXJyKHNlbGVjdG9yU3RyaW5ncy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBsaXRlcmFsKHZhbHVlKTsgfSkpKTtcbiAgICB9XG4gICAgaWYgKHNlbGVjdG9ycy5sZW5ndGggPT0gMSkge1xuICAgICAgICB2YXIgZmlyc3QgPSBzZWxlY3RvcnNbMF07XG4gICAgICAgIGlmIChmaXJzdC5pZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0Q3R4LmltcG9ydEV4cHIoZmlyc3QuaWRlbnRpZmllci5yZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVycm9yKCdVbmV4cGVjdGVkIHF1ZXJ5IGZvcm0nKTtcbiAgICByZXR1cm4gTlVMTF9FWFBSO1xufVxuZnVuY3Rpb24gcHJlcGFyZVF1ZXJ5UGFyYW1zKHF1ZXJ5LCBjb25zdGFudFBvb2wpIHtcbiAgICB2YXIgcGFyYW1ldGVycyA9IFtnZXRRdWVyeVByZWRpY2F0ZShxdWVyeSwgY29uc3RhbnRQb29sKSwgbGl0ZXJhbChxdWVyeS5kZXNjZW5kYW50cyldO1xuICAgIGlmIChxdWVyeS5yZWFkKSB7XG4gICAgICAgIHBhcmFtZXRlcnMucHVzaChxdWVyeS5yZWFkKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtZXRlcnM7XG59XG4vLyBUdXJuIGEgZGlyZWN0aXZlIHNlbGVjdG9yIGludG8gYW4gUjMtY29tcGF0aWJsZSBzZWxlY3RvciBmb3IgZGlyZWN0aXZlIGRlZlxuZnVuY3Rpb24gY3JlYXRlRGlyZWN0aXZlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gYXNMaXRlcmFsKHBhcnNlU2VsZWN0b3JUb1IzU2VsZWN0b3Ioc2VsZWN0b3IpKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRBdHRyaWJ1dGVzVG9FeHByZXNzaW9ucyhhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGVfMiwgX2E7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cmlidXRlcykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gX2MudmFsdWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChsaXRlcmFsKGtleSksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbi8vIERlZmluZSBhbmQgdXBkYXRlIGFueSBjb250ZW50IHF1ZXJpZXNcbmZ1bmN0aW9uIGNyZWF0ZUNvbnRlbnRRdWVyaWVzRnVuY3Rpb24ocXVlcmllcywgY29uc3RhbnRQb29sLCBuYW1lKSB7XG4gICAgdmFyIGVfMywgX2E7XG4gICAgdmFyIGNyZWF0ZVN0YXRlbWVudHMgPSBbXTtcbiAgICB2YXIgdXBkYXRlU3RhdGVtZW50cyA9IFtdO1xuICAgIHZhciB0ZW1wQWxsb2NhdG9yID0gdGVtcG9yYXJ5QWxsb2NhdG9yKHVwZGF0ZVN0YXRlbWVudHMsIFRFTVBPUkFSWV9OQU1FKTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBxdWVyaWVzXzEgPSBfX3ZhbHVlcyhxdWVyaWVzKSwgcXVlcmllc18xXzEgPSBxdWVyaWVzXzEubmV4dCgpOyAhcXVlcmllc18xXzEuZG9uZTsgcXVlcmllc18xXzEgPSBxdWVyaWVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBxdWVyaWVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIHZhciBxdWVyeUluc3RydWN0aW9uID0gcXVlcnkuc3RhdGljID8gSWRlbnRpZmllcnMkMS5zdGF0aWNDb250ZW50UXVlcnkgOiBJZGVudGlmaWVycyQxLmNvbnRlbnRRdWVyeTtcbiAgICAgICAgICAgIC8vIGNyZWF0aW9uLCBlLmcuIHIzLmNvbnRlbnRRdWVyeShkaXJJbmRleCwgc29tZVByZWRpY2F0ZSwgdHJ1ZSwgbnVsbCk7XG4gICAgICAgICAgICBjcmVhdGVTdGF0ZW1lbnRzLnB1c2goaW1wb3J0RXhwcihxdWVyeUluc3RydWN0aW9uKVxuICAgICAgICAgICAgICAgIC5jYWxsRm4oX19zcHJlYWQoW3ZhcmlhYmxlKCdkaXJJbmRleCcpXSwgcHJlcGFyZVF1ZXJ5UGFyYW1zKHF1ZXJ5LCBjb25zdGFudFBvb2wpKSlcbiAgICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgICAgLy8gdXBkYXRlLCBlLmcuIChyMy5xdWVyeVJlZnJlc2godG1wID0gcjMubG9hZENvbnRlbnRRdWVyeSgpKSAmJiAoY3R4LnNvbWVEaXIgPSB0bXApKTtcbiAgICAgICAgICAgIHZhciB0ZW1wb3JhcnkgPSB0ZW1wQWxsb2NhdG9yKCk7XG4gICAgICAgICAgICB2YXIgZ2V0UXVlcnlMaXN0ID0gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmxvYWRDb250ZW50UXVlcnkpLmNhbGxGbihbXSk7XG4gICAgICAgICAgICB2YXIgcmVmcmVzaCA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5xdWVyeVJlZnJlc2gpLmNhbGxGbihbdGVtcG9yYXJ5LnNldChnZXRRdWVyeUxpc3QpXSk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlRGlyZWN0aXZlID0gdmFyaWFibGUoQ09OVEVYVF9OQU1FKVxuICAgICAgICAgICAgICAgIC5wcm9wKHF1ZXJ5LnByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAuc2V0KHF1ZXJ5LmZpcnN0ID8gdGVtcG9yYXJ5LnByb3AoJ2ZpcnN0JykgOiB0ZW1wb3JhcnkpO1xuICAgICAgICAgICAgdXBkYXRlU3RhdGVtZW50cy5wdXNoKHJlZnJlc2guYW5kKHVwZGF0ZURpcmVjdGl2ZSkudG9TdG10KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocXVlcmllc18xXzEgJiYgIXF1ZXJpZXNfMV8xLmRvbmUgJiYgKF9hID0gcXVlcmllc18xLnJldHVybikpIF9hLmNhbGwocXVlcmllc18xKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgfVxuICAgIHZhciBjb250ZW50UXVlcmllc0ZuTmFtZSA9IG5hbWUgPyBuYW1lICsgXCJfQ29udGVudFF1ZXJpZXNcIiA6IG51bGw7XG4gICAgcmV0dXJuIGZuKFtcbiAgICAgICAgbmV3IEZuUGFyYW0oUkVOREVSX0ZMQUdTLCBOVU1CRVJfVFlQRSksIG5ldyBGblBhcmFtKENPTlRFWFRfTkFNRSwgbnVsbCksXG4gICAgICAgIG5ldyBGblBhcmFtKCdkaXJJbmRleCcsIG51bGwpXG4gICAgXSwgW1xuICAgICAgICByZW5kZXJGbGFnQ2hlY2tJZlN0bXQoMSAvKiBDcmVhdGUgKi8sIGNyZWF0ZVN0YXRlbWVudHMpLFxuICAgICAgICByZW5kZXJGbGFnQ2hlY2tJZlN0bXQoMiAvKiBVcGRhdGUgKi8sIHVwZGF0ZVN0YXRlbWVudHMpXG4gICAgXSwgSU5GRVJSRURfVFlQRSwgbnVsbCwgY29udGVudFF1ZXJpZXNGbk5hbWUpO1xufVxuZnVuY3Rpb24gc3RyaW5nQXNUeXBlKHN0cikge1xuICAgIHJldHVybiBleHByZXNzaW9uVHlwZShsaXRlcmFsKHN0cikpO1xufVxuZnVuY3Rpb24gc3RyaW5nTWFwQXNUeXBlKG1hcCkge1xuICAgIHZhciBtYXBWYWx1ZXMgPSBPYmplY3Qua2V5cyhtYXApLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IEFycmF5LmlzQXJyYXkobWFwW2tleV0pID8gbWFwW2tleV1bMF0gOiBtYXBba2V5XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IGxpdGVyYWwodmFsdWUpLFxuICAgICAgICAgICAgcXVvdGVkOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBleHByZXNzaW9uVHlwZShsaXRlcmFsTWFwKG1hcFZhbHVlcykpO1xufVxuZnVuY3Rpb24gc3RyaW5nQXJyYXlBc1R5cGUoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5sZW5ndGggPiAwID8gZXhwcmVzc2lvblR5cGUobGl0ZXJhbEFycihhcnIubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbGl0ZXJhbCh2YWx1ZSk7IH0pKSkgOlxuICAgICAgICBOT05FX1RZUEU7XG59XG5mdW5jdGlvbiBjcmVhdGVUeXBlRm9yRGVmKG1ldGEsIHR5cGVCYXNlKSB7XG4gICAgLy8gT24gdGhlIHR5cGUgc2lkZSwgcmVtb3ZlIG5ld2xpbmVzIGZyb20gdGhlIHNlbGVjdG9yIGFzIGl0IHdpbGwgbmVlZCB0byBmaXQgaW50byBhIFR5cGVTY3JpcHRcbiAgICAvLyBzdHJpbmcgbGl0ZXJhbCwgd2hpY2ggbXVzdCBiZSBvbiBvbmUgbGluZS5cbiAgICB2YXIgc2VsZWN0b3JGb3JUeXBlID0gKG1ldGEuc2VsZWN0b3IgfHwgJycpLnJlcGxhY2UoL1xcbi9nLCAnJyk7XG4gICAgcmV0dXJuIGV4cHJlc3Npb25UeXBlKGltcG9ydEV4cHIodHlwZUJhc2UsIFtcbiAgICAgICAgdHlwZVdpdGhQYXJhbWV0ZXJzKG1ldGEudHlwZSwgbWV0YS50eXBlQXJndW1lbnRDb3VudCksXG4gICAgICAgIHN0cmluZ0FzVHlwZShzZWxlY3RvckZvclR5cGUpLFxuICAgICAgICBtZXRhLmV4cG9ydEFzICE9PSBudWxsID8gc3RyaW5nQXJyYXlBc1R5cGUobWV0YS5leHBvcnRBcykgOiBOT05FX1RZUEUsXG4gICAgICAgIHN0cmluZ01hcEFzVHlwZShtZXRhLmlucHV0cyksXG4gICAgICAgIHN0cmluZ01hcEFzVHlwZShtZXRhLm91dHB1dHMpLFxuICAgICAgICBzdHJpbmdBcnJheUFzVHlwZShtZXRhLnF1ZXJpZXMubWFwKGZ1bmN0aW9uIChxKSB7IHJldHVybiBxLnByb3BlcnR5TmFtZTsgfSkpLFxuICAgIF0pKTtcbn1cbi8vIERlZmluZSBhbmQgdXBkYXRlIGFueSB2aWV3IHF1ZXJpZXNcbmZ1bmN0aW9uIGNyZWF0ZVZpZXdRdWVyaWVzRnVuY3Rpb24odmlld1F1ZXJpZXMsIGNvbnN0YW50UG9vbCwgbmFtZSkge1xuICAgIHZhciBjcmVhdGVTdGF0ZW1lbnRzID0gW107XG4gICAgdmFyIHVwZGF0ZVN0YXRlbWVudHMgPSBbXTtcbiAgICB2YXIgdGVtcEFsbG9jYXRvciA9IHRlbXBvcmFyeUFsbG9jYXRvcih1cGRhdGVTdGF0ZW1lbnRzLCBURU1QT1JBUllfTkFNRSk7XG4gICAgdmlld1F1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgdmFyIHF1ZXJ5SW5zdHJ1Y3Rpb24gPSBxdWVyeS5zdGF0aWMgPyBJZGVudGlmaWVycyQxLnN0YXRpY1ZpZXdRdWVyeSA6IElkZW50aWZpZXJzJDEudmlld1F1ZXJ5O1xuICAgICAgICAvLyBjcmVhdGlvbiwgZS5nLiByMy52aWV3UXVlcnkoc29tZVByZWRpY2F0ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBxdWVyeURlZmluaXRpb24gPSBpbXBvcnRFeHByKHF1ZXJ5SW5zdHJ1Y3Rpb24pLmNhbGxGbihwcmVwYXJlUXVlcnlQYXJhbXMocXVlcnksIGNvbnN0YW50UG9vbCkpO1xuICAgICAgICBjcmVhdGVTdGF0ZW1lbnRzLnB1c2gocXVlcnlEZWZpbml0aW9uLnRvU3RtdCgpKTtcbiAgICAgICAgLy8gdXBkYXRlLCBlLmcuIChyMy5xdWVyeVJlZnJlc2godG1wID0gcjMubG9hZFZpZXdRdWVyeSgpKSAmJiAoY3R4LnNvbWVEaXIgPSB0bXApKTtcbiAgICAgICAgdmFyIHRlbXBvcmFyeSA9IHRlbXBBbGxvY2F0b3IoKTtcbiAgICAgICAgdmFyIGdldFF1ZXJ5TGlzdCA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5sb2FkVmlld1F1ZXJ5KS5jYWxsRm4oW10pO1xuICAgICAgICB2YXIgcmVmcmVzaCA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5xdWVyeVJlZnJlc2gpLmNhbGxGbihbdGVtcG9yYXJ5LnNldChnZXRRdWVyeUxpc3QpXSk7XG4gICAgICAgIHZhciB1cGRhdGVEaXJlY3RpdmUgPSB2YXJpYWJsZShDT05URVhUX05BTUUpXG4gICAgICAgICAgICAucHJvcChxdWVyeS5wcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAuc2V0KHF1ZXJ5LmZpcnN0ID8gdGVtcG9yYXJ5LnByb3AoJ2ZpcnN0JykgOiB0ZW1wb3JhcnkpO1xuICAgICAgICB1cGRhdGVTdGF0ZW1lbnRzLnB1c2gocmVmcmVzaC5hbmQodXBkYXRlRGlyZWN0aXZlKS50b1N0bXQoKSk7XG4gICAgfSk7XG4gICAgdmFyIHZpZXdRdWVyeUZuTmFtZSA9IG5hbWUgPyBuYW1lICsgXCJfUXVlcnlcIiA6IG51bGw7XG4gICAgcmV0dXJuIGZuKFtuZXcgRm5QYXJhbShSRU5ERVJfRkxBR1MsIE5VTUJFUl9UWVBFKSwgbmV3IEZuUGFyYW0oQ09OVEVYVF9OQU1FLCBudWxsKV0sIFtcbiAgICAgICAgcmVuZGVyRmxhZ0NoZWNrSWZTdG10KDEgLyogQ3JlYXRlICovLCBjcmVhdGVTdGF0ZW1lbnRzKSxcbiAgICAgICAgcmVuZGVyRmxhZ0NoZWNrSWZTdG10KDIgLyogVXBkYXRlICovLCB1cGRhdGVTdGF0ZW1lbnRzKVxuICAgIF0sIElORkVSUkVEX1RZUEUsIG51bGwsIHZpZXdRdWVyeUZuTmFtZSk7XG59XG4vLyBSZXR1cm4gYSBob3N0IGJpbmRpbmcgZnVuY3Rpb24gb3IgbnVsbCBpZiBvbmUgaXMgbm90IG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIGNyZWF0ZUhvc3RCaW5kaW5nc0Z1bmN0aW9uKGhvc3RCaW5kaW5nc01ldGFkYXRhLCB0eXBlU291cmNlU3BhbiwgYmluZGluZ1BhcnNlciwgY29uc3RhbnRQb29sLCBzZWxlY3RvciwgbmFtZSkge1xuICAgIC8vIEluaXRpYWxpemUgaG9zdFZhcnNDb3VudCB0byBudW1iZXIgb2YgYm91bmQgaG9zdCBwcm9wZXJ0aWVzIChpbnRlcnBvbGF0aW9ucyBpbGxlZ2FsKVxuICAgIHZhciBob3N0VmFyc0NvdW50ID0gT2JqZWN0LmtleXMoaG9zdEJpbmRpbmdzTWV0YWRhdGEucHJvcGVydGllcykubGVuZ3RoO1xuICAgIHZhciBlbFZhckV4cCA9IHZhcmlhYmxlKCdlbEluZGV4Jyk7XG4gICAgdmFyIGJpbmRpbmdDb250ZXh0ID0gdmFyaWFibGUoQ09OVEVYVF9OQU1FKTtcbiAgICB2YXIgc3R5bGVCdWlsZGVyID0gbmV3IFN0eWxpbmdCdWlsZGVyKGVsVmFyRXhwLCBiaW5kaW5nQ29udGV4dCk7XG4gICAgdmFyIF9hID0gaG9zdEJpbmRpbmdzTWV0YWRhdGEuc3BlY2lhbEF0dHJpYnV0ZXMsIHN0eWxlQXR0ciA9IF9hLnN0eWxlQXR0ciwgY2xhc3NBdHRyID0gX2EuY2xhc3NBdHRyO1xuICAgIGlmIChzdHlsZUF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdHlsZUJ1aWxkZXIucmVnaXN0ZXJTdHlsZUF0dHIoc3R5bGVBdHRyKTtcbiAgICB9XG4gICAgaWYgKGNsYXNzQXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0eWxlQnVpbGRlci5yZWdpc3RlckNsYXNzQXR0cihjbGFzc0F0dHIpO1xuICAgIH1cbiAgICB2YXIgY3JlYXRlU3RhdGVtZW50cyA9IFtdO1xuICAgIHZhciB1cGRhdGVTdGF0ZW1lbnRzID0gW107XG4gICAgdmFyIHRvdGFsSG9zdFZhcnNDb3VudCA9IGhvc3RWYXJzQ291bnQ7XG4gICAgdmFyIGhvc3RCaW5kaW5nU291cmNlU3BhbiA9IHR5cGVTb3VyY2VTcGFuO1xuICAgIHZhciBkaXJlY3RpdmVTdW1tYXJ5ID0gbWV0YWRhdGFBc1N1bW1hcnkoaG9zdEJpbmRpbmdzTWV0YWRhdGEpO1xuICAgIHZhciB2YWx1ZUNvbnZlcnRlcjtcbiAgICB2YXIgZ2V0VmFsdWVDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdmFsdWVDb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgIHZhciBob3N0VmFyc0NvdW50Rm4gPSBmdW5jdGlvbiAobnVtU2xvdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxWYXJzQ291bnQgPSB0b3RhbEhvc3RWYXJzQ291bnQ7XG4gICAgICAgICAgICAgICAgdG90YWxIb3N0VmFyc0NvdW50ICs9IG51bVNsb3RzO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFZhcnNDb3VudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YWx1ZUNvbnZlcnRlciA9IG5ldyBWYWx1ZUNvbnZlcnRlcihjb25zdGFudFBvb2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yKCdVbmV4cGVjdGVkIG5vZGUnKTsgfSwgLy8gbmV3IG5vZGVzIGFyZSBpbGxlZ2FsIGhlcmVcbiAgICAgICAgICAgIGhvc3RWYXJzQ291bnRGbiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3IoJ1VuZXhwZWN0ZWQgcGlwZScpOyB9KTsgLy8gcGlwZXMgYXJlIGlsbGVnYWwgaGVyZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZUNvbnZlcnRlcjtcbiAgICB9O1xuICAgIC8vIENhbGN1bGF0ZSBob3N0IGV2ZW50IGJpbmRpbmdzXG4gICAgdmFyIGV2ZW50QmluZGluZ3MgPSBiaW5kaW5nUGFyc2VyLmNyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMoZGlyZWN0aXZlU3VtbWFyeSwgaG9zdEJpbmRpbmdTb3VyY2VTcGFuKTtcbiAgICBpZiAoZXZlbnRCaW5kaW5ncyAmJiBldmVudEJpbmRpbmdzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gY3JlYXRlSG9zdExpc3RlbmVycyhldmVudEJpbmRpbmdzLCBuYW1lKTtcbiAgICAgICAgY3JlYXRlU3RhdGVtZW50cy5wdXNoLmFwcGx5KGNyZWF0ZVN0YXRlbWVudHMsIF9fc3ByZWFkKGxpc3RlbmVycykpO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGhvc3QgcHJvcGVydHkgYmluZGluZ3NcbiAgICB2YXIgYmluZGluZ3MgPSBiaW5kaW5nUGFyc2VyLmNyZWF0ZUJvdW5kSG9zdFByb3BlcnRpZXMoZGlyZWN0aXZlU3VtbWFyeSwgaG9zdEJpbmRpbmdTb3VyY2VTcGFuKTtcbiAgICB2YXIgcHJvcGVydHlCaW5kaW5ncyA9IFtdO1xuICAgIHZhciBhdHRyaWJ1dGVCaW5kaW5ncyA9IFtdO1xuICAgIHZhciBzeW50aGV0aWNIb3N0QmluZGluZ3MgPSBbXTtcbiAgICBiaW5kaW5ncyAmJiBiaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgIHZhciBuYW1lID0gYmluZGluZy5uYW1lO1xuICAgICAgICB2YXIgc3R5bGluZ0lucHV0V2FzU2V0ID0gc3R5bGVCdWlsZGVyLnJlZ2lzdGVySW5wdXRCYXNlZE9uTmFtZShuYW1lLCBiaW5kaW5nLmV4cHJlc3Npb24sIGJpbmRpbmcuc291cmNlU3Bhbik7XG4gICAgICAgIGlmICghc3R5bGluZ0lucHV0V2FzU2V0KSB7XG4gICAgICAgICAgICAvLyByZXNvbHZlIGxpdGVyYWwgYXJyYXlzIGFuZCBsaXRlcmFsIG9iamVjdHNcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGJpbmRpbmcuZXhwcmVzc2lvbi52aXNpdChnZXRWYWx1ZUNvbnZlcnRlcigpKTtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nRXhwciA9IGJpbmRpbmdGbihiaW5kaW5nQ29udGV4dCwgdmFsdWUpO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0QmluZGluZ05hbWVBbmRJbnN0cnVjdGlvbihiaW5kaW5nKSwgYmluZGluZ05hbWUgPSBfYS5iaW5kaW5nTmFtZSwgaW5zdHJ1Y3Rpb24gPSBfYS5pbnN0cnVjdGlvbiwgaXNBdHRyaWJ1dGUgPSBfYS5pc0F0dHJpYnV0ZTtcbiAgICAgICAgICAgIHZhciBzZWN1cml0eUNvbnRleHRzID0gYmluZGluZ1BhcnNlci5jYWxjUG9zc2libGVTZWN1cml0eUNvbnRleHRzKHNlbGVjdG9yLCBiaW5kaW5nTmFtZSwgaXNBdHRyaWJ1dGUpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gY29udGV4dCAhPT0gU2VjdXJpdHlDb250ZXh0Lk5PTkU7IH0pO1xuICAgICAgICAgICAgdmFyIHNhbml0aXplckZuID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChzZWN1cml0eUNvbnRleHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWN1cml0eUNvbnRleHRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzLmluZGV4T2YoU2VjdXJpdHlDb250ZXh0LlVSTCkgPiAtMSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzLmluZGV4T2YoU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTCkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHNvbWUgVVJMIGF0dHJpYnV0ZXMgKHN1Y2ggYXMgXCJzcmNcIiBhbmQgXCJocmVmXCIpIHRoYXQgbWF5IGJlIGEgcGFydFxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBkaWZmZXJlbnQgc2VjdXJpdHkgY29udGV4dHMuIEluIHRoaXMgY2FzZSB3ZSB1c2Ugc3BlY2lhbCBzYW50aXRpemF0aW9uIGZ1bmN0aW9uIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3QgdGhlIGFjdHVhbCBzYW5pdGl6ZXIgYXQgcnVudGltZSBiYXNlZCBvbiBhIHRhZyBuYW1lIHRoYXQgaXMgcHJvdmlkZWQgd2hpbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaW52b2tpbmcgc2FuaXRpemF0aW9uIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBzYW5pdGl6ZXJGbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5zYW5pdGl6ZVVybE9yUmVzb3VyY2VVcmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2FuaXRpemVyRm4gPSByZXNvbHZlU2FuaXRpemF0aW9uRm4oc2VjdXJpdHlDb250ZXh0c1swXSwgaXNBdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbnN0cnVjdGlvblBhcmFtcyA9IFtsaXRlcmFsKGJpbmRpbmdOYW1lKSwgYmluZGluZ0V4cHIuY3VyclZhbEV4cHJdO1xuICAgICAgICAgICAgaWYgKHNhbml0aXplckZuKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25QYXJhbXMucHVzaChzYW5pdGl6ZXJGbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVTdGF0ZW1lbnRzLnB1c2guYXBwbHkodXBkYXRlU3RhdGVtZW50cywgX19zcHJlYWQoYmluZGluZ0V4cHIuc3RtdHMpKTtcbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbiA9PT0gSWRlbnRpZmllcnMkMS5ob3N0UHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUJpbmRpbmdzLnB1c2goaW5zdHJ1Y3Rpb25QYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb24gPT09IElkZW50aWZpZXJzJDEuYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlQmluZGluZ3MucHVzaChpbnN0cnVjdGlvblBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbiA9PT0gSWRlbnRpZmllcnMkMS51cGRhdGVTeW50aGV0aWNIb3N0QmluZGluZykge1xuICAgICAgICAgICAgICAgIHN5bnRoZXRpY0hvc3RCaW5kaW5ncy5wdXNoKGluc3RydWN0aW9uUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVN0YXRlbWVudHMucHVzaChpbXBvcnRFeHByKGluc3RydWN0aW9uKS5jYWxsRm4oaW5zdHJ1Y3Rpb25QYXJhbXMpLnRvU3RtdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChwcm9wZXJ0eUJpbmRpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdXBkYXRlU3RhdGVtZW50cy5wdXNoKGNoYWluZWRJbnN0cnVjdGlvbihJZGVudGlmaWVycyQxLmhvc3RQcm9wZXJ0eSwgcHJvcGVydHlCaW5kaW5ncykudG9TdG10KCkpO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlQmluZGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICB1cGRhdGVTdGF0ZW1lbnRzLnB1c2goY2hhaW5lZEluc3RydWN0aW9uKElkZW50aWZpZXJzJDEuYXR0cmlidXRlLCBhdHRyaWJ1dGVCaW5kaW5ncykudG9TdG10KCkpO1xuICAgIH1cbiAgICBpZiAoc3ludGhldGljSG9zdEJpbmRpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdXBkYXRlU3RhdGVtZW50cy5wdXNoKGNoYWluZWRJbnN0cnVjdGlvbihJZGVudGlmaWVycyQxLnVwZGF0ZVN5bnRoZXRpY0hvc3RCaW5kaW5nLCBzeW50aGV0aWNIb3N0QmluZGluZ3MpLnRvU3RtdCgpKTtcbiAgICB9XG4gICAgLy8gc2luY2Ugd2UncmUgZGVhbGluZyB3aXRoIGRpcmVjdGl2ZXMvY29tcG9uZW50cyBhbmQgYm90aCBoYXZlIGhvc3RCaW5kaW5nXG4gICAgLy8gZnVuY3Rpb25zLCB3ZSBuZWVkIHRvIGdlbmVyYXRlIGEgc3BlY2lhbCBob3N0QXR0cnMgaW5zdHJ1Y3Rpb24gdGhhdCBkZWFsc1xuICAgIC8vIHdpdGggYm90aCB0aGUgYXNzaWdubWVudCBvZiBzdHlsaW5nIGFzIHdlbGwgYXMgc3RhdGljIGF0dHJpYnV0ZXMgdG8gdGhlIGhvc3RcbiAgICAvLyBlbGVtZW50LiBUaGUgaW5zdHJ1Y3Rpb24gYmVsb3cgd2lsbCBpbnN0cnVjdCBhbGwgaW5pdGlhbCBzdHlsaW5nIChzdHlsaW5nXG4gICAgLy8gdGhhdCBpcyBpbnNpZGUgb2YgYSBob3N0IGJpbmRpbmcgd2l0aGluIGEgZGlyZWN0aXZlL2NvbXBvbmVudCkgdG8gYmUgYXR0YWNoZWRcbiAgICAvLyB0byB0aGUgaG9zdCBlbGVtZW50IGFsb25nc2lkZSBhbnkgb2YgdGhlIHByb3ZpZGVkIGhvc3QgYXR0cmlidXRlcyB0aGF0IHdlcmVcbiAgICAvLyBjb2xsZWN0ZWQgZWFybGllci5cbiAgICB2YXIgaG9zdEF0dHJzID0gY29udmVydEF0dHJpYnV0ZXNUb0V4cHJlc3Npb25zKGhvc3RCaW5kaW5nc01ldGFkYXRhLmF0dHJpYnV0ZXMpO1xuICAgIHZhciBob3N0SW5zdHJ1Y3Rpb24gPSBzdHlsZUJ1aWxkZXIuYnVpbGRIb3N0QXR0cnNJbnN0cnVjdGlvbihudWxsLCBob3N0QXR0cnMsIGNvbnN0YW50UG9vbCk7XG4gICAgaWYgKGhvc3RJbnN0cnVjdGlvbikge1xuICAgICAgICBjcmVhdGVTdGF0ZW1lbnRzLnB1c2goY3JlYXRlU3R5bGluZ1N0bXQoaG9zdEluc3RydWN0aW9uLCBiaW5kaW5nQ29udGV4dCwgYmluZGluZ0ZuKSk7XG4gICAgfVxuICAgIGlmIChzdHlsZUJ1aWxkZXIuaGFzQmluZGluZ3MpIHtcbiAgICAgICAgLy8gc2luZ3VsYXIgc3R5bGUvY2xhc3MgYmluZGluZ3MgKHRoaW5ncyBsaWtlIGBbc3R5bGUucHJvcF1gIGFuZCBgW2NsYXNzLm5hbWVdYClcbiAgICAgICAgLy8gTVVTVCBiZSByZWdpc3RlcmVkIG9uIGEgZ2l2ZW4gZWxlbWVudCB3aXRoaW4gdGhlIGNvbXBvbmVudC9kaXJlY3RpdmVcbiAgICAgICAgLy8gdGVtcGxhdGVGbi9ob3N0QmluZGluZ3NGbiBmdW5jdGlvbnMuIFRoZSBpbnN0cnVjdGlvbiBiZWxvdyB3aWxsIGZpZ3VyZSBvdXRcbiAgICAgICAgLy8gd2hhdCBhbGwgdGhlIGJpbmRpbmdzIGFyZSBhbmQgdGhlbiBnZW5lcmF0ZSB0aGUgc3RhdGVtZW50cyByZXF1aXJlZCB0byByZWdpc3RlclxuICAgICAgICAvLyB0aG9zZSBiaW5kaW5ncyB0byB0aGUgZWxlbWVudCB2aWEgYHN0eWxpbmdgLlxuICAgICAgICB2YXIgc3R5bGluZ0luc3RydWN0aW9uID0gc3R5bGVCdWlsZGVyLmJ1aWxkU3R5bGluZ0luc3RydWN0aW9uKG51bGwsIGNvbnN0YW50UG9vbCk7XG4gICAgICAgIGlmIChzdHlsaW5nSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIGNyZWF0ZVN0YXRlbWVudHMucHVzaChjcmVhdGVTdHlsaW5nU3RtdChzdHlsaW5nSW5zdHJ1Y3Rpb24sIGJpbmRpbmdDb250ZXh0LCBiaW5kaW5nRm4pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5hbGx5IGVhY2ggYmluZGluZyB0aGF0IHdhcyByZWdpc3RlcmVkIGluIHRoZSBzdGF0ZW1lbnQgYWJvdmUgd2lsbCBuZWVkIHRvIGJlIGFkZGVkIHRvXG4gICAgICAgIC8vIHRoZSB1cGRhdGUgYmxvY2sgb2YgYSBjb21wb25lbnQvZGlyZWN0aXZlIHRlbXBsYXRlRm4vaG9zdEJpbmRpbmdzRm4gc28gdGhhdCB0aGUgYmluZGluZ3NcbiAgICAgICAgLy8gYXJlIGV2YWx1YXRlZCBhbmQgdXBkYXRlZCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgICAgIHN0eWxlQnVpbGRlci5idWlsZFVwZGF0ZUxldmVsSW5zdHJ1Y3Rpb25zKGdldFZhbHVlQ29udmVydGVyKCkpLmZvckVhY2goZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICAvLyB3ZSBzdWJ0cmFjdCBhIHZhbHVlIG9mIGAxYCBoZXJlIGJlY2F1c2UgdGhlIGJpbmRpbmcgc2xvdCB3YXMgYWxyZWFkeVxuICAgICAgICAgICAgLy8gYWxsb2NhdGVkIGF0IHRoZSB0b3Agb2YgdGhpcyBtZXRob2Qgd2hlbiBhbGwgdGhlIGlucHV0IGJpbmRpbmdzIHdlcmVcbiAgICAgICAgICAgIC8vIGNvdW50ZWQuXG4gICAgICAgICAgICB0b3RhbEhvc3RWYXJzQ291bnQgKz0gTWF0aC5tYXgoaW5zdHJ1Y3Rpb24uYWxsb2NhdGVCaW5kaW5nU2xvdHMgLSAxLCAwKTtcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlbWVudHMucHVzaChjcmVhdGVTdHlsaW5nU3RtdChpbnN0cnVjdGlvbiwgYmluZGluZ0NvbnRleHQsIGJpbmRpbmdGbikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRvdGFsSG9zdFZhcnNDb3VudCkge1xuICAgICAgICBjcmVhdGVTdGF0ZW1lbnRzLnVuc2hpZnQoaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmFsbG9jSG9zdFZhcnMpLmNhbGxGbihbbGl0ZXJhbCh0b3RhbEhvc3RWYXJzQ291bnQpXSkudG9TdG10KCkpO1xuICAgIH1cbiAgICBpZiAoY3JlYXRlU3RhdGVtZW50cy5sZW5ndGggPiAwIHx8IHVwZGF0ZVN0YXRlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgaG9zdEJpbmRpbmdzRm5OYW1lID0gbmFtZSA/IG5hbWUgKyBcIl9Ib3N0QmluZGluZ3NcIiA6IG51bGw7XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgIGlmIChjcmVhdGVTdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChyZW5kZXJGbGFnQ2hlY2tJZlN0bXQoMSAvKiBDcmVhdGUgKi8sIGNyZWF0ZVN0YXRlbWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlU3RhdGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocmVuZGVyRmxhZ0NoZWNrSWZTdG10KDIgLyogVXBkYXRlICovLCB1cGRhdGVTdGF0ZW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuKFtcbiAgICAgICAgICAgIG5ldyBGblBhcmFtKFJFTkRFUl9GTEFHUywgTlVNQkVSX1RZUEUpLCBuZXcgRm5QYXJhbShDT05URVhUX05BTUUsIG51bGwpLFxuICAgICAgICAgICAgbmV3IEZuUGFyYW0oZWxWYXJFeHAubmFtZSwgTlVNQkVSX1RZUEUpXG4gICAgICAgIF0sIHN0YXRlbWVudHMsIElORkVSUkVEX1RZUEUsIG51bGwsIGhvc3RCaW5kaW5nc0ZuTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYmluZGluZ0ZuKGltcGxpY2l0LCB2YWx1ZSkge1xuICAgIHJldHVybiBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKG51bGwsIGltcGxpY2l0LCB2YWx1ZSwgJ2InLCBCaW5kaW5nRm9ybS5UcnlTaW1wbGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yKCdVbmV4cGVjdGVkIGludGVycG9sYXRpb24nKTsgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdHlsaW5nU3RtdChpbnN0cnVjdGlvbiwgYmluZGluZ0NvbnRleHQsIGJpbmRpbmdGbikge1xuICAgIHZhciBwYXJhbXMgPSBpbnN0cnVjdGlvbi5wYXJhbXMoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBiaW5kaW5nRm4oYmluZGluZ0NvbnRleHQsIHZhbHVlKS5jdXJyVmFsRXhwcjsgfSk7XG4gICAgcmV0dXJuIGltcG9ydEV4cHIoaW5zdHJ1Y3Rpb24ucmVmZXJlbmNlLCBudWxsLCBpbnN0cnVjdGlvbi5zb3VyY2VTcGFuKVxuICAgICAgICAuY2FsbEZuKHBhcmFtcywgaW5zdHJ1Y3Rpb24uc291cmNlU3BhbilcbiAgICAgICAgLnRvU3RtdCgpO1xufVxuZnVuY3Rpb24gZ2V0QmluZGluZ05hbWVBbmRJbnN0cnVjdGlvbihiaW5kaW5nKSB7XG4gICAgdmFyIGJpbmRpbmdOYW1lID0gYmluZGluZy5uYW1lO1xuICAgIHZhciBpbnN0cnVjdGlvbjtcbiAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhpcyBpcyBhbiBhdHRyIGJpbmRpbmcgb3IgYSBwcm9wZXJ0eSBiaW5kaW5nXG4gICAgdmFyIGF0dHJNYXRjaGVzID0gYmluZGluZ05hbWUubWF0Y2goQVRUUl9SRUdFWCk7XG4gICAgaWYgKGF0dHJNYXRjaGVzKSB7XG4gICAgICAgIGJpbmRpbmdOYW1lID0gYXR0ck1hdGNoZXNbMV07XG4gICAgICAgIGluc3RydWN0aW9uID0gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoYmluZGluZy5pc0FuaW1hdGlvbikge1xuICAgICAgICAgICAgYmluZGluZ05hbWUgPSBwcmVwYXJlU3ludGhldGljUHJvcGVydHlOYW1lKGJpbmRpbmdOYW1lKTtcbiAgICAgICAgICAgIC8vIGhvc3QgYmluZGluZ3MgdGhhdCBoYXZlIGEgc3ludGhldGljIHByb3BlcnR5IChlLmcuIEBmb28pIHNob3VsZCBhbHdheXMgYmUgcmVuZGVyZWRcbiAgICAgICAgICAgIC8vIGluIHRoZSBjb250ZXh0IG9mIHRoZSBjb21wb25lbnQgYW5kIG5vdCB0aGUgcGFyZW50LiBUaGVyZWZvcmUgdGhlcmUgaXMgYSBzcGVjaWFsXG4gICAgICAgICAgICAvLyBjb21wYXRpYmlsaXR5IGluc3RydWN0aW9uIGF2YWlsYWJsZSBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBJZGVudGlmaWVycyQxLnVwZGF0ZVN5bnRoZXRpY0hvc3RCaW5kaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBJZGVudGlmaWVycyQxLmhvc3RQcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBiaW5kaW5nTmFtZTogYmluZGluZ05hbWUsIGluc3RydWN0aW9uOiBpbnN0cnVjdGlvbiwgaXNBdHRyaWJ1dGU6ICEhYXR0ck1hdGNoZXMgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhvc3RMaXN0ZW5lcnMoZXZlbnRCaW5kaW5ncywgbmFtZSkge1xuICAgIHJldHVybiBldmVudEJpbmRpbmdzLm1hcChmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgICB2YXIgYmluZGluZ05hbWUgPSBiaW5kaW5nLm5hbWUgJiYgc2FuaXRpemVJZGVudGlmaWVyKGJpbmRpbmcubmFtZSk7XG4gICAgICAgIHZhciBiaW5kaW5nRm5OYW1lID0gYmluZGluZy50eXBlID09PSAxIC8qIEFuaW1hdGlvbiAqLyA/XG4gICAgICAgICAgICBwcmVwYXJlU3ludGhldGljTGlzdGVuZXJGdW5jdGlvbk5hbWUoYmluZGluZ05hbWUsIGJpbmRpbmcudGFyZ2V0T3JQaGFzZSkgOlxuICAgICAgICAgICAgYmluZGluZ05hbWU7XG4gICAgICAgIHZhciBoYW5kbGVyTmFtZSA9IG5hbWUgJiYgYmluZGluZ05hbWUgPyBuYW1lICsgXCJfXCIgKyBiaW5kaW5nRm5OYW1lICsgXCJfSG9zdEJpbmRpbmdIYW5kbGVyXCIgOiBudWxsO1xuICAgICAgICB2YXIgcGFyYW1zID0gcHJlcGFyZUV2ZW50TGlzdGVuZXJQYXJhbWV0ZXJzKEJvdW5kRXZlbnQuZnJvbVBhcnNlZEV2ZW50KGJpbmRpbmcpLCBoYW5kbGVyTmFtZSk7XG4gICAgICAgIHZhciBpbnN0cnVjdGlvbiA9IGJpbmRpbmcudHlwZSA9PSAxIC8qIEFuaW1hdGlvbiAqLyA/IElkZW50aWZpZXJzJDEuY29tcG9uZW50SG9zdFN5bnRoZXRpY0xpc3RlbmVyIDogSWRlbnRpZmllcnMkMS5saXN0ZW5lcjtcbiAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoaW5zdHJ1Y3Rpb24pLmNhbGxGbihwYXJhbXMpLnRvU3RtdCgpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbWV0YWRhdGFBc1N1bW1hcnkobWV0YSkge1xuICAgIC8vIGNsYW5nLWZvcm1hdCBvZmZcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgYnkgdGhlIEJpbmRpbmdQYXJzZXIsIHdoaWNoIG9ubHkgZGVhbHMgd2l0aCBsaXN0ZW5lcnMgYW5kIHByb3BlcnRpZXMuIFRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gbmVlZCB0byBwYXNzIGF0dHJpYnV0ZXMgdG8gaXQuXG4gICAgICAgIGhvc3RBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgaG9zdExpc3RlbmVyczogbWV0YS5saXN0ZW5lcnMsXG4gICAgICAgIGhvc3RQcm9wZXJ0aWVzOiBtZXRhLnByb3BlcnRpZXMsXG4gICAgfTtcbiAgICAvLyBjbGFuZy1mb3JtYXQgb25cbn1cbmZ1bmN0aW9uIHR5cGVNYXBUb0V4cHJlc3Npb25NYXAobWFwLCBvdXRwdXRDdHgpIHtcbiAgICAvLyBDb252ZXJ0IGVhY2ggbWFwIGVudHJ5IGludG8gYW5vdGhlciBlbnRyeSB3aGVyZSB0aGUgdmFsdWUgaXMgYW4gZXhwcmVzc2lvbiBpbXBvcnRpbmcgdGhlIHR5cGUuXG4gICAgdmFyIGVudHJpZXMgPSBBcnJheS5mcm9tKG1hcCkubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBrZXkgPSBfYlswXSwgdHlwZSA9IF9iWzFdO1xuICAgICAgICByZXR1cm4gW2tleSwgb3V0cHV0Q3R4LmltcG9ydEV4cHIodHlwZSldO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgTWFwKGVudHJpZXMpO1xufVxudmFyIEhPU1RfUkVHX0VYUCQxID0gL14oPzpcXFsoW15cXF1dKylcXF0pfCg/OlxcKChbXlxcKV0rKVxcKSkkLztcbmZ1bmN0aW9uIHBhcnNlSG9zdEJpbmRpbmdzKGhvc3QpIHtcbiAgICB2YXIgZV80LCBfYTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgIHZhciBsaXN0ZW5lcnMgPSB7fTtcbiAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgIHZhciBzcGVjaWFsQXR0cmlidXRlcyA9IHt9O1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoT2JqZWN0LmtleXMoaG9zdCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gX2MudmFsdWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBob3N0W2tleV07XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGtleS5tYXRjaChIT1NUX1JFR19FWFAkMSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhhbHhodWIpOiBtYWtlIHRoaXMgYSBkaWFnbm9zdGljLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNsYXNzIGJpbmRpbmcgbXVzdCBiZSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsQXR0cmlidXRlcy5jbGFzc0F0dHIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oYWx4aHViKTogbWFrZSB0aGlzIGEgZGlhZ25vc3RpYy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHlsZSBiaW5kaW5nIG11c3QgYmUgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbEF0dHJpYnV0ZXMuc3R5bGVBdHRyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gbGl0ZXJhbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGVzWzEgLyogQmluZGluZyAqL10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oYWx4aHViKTogbWFrZSB0aGlzIGEgZGlhZ25vc3RpYy5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvcGVydHkgYmluZGluZyBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc3ludGhldGljIHByb3BlcnRpZXMgKHRoZSBvbmVzIHRoYXQgaGF2ZSBhIGBAYCBhcyBhIHByZWZpeClcbiAgICAgICAgICAgICAgICAvLyBhcmUgc3RpbGwgdHJlYXRlZCB0aGUgc2FtZSBhcyByZWd1bGFyIHByb3BlcnRpZXMuIFRoZXJlZm9yZVxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIHBvaW50IGluIHN0b3JpbmcgdGhlbSBpbiBhIHNlcGFyYXRlIG1hcC5cbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW21hdGNoZXNbMSAvKiBCaW5kaW5nICovXV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoZXNbMiAvKiBFdmVudCAqL10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oYWx4aHViKTogbWFrZSB0aGlzIGEgZGlhZ25vc3RpYy5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgYmluZGluZyBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW21hdGNoZXNbMiAvKiBFdmVudCAqL11dID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiB7IGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsIGxpc3RlbmVyczogbGlzdGVuZXJzLCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBzcGVjaWFsQXR0cmlidXRlczogc3BlY2lhbEF0dHJpYnV0ZXMgfTtcbn1cbi8qKlxuICogVmVyaWZpZXMgaG9zdCBiaW5kaW5ncyBhbmQgcmV0dXJucyB0aGUgbGlzdCBvZiBlcnJvcnMgKGlmIGFueSkuIEVtcHR5IGFycmF5IGluZGljYXRlcyB0aGF0IGFcbiAqIGdpdmVuIHNldCBvZiBob3N0IGJpbmRpbmdzIGhhcyBubyBlcnJvcnMuXG4gKlxuICogQHBhcmFtIGJpbmRpbmdzIHNldCBvZiBob3N0IGJpbmRpbmdzIHRvIHZlcmlmeS5cbiAqIEBwYXJhbSBzb3VyY2VTcGFuIHNvdXJjZSBzcGFuIHdoZXJlIGhvc3QgYmluZGluZ3Mgd2VyZSBkZWZpbmVkLlxuICogQHJldHVybnMgYXJyYXkgb2YgZXJyb3JzIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHNldCBvZiBob3N0IGJpbmRpbmdzLlxuICovXG5mdW5jdGlvbiB2ZXJpZnlIb3N0QmluZGluZ3MoYmluZGluZ3MsIHNvdXJjZVNwYW4pIHtcbiAgICB2YXIgc3VtbWFyeSA9IG1ldGFkYXRhQXNTdW1tYXJ5KGJpbmRpbmdzKTtcbiAgICAvLyBUT0RPOiBhYnN0cmFjdCBvdXQgaG9zdCBiaW5kaW5ncyB2ZXJpZmljYXRpb24gbG9naWMgYW5kIHVzZSBpdCBpbnN0ZWFkIG9mXG4gICAgLy8gY3JlYXRpbmcgZXZlbnRzIGFuZCBwcm9wZXJ0aWVzIEFTVHMgdG8gZGV0ZWN0IGVycm9ycyAoRlctOTk2KVxuICAgIHZhciBiaW5kaW5nUGFyc2VyID0gbWFrZUJpbmRpbmdQYXJzZXIoKTtcbiAgICBiaW5kaW5nUGFyc2VyLmNyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMoc3VtbWFyeSwgc291cmNlU3Bhbik7XG4gICAgYmluZGluZ1BhcnNlci5jcmVhdGVCb3VuZEhvc3RQcm9wZXJ0aWVzKHN1bW1hcnksIHNvdXJjZVNwYW4pO1xuICAgIHJldHVybiBiaW5kaW5nUGFyc2VyLmVycm9ycztcbn1cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZXMoc3R5bGVzLCBzZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgdmFyIHNoYWRvd0NzcyA9IG5ldyBTaGFkb3dDc3MoKTtcbiAgICByZXR1cm4gc3R5bGVzLm1hcChmdW5jdGlvbiAoc3R5bGUpIHsgcmV0dXJuIHNoYWRvd0Nzcy5zaGltQ3NzVGV4dChzdHlsZSwgc2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7IH0pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEFuIGludGVyZmFjZSBmb3IgcmV0cmlldmluZyBkb2N1bWVudHMgYnkgVVJMIHRoYXQgdGhlIGNvbXBpbGVyIHVzZXNcbiAqIHRvIGxvYWQgdGVtcGxhdGVzLlxuICovXG52YXIgUmVzb3VyY2VMb2FkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzb3VyY2VMb2FkZXIoKSB7XG4gICAgfVxuICAgIFJlc291cmNlTG9hZGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiAnJzsgfTtcbiAgICByZXR1cm4gUmVzb3VyY2VMb2FkZXI7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQ29tcGlsZXJGYWNhZGVJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVyRmFjYWRlSW1wbChqaXRFdmFsdWF0b3IpIHtcbiAgICAgICAgaWYgKGppdEV2YWx1YXRvciA9PT0gdm9pZCAwKSB7IGppdEV2YWx1YXRvciA9IG5ldyBKaXRFdmFsdWF0b3IoKTsgfVxuICAgICAgICB0aGlzLmppdEV2YWx1YXRvciA9IGppdEV2YWx1YXRvcjtcbiAgICAgICAgdGhpcy5SM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGUgPSBSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGU7XG4gICAgICAgIHRoaXMuUmVzb3VyY2VMb2FkZXIgPSBSZXNvdXJjZUxvYWRlcjtcbiAgICAgICAgdGhpcy5lbGVtZW50U2NoZW1hUmVnaXN0cnkgPSBuZXcgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCk7XG4gICAgfVxuICAgIENvbXBpbGVyRmFjYWRlSW1wbC5wcm90b3R5cGUuY29tcGlsZVBpcGUgPSBmdW5jdGlvbiAoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZmFjYWRlKSB7XG4gICAgICAgIHZhciByZXMgPSBjb21waWxlUGlwZUZyb21NZXRhZGF0YSh7XG4gICAgICAgICAgICBuYW1lOiBmYWNhZGUubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnR5cGUpLFxuICAgICAgICAgICAgdHlwZUFyZ3VtZW50Q291bnQ6IGZhY2FkZS50eXBlQXJndW1lbnRDb3VudCxcbiAgICAgICAgICAgIGRlcHM6IGNvbnZlcnRSM0RlcGVuZGVuY3lNZXRhZGF0YUFycmF5KGZhY2FkZS5kZXBzKSxcbiAgICAgICAgICAgIHBpcGVOYW1lOiBmYWNhZGUucGlwZU5hbWUsXG4gICAgICAgICAgICBwdXJlOiBmYWNhZGUucHVyZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24ocmVzLmV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIHJlcy5zdGF0ZW1lbnRzKTtcbiAgICB9O1xuICAgIENvbXBpbGVyRmFjYWRlSW1wbC5wcm90b3R5cGUuY29tcGlsZUluamVjdGFibGUgPSBmdW5jdGlvbiAoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZmFjYWRlKSB7XG4gICAgICAgIHZhciBfYSA9IGNvbXBpbGVJbmplY3RhYmxlKHtcbiAgICAgICAgICAgIG5hbWU6IGZhY2FkZS5uYW1lLFxuICAgICAgICAgICAgdHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudHlwZSksXG4gICAgICAgICAgICB0eXBlQXJndW1lbnRDb3VudDogZmFjYWRlLnR5cGVBcmd1bWVudENvdW50LFxuICAgICAgICAgICAgcHJvdmlkZWRJbjogY29tcHV0ZVByb3ZpZGVkSW4oZmFjYWRlLnByb3ZpZGVkSW4pLFxuICAgICAgICAgICAgdXNlQ2xhc3M6IHdyYXBFeHByZXNzaW9uKGZhY2FkZSwgVVNFX0NMQVNTKSxcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IHdyYXBFeHByZXNzaW9uKGZhY2FkZSwgVVNFX0ZBQ1RPUlkpLFxuICAgICAgICAgICAgdXNlVmFsdWU6IHdyYXBFeHByZXNzaW9uKGZhY2FkZSwgVVNFX1ZBTFVFKSxcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiB3cmFwRXhwcmVzc2lvbihmYWNhZGUsIFVTRV9FWElTVElORyksXG4gICAgICAgICAgICBjdG9yRGVwczogY29udmVydFIzRGVwZW5kZW5jeU1ldGFkYXRhQXJyYXkoZmFjYWRlLmN0b3JEZXBzKSxcbiAgICAgICAgICAgIHVzZXJEZXBzOiBjb252ZXJ0UjNEZXBlbmRlbmN5TWV0YWRhdGFBcnJheShmYWNhZGUudXNlckRlcHMpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgfSksIGV4cHJlc3Npb24gPSBfYS5leHByZXNzaW9uLCBzdGF0ZW1lbnRzID0gX2Euc3RhdGVtZW50cztcbiAgICAgICAgcmV0dXJuIHRoaXMuaml0RXhwcmVzc2lvbihleHByZXNzaW9uLCBhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBzdGF0ZW1lbnRzKTtcbiAgICB9O1xuICAgIENvbXBpbGVyRmFjYWRlSW1wbC5wcm90b3R5cGUuY29tcGlsZUluamVjdG9yID0gZnVuY3Rpb24gKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGZhY2FkZSkge1xuICAgICAgICB2YXIgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGZhY2FkZS5uYW1lLFxuICAgICAgICAgICAgdHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudHlwZSksXG4gICAgICAgICAgICBkZXBzOiBjb252ZXJ0UjNEZXBlbmRlbmN5TWV0YWRhdGFBcnJheShmYWNhZGUuZGVwcyksXG4gICAgICAgICAgICBwcm92aWRlcnM6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnByb3ZpZGVycyksXG4gICAgICAgICAgICBpbXBvcnRzOiBmYWNhZGUuaW1wb3J0cy5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIG5ldyBXcmFwcGVkTm9kZUV4cHIoaSk7IH0pLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzID0gY29tcGlsZUluamVjdG9yKG1ldGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKHJlcy5leHByZXNzaW9uLCBhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCByZXMuc3RhdGVtZW50cyk7XG4gICAgfTtcbiAgICBDb21waWxlckZhY2FkZUltcGwucHJvdG90eXBlLmNvbXBpbGVOZ01vZHVsZSA9IGZ1bmN0aW9uIChhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBmYWNhZGUpIHtcbiAgICAgICAgdmFyIG1ldGEgPSB7XG4gICAgICAgICAgICB0eXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS50eXBlKSxcbiAgICAgICAgICAgIGJvb3RzdHJhcDogZmFjYWRlLmJvb3RzdHJhcC5tYXAod3JhcFJlZmVyZW5jZSksXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IGZhY2FkZS5kZWNsYXJhdGlvbnMubWFwKHdyYXBSZWZlcmVuY2UpLFxuICAgICAgICAgICAgaW1wb3J0czogZmFjYWRlLmltcG9ydHMubWFwKHdyYXBSZWZlcmVuY2UpLFxuICAgICAgICAgICAgZXhwb3J0czogZmFjYWRlLmV4cG9ydHMubWFwKHdyYXBSZWZlcmVuY2UpLFxuICAgICAgICAgICAgZW1pdElubGluZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRhaW5zRm9yd2FyZERlY2xzOiBmYWxzZSxcbiAgICAgICAgICAgIHNjaGVtYXM6IGZhY2FkZS5zY2hlbWFzID8gZmFjYWRlLnNjaGVtYXMubWFwKHdyYXBSZWZlcmVuY2UpIDogbnVsbCxcbiAgICAgICAgICAgIGlkOiBmYWNhZGUuaWQgPyBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS5pZCkgOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzID0gY29tcGlsZU5nTW9kdWxlKG1ldGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKHJlcy5leHByZXNzaW9uLCBhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBbXSk7XG4gICAgfTtcbiAgICBDb21waWxlckZhY2FkZUltcGwucHJvdG90eXBlLmNvbXBpbGVEaXJlY3RpdmUgPSBmdW5jdGlvbiAoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZmFjYWRlKSB7XG4gICAgICAgIHZhciBjb25zdGFudFBvb2wgPSBuZXcgQ29uc3RhbnRQb29sKCk7XG4gICAgICAgIHZhciBiaW5kaW5nUGFyc2VyID0gbWFrZUJpbmRpbmdQYXJzZXIoKTtcbiAgICAgICAgdmFyIG1ldGEgPSBjb252ZXJ0RGlyZWN0aXZlRmFjYWRlVG9NZXRhZGF0YShmYWNhZGUpO1xuICAgICAgICB2YXIgcmVzID0gY29tcGlsZURpcmVjdGl2ZUZyb21NZXRhZGF0YShtZXRhLCBjb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpO1xuICAgICAgICB2YXIgcHJlU3RhdGVtZW50cyA9IF9fc3ByZWFkKGNvbnN0YW50UG9vbC5zdGF0ZW1lbnRzLCByZXMuc3RhdGVtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24ocmVzLmV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIHByZVN0YXRlbWVudHMpO1xuICAgIH07XG4gICAgQ29tcGlsZXJGYWNhZGVJbXBsLnByb3RvdHlwZS5jb21waWxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGZhY2FkZSkge1xuICAgICAgICAvLyBUaGUgQ29uc3RhbnRQb29sIGlzIGEgcmVxdWlyZW1lbnQgb2YgdGhlIEpJVCdlci5cbiAgICAgICAgdmFyIGNvbnN0YW50UG9vbCA9IG5ldyBDb25zdGFudFBvb2woKTtcbiAgICAgICAgdmFyIGludGVycG9sYXRpb25Db25maWcgPSBmYWNhZGUuaW50ZXJwb2xhdGlvbiA/XG4gICAgICAgICAgICBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheShmYWNhZGUuaW50ZXJwb2xhdGlvbikgOlxuICAgICAgICAgICAgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRztcbiAgICAgICAgLy8gUGFyc2UgdGhlIHRlbXBsYXRlIGFuZCBjaGVjayBmb3IgZXJyb3JzLlxuICAgICAgICB2YXIgdGVtcGxhdGUgPSBwYXJzZVRlbXBsYXRlKGZhY2FkZS50ZW1wbGF0ZSwgc291cmNlTWFwVXJsLCB7IHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhY2FkZS5wcmVzZXJ2ZVdoaXRlc3BhY2VzLCBpbnRlcnBvbGF0aW9uQ29uZmlnOiBpbnRlcnBvbGF0aW9uQ29uZmlnIH0pO1xuICAgICAgICBpZiAodGVtcGxhdGUuZXJyb3JzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSB0ZW1wbGF0ZS5lcnJvcnMubWFwKGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGVyci50b1N0cmluZygpOyB9KS5qb2luKCcsICcpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3JzIGR1cmluZyBKSVQgY29tcGlsYXRpb24gb2YgdGVtcGxhdGUgZm9yIFwiICsgZmFjYWRlLm5hbWUgKyBcIjogXCIgKyBlcnJvcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXBpbGUgdGhlIGNvbXBvbmVudCBtZXRhZGF0YSwgaW5jbHVkaW5nIHRlbXBsYXRlLCBpbnRvIGFuIGV4cHJlc3Npb24uXG4gICAgICAgIC8vIFRPRE8oYWx4aHViKTogaW1wbGVtZW50IGlucHV0cywgb3V0cHV0cywgcXVlcmllcywgZXRjLlxuICAgICAgICB2YXIgcmVzID0gY29tcGlsZUNvbXBvbmVudEZyb21NZXRhZGF0YShfX2Fzc2lnbih7fSwgZmFjYWRlLCBjb252ZXJ0RGlyZWN0aXZlRmFjYWRlVG9NZXRhZGF0YShmYWNhZGUpLCB7IHNlbGVjdG9yOiBmYWNhZGUuc2VsZWN0b3IgfHwgdGhpcy5lbGVtZW50U2NoZW1hUmVnaXN0cnkuZ2V0RGVmYXVsdENvbXBvbmVudEVsZW1lbnROYW1lKCksIHRlbXBsYXRlOiB0ZW1wbGF0ZSwgd3JhcERpcmVjdGl2ZXNBbmRQaXBlc0luQ2xvc3VyZTogZmFsc2UsIHN0eWxlczogZmFjYWRlLnN0eWxlcyB8fCBbXSwgZW5jYXBzdWxhdGlvbjogZmFjYWRlLmVuY2Fwc3VsYXRpb24sIGludGVycG9sYXRpb246IGludGVycG9sYXRpb25Db25maWcsIGNoYW5nZURldGVjdGlvbjogZmFjYWRlLmNoYW5nZURldGVjdGlvbiwgYW5pbWF0aW9uczogZmFjYWRlLmFuaW1hdGlvbnMgIT0gbnVsbCA/IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLmFuaW1hdGlvbnMpIDogbnVsbCwgdmlld1Byb3ZpZGVyczogZmFjYWRlLnZpZXdQcm92aWRlcnMgIT0gbnVsbCA/IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnZpZXdQcm92aWRlcnMpIDpcbiAgICAgICAgICAgICAgICBudWxsLCByZWxhdGl2ZUNvbnRleHRGaWxlUGF0aDogJycsIGkxOG5Vc2VFeHRlcm5hbElkczogdHJ1ZSB9KSwgY29uc3RhbnRQb29sLCBtYWtlQmluZGluZ1BhcnNlcihpbnRlcnBvbGF0aW9uQ29uZmlnKSk7XG4gICAgICAgIHZhciBwcmVTdGF0ZW1lbnRzID0gX19zcHJlYWQoY29uc3RhbnRQb29sLnN0YXRlbWVudHMsIHJlcy5zdGF0ZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaml0RXhwcmVzc2lvbihyZXMuZXhwcmVzc2lvbiwgYW5ndWxhckNvcmVFbnYsIFwibmc6Ly8vXCIgKyBmYWNhZGUubmFtZSArIFwiLmpzXCIsIHByZVN0YXRlbWVudHMpO1xuICAgIH07XG4gICAgQ29tcGlsZXJGYWNhZGVJbXBsLnByb3RvdHlwZS5jb21waWxlQmFzZSA9IGZ1bmN0aW9uIChhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBmYWNhZGUpIHtcbiAgICAgICAgdmFyIGNvbnN0YW50UG9vbCA9IG5ldyBDb25zdGFudFBvb2woKTtcbiAgICAgICAgdmFyIHR5cGVTb3VyY2VTcGFuID0gdGhpcy5jcmVhdGVQYXJzZVNvdXJjZVNwYW4oJ0Jhc2UnLCBmYWNhZGUubmFtZSwgXCJuZzovLy9cIiArIGZhY2FkZS5uYW1lICsgXCIuanNcIik7XG4gICAgICAgIHZhciBtZXRhID0gX19hc3NpZ24oe30sIGZhY2FkZSwgeyB0eXBlU291cmNlU3BhbjogdHlwZVNvdXJjZVNwYW4sIHZpZXdRdWVyaWVzOiBmYWNhZGUudmlld1F1ZXJpZXMgPyBmYWNhZGUudmlld1F1ZXJpZXMubWFwKGNvbnZlcnRUb1IzUXVlcnlNZXRhZGF0YSkgOlxuICAgICAgICAgICAgICAgIGZhY2FkZS52aWV3UXVlcmllcywgcXVlcmllczogZmFjYWRlLnF1ZXJpZXMgPyBmYWNhZGUucXVlcmllcy5tYXAoY29udmVydFRvUjNRdWVyeU1ldGFkYXRhKSA6IGZhY2FkZS5xdWVyaWVzLCBob3N0OiBleHRyYWN0SG9zdEJpbmRpbmdzKGZhY2FkZS5wcm9wTWV0YWRhdGEsIHR5cGVTb3VyY2VTcGFuKSB9KTtcbiAgICAgICAgdmFyIHJlcyA9IGNvbXBpbGVCYXNlRGVmRnJvbU1ldGFkYXRhKG1ldGEsIGNvbnN0YW50UG9vbCwgbWFrZUJpbmRpbmdQYXJzZXIoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24ocmVzLmV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGNvbnN0YW50UG9vbC5zdGF0ZW1lbnRzKTtcbiAgICB9O1xuICAgIENvbXBpbGVyRmFjYWRlSW1wbC5wcm90b3R5cGUuY3JlYXRlUGFyc2VTb3VyY2VTcGFuID0gZnVuY3Rpb24gKGtpbmQsIHR5cGVOYW1lLCBzb3VyY2VVcmwpIHtcbiAgICAgICAgcmV0dXJuIHIzSml0VHlwZVNvdXJjZVNwYW4oa2luZCwgdHlwZU5hbWUsIHNvdXJjZVVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBKSVQgY29tcGlsZXMgYW4gZXhwcmVzc2lvbiBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyB0aGF0IGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVmIHRoZSBkZWZpbml0aW9uIHdoaWNoIHdpbGwgYmUgY29tcGlsZWQgYW5kIGV4ZWN1dGVkIHRvIGdldCB0aGUgdmFsdWUgdG8gcGF0Y2hcbiAgICAgKiBAcGFyYW0gY29udGV4dCBhbiBvYmplY3QgbWFwIG9mIEBhbmd1bGFyL2NvcmUgc3ltYm9sIG5hbWVzIHRvIHN5bWJvbHMgd2hpY2ggd2lsbCBiZSBhdmFpbGFibGVcbiAgICAgKiBpbiB0aGUgY29udGV4dCBvZiB0aGUgY29tcGlsZWQgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSBzb3VyY2VVcmwgYSBVUkwgdG8gdXNlIGZvciB0aGUgc291cmNlIG1hcCBvZiB0aGUgY29tcGlsZWQgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSBwcmVTdGF0ZW1lbnRzIGEgY29sbGVjdGlvbiBvZiBzdGF0ZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGV2YWx1YXRlZCBiZWZvcmUgdGhlIGV4cHJlc3Npb24uXG4gICAgICovXG4gICAgQ29tcGlsZXJGYWNhZGVJbXBsLnByb3RvdHlwZS5qaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKGRlZiwgY29udGV4dCwgc291cmNlVXJsLCBwcmVTdGF0ZW1lbnRzKSB7XG4gICAgICAgIC8vIFRoZSBDb25zdGFudFBvb2wgbWF5IGNvbnRhaW4gU3RhdGVtZW50cyB3aGljaCBkZWNsYXJlIHZhcmlhYmxlcyB1c2VkIGluIHRoZSBmaW5hbCBleHByZXNzaW9uLlxuICAgICAgICAvLyBUaGVyZWZvcmUsIGl0cyBzdGF0ZW1lbnRzIG5lZWQgdG8gcHJlY2VkZSB0aGUgYWN0dWFsIEpJVCBvcGVyYXRpb24uIFRoZSBmaW5hbCBzdGF0ZW1lbnQgaXMgYVxuICAgICAgICAvLyBkZWNsYXJhdGlvbiBvZiAkZGVmIHdoaWNoIGlzIHNldCB0byB0aGUgZXhwcmVzc2lvbiBiZWluZyBjb21waWxlZC5cbiAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBfX3NwcmVhZChwcmVTdGF0ZW1lbnRzLCBbXG4gICAgICAgICAgICBuZXcgRGVjbGFyZVZhclN0bXQoJyRkZWYnLCBkZWYsIHVuZGVmaW5lZCwgW1N0bXRNb2RpZmllci5FeHBvcnRlZF0pLFxuICAgICAgICBdKTtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuaml0RXZhbHVhdG9yLmV2YWx1YXRlU3RhdGVtZW50cyhzb3VyY2VVcmwsIHN0YXRlbWVudHMsIG5ldyBSM0ppdFJlZmxlY3Rvcihjb250ZXh0KSwgLyogZW5hYmxlU291cmNlTWFwcyAqLyB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJlc1snJGRlZiddO1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBpbGVyRmFjYWRlSW1wbDtcbn0oKSk7XG52YXIgVVNFX0NMQVNTID0gT2JqZWN0LmtleXMoeyB1c2VDbGFzczogbnVsbCB9KVswXTtcbnZhciBVU0VfRkFDVE9SWSA9IE9iamVjdC5rZXlzKHsgdXNlRmFjdG9yeTogbnVsbCB9KVswXTtcbnZhciBVU0VfVkFMVUUgPSBPYmplY3Qua2V5cyh7IHVzZVZhbHVlOiBudWxsIH0pWzBdO1xudmFyIFVTRV9FWElTVElORyA9IE9iamVjdC5rZXlzKHsgdXNlRXhpc3Rpbmc6IG51bGwgfSlbMF07XG52YXIgd3JhcFJlZmVyZW5jZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciB3cmFwcGVkID0gbmV3IFdyYXBwZWROb2RlRXhwcih2YWx1ZSk7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHdyYXBwZWQsIHR5cGU6IHdyYXBwZWQgfTtcbn07XG5mdW5jdGlvbiBjb252ZXJ0VG9SM1F1ZXJ5TWV0YWRhdGEoZmFjYWRlKSB7XG4gICAgcmV0dXJuIF9fYXNzaWduKHt9LCBmYWNhZGUsIHsgcHJlZGljYXRlOiBBcnJheS5pc0FycmF5KGZhY2FkZS5wcmVkaWNhdGUpID8gZmFjYWRlLnByZWRpY2F0ZSA6XG4gICAgICAgICAgICBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS5wcmVkaWNhdGUpLCByZWFkOiBmYWNhZGUucmVhZCA/IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnJlYWQpIDogbnVsbCwgc3RhdGljOiBmYWNhZGUuc3RhdGljIH0pO1xufVxuZnVuY3Rpb24gY29udmVydERpcmVjdGl2ZUZhY2FkZVRvTWV0YWRhdGEoZmFjYWRlKSB7XG4gICAgdmFyIGlucHV0c0Zyb21NZXRhZGF0YSA9IHBhcnNlSW5wdXRPdXRwdXRzKGZhY2FkZS5pbnB1dHMgfHwgW10pO1xuICAgIHZhciBvdXRwdXRzRnJvbU1ldGFkYXRhID0gcGFyc2VJbnB1dE91dHB1dHMoZmFjYWRlLm91dHB1dHMgfHwgW10pO1xuICAgIHZhciBwcm9wTWV0YWRhdGEgPSBmYWNhZGUucHJvcE1ldGFkYXRhO1xuICAgIHZhciBpbnB1dHNGcm9tVHlwZSA9IHt9O1xuICAgIHZhciBvdXRwdXRzRnJvbVR5cGUgPSB7fTtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBpZiAocHJvcE1ldGFkYXRhLmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICAgICAgcHJvcE1ldGFkYXRhW2ZpZWxkXS5mb3JFYWNoKGZ1bmN0aW9uIChhbm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbnB1dChhbm4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0c0Zyb21UeXBlW2ZpZWxkXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBhbm4uYmluZGluZ1Byb3BlcnR5TmFtZSA/IFthbm4uYmluZGluZ1Byb3BlcnR5TmFtZSwgZmllbGRdIDogZmllbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT3V0cHV0KGFubikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0c0Zyb21UeXBlW2ZpZWxkXSA9IGFubi5iaW5kaW5nUHJvcGVydHlOYW1lIHx8IGZpZWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBmaWVsZCBpbiBwcm9wTWV0YWRhdGEpIHtcbiAgICAgICAgX2xvb3BfMShmaWVsZCk7XG4gICAgfVxuICAgIHJldHVybiBfX2Fzc2lnbih7fSwgZmFjYWRlLCB7IHR5cGVTb3VyY2VTcGFuOiBmYWNhZGUudHlwZVNvdXJjZVNwYW4sIHR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnR5cGUpLCBkZXBzOiBjb252ZXJ0UjNEZXBlbmRlbmN5TWV0YWRhdGFBcnJheShmYWNhZGUuZGVwcyksIGhvc3Q6IGV4dHJhY3RIb3N0QmluZGluZ3MoZmFjYWRlLnByb3BNZXRhZGF0YSwgZmFjYWRlLnR5cGVTb3VyY2VTcGFuLCBmYWNhZGUuaG9zdCksIGlucHV0czogX19hc3NpZ24oe30sIGlucHV0c0Zyb21NZXRhZGF0YSwgaW5wdXRzRnJvbVR5cGUpLCBvdXRwdXRzOiBfX2Fzc2lnbih7fSwgb3V0cHV0c0Zyb21NZXRhZGF0YSwgb3V0cHV0c0Zyb21UeXBlKSwgcXVlcmllczogZmFjYWRlLnF1ZXJpZXMubWFwKGNvbnZlcnRUb1IzUXVlcnlNZXRhZGF0YSksIHByb3ZpZGVyczogZmFjYWRlLnByb3ZpZGVycyAhPSBudWxsID8gbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUucHJvdmlkZXJzKSA6IG51bGwsIHZpZXdRdWVyaWVzOiBmYWNhZGUudmlld1F1ZXJpZXMubWFwKGNvbnZlcnRUb1IzUXVlcnlNZXRhZGF0YSkgfSk7XG59XG5mdW5jdGlvbiB3cmFwRXhwcmVzc2lvbihvYmosIHByb3BlcnR5KSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcmFwcGVkTm9kZUV4cHIob2JqW3Byb3BlcnR5XSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVQcm92aWRlZEluKHByb3ZpZGVkSW4pIHtcbiAgICBpZiAocHJvdmlkZWRJbiA9PSBudWxsIHx8IHR5cGVvZiBwcm92aWRlZEluID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByKHByb3ZpZGVkSW4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcmFwcGVkTm9kZUV4cHIocHJvdmlkZWRJbik7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydFIzRGVwZW5kZW5jeU1ldGFkYXRhKGZhY2FkZSkge1xuICAgIHZhciB0b2tlbkV4cHI7XG4gICAgaWYgKGZhY2FkZS50b2tlbiA9PT0gbnVsbCkge1xuICAgICAgICB0b2tlbkV4cHIgPSBuZXcgTGl0ZXJhbEV4cHIobnVsbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZhY2FkZS5yZXNvbHZlZCA9PT0gUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlLkF0dHJpYnV0ZSkge1xuICAgICAgICB0b2tlbkV4cHIgPSBuZXcgTGl0ZXJhbEV4cHIoZmFjYWRlLnRva2VuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRva2VuRXhwciA9IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IHRva2VuRXhwcixcbiAgICAgICAgcmVzb2x2ZWQ6IGZhY2FkZS5yZXNvbHZlZCxcbiAgICAgICAgaG9zdDogZmFjYWRlLmhvc3QsXG4gICAgICAgIG9wdGlvbmFsOiBmYWNhZGUub3B0aW9uYWwsXG4gICAgICAgIHNlbGY6IGZhY2FkZS5zZWxmLFxuICAgICAgICBza2lwU2VsZjogZmFjYWRlLnNraXBTZWxmXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSM0RlcGVuZGVuY3lNZXRhZGF0YUFycmF5KGZhY2FkZXMpIHtcbiAgICByZXR1cm4gZmFjYWRlcyA9PSBudWxsID8gbnVsbCA6IGZhY2FkZXMubWFwKGNvbnZlcnRSM0RlcGVuZGVuY3lNZXRhZGF0YSk7XG59XG5mdW5jdGlvbiBleHRyYWN0SG9zdEJpbmRpbmdzKHByb3BNZXRhZGF0YSwgc291cmNlU3BhbiwgaG9zdCkge1xuICAgIC8vIEZpcnN0IHBhcnNlIHRoZSBkZWNsYXJhdGlvbnMgZnJvbSB0aGUgbWV0YWRhdGEuXG4gICAgdmFyIGJpbmRpbmdzID0gcGFyc2VIb3N0QmluZGluZ3MoaG9zdCB8fCB7fSk7XG4gICAgLy8gQWZ0ZXIgdGhhdCBjaGVjayBob3N0IGJpbmRpbmdzIGZvciBlcnJvcnNcbiAgICB2YXIgZXJyb3JzID0gdmVyaWZ5SG9zdEJpbmRpbmdzKGJpbmRpbmdzLCBzb3VyY2VTcGFuKTtcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGVycm9yLm1zZzsgfSkuam9pbignXFxuJykpO1xuICAgIH1cbiAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBpZiAocHJvcE1ldGFkYXRhLmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICAgICAgcHJvcE1ldGFkYXRhW2ZpZWxkXS5mb3JFYWNoKGZ1bmN0aW9uIChhbm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNIb3N0QmluZGluZyhhbm4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdzLnByb3BlcnRpZXNbYW5uLmhvc3RQcm9wZXJ0eU5hbWUgfHwgZmllbGRdID0gZmllbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSG9zdExpc3RlbmVyKGFubikpIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ3MubGlzdGVuZXJzW2Fubi5ldmVudE5hbWUgfHwgZmllbGRdID0gZmllbGQgKyBcIihcIiArIChhbm4uYXJncyB8fCBbXSkuam9pbignLCcpICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIE5leHQsIGxvb3Agb3ZlciB0aGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0LCBsb29raW5nIGZvciBASG9zdEJpbmRpbmcgYW5kIEBIb3N0TGlzdGVuZXIuXG4gICAgZm9yICh2YXIgZmllbGQgaW4gcHJvcE1ldGFkYXRhKSB7XG4gICAgICAgIF9sb29wXzIoZmllbGQpO1xuICAgIH1cbiAgICByZXR1cm4gYmluZGluZ3M7XG59XG5mdW5jdGlvbiBpc0hvc3RCaW5kaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLm5nTWV0YWRhdGFOYW1lID09PSAnSG9zdEJpbmRpbmcnO1xufVxuZnVuY3Rpb24gaXNIb3N0TGlzdGVuZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUubmdNZXRhZGF0YU5hbWUgPT09ICdIb3N0TGlzdGVuZXInO1xufVxuZnVuY3Rpb24gaXNJbnB1dCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5uZ01ldGFkYXRhTmFtZSA9PT0gJ0lucHV0Jztcbn1cbmZ1bmN0aW9uIGlzT3V0cHV0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLm5nTWV0YWRhdGFOYW1lID09PSAnT3V0cHV0Jztcbn1cbmZ1bmN0aW9uIHBhcnNlSW5wdXRPdXRwdXRzKHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChtYXAsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZCh2YWx1ZS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocGllY2UpIHsgcmV0dXJuIHBpZWNlLnRyaW0oKTsgfSksIDIpLCBmaWVsZCA9IF9hWzBdLCBwcm9wZXJ0eSA9IF9hWzFdO1xuICAgICAgICBtYXBbZmllbGRdID0gcHJvcGVydHkgfHwgZmllbGQ7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gcHVibGlzaEZhY2FkZShnbG9iYWwpIHtcbiAgICB2YXIgbmcgPSBnbG9iYWwubmcgfHwgKGdsb2JhbC5uZyA9IHt9KTtcbiAgICBuZy7JtWNvbXBpbGVyRmFjYWRlID0gbmV3IENvbXBpbGVyRmFjYWRlSW1wbCgpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVkVSU0lPTiQxID0gbmV3IFZlcnNpb24oJzguMi4xNCcpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQ29tcGlsZXJDb25maWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGlsZXJDb25maWcoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IuZGVmYXVsdEVuY2Fwc3VsYXRpb24sIGRlZmF1bHRFbmNhcHN1bGF0aW9uID0gX2MgPT09IHZvaWQgMCA/IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkIDogX2MsIF9kID0gX2IudXNlSml0LCB1c2VKaXQgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLCBfZSA9IF9iLmppdERldk1vZGUsIGppdERldk1vZGUgPSBfZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZSwgX2YgPSBfYi5taXNzaW5nVHJhbnNsYXRpb24sIG1pc3NpbmdUcmFuc2xhdGlvbiA9IF9mID09PSB2b2lkIDAgPyBudWxsIDogX2YsIHByZXNlcnZlV2hpdGVzcGFjZXMgPSBfYi5wcmVzZXJ2ZVdoaXRlc3BhY2VzLCBzdHJpY3RJbmplY3Rpb25QYXJhbWV0ZXJzID0gX2Iuc3RyaWN0SW5qZWN0aW9uUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5kZWZhdWx0RW5jYXBzdWxhdGlvbiA9IGRlZmF1bHRFbmNhcHN1bGF0aW9uO1xuICAgICAgICB0aGlzLnVzZUppdCA9ICEhdXNlSml0O1xuICAgICAgICB0aGlzLmppdERldk1vZGUgPSAhIWppdERldk1vZGU7XG4gICAgICAgIHRoaXMubWlzc2luZ1RyYW5zbGF0aW9uID0gbWlzc2luZ1RyYW5zbGF0aW9uO1xuICAgICAgICB0aGlzLnByZXNlcnZlV2hpdGVzcGFjZXMgPSBwcmVzZXJ2ZVdoaXRlc3BhY2VzRGVmYXVsdChub1VuZGVmaW5lZChwcmVzZXJ2ZVdoaXRlc3BhY2VzKSk7XG4gICAgICAgIHRoaXMuc3RyaWN0SW5qZWN0aW9uUGFyYW1ldGVycyA9IHN0cmljdEluamVjdGlvblBhcmFtZXRlcnMgPT09IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlckNvbmZpZztcbn0oKSk7XG5mdW5jdGlvbiBwcmVzZXJ2ZVdoaXRlc3BhY2VzRGVmYXVsdChwcmVzZXJ2ZVdoaXRlc3BhY2VzT3B0aW9uLCBkZWZhdWx0U2V0dGluZykge1xuICAgIGlmIChkZWZhdWx0U2V0dGluZyA9PT0gdm9pZCAwKSB7IGRlZmF1bHRTZXR0aW5nID0gZmFsc2U7IH1cbiAgICByZXR1cm4gcHJlc2VydmVXaGl0ZXNwYWNlc09wdGlvbiA9PT0gbnVsbCA/IGRlZmF1bHRTZXR0aW5nIDogcHJlc2VydmVXaGl0ZXNwYWNlc09wdGlvbjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIERpcmVjdGl2ZU5vcm1hbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlyZWN0aXZlTm9ybWFsaXplcihfcmVzb3VyY2VMb2FkZXIsIF91cmxSZXNvbHZlciwgX2h0bWxQYXJzZXIsIF9jb25maWcpIHtcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXIgPSBfcmVzb3VyY2VMb2FkZXI7XG4gICAgICAgIHRoaXMuX3VybFJlc29sdmVyID0gX3VybFJlc29sdmVyO1xuICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gICAgICAgIHRoaXMuX3Jlc291cmNlTG9hZGVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3Jlc291cmNlTG9hZGVyQ2FjaGUuY2xlYXIoKTsgfTtcbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5jbGVhckNhY2hlRm9yID0gZnVuY3Rpb24gKG5vcm1hbGl6ZWREaXJlY3RpdmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFub3JtYWxpemVkRGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlbXBsYXRlID0gbm9ybWFsaXplZERpcmVjdGl2ZS50ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZS5kZWxldGUodGVtcGxhdGUudGVtcGxhdGVVcmwpO1xuICAgICAgICB0ZW1wbGF0ZS5leHRlcm5hbFN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc2hlZXQpIHsgX3RoaXMuX3Jlc291cmNlTG9hZGVyQ2FjaGUuZGVsZXRlKHN0eWxlc2hlZXQubW9kdWxlVXJsKTsgfSk7XG4gICAgfTtcbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5fZmV0Y2ggPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLmdldCh1cmwpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fcmVzb3VyY2VMb2FkZXIuZ2V0KHVybCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLnNldCh1cmwsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZVRlbXBsYXRlID0gZnVuY3Rpb24gKHByZW5vcm1EYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChpc0RlZmluZWQocHJlbm9ybURhdGEudGVtcGxhdGUpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHByZW5vcm1EYXRhLnRlbXBsYXRlVXJsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKFwiJ1wiICsgc3RyaW5naWZ5KHByZW5vcm1EYXRhLmNvbXBvbmVudFR5cGUpICsgXCInIGNvbXBvbmVudCBjYW5ub3QgZGVmaW5lIGJvdGggdGVtcGxhdGUgYW5kIHRlbXBsYXRlVXJsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVub3JtRGF0YS50ZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIlRoZSB0ZW1wbGF0ZSBzcGVjaWZpZWQgZm9yIGNvbXBvbmVudCBcIiArIHN0cmluZ2lmeShwcmVub3JtRGF0YS5jb21wb25lbnRUeXBlKSArIFwiIGlzIG5vdCBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0RlZmluZWQocHJlbm9ybURhdGEudGVtcGxhdGVVcmwpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZW5vcm1EYXRhLnRlbXBsYXRlVXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKFwiVGhlIHRlbXBsYXRlVXJsIHNwZWNpZmllZCBmb3IgY29tcG9uZW50IFwiICsgc3RyaW5naWZ5KHByZW5vcm1EYXRhLmNvbXBvbmVudFR5cGUpICsgXCIgaXMgbm90IGEgc3RyaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCJObyB0ZW1wbGF0ZSBzcGVjaWZpZWQgZm9yIGNvbXBvbmVudCBcIiArIHN0cmluZ2lmeShwcmVub3JtRGF0YS5jb21wb25lbnRUeXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmaW5lZChwcmVub3JtRGF0YS5wcmVzZXJ2ZVdoaXRlc3BhY2VzKSAmJlxuICAgICAgICAgICAgdHlwZW9mIHByZW5vcm1EYXRhLnByZXNlcnZlV2hpdGVzcGFjZXMgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCJUaGUgcHJlc2VydmVXaGl0ZXNwYWNlcyBvcHRpb24gZm9yIGNvbXBvbmVudCBcIiArIHN0cmluZ2lmeShwcmVub3JtRGF0YS5jb21wb25lbnRUeXBlKSArIFwiIG11c3QgYmUgYSBib29sZWFuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTeW5jQXN5bmMudGhlbih0aGlzLl9wcmVQYXJzZVRlbXBsYXRlKHByZW5vcm1EYXRhKSwgZnVuY3Rpb24gKHByZXBhcnNlZFRlbXBsYXRlKSB7IHJldHVybiBfdGhpcy5fbm9ybWFsaXplVGVtcGxhdGVNZXRhZGF0YShwcmVub3JtRGF0YSwgcHJlcGFyc2VkVGVtcGxhdGUpOyB9KTtcbiAgICB9O1xuICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLl9wcmVQYXJzZVRlbXBsYXRlID0gZnVuY3Rpb24gKHByZW5vbURhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRlbXBsYXRlO1xuICAgICAgICB2YXIgdGVtcGxhdGVVcmw7XG4gICAgICAgIGlmIChwcmVub21EYXRhLnRlbXBsYXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gcHJlbm9tRGF0YS50ZW1wbGF0ZTtcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsID0gcHJlbm9tRGF0YS5tb2R1bGVVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZVVybCA9IHRoaXMuX3VybFJlc29sdmVyLnJlc29sdmUocHJlbm9tRGF0YS5tb2R1bGVVcmwsIHByZW5vbURhdGEudGVtcGxhdGVVcmwpO1xuICAgICAgICAgICAgdGVtcGxhdGUgPSB0aGlzLl9mZXRjaCh0ZW1wbGF0ZVVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN5bmNBc3luYy50aGVuKHRlbXBsYXRlLCBmdW5jdGlvbiAodGVtcGxhdGUpIHsgcmV0dXJuIF90aGlzLl9wcmVwYXJzZUxvYWRlZFRlbXBsYXRlKHByZW5vbURhdGEsIHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCk7IH0pO1xuICAgIH07XG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX3ByZXBhcnNlTG9hZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAocHJlbm9ybURhdGEsIHRlbXBsYXRlLCB0ZW1wbGF0ZUFic1VybCkge1xuICAgICAgICB2YXIgaXNJbmxpbmUgPSAhIXByZW5vcm1EYXRhLnRlbXBsYXRlO1xuICAgICAgICB2YXIgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IEludGVycG9sYXRpb25Db25maWcuZnJvbUFycmF5KHByZW5vcm1EYXRhLmludGVycG9sYXRpb24pO1xuICAgICAgICB2YXIgdGVtcGxhdGVVcmwgPSB0ZW1wbGF0ZVNvdXJjZVVybCh7IHJlZmVyZW5jZTogcHJlbm9ybURhdGEubmdNb2R1bGVUeXBlIH0sIHsgdHlwZTogeyByZWZlcmVuY2U6IHByZW5vcm1EYXRhLmNvbXBvbmVudFR5cGUgfSB9LCB7IGlzSW5saW5lOiBpc0lubGluZSwgdGVtcGxhdGVVcmw6IHRlbXBsYXRlQWJzVXJsIH0pO1xuICAgICAgICB2YXIgcm9vdE5vZGVzQW5kRXJyb3JzID0gdGhpcy5faHRtbFBhcnNlci5wYXJzZSh0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwsIHsgdG9rZW5pemVFeHBhbnNpb25Gb3JtczogdHJ1ZSwgaW50ZXJwb2xhdGlvbkNvbmZpZzogaW50ZXJwb2xhdGlvbkNvbmZpZyB9KTtcbiAgICAgICAgaWYgKHJvb3ROb2Rlc0FuZEVycm9ycy5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGVycm9yU3RyaW5nID0gcm9vdE5vZGVzQW5kRXJyb3JzLmVycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKFwiVGVtcGxhdGUgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZW1wbGF0ZU1ldGFkYXRhU3R5bGVzID0gdGhpcy5fbm9ybWFsaXplU3R5bGVzaGVldChuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7IHN0eWxlczogcHJlbm9ybURhdGEuc3R5bGVzLCBtb2R1bGVVcmw6IHByZW5vcm1EYXRhLm1vZHVsZVVybCB9KSk7XG4gICAgICAgIHZhciB2aXNpdG9yID0gbmV3IFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yKCk7XG4gICAgICAgIHZpc2l0QWxsJDEodmlzaXRvciwgcm9vdE5vZGVzQW5kRXJyb3JzLnJvb3ROb2Rlcyk7XG4gICAgICAgIHZhciB0ZW1wbGF0ZVN0eWxlcyA9IHRoaXMuX25vcm1hbGl6ZVN0eWxlc2hlZXQobmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoeyBzdHlsZXM6IHZpc2l0b3Iuc3R5bGVzLCBzdHlsZVVybHM6IHZpc2l0b3Iuc3R5bGVVcmxzLCBtb2R1bGVVcmw6IHRlbXBsYXRlQWJzVXJsIH0pKTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IHRlbXBsYXRlTWV0YWRhdGFTdHlsZXMuc3R5bGVzLmNvbmNhdCh0ZW1wbGF0ZVN0eWxlcy5zdHlsZXMpO1xuICAgICAgICB2YXIgaW5saW5lU3R5bGVVcmxzID0gdGVtcGxhdGVNZXRhZGF0YVN0eWxlcy5zdHlsZVVybHMuY29uY2F0KHRlbXBsYXRlU3R5bGVzLnN0eWxlVXJscyk7XG4gICAgICAgIHZhciBzdHlsZVVybHMgPSB0aGlzXG4gICAgICAgICAgICAuX25vcm1hbGl6ZVN0eWxlc2hlZXQobmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoeyBzdHlsZVVybHM6IHByZW5vcm1EYXRhLnN0eWxlVXJscywgbW9kdWxlVXJsOiBwcmVub3JtRGF0YS5tb2R1bGVVcmwgfSkpXG4gICAgICAgICAgICAuc3R5bGVVcmxzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IHRlbXBsYXRlQWJzVXJsLCBpc0lubGluZTogaXNJbmxpbmUsXG4gICAgICAgICAgICBodG1sQXN0OiByb290Tm9kZXNBbmRFcnJvcnMsIHN0eWxlczogc3R5bGVzLCBpbmxpbmVTdHlsZVVybHM6IGlubGluZVN0eWxlVXJscywgc3R5bGVVcmxzOiBzdHlsZVVybHMsXG4gICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IHZpc2l0b3IubmdDb250ZW50U2VsZWN0b3JzLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX25vcm1hbGl6ZVRlbXBsYXRlTWV0YWRhdGEgPSBmdW5jdGlvbiAocHJlbm9ybURhdGEsIHByZXBhcnNlZFRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBTeW5jQXN5bmMudGhlbih0aGlzLl9sb2FkTWlzc2luZ0V4dGVybmFsU3R5bGVzaGVldHMocHJlcGFyc2VkVGVtcGxhdGUuc3R5bGVVcmxzLmNvbmNhdChwcmVwYXJzZWRUZW1wbGF0ZS5pbmxpbmVTdHlsZVVybHMpKSwgZnVuY3Rpb24gKGV4dGVybmFsU3R5bGVzaGVldHMpIHsgcmV0dXJuIF90aGlzLl9ub3JtYWxpemVMb2FkZWRUZW1wbGF0ZU1ldGFkYXRhKHByZW5vcm1EYXRhLCBwcmVwYXJzZWRUZW1wbGF0ZSwgZXh0ZXJuYWxTdHlsZXNoZWV0cyk7IH0pO1xuICAgIH07XG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX25vcm1hbGl6ZUxvYWRlZFRlbXBsYXRlTWV0YWRhdGEgPSBmdW5jdGlvbiAocHJlbm9ybURhdGEsIHByZXBhcnNlZFRlbXBsYXRlLCBzdHlsZXNoZWV0cykge1xuICAgICAgICAvLyBBbGdvcml0aG06XG4gICAgICAgIC8vIC0gcHJvZHVjZSBleGFjdGx5IDEgZW50cnkgcGVyIG9yaWdpbmFsIHN0eWxlVXJsIGluXG4gICAgICAgIC8vIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhLmV4dGVybmFsU3R5bGVzaGVldHMgd2l0aCBhbGwgc3R5bGVzIGlubGluZWRcbiAgICAgICAgLy8gLSBpbmxpbmUgYWxsIHN0eWxlcyB0aGF0IGFyZSByZWZlcmVuY2VkIGJ5IHRoZSB0ZW1wbGF0ZSBpbnRvIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhLnN0eWxlcy5cbiAgICAgICAgLy8gUmVhc29uOiBiZSBhYmxlIHRvIGRldGVybWluZSBob3cgbWFueSBzdHlsZXNoZWV0cyB0aGVyZSBhcmUgZXZlbiB3aXRob3V0IGxvYWRpbmdcbiAgICAgICAgLy8gdGhlIHRlbXBsYXRlIG5vciB0aGUgc3R5bGVzaGVldHMsIHNvIHdlIGNhbiBjcmVhdGUgYSBzdHViIGZvciBUeXBlU2NyaXB0IGFsd2F5cyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIChhcyByZXNvdXJjZSBsb2FkaW5nIG1heSBiZSBhc3luYylcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN0eWxlcyA9IF9fc3ByZWFkKHByZXBhcnNlZFRlbXBsYXRlLnN0eWxlcyk7XG4gICAgICAgIHRoaXMuX2lubGluZVN0eWxlcyhwcmVwYXJzZWRUZW1wbGF0ZS5pbmxpbmVTdHlsZVVybHMsIHN0eWxlc2hlZXRzLCBzdHlsZXMpO1xuICAgICAgICB2YXIgc3R5bGVVcmxzID0gcHJlcGFyc2VkVGVtcGxhdGUuc3R5bGVVcmxzO1xuICAgICAgICB2YXIgZXh0ZXJuYWxTdHlsZXNoZWV0cyA9IHN0eWxlVXJscy5tYXAoZnVuY3Rpb24gKHN0eWxlVXJsKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVzaGVldCA9IHN0eWxlc2hlZXRzLmdldChzdHlsZVVybCk7XG4gICAgICAgICAgICB2YXIgc3R5bGVzID0gX19zcHJlYWQoc3R5bGVzaGVldC5zdHlsZXMpO1xuICAgICAgICAgICAgX3RoaXMuX2lubGluZVN0eWxlcyhzdHlsZXNoZWV0LnN0eWxlVXJscywgc3R5bGVzaGVldHMsIHN0eWxlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoeyBtb2R1bGVVcmw6IHN0eWxlVXJsLCBzdHlsZXM6IHN0eWxlcyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBlbmNhcHN1bGF0aW9uID0gcHJlbm9ybURhdGEuZW5jYXBzdWxhdGlvbjtcbiAgICAgICAgaWYgKGVuY2Fwc3VsYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbiA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0RW5jYXBzdWxhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jYXBzdWxhdGlvbiA9PT0gVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQgJiYgc3R5bGVzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgc3R5bGVVcmxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbiA9IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSh7XG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBlbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgdGVtcGxhdGU6IHByZXBhcnNlZFRlbXBsYXRlLnRlbXBsYXRlLFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IHByZXBhcnNlZFRlbXBsYXRlLnRlbXBsYXRlVXJsLFxuICAgICAgICAgICAgaHRtbEFzdDogcHJlcGFyc2VkVGVtcGxhdGUuaHRtbEFzdCwgc3R5bGVzOiBzdHlsZXMsIHN0eWxlVXJsczogc3R5bGVVcmxzLFxuICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiBwcmVwYXJzZWRUZW1wbGF0ZS5uZ0NvbnRlbnRTZWxlY3RvcnMsXG4gICAgICAgICAgICBhbmltYXRpb25zOiBwcmVub3JtRGF0YS5hbmltYXRpb25zLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogcHJlbm9ybURhdGEuaW50ZXJwb2xhdGlvbixcbiAgICAgICAgICAgIGlzSW5saW5lOiBwcmVwYXJzZWRUZW1wbGF0ZS5pc0lubGluZSwgZXh0ZXJuYWxTdHlsZXNoZWV0czogZXh0ZXJuYWxTdHlsZXNoZWV0cyxcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZXM6IHByZXNlcnZlV2hpdGVzcGFjZXNEZWZhdWx0KHByZW5vcm1EYXRhLnByZXNlcnZlV2hpdGVzcGFjZXMsIHRoaXMuX2NvbmZpZy5wcmVzZXJ2ZVdoaXRlc3BhY2VzKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5faW5saW5lU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlVXJscywgc3R5bGVzaGVldHMsIHRhcmdldFN0eWxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzdHlsZVVybHMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVVcmwpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZXNoZWV0ID0gc3R5bGVzaGVldHMuZ2V0KHN0eWxlVXJsKTtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7IHJldHVybiB0YXJnZXRTdHlsZXMucHVzaChzdHlsZSk7IH0pO1xuICAgICAgICAgICAgX3RoaXMuX2lubGluZVN0eWxlcyhzdHlsZXNoZWV0LnN0eWxlVXJscywgc3R5bGVzaGVldHMsIHRhcmdldFN0eWxlcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX2xvYWRNaXNzaW5nRXh0ZXJuYWxTdHlsZXNoZWV0cyA9IGZ1bmN0aW9uIChzdHlsZVVybHMsIGxvYWRlZFN0eWxlc2hlZXRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChsb2FkZWRTdHlsZXNoZWV0cyA9PT0gdm9pZCAwKSB7IGxvYWRlZFN0eWxlc2hlZXRzID0gbmV3IE1hcCgpOyB9XG4gICAgICAgIHJldHVybiBTeW5jQXN5bmMudGhlbihTeW5jQXN5bmMuYWxsKHN0eWxlVXJscy5maWx0ZXIoZnVuY3Rpb24gKHN0eWxlVXJsKSB7IHJldHVybiAhbG9hZGVkU3R5bGVzaGVldHMuaGFzKHN0eWxlVXJsKTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHN0eWxlVXJsKSB7IHJldHVybiBTeW5jQXN5bmMudGhlbihfdGhpcy5fZmV0Y2goc3R5bGVVcmwpLCBmdW5jdGlvbiAobG9hZGVkU3R5bGUpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZXNoZWV0ID0gX3RoaXMuX25vcm1hbGl6ZVN0eWxlc2hlZXQobmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoeyBzdHlsZXM6IFtsb2FkZWRTdHlsZV0sIG1vZHVsZVVybDogc3R5bGVVcmwgfSkpO1xuICAgICAgICAgICAgbG9hZGVkU3R5bGVzaGVldHMuc2V0KHN0eWxlVXJsLCBzdHlsZXNoZWV0KTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fbG9hZE1pc3NpbmdFeHRlcm5hbFN0eWxlc2hlZXRzKHN0eWxlc2hlZXQuc3R5bGVVcmxzLCBsb2FkZWRTdHlsZXNoZWV0cyk7XG4gICAgICAgIH0pOyB9KSksIGZ1bmN0aW9uIChfKSB7IHJldHVybiBsb2FkZWRTdHlsZXNoZWV0czsgfSk7XG4gICAgfTtcbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5fbm9ybWFsaXplU3R5bGVzaGVldCA9IGZ1bmN0aW9uIChzdHlsZXNoZWV0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtb2R1bGVVcmwgPSBzdHlsZXNoZWV0Lm1vZHVsZVVybDtcbiAgICAgICAgdmFyIGFsbFN0eWxlVXJscyA9IHN0eWxlc2hlZXQuc3R5bGVVcmxzLmZpbHRlcihpc1N0eWxlVXJsUmVzb2x2YWJsZSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gX3RoaXMuX3VybFJlc29sdmVyLnJlc29sdmUobW9kdWxlVXJsLCB1cmwpOyB9KTtcbiAgICAgICAgdmFyIGFsbFN0eWxlcyA9IHN0eWxlc2hlZXQuc3R5bGVzLm1hcChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZVdpdGhJbXBvcnRzID0gZXh0cmFjdFN0eWxlVXJscyhfdGhpcy5fdXJsUmVzb2x2ZXIsIG1vZHVsZVVybCwgc3R5bGUpO1xuICAgICAgICAgICAgYWxsU3R5bGVVcmxzLnB1c2guYXBwbHkoYWxsU3R5bGVVcmxzLCBfX3NwcmVhZChzdHlsZVdpdGhJbXBvcnRzLnN0eWxlVXJscykpO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlV2l0aEltcG9ydHMuc3R5bGU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoeyBzdHlsZXM6IGFsbFN0eWxlcywgc3R5bGVVcmxzOiBhbGxTdHlsZVVybHMsIG1vZHVsZVVybDogbW9kdWxlVXJsIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERpcmVjdGl2ZU5vcm1hbGl6ZXI7XG59KCkpO1xudmFyIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yKCkge1xuICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IFtdO1xuICAgICAgICB0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50ID0gMDtcbiAgICB9XG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHByZXBhcnNlZEVsZW1lbnQgPSBwcmVwYXJzZUVsZW1lbnQoYXN0KTtcbiAgICAgICAgc3dpdGNoIChwcmVwYXJzZWRFbGVtZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgUHJlcGFyc2VkRWxlbWVudFR5cGUuTkdfQ09OVEVOVDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZ05vbkJpbmRhYmxlU3RhY2tDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycy5wdXNoKHByZXBhcnNlZEVsZW1lbnQuc2VsZWN0QXR0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRTpcbiAgICAgICAgICAgICAgICB2YXIgdGV4dENvbnRlbnRfMSA9ICcnO1xuICAgICAgICAgICAgICAgIGFzdC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUZXh0JDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb250ZW50XzEgKz0gY2hpbGQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlcy5wdXNoKHRleHRDb250ZW50XzEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUOlxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVVcmxzLnB1c2gocHJlcGFyc2VkRWxlbWVudC5ocmVmQXR0cik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50Lm5vbkJpbmRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCBhc3QuY2hpbGRyZW4pO1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC5ub25CaW5kYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5uZ05vbkJpbmRhYmxlU3RhY2tDb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB2aXNpdEFsbCQxKHRoaXMsIGFzdC5jYXNlcyk7IH07XG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCBhc3QuZXhwcmVzc2lvbik7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIHJldHVybiBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBRVUVSWV9NRVRBREFUQV9JREVOVElGSUVSUyA9IFtcbiAgICBjcmVhdGVWaWV3Q2hpbGQsXG4gICAgY3JlYXRlVmlld0NoaWxkcmVuLFxuICAgIGNyZWF0ZUNvbnRlbnRDaGlsZCxcbiAgICBjcmVhdGVDb250ZW50Q2hpbGRyZW4sXG5dO1xuLypcbiAqIFJlc29sdmUgYSBgVHlwZWAgZm9yIHtAbGluayBEaXJlY3RpdmV9LlxuICpcbiAqIFRoaXMgaW50ZXJmYWNlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gY3JlYXRlIGN1c3RvbSBiZWhhdmlvci5cbiAqXG4gKiBTZWUge0BsaW5rIENvbXBpbGVyfVxuICovXG52YXIgRGlyZWN0aXZlUmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlyZWN0aXZlUmVzb2x2ZXIoX3JlZmxlY3Rvcikge1xuICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgIH1cbiAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuaXNEaXJlY3RpdmUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgdHlwZU1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKHJlc29sdmVGb3J3YXJkUmVmKHR5cGUpKTtcbiAgICAgICAgcmV0dXJuIHR5cGVNZXRhZGF0YSAmJiB0eXBlTWV0YWRhdGEuc29tZShpc0RpcmVjdGl2ZU1ldGFkYXRhKTtcbiAgICB9O1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgdHlwZU1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKHJlc29sdmVGb3J3YXJkUmVmKHR5cGUpKTtcbiAgICAgICAgaWYgKHR5cGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0gZmluZExhc3QodHlwZU1ldGFkYXRhLCBpc0RpcmVjdGl2ZU1ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdG9yLnByb3BNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgICAgICB2YXIgZ3VhcmRzID0gdGhpcy5fcmVmbGVjdG9yLmd1YXJkcyh0eXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVyZ2VXaXRoUHJvcGVydHlNZXRhZGF0YShtZXRhZGF0YSwgcHJvcGVydHlNZXRhZGF0YSwgZ3VhcmRzLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBEaXJlY3RpdmUgYW5ub3RhdGlvbiBmb3VuZCBvbiBcIiArIHN0cmluZ2lmeSh0eXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuX21lcmdlV2l0aFByb3BlcnR5TWV0YWRhdGEgPSBmdW5jdGlvbiAoZG0sIHByb3BlcnR5TWV0YWRhdGEsIGd1YXJkcywgZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICB2YXIgaW5wdXRzID0gW107XG4gICAgICAgIHZhciBvdXRwdXRzID0gW107XG4gICAgICAgIHZhciBob3N0ID0ge307XG4gICAgICAgIHZhciBxdWVyaWVzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BlcnR5TWV0YWRhdGEpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBmaW5kTGFzdChwcm9wZXJ0eU1ldGFkYXRhW3Byb3BOYW1lXSwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGNyZWF0ZUlucHV0LmlzVHlwZU9mKGEpOyB9KTtcbiAgICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5iaW5kaW5nUHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0cy5wdXNoKHByb3BOYW1lICsgXCI6IFwiICsgaW5wdXQuYmluZGluZ1Byb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHMucHVzaChwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IGZpbmRMYXN0KHByb3BlcnR5TWV0YWRhdGFbcHJvcE5hbWVdLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gY3JlYXRlT3V0cHV0LmlzVHlwZU9mKGEpOyB9KTtcbiAgICAgICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0LmJpbmRpbmdQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHByb3BOYW1lICsgXCI6IFwiICsgb3V0cHV0LmJpbmRpbmdQcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaG9zdEJpbmRpbmdzID0gcHJvcGVydHlNZXRhZGF0YVtwcm9wTmFtZV0uZmlsdGVyKGZ1bmN0aW9uIChhKSB7IHJldHVybiBjcmVhdGVIb3N0QmluZGluZy5pc1R5cGVPZihhKTsgfSk7XG4gICAgICAgICAgICBob3N0QmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoaG9zdEJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdEJpbmRpbmcuaG9zdFByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRXaXRoID0gaG9zdEJpbmRpbmcuaG9zdFByb3BlcnR5TmFtZVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0V2l0aCA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJASG9zdEJpbmRpbmcgY2FuIG5vdCBiaW5kIHRvIGV2ZW50cy4gVXNlIEBIb3N0TGlzdGVuZXIgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRXaXRoID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBIb3N0QmluZGluZyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgcHJvcGVydHkgbmFtZSwgJ2NsYXNzLjxuYW1lPicsIG9yICdhdHRyLjxuYW1lPicuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhvc3RbXCJbXCIgKyBob3N0QmluZGluZy5ob3N0UHJvcGVydHlOYW1lICsgXCJdXCJdID0gcHJvcE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBob3N0W1wiW1wiICsgcHJvcE5hbWUgKyBcIl1cIl0gPSBwcm9wTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBob3N0TGlzdGVuZXJzID0gcHJvcGVydHlNZXRhZGF0YVtwcm9wTmFtZV0uZmlsdGVyKGZ1bmN0aW9uIChhKSB7IHJldHVybiBjcmVhdGVIb3N0TGlzdGVuZXIuaXNUeXBlT2YoYSk7IH0pO1xuICAgICAgICAgICAgaG9zdExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChob3N0TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGhvc3RMaXN0ZW5lci5hcmdzIHx8IFtdO1xuICAgICAgICAgICAgICAgIGhvc3RbXCIoXCIgKyBob3N0TGlzdGVuZXIuZXZlbnROYW1lICsgXCIpXCJdID0gcHJvcE5hbWUgKyBcIihcIiArIGFyZ3Muam9pbignLCcpICsgXCIpXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IGZpbmRMYXN0KHByb3BlcnR5TWV0YWRhdGFbcHJvcE5hbWVdLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gUVVFUllfTUVUQURBVEFfSURFTlRJRklFUlMuc29tZShmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5pc1R5cGVPZihhKTsgfSk7IH0pO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgcXVlcmllc1twcm9wTmFtZV0gPSBxdWVyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXJnZShkbSwgaW5wdXRzLCBvdXRwdXRzLCBob3N0LCBxdWVyaWVzLCBndWFyZHMsIGRpcmVjdGl2ZVR5cGUpO1xuICAgIH07XG4gICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLl9leHRyYWN0UHVibGljTmFtZSA9IGZ1bmN0aW9uIChkZWYpIHsgcmV0dXJuIHNwbGl0QXRDb2xvbihkZWYsIFtudWxsLCBkZWZdKVsxXS50cmltKCk7IH07XG4gICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLl9kZWR1cGVCaW5kaW5ncyA9IGZ1bmN0aW9uIChiaW5kaW5ncykge1xuICAgICAgICB2YXIgbmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciBwdWJsaWNOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIHJldmVyc2VkUmVzdWx0ID0gW107XG4gICAgICAgIC8vIGdvIGxhc3QgdG8gZmlyc3QgdG8gYWxsb3cgbGF0ZXIgZW50cmllcyB0byBvdmVyd3JpdGUgcHJldmlvdXMgZW50cmllc1xuICAgICAgICBmb3IgKHZhciBpID0gYmluZGluZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gdGhpcy5fZXh0cmFjdFB1YmxpY05hbWUoYmluZGluZyk7XG4gICAgICAgICAgICBwdWJsaWNOYW1lcy5hZGQobmFtZV8xKTtcbiAgICAgICAgICAgIGlmICghbmFtZXMuaGFzKG5hbWVfMSkpIHtcbiAgICAgICAgICAgICAgICBuYW1lcy5hZGQobmFtZV8xKTtcbiAgICAgICAgICAgICAgICByZXZlcnNlZFJlc3VsdC5wdXNoKGJpbmRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXZlcnNlZFJlc3VsdC5yZXZlcnNlKCk7XG4gICAgfTtcbiAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuX21lcmdlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZSwgaW5wdXRzLCBvdXRwdXRzLCBob3N0LCBxdWVyaWVzLCBndWFyZHMsIGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgdmFyIG1lcmdlZElucHV0cyA9IHRoaXMuX2RlZHVwZUJpbmRpbmdzKGRpcmVjdGl2ZS5pbnB1dHMgPyBkaXJlY3RpdmUuaW5wdXRzLmNvbmNhdChpbnB1dHMpIDogaW5wdXRzKTtcbiAgICAgICAgdmFyIG1lcmdlZE91dHB1dHMgPSB0aGlzLl9kZWR1cGVCaW5kaW5ncyhkaXJlY3RpdmUub3V0cHV0cyA/IGRpcmVjdGl2ZS5vdXRwdXRzLmNvbmNhdChvdXRwdXRzKSA6IG91dHB1dHMpO1xuICAgICAgICB2YXIgbWVyZ2VkSG9zdCA9IGRpcmVjdGl2ZS5ob3N0ID8gX19hc3NpZ24oe30sIGRpcmVjdGl2ZS5ob3N0LCBob3N0KSA6IGhvc3Q7XG4gICAgICAgIHZhciBtZXJnZWRRdWVyaWVzID0gZGlyZWN0aXZlLnF1ZXJpZXMgPyBfX2Fzc2lnbih7fSwgZGlyZWN0aXZlLnF1ZXJpZXMsIHF1ZXJpZXMpIDogcXVlcmllcztcbiAgICAgICAgaWYgKGNyZWF0ZUNvbXBvbmVudC5pc1R5cGVPZihkaXJlY3RpdmUpKSB7XG4gICAgICAgICAgICB2YXIgY29tcCA9IGRpcmVjdGl2ZTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBjb21wLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGlucHV0czogbWVyZ2VkSW5wdXRzLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IG1lcmdlZE91dHB1dHMsXG4gICAgICAgICAgICAgICAgaG9zdDogbWVyZ2VkSG9zdCxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogY29tcC5leHBvcnRBcyxcbiAgICAgICAgICAgICAgICBtb2R1bGVJZDogY29tcC5tb2R1bGVJZCxcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiBtZXJnZWRRdWVyaWVzLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogY29tcC5jaGFuZ2VEZXRlY3Rpb24sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBjb21wLnByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiBjb21wLnZpZXdQcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBjb21wLmVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogY29tcC50ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogY29tcC50ZW1wbGF0ZVVybCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IGNvbXAuc3R5bGVzLFxuICAgICAgICAgICAgICAgIHN0eWxlVXJsczogY29tcC5zdHlsZVVybHMsXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogY29tcC5lbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IGNvbXAuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBjb21wLmludGVycG9sYXRpb24sXG4gICAgICAgICAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlczogZGlyZWN0aXZlLnByZXNlcnZlV2hpdGVzcGFjZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEaXJlY3RpdmUoe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBkaXJlY3RpdmUuc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBtZXJnZWRJbnB1dHMsXG4gICAgICAgICAgICAgICAgb3V0cHV0czogbWVyZ2VkT3V0cHV0cyxcbiAgICAgICAgICAgICAgICBob3N0OiBtZXJnZWRIb3N0LFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiBkaXJlY3RpdmUuZXhwb3J0QXMsXG4gICAgICAgICAgICAgICAgcXVlcmllczogbWVyZ2VkUXVlcmllcyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IGRpcmVjdGl2ZS5wcm92aWRlcnMsIGd1YXJkczogZ3VhcmRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERpcmVjdGl2ZVJlc29sdmVyO1xufSgpKTtcbmZ1bmN0aW9uIGlzRGlyZWN0aXZlTWV0YWRhdGEodHlwZSkge1xuICAgIHJldHVybiBjcmVhdGVEaXJlY3RpdmUuaXNUeXBlT2YodHlwZSkgfHwgY3JlYXRlQ29tcG9uZW50LmlzVHlwZU9mKHR5cGUpO1xufVxuZnVuY3Rpb24gZmluZExhc3QoYXJyLCBjb25kaXRpb24pIHtcbiAgICBmb3IgKHZhciBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24oYXJyW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycltpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBbiBpMThuIGVycm9yLlxuICovXG52YXIgSTE4bkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJMThuRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSTE4bkVycm9yKHNwYW4sIG1zZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgbXNnKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSTE4bkVycm9yO1xufShQYXJzZUVycm9yKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfSTE4Tl9BVFRSID0gJ2kxOG4nO1xudmFyIF9JMThOX0FUVFJfUFJFRklYID0gJ2kxOG4tJztcbnZhciBfSTE4Tl9DT01NRU5UX1BSRUZJWF9SRUdFWFAgPSAvXmkxOG46Py87XG52YXIgTUVBTklOR19TRVBBUkFUT1IgPSAnfCc7XG52YXIgSURfU0VQQVJBVE9SID0gJ0BAJztcbnZhciBpMThuQ29tbWVudHNXYXJuZWQgPSBmYWxzZTtcbi8qKlxuICogRXh0cmFjdCB0cmFuc2xhdGFibGUgbWVzc2FnZXMgZnJvbSBhbiBodG1sIEFTVFxuICovXG5mdW5jdGlvbiBleHRyYWN0TWVzc2FnZXMobm9kZXMsIGludGVycG9sYXRpb25Db25maWcsIGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycykge1xuICAgIHZhciB2aXNpdG9yID0gbmV3IF9WaXNpdG9yJDIoaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKTtcbiAgICByZXR1cm4gdmlzaXRvci5leHRyYWN0KG5vZGVzLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbn1cbmZ1bmN0aW9uIG1lcmdlVHJhbnNsYXRpb25zKG5vZGVzLCB0cmFuc2xhdGlvbnMsIGludGVycG9sYXRpb25Db25maWcsIGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycykge1xuICAgIHZhciB2aXNpdG9yID0gbmV3IF9WaXNpdG9yJDIoaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKTtcbiAgICByZXR1cm4gdmlzaXRvci5tZXJnZShub2RlcywgdHJhbnNsYXRpb25zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbn1cbnZhciBFeHRyYWN0aW9uUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4dHJhY3Rpb25SZXN1bHQobWVzc2FnZXMsIGVycm9ycykge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gRXh0cmFjdGlvblJlc3VsdDtcbn0oKSk7XG52YXIgX1Zpc2l0b3JNb2RlO1xuKGZ1bmN0aW9uIChfVmlzaXRvck1vZGUpIHtcbiAgICBfVmlzaXRvck1vZGVbX1Zpc2l0b3JNb2RlW1wiRXh0cmFjdFwiXSA9IDBdID0gXCJFeHRyYWN0XCI7XG4gICAgX1Zpc2l0b3JNb2RlW19WaXNpdG9yTW9kZVtcIk1lcmdlXCJdID0gMV0gPSBcIk1lcmdlXCI7XG59KShfVmlzaXRvck1vZGUgfHwgKF9WaXNpdG9yTW9kZSA9IHt9KSk7XG4vKipcbiAqIFRoaXMgVmlzaXRvciBpcyB1c2VkOlxuICogMS4gdG8gZXh0cmFjdCBhbGwgdGhlIHRyYW5zbGF0YWJsZSBzdHJpbmdzIGZyb20gYW4gaHRtbCBBU1QgKHNlZSBgZXh0cmFjdCgpYCksXG4gKiAyLiB0byByZXBsYWNlIHRoZSB0cmFuc2xhdGFibGUgc3RyaW5ncyB3aXRoIHRoZSBhY3R1YWwgdHJhbnNsYXRpb25zIChzZWUgYG1lcmdlKClgKVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgX1Zpc2l0b3IkMiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfVmlzaXRvcihfaW1wbGljaXRUYWdzLCBfaW1wbGljaXRBdHRycykge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdFRhZ3MgPSBfaW1wbGljaXRUYWdzO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdEF0dHJzID0gX2ltcGxpY2l0QXR0cnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBtZXNzYWdlcyBmcm9tIHRoZSB0cmVlXG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbiAobm9kZXMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5faW5pdChfVmlzaXRvck1vZGUuRXh0cmFjdCwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMsIG51bGwpOyB9KTtcbiAgICAgICAgaWYgKHRoaXMuX2luSTE4bkJsb2NrKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSwgJ1VuY2xvc2VkIGJsb2NrJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFeHRyYWN0aW9uUmVzdWx0KHRoaXMuX21lc3NhZ2VzLCB0aGlzLl9lcnJvcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRyZWUgd2hlcmUgYWxsIHRyYW5zbGF0YWJsZSBub2RlcyBhcmUgdHJhbnNsYXRlZFxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChub2RlcywgdHJhbnNsYXRpb25zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2luaXQoX1Zpc2l0b3JNb2RlLk1lcmdlLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25zID0gdHJhbnNsYXRpb25zO1xuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBzaW5nbGUgZmFrZSByb290IGVsZW1lbnRcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBuZXcgRWxlbWVudCQxKCd3cmFwcGVyJywgW10sIG5vZGVzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZWROb2RlID0gd3JhcHBlci52aXNpdCh0aGlzLCBudWxsKTtcbiAgICAgICAgaWYgKHRoaXMuX2luSTE4bkJsb2NrKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSwgJ1VuY2xvc2VkIGJsb2NrJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVRyZWVSZXN1bHQodHJhbnNsYXRlZE5vZGUuY2hpbGRyZW4sIHRoaXMuX2Vycm9ycyk7XG4gICAgfTtcbiAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gUGFyc2UgY2FzZXMgZm9yIHRyYW5zbGF0YWJsZSBodG1sIGF0dHJpYnV0ZXNcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB2aXNpdEFsbCQxKHRoaXMsIGljdUNhc2UuZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXhwYW5zaW9uQ2FzZShpY3VDYXNlLnZhbHVlLCBleHByZXNzaW9uLCBpY3VDYXNlLnNvdXJjZVNwYW4sIGljdUNhc2UudmFsdWVTb3VyY2VTcGFuLCBpY3VDYXNlLmV4cFNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX21heUJlQWRkQmxvY2tDaGlsZHJlbihpY3UpO1xuICAgICAgICB2YXIgd2FzSW5JY3UgPSB0aGlzLl9pbkljdTtcbiAgICAgICAgaWYgKCF0aGlzLl9pbkljdSkge1xuICAgICAgICAgICAgLy8gbmVzdGVkIElDVSBtZXNzYWdlcyBzaG91bGQgbm90IGJlIGV4dHJhY3RlZCBidXQgdG9wLWxldmVsIHRyYW5zbGF0ZWQgYXMgYSB3aG9sZVxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZShbaWN1XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbkljdSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhc2VzID0gdmlzaXRBbGwkMSh0aGlzLCBpY3UuY2FzZXMsIGNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICBpY3UgPSBuZXcgRXhwYW5zaW9uKGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGNhc2VzLCBpY3Uuc291cmNlU3BhbiwgaWN1LnN3aXRjaFZhbHVlU291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5JY3UgPSB3YXNJbkljdTtcbiAgICAgICAgcmV0dXJuIGljdTtcbiAgICB9O1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkge1xuICAgICAgICB2YXIgaXNPcGVuaW5nID0gX2lzT3BlbmluZ0NvbW1lbnQoY29tbWVudCk7XG4gICAgICAgIGlmIChpc09wZW5pbmcgJiYgdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGNvbW1lbnQsICdDb3VsZCBub3Qgc3RhcnQgYSBibG9jayBpbnNpZGUgYSB0cmFuc2xhdGFibGUgc2VjdGlvbicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0Nsb3NpbmcgPSBfaXNDbG9zaW5nQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgaWYgKGlzQ2xvc2luZyAmJiAhdGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGNvbW1lbnQsICdUcnlpbmcgdG8gY2xvc2UgYW4gdW5vcGVuZWQgYmxvY2snKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2luSTE4bk5vZGUgJiYgIXRoaXMuX2luSWN1KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luSTE4bkJsb2NrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT3BlbmluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkIGZyb20gdjUgeW91IHNob3VsZCB1c2UgPG5nLWNvbnRhaW5lciBpMThuPiBpbnN0ZWFkIG9mIGkxOG4gY29tbWVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpMThuQ29tbWVudHNXYXJuZWQgJiYgY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkxOG5Db21tZW50c1dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGV0YWlscyA9IGNvbW1lbnQuc291cmNlU3Bhbi5kZXRhaWxzID8gXCIsIFwiICsgY29tbWVudC5zb3VyY2VTcGFuLmRldGFpbHMgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8ob2NvbWJlKTogdXNlIGEgbG9nIHNlcnZpY2Ugb25jZSB0aGVyZSBpcyBhIHB1YmxpYyBvbmUgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJJMThuIGNvbW1lbnRzIGFyZSBkZXByZWNhdGVkLCB1c2UgYW4gPG5nLWNvbnRhaW5lcj4gZWxlbWVudCBpbnN0ZWFkIChcIiArIGNvbW1lbnQuc291cmNlU3Bhbi5zdGFydCArIGRldGFpbHMgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5JMThuQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0RGVwdGggPSB0aGlzLl9kZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja01lYW5pbmdBbmREZXNjID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQudmFsdWUucmVwbGFjZShfSTE4Tl9DT01NRU5UX1BSRUZJWF9SRUdFWFAsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5UcmFuc2xhdGFibGVTZWN0aW9uKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc0Nsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RlcHRoID09IHRoaXMuX2Jsb2NrU3RhcnREZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uKGNvbW1lbnQsIHRoaXMuX2Jsb2NrQ2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5JMThuQmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5fYWRkTWVzc2FnZSh0aGlzLl9ibG9ja0NoaWxkcmVuLCB0aGlzLl9ibG9ja01lYW5pbmdBbmREZXNjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIGF0dHJpYnV0ZXMgaW4gc2VjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMuX3RyYW5zbGF0ZU1lc3NhZ2UoY29tbWVudCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRBbGwkMSh0aGlzLCBub2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihjb21tZW50LCAnSTE4TiBibG9ja3Mgc2hvdWxkIG5vdCBjcm9zcyBlbGVtZW50IGJvdW5kYXJpZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4oZWwpO1xuICAgICAgICB0aGlzLl9kZXB0aCsrO1xuICAgICAgICB2YXIgd2FzSW5JMThuTm9kZSA9IHRoaXMuX2luSTE4bk5vZGU7XG4gICAgICAgIHZhciB3YXNJbkltcGxpY2l0Tm9kZSA9IHRoaXMuX2luSW1wbGljaXROb2RlO1xuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICB2YXIgdHJhbnNsYXRlZENoaWxkTm9kZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIEV4dHJhY3Q6XG4gICAgICAgIC8vIC0gdG9wIGxldmVsIG5vZGVzIHdpdGggdGhlIChpbXBsaWNpdCkgXCJpMThuXCIgYXR0cmlidXRlIGlmIG5vdCBhbHJlYWR5IGluIGEgc2VjdGlvblxuICAgICAgICAvLyAtIElDVSBtZXNzYWdlc1xuICAgICAgICB2YXIgaTE4bkF0dHIgPSBfZ2V0STE4bkF0dHIoZWwpO1xuICAgICAgICB2YXIgaTE4bk1ldGEgPSBpMThuQXR0ciA/IGkxOG5BdHRyLnZhbHVlIDogJyc7XG4gICAgICAgIHZhciBpc0ltcGxpY2l0ID0gdGhpcy5faW1wbGljaXRUYWdzLnNvbWUoZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gZWwubmFtZSA9PT0gdGFnOyB9KSAmJiAhdGhpcy5faW5JY3UgJiZcbiAgICAgICAgICAgICF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbjtcbiAgICAgICAgdmFyIGlzVG9wTGV2ZWxJbXBsaWNpdCA9ICF3YXNJbkltcGxpY2l0Tm9kZSAmJiBpc0ltcGxpY2l0O1xuICAgICAgICB0aGlzLl9pbkltcGxpY2l0Tm9kZSA9IHdhc0luSW1wbGljaXROb2RlIHx8IGlzSW1wbGljaXQ7XG4gICAgICAgIGlmICghdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24gJiYgIXRoaXMuX2luSWN1KSB7XG4gICAgICAgICAgICBpZiAoaTE4bkF0dHIgfHwgaXNUb3BMZXZlbEltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5JMThuTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLl9hZGRNZXNzYWdlKGVsLmNoaWxkcmVuLCBpMThuTWV0YSk7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZENoaWxkTm9kZXMgPSB0aGlzLl90cmFuc2xhdGVNZXNzYWdlKGVsLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09IF9WaXNpdG9yTW9kZS5FeHRyYWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzVHJhbnNsYXRhYmxlID0gaTE4bkF0dHIgfHwgaXNUb3BMZXZlbEltcGxpY2l0O1xuICAgICAgICAgICAgICAgIGlmIChpc1RyYW5zbGF0YWJsZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblRyYW5zbGF0YWJsZVNlY3Rpb24oZWwpO1xuICAgICAgICAgICAgICAgIHZpc2l0QWxsJDEodGhpcywgZWwuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpc1RyYW5zbGF0YWJsZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uKGVsLCBlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaTE4bkF0dHIgfHwgaXNUb3BMZXZlbEltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZWwsICdDb3VsZCBub3QgbWFyayBhbiBlbGVtZW50IGFzIHRyYW5zbGF0YWJsZSBpbnNpZGUgYSB0cmFuc2xhdGFibGUgc2VjdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT0gX1Zpc2l0b3JNb2RlLkV4dHJhY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBEZXNjZW5kIGludG8gY2hpbGQgbm9kZXMgZm9yIGV4dHJhY3Rpb25cbiAgICAgICAgICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICB2YXIgdmlzaXROb2RlcyA9IHRyYW5zbGF0ZWRDaGlsZE5vZGVzIHx8IGVsLmNoaWxkcmVuO1xuICAgICAgICAgICAgdmlzaXROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciB2aXNpdGVkID0gY2hpbGQudmlzaXQoX3RoaXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkICYmICFfdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IGFkZCB0aGUgY2hpbGRyZW4gZnJvbSB0cmFuc2xhdGFibGUgc2VjdGlvbnMgKD0gaTE4biBibG9ja3MgaGVyZSlcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGJlIGFkZGVkIGxhdGVyIGluIHRoaXMgbG9vcCB3aGVuIHRoZSBibG9jayBjbG9zZXMgKGkuZS4gb24gYDwhLS0gL2kxOG4gLS0+YClcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyA9IGNoaWxkTm9kZXMuY29uY2F0KHZpc2l0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc2l0QXR0cmlidXRlc09mKGVsKTtcbiAgICAgICAgdGhpcy5fZGVwdGgtLTtcbiAgICAgICAgdGhpcy5faW5JMThuTm9kZSA9IHdhc0luSTE4bk5vZGU7XG4gICAgICAgIHRoaXMuX2luSW1wbGljaXROb2RlID0gd2FzSW5JbXBsaWNpdE5vZGU7XG4gICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2xhdGVkQXR0cnMgPSB0aGlzLl90cmFuc2xhdGVBdHRyaWJ1dGVzKGVsKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudCQxKGVsLm5hbWUsIHRyYW5zbGF0ZWRBdHRycywgY2hpbGROb2RlcywgZWwuc291cmNlU3BhbiwgZWwuc3RhcnRTb3VyY2VTcGFuLCBlbC5lbmRTb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgfTtcbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAobW9kZSwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICB0aGlzLl9tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5faW5JMThuQmxvY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5JMThuTm9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kZXB0aCA9IDA7XG4gICAgICAgIHRoaXMuX2luSWN1ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLl9tZXNzYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLl9pbkltcGxpY2l0Tm9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jcmVhdGVJMThuTWVzc2FnZSA9IGNyZWF0ZUkxOG5NZXNzYWdlRmFjdG9yeShpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICB9O1xuICAgIC8vIGxvb2tzIGZvciB0cmFuc2xhdGFibGUgYXR0cmlidXRlc1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRBdHRyaWJ1dGVzT2YgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV4cGxpY2l0QXR0ck5hbWVUb1ZhbHVlID0ge307XG4gICAgICAgIHZhciBpbXBsaWNpdEF0dHJOYW1lcyA9IHRoaXMuX2ltcGxpY2l0QXR0cnNbZWwubmFtZV0gfHwgW107XG4gICAgICAgIGVsLmF0dHJzLmZpbHRlcihmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lLnN0YXJ0c1dpdGgoX0kxOE5fQVRUUl9QUkVGSVgpOyB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGV4cGxpY2l0QXR0ck5hbWVUb1ZhbHVlW2F0dHIubmFtZS5zbGljZShfSTE4Tl9BVFRSX1BSRUZJWC5sZW5ndGgpXSA9XG4gICAgICAgICAgICBhdHRyLnZhbHVlOyB9KTtcbiAgICAgICAgZWwuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgaWYgKGF0dHIubmFtZSBpbiBleHBsaWNpdEF0dHJOYW1lVG9WYWx1ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9hZGRNZXNzYWdlKFthdHRyXSwgZXhwbGljaXRBdHRyTmFtZVRvVmFsdWVbYXR0ci5uYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbXBsaWNpdEF0dHJOYW1lcy5zb21lKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBhdHRyLm5hbWUgPT09IG5hbWU7IH0pKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2FkZE1lc3NhZ2UoW2F0dHJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBhZGQgYSB0cmFuc2xhdGFibGUgbWVzc2FnZVxuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fYWRkTWVzc2FnZSA9IGZ1bmN0aW9uIChhc3QsIG1zZ01ldGEpIHtcbiAgICAgICAgaWYgKGFzdC5sZW5ndGggPT0gMCB8fFxuICAgICAgICAgICAgYXN0Lmxlbmd0aCA9PSAxICYmIGFzdFswXSBpbnN0YW5jZW9mIEF0dHJpYnV0ZSAmJiAhYXN0WzBdLnZhbHVlKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgY3JlYXRlIGVtcHR5IG1lc3NhZ2VzXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSBfcGFyc2VNZXNzYWdlTWV0YShtc2dNZXRhKSwgbWVhbmluZyA9IF9hLm1lYW5pbmcsIGRlc2NyaXB0aW9uID0gX2EuZGVzY3JpcHRpb24sIGlkID0gX2EuaWQ7XG4gICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UoYXN0LCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuICAgIC8vIFRyYW5zbGF0ZXMgdGhlIGdpdmVuIG1lc3NhZ2UgZ2l2ZW4gdGhlIGBUcmFuc2xhdGlvbkJ1bmRsZWBcbiAgICAvLyBUaGlzIGlzIHVzZWQgZm9yIHRyYW5zbGF0aW5nIGVsZW1lbnRzIC8gYmxvY2tzIC0gc2VlIGBfdHJhbnNsYXRlQXR0cmlidXRlc2AgZm9yIGF0dHJpYnV0ZXNcbiAgICAvLyBuby1vcCB3aGVuIGNhbGxlZCBpbiBleHRyYWN0aW9uIG1vZGUgKHJldHVybnMgW10pXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl90cmFuc2xhdGVNZXNzYWdlID0gZnVuY3Rpb24gKGVsLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlICYmIHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5fdHJhbnNsYXRpb25zLmdldChtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVsLCBcIlRyYW5zbGF0aW9uIHVuYXZhaWxhYmxlIGZvciBtZXNzYWdlIGlkPVxcXCJcIiArIHRoaXMuX3RyYW5zbGF0aW9ucy5kaWdlc3QobWVzc2FnZSkgKyBcIlxcXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgLy8gdHJhbnNsYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIGFuIGVsZW1lbnQgYW5kIHJlbW92ZSBpMThuIHNwZWNpZmljIGF0dHJpYnV0ZXNcbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX3RyYW5zbGF0ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBlbC5hdHRycztcbiAgICAgICAgdmFyIGkxOG5QYXJzZWRNZXNzYWdlTWV0YSA9IHt9O1xuICAgICAgICBhdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChhdHRyLm5hbWUuc3RhcnRzV2l0aChfSTE4Tl9BVFRSX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgICBpMThuUGFyc2VkTWVzc2FnZU1ldGFbYXR0ci5uYW1lLnNsaWNlKF9JMThOX0FUVFJfUFJFRklYLmxlbmd0aCldID1cbiAgICAgICAgICAgICAgICAgICAgX3BhcnNlTWVzc2FnZU1ldGEoYXR0ci52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdHJhbnNsYXRlZEF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci5uYW1lID09PSBfSTE4Tl9BVFRSIHx8IGF0dHIubmFtZS5zdGFydHNXaXRoKF9JMThOX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGkxOG4gc3BlY2lmaWMgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRyLnZhbHVlICYmIGF0dHIudmFsdWUgIT0gJycgJiYgaTE4blBhcnNlZE1lc3NhZ2VNZXRhLmhhc093blByb3BlcnR5KGF0dHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBpMThuUGFyc2VkTWVzc2FnZU1ldGFbYXR0ci5uYW1lXSwgbWVhbmluZyA9IF9hLm1lYW5pbmcsIGRlc2NyaXB0aW9uID0gX2EuZGVzY3JpcHRpb24sIGlkID0gX2EuaWQ7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBfdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UoW2F0dHJdLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQpO1xuICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IF90aGlzLl90cmFuc2xhdGlvbnMuZ2V0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzLnB1c2gobmV3IEF0dHJpYnV0ZShhdHRyLm5hbWUsICcnLCBhdHRyLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2Rlc1swXSBpbnN0YW5jZW9mIFRleHQkMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9kZXNbMF0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVkQXR0cmlidXRlcy5wdXNoKG5ldyBBdHRyaWJ1dGUoYXR0ci5uYW1lLCB2YWx1ZSwgYXR0ci5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoZWwsIFwiVW5leHBlY3RlZCB0cmFuc2xhdGlvbiBmb3IgYXR0cmlidXRlIFxcXCJcIiArIGF0dHIubmFtZSArIFwiXFxcIiAoaWQ9XFxcIlwiICsgKGlkIHx8IF90aGlzLl90cmFuc2xhdGlvbnMuZGlnZXN0KG1lc3NhZ2UpKSArIFwiXFxcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihlbCwgXCJUcmFuc2xhdGlvbiB1bmF2YWlsYWJsZSBmb3IgYXR0cmlidXRlIFxcXCJcIiArIGF0dHIubmFtZSArIFwiXFxcIiAoaWQ9XFxcIlwiICsgKGlkIHx8IF90aGlzLl90cmFuc2xhdGlvbnMuZGlnZXN0KG1lc3NhZ2UpKSArIFwiXFxcIilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZEF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cmFuc2xhdGVkQXR0cmlidXRlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgbm9kZSBhcyBhIGNoaWxkIG9mIHRoZSBibG9jayB3aGVuOlxuICAgICAqIC0gd2UgYXJlIGluIGEgYmxvY2ssXG4gICAgICogLSB3ZSBhcmUgbm90IGluc2lkZSBhIElDVSBtZXNzYWdlICh0aG9zZSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5KSxcbiAgICAgKiAtIHRoZSBub2RlIGlzIGEgXCJkaXJlY3QgY2hpbGRcIiBvZiB0aGUgYmxvY2tcbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX21heUJlQWRkQmxvY2tDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbkkxOG5CbG9jayAmJiAhdGhpcy5faW5JY3UgJiYgdGhpcy5fZGVwdGggPT0gdGhpcy5fYmxvY2tTdGFydERlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLl9ibG9ja0NoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoZSBzdGFydCBvZiBhIHNlY3Rpb24sIHNlZSBgX2Nsb3NlVHJhbnNsYXRhYmxlU2VjdGlvbmBcbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX29wZW5UcmFuc2xhdGFibGVTZWN0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2RlLCAnVW5leHBlY3RlZCBzZWN0aW9uIHN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ID0gdGhpcy5fbWVzc2FnZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX1Zpc2l0b3IucHJvdG90eXBlLCBcIl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHRyYW5zbGF0YWJsZSBzZWN0aW9uIGNvdWxkIGJlOlxuICAgICAgICAgKiAtIHRoZSBjb250ZW50IG9mIHRyYW5zbGF0YWJsZSBlbGVtZW50LFxuICAgICAgICAgKiAtIG5vZGVzIGJldHdlZW4gYDwhLS0gaTE4biAtLT5gIGFuZCBgPCEtLSAvaTE4biAtLT5gIGNvbW1lbnRzXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ICE9PSB2b2lkIDA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRlcm1pbmF0ZXMgYSBzZWN0aW9uLlxuICAgICAqXG4gICAgICogSWYgYSBzZWN0aW9uIGhhcyBvbmx5IG9uZSBzaWduaWZpY2FudCBjaGlsZHJlbiAoY29tbWVudHMgbm90IHNpZ25pZmljYW50KSB0aGVuIHdlIHNob3VsZCBub3RcbiAgICAgKiBrZWVwIHRoZSBtZXNzYWdlIGZyb20gdGhpcyBjaGlsZHJlbjpcbiAgICAgKlxuICAgICAqIGA8cCBpMThuPVwibWVhbmluZ3xkZXNjcmlwdGlvblwiPntJQ1UgbWVzc2FnZX08L3A+YCB3b3VsZCBwcm9kdWNlIHR3byBtZXNzYWdlczpcbiAgICAgKiAtIG9uZSBmb3IgdGhlIDxwPiBjb250ZW50IHdpdGggbWVhbmluZyBhbmQgZGVzY3JpcHRpb24sXG4gICAgICogLSBhbm90aGVyIG9uZSBmb3IgdGhlIElDVSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogSW4gdGhpcyBjYXNlIHRoZSBsYXN0IG1lc3NhZ2UgaXMgZGlzY2FyZGVkIGFzIGl0IGNvbnRhaW5zIGxlc3MgaW5mb3JtYXRpb24gKHRoZSBBU1QgaXNcbiAgICAgKiBvdGhlcndpc2UgaWRlbnRpY2FsKS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB3ZSBzaG91bGQgc3RpbGwga2VlcCBtZXNzYWdlcyBleHRyYWN0ZWQgZnJvbSBhdHRyaWJ1dGVzIGluc2lkZSB0aGUgc2VjdGlvbiAoaWUgaW4gdGhlXG4gICAgICogSUNVIG1lc3NhZ2UgaGVyZSlcbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX2Nsb3NlVHJhbnNsYXRhYmxlU2VjdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBkaXJlY3RDaGlsZHJlbikge1xuICAgICAgICBpZiAoIXRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2RlLCAnVW5leHBlY3RlZCBzZWN0aW9uIGVuZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydEluZGV4ID0gdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydDtcbiAgICAgICAgdmFyIHNpZ25pZmljYW50Q2hpbGRyZW4gPSBkaXJlY3RDaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50LCBub2RlKSB7IHJldHVybiBjb3VudCArIChub2RlIGluc3RhbmNlb2YgQ29tbWVudCA/IDAgOiAxKTsgfSwgMCk7XG4gICAgICAgIGlmIChzaWduaWZpY2FudENoaWxkcmVuID09IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9tZXNzYWdlcy5sZW5ndGggLSAxOyBpID49IHN0YXJ0SW5kZXg7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBhc3QgPSB0aGlzLl9tZXNzYWdlc1tpXS5ub2RlcztcbiAgICAgICAgICAgICAgICBpZiAoIShhc3QubGVuZ3RoID09IDEgJiYgYXN0WzBdIGluc3RhbmNlb2YgVGV4dCQxKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtc2cpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1zZykpO1xuICAgIH07XG4gICAgcmV0dXJuIF9WaXNpdG9yO1xufSgpKTtcbmZ1bmN0aW9uIF9pc09wZW5pbmdDb21tZW50KG4pIHtcbiAgICByZXR1cm4gISEobiBpbnN0YW5jZW9mIENvbW1lbnQgJiYgbi52YWx1ZSAmJiBuLnZhbHVlLnN0YXJ0c1dpdGgoJ2kxOG4nKSk7XG59XG5mdW5jdGlvbiBfaXNDbG9zaW5nQ29tbWVudChuKSB7XG4gICAgcmV0dXJuICEhKG4gaW5zdGFuY2VvZiBDb21tZW50ICYmIG4udmFsdWUgJiYgbi52YWx1ZSA9PT0gJy9pMThuJyk7XG59XG5mdW5jdGlvbiBfZ2V0STE4bkF0dHIocCkge1xuICAgIHJldHVybiBwLmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gX0kxOE5fQVRUUjsgfSkgfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIF9wYXJzZU1lc3NhZ2VNZXRhKGkxOG4pIHtcbiAgICBpZiAoIWkxOG4pXG4gICAgICAgIHJldHVybiB7IG1lYW5pbmc6ICcnLCBkZXNjcmlwdGlvbjogJycsIGlkOiAnJyB9O1xuICAgIHZhciBpZEluZGV4ID0gaTE4bi5pbmRleE9mKElEX1NFUEFSQVRPUik7XG4gICAgdmFyIGRlc2NJbmRleCA9IGkxOG4uaW5kZXhPZihNRUFOSU5HX1NFUEFSQVRPUik7XG4gICAgdmFyIF9hID0gX19yZWFkKChpZEluZGV4ID4gLTEpID8gW2kxOG4uc2xpY2UoMCwgaWRJbmRleCksIGkxOG4uc2xpY2UoaWRJbmRleCArIDIpXSA6IFtpMThuLCAnJ10sIDIpLCBtZWFuaW5nQW5kRGVzYyA9IF9hWzBdLCBpZCA9IF9hWzFdO1xuICAgIHZhciBfYiA9IF9fcmVhZCgoZGVzY0luZGV4ID4gLTEpID9cbiAgICAgICAgW21lYW5pbmdBbmREZXNjLnNsaWNlKDAsIGRlc2NJbmRleCksIG1lYW5pbmdBbmREZXNjLnNsaWNlKGRlc2NJbmRleCArIDEpXSA6XG4gICAgICAgIFsnJywgbWVhbmluZ0FuZERlc2NdLCAyKSwgbWVhbmluZyA9IF9iWzBdLCBkZXNjcmlwdGlvbiA9IF9iWzFdO1xuICAgIHJldHVybiB7IG1lYW5pbmc6IG1lYW5pbmcsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiwgaWQ6IGlkIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBYbWxUYWdEZWZpbml0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhtbFRhZ0RlZmluaXRpb24oKSB7XG4gICAgICAgIHRoaXMuY2xvc2VkQnlQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IFRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEE7XG4gICAgICAgIHRoaXMuaXNWb2lkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaWdub3JlRmlyc3RMZiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhblNlbGZDbG9zZSA9IHRydWU7XG4gICAgfVxuICAgIFhtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLnJlcXVpcmVFeHRyYVBhcmVudCA9IGZ1bmN0aW9uIChjdXJyZW50UGFyZW50KSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICBYbWxUYWdEZWZpbml0aW9uLnByb3RvdHlwZS5pc0Nsb3NlZEJ5Q2hpbGQgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgcmV0dXJuIFhtbFRhZ0RlZmluaXRpb247XG59KCkpO1xudmFyIF9UQUdfREVGSU5JVElPTiA9IG5ldyBYbWxUYWdEZWZpbml0aW9uKCk7XG5mdW5jdGlvbiBnZXRYbWxUYWdEZWZpbml0aW9uKHRhZ05hbWUpIHtcbiAgICByZXR1cm4gX1RBR19ERUZJTklUSU9OO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgWG1sUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYbWxQYXJzZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWG1sUGFyc2VyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ2V0WG1sVGFnRGVmaW5pdGlvbikgfHwgdGhpcztcbiAgICB9XG4gICAgWG1sUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHVybCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5wYXJzZS5jYWxsKHRoaXMsIHNvdXJjZSwgdXJsLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBYbWxQYXJzZXI7XG59KFBhcnNlcikpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX1ZFUlNJT04gPSAnMS4yJztcbnZhciBfWE1MTlMgPSAndXJuOm9hc2lzOm5hbWVzOnRjOnhsaWZmOmRvY3VtZW50OjEuMic7XG4vLyBUT0RPKHZpY2IpOiBtYWtlIHRoaXMgYSBwYXJhbSAocy9fLy0vKVxudmFyIF9ERUZBVUxUX1NPVVJDRV9MQU5HID0gJ2VuJztcbnZhciBfUExBQ0VIT0xERVJfVEFHJDEgPSAneCc7XG52YXIgX01BUktFUl9UQUcgPSAnbXJrJztcbnZhciBfRklMRV9UQUcgPSAnZmlsZSc7XG52YXIgX1NPVVJDRV9UQUckMSA9ICdzb3VyY2UnO1xudmFyIF9TRUdNRU5UX1NPVVJDRV9UQUcgPSAnc2VnLXNvdXJjZSc7XG52YXIgX0FMVF9UUkFOU19UQUcgPSAnYWx0LXRyYW5zJztcbnZhciBfVEFSR0VUX1RBRyA9ICd0YXJnZXQnO1xudmFyIF9VTklUX1RBRyA9ICd0cmFucy11bml0JztcbnZhciBfQ09OVEVYVF9HUk9VUF9UQUcgPSAnY29udGV4dC1ncm91cCc7XG52YXIgX0NPTlRFWFRfVEFHID0gJ2NvbnRleHQnO1xuLy8gaHR0cDovL2RvY3Mub2FzaXMtb3Blbi5vcmcveGxpZmYvdjEuMi9vcy94bGlmZi1jb3JlLmh0bWxcbi8vIGh0dHA6Ly9kb2NzLm9hc2lzLW9wZW4ub3JnL3hsaWZmL3YxLjIveGxpZmYtcHJvZmlsZS1odG1sL3hsaWZmLXByb2ZpbGUtaHRtbC0xLjIuaHRtbFxudmFyIFhsaWZmID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYbGlmZiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBYbGlmZigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBYbGlmZi5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAobWVzc2FnZXMsIGxvY2FsZSkge1xuICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBfV3JpdGVWaXNpdG9yKCk7XG4gICAgICAgIHZhciB0cmFuc1VuaXRzID0gW107XG4gICAgICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBjb250ZXh0VGFncyA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0R3JvdXBUYWcgPSBuZXcgVGFnKF9DT05URVhUX0dST1VQX1RBRywgeyBwdXJwb3NlOiAnbG9jYXRpb24nIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRleHRHcm91cFRhZy5jaGlsZHJlbi5wdXNoKG5ldyBDUigxMCksIG5ldyBUYWcoX0NPTlRFWFRfVEFHLCB7ICdjb250ZXh0LXR5cGUnOiAnc291cmNlZmlsZScgfSwgW25ldyBUZXh0JDIoc291cmNlLmZpbGVQYXRoKV0pLCBuZXcgQ1IoMTApLCBuZXcgVGFnKF9DT05URVhUX1RBRywgeyAnY29udGV4dC10eXBlJzogJ2xpbmVudW1iZXInIH0sIFtuZXcgVGV4dCQyKFwiXCIgKyBzb3VyY2Uuc3RhcnRMaW5lKV0pLCBuZXcgQ1IoOCkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHRUYWdzLnB1c2gobmV3IENSKDgpLCBjb250ZXh0R3JvdXBUYWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgdHJhbnNVbml0ID0gbmV3IFRhZyhfVU5JVF9UQUcsIHsgaWQ6IG1lc3NhZ2UuaWQsIGRhdGF0eXBlOiAnaHRtbCcgfSk7XG4gICAgICAgICAgICAoX2EgPSB0cmFuc1VuaXQuY2hpbGRyZW4pLnB1c2guYXBwbHkoX2EsIF9fc3ByZWFkKFtuZXcgQ1IoOCksIG5ldyBUYWcoX1NPVVJDRV9UQUckMSwge30sIHZpc2l0b3Iuc2VyaWFsaXplKG1lc3NhZ2Uubm9kZXMpKV0sIGNvbnRleHRUYWdzKSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRyYW5zVW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZygnbm90ZScsIHsgcHJpb3JpdHk6ICcxJywgZnJvbTogJ2Rlc2NyaXB0aW9uJyB9LCBbbmV3IFRleHQkMihtZXNzYWdlLmRlc2NyaXB0aW9uKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IHByaW9yaXR5OiAnMScsIGZyb206ICdtZWFuaW5nJyB9LCBbbmV3IFRleHQkMihtZXNzYWdlLm1lYW5pbmcpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNVbml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDYpKTtcbiAgICAgICAgICAgIHRyYW5zVW5pdHMucHVzaChuZXcgQ1IoNiksIHRyYW5zVW5pdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYm9keSA9IG5ldyBUYWcoJ2JvZHknLCB7fSwgX19zcHJlYWQodHJhbnNVbml0cywgW25ldyBDUig0KV0pKTtcbiAgICAgICAgdmFyIGZpbGUgPSBuZXcgVGFnKCdmaWxlJywge1xuICAgICAgICAgICAgJ3NvdXJjZS1sYW5ndWFnZSc6IGxvY2FsZSB8fCBfREVGQVVMVF9TT1VSQ0VfTEFORyxcbiAgICAgICAgICAgIGRhdGF0eXBlOiAncGxhaW50ZXh0JyxcbiAgICAgICAgICAgIG9yaWdpbmFsOiAnbmcyLnRlbXBsYXRlJyxcbiAgICAgICAgfSwgW25ldyBDUig0KSwgYm9keSwgbmV3IENSKDIpXSk7XG4gICAgICAgIHZhciB4bGlmZiA9IG5ldyBUYWcoJ3hsaWZmJywgeyB2ZXJzaW9uOiBfVkVSU0lPTiwgeG1sbnM6IF9YTUxOUyB9LCBbbmV3IENSKDIpLCBmaWxlLCBuZXcgQ1IoKV0pO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplKFtcbiAgICAgICAgICAgIG5ldyBEZWNsYXJhdGlvbih7IHZlcnNpb246ICcxLjAnLCBlbmNvZGluZzogJ1VURi04JyB9KSwgbmV3IENSKCksIHhsaWZmLCBuZXcgQ1IoKVxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIFhsaWZmLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCkge1xuICAgICAgICAvLyB4bGlmZiB0byB4bWwgbm9kZXNcbiAgICAgICAgdmFyIHhsaWZmUGFyc2VyID0gbmV3IFhsaWZmUGFyc2VyKCk7XG4gICAgICAgIHZhciBfYSA9IHhsaWZmUGFyc2VyLnBhcnNlKGNvbnRlbnQsIHVybCksIGxvY2FsZSA9IF9hLmxvY2FsZSwgbXNnSWRUb0h0bWwgPSBfYS5tc2dJZFRvSHRtbCwgZXJyb3JzID0gX2EuZXJyb3JzO1xuICAgICAgICAvLyB4bWwgbm9kZXMgdG8gaTE4biBub2Rlc1xuICAgICAgICB2YXIgaTE4bk5vZGVzQnlNc2dJZCA9IHt9O1xuICAgICAgICB2YXIgY29udmVydGVyID0gbmV3IFhtbFRvSTE4bigpO1xuICAgICAgICBPYmplY3Qua2V5cyhtc2dJZFRvSHRtbCkuZm9yRWFjaChmdW5jdGlvbiAobXNnSWQpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGNvbnZlcnRlci5jb252ZXJ0KG1zZ0lkVG9IdG1sW21zZ0lkXSwgdXJsKSwgaTE4bk5vZGVzID0gX2EuaTE4bk5vZGVzLCBlID0gX2EuZXJyb3JzO1xuICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBfX3NwcmVhZChlKSk7XG4gICAgICAgICAgICBpMThuTm9kZXNCeU1zZ0lkW21zZ0lkXSA9IGkxOG5Ob2RlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4bGlmZiBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxvY2FsZTogbG9jYWxlLCBpMThuTm9kZXNCeU1zZ0lkOiBpMThuTm9kZXNCeU1zZ0lkIH07XG4gICAgfTtcbiAgICBYbGlmZi5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIGRpZ2VzdChtZXNzYWdlKTsgfTtcbiAgICByZXR1cm4gWGxpZmY7XG59KFNlcmlhbGl6ZXIpKTtcbnZhciBfV3JpdGVWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9Xcml0ZVZpc2l0b3IoKSB7XG4gICAgfVxuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiBbbmV3IFRleHQkMih0ZXh0LnZhbHVlKV07IH07XG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICBjb250YWluZXIuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZXMucHVzaC5hcHBseShub2RlcywgX19zcHJlYWQobm9kZS52aXNpdChfdGhpcykpKTsgfSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9O1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbm9kZXMgPSBbbmV3IFRleHQkMihcIntcIiArIGljdS5leHByZXNzaW9uUGxhY2Vob2xkZXIgKyBcIiwgXCIgKyBpY3UudHlwZSArIFwiLCBcIildO1xuICAgICAgICBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2guYXBwbHkobm9kZXMsIF9fc3ByZWFkKFtuZXcgVGV4dCQyKGMgKyBcIiB7XCIpXSwgaWN1LmNhc2VzW2NdLnZpc2l0KF90aGlzKSwgW25ldyBUZXh0JDIoXCJ9IFwiKV0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGVzLnB1c2gobmV3IFRleHQkMihcIn1cIikpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfTtcbiAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjdHlwZSA9IGdldEN0eXBlRm9yVGFnKHBoLnRhZyk7XG4gICAgICAgIGlmIChwaC5pc1ZvaWQpIHtcbiAgICAgICAgICAgIC8vIHZvaWQgdGFncyBoYXZlIG5vIGNoaWxkcmVuIG5vciBjbG9zaW5nIHRhZ3NcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHsgaWQ6IHBoLnN0YXJ0TmFtZSwgY3R5cGU6IGN0eXBlLCAnZXF1aXYtdGV4dCc6IFwiPFwiICsgcGgudGFnICsgXCIvPlwiIH0pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnRUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7IGlkOiBwaC5zdGFydE5hbWUsIGN0eXBlOiBjdHlwZSwgJ2VxdWl2LXRleHQnOiBcIjxcIiArIHBoLnRhZyArIFwiPlwiIH0pO1xuICAgICAgICB2YXIgY2xvc2VUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7IGlkOiBwaC5jbG9zZU5hbWUsIGN0eXBlOiBjdHlwZSwgJ2VxdWl2LXRleHQnOiBcIjwvXCIgKyBwaC50YWcgKyBcIj5cIiB9KTtcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkKFtzdGFydFRhZ1BoXSwgdGhpcy5zZXJpYWxpemUocGguY2hpbGRyZW4pLCBbY2xvc2VUYWdQaF0pO1xuICAgIH07XG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7IGlkOiBwaC5uYW1lLCAnZXF1aXYtdGV4dCc6IFwie3tcIiArIHBoLnZhbHVlICsgXCJ9fVwiIH0pXTtcbiAgICB9O1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGVxdWl2VGV4dCA9IFwie1wiICsgcGgudmFsdWUuZXhwcmVzc2lvbiArIFwiLCBcIiArIHBoLnZhbHVlLnR5cGUgKyBcIiwgXCIgKyBPYmplY3Qua2V5cyhwaC52YWx1ZS5jYXNlcykubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgKyAnIHsuLi59JzsgfSkuam9pbignICcpICsgXCJ9XCI7XG4gICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHsgaWQ6IHBoLm5hbWUsICdlcXVpdi10ZXh0JzogZXF1aXZUZXh0IH0pXTtcbiAgICB9O1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBfX3NwcmVhZChub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KSkpO1xuICAgIH07XG4gICAgcmV0dXJuIF9Xcml0ZVZpc2l0b3I7XG59KCkpO1xuLy8gVE9ETyh2aWNiKTogYWRkIGVycm9yIG1hbmFnZW1lbnQgKHN0cnVjdHVyZSlcbi8vIEV4dHJhY3QgbWVzc2FnZXMgYXMgeG1sIG5vZGVzIGZyb20gdGhlIHhsaWZmIGZpbGVcbnZhciBYbGlmZlBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbGlmZlBhcnNlcigpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxlID0gbnVsbDtcbiAgICB9XG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHhsaWZmLCB1cmwpIHtcbiAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWwgPSB7fTtcbiAgICAgICAgdmFyIHhtbCA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZSh4bGlmZiwgdXJsKTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sLmVycm9ycztcbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCB4bWwucm9vdE5vZGVzLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1zZ0lkVG9IdG1sOiB0aGlzLl9tc2dJZFRvSHRtbCxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgc3dpdGNoIChlbGVtZW50Lm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgX1VOSVRfVEFHOlxuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXRNbFN0cmluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnaWQnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9VTklUX1RBRyArIFwiPiBtaXNzZXMgdGhlIFxcXCJpZFxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gaWRBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbXNnSWRUb0h0bWwuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIkR1cGxpY2F0ZWQgdHJhbnNsYXRpb25zIGZvciBtc2cgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl91bml0TWxTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWxbaWRdID0gdGhpcy5fdW5pdE1sU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCJNZXNzYWdlIFwiICsgaWQgKyBcIiBtaXNzZXMgYSB0cmFuc2xhdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGlnbm9yZSB0aG9zZSB0YWdzXG4gICAgICAgICAgICBjYXNlIF9TT1VSQ0VfVEFHJDE6XG4gICAgICAgICAgICBjYXNlIF9TRUdNRU5UX1NPVVJDRV9UQUc6XG4gICAgICAgICAgICBjYXNlIF9BTFRfVFJBTlNfVEFHOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfVEFSR0VUX1RBRzpcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJUZXh0U3RhcnQgPSBlbGVtZW50LnN0YXJ0U291cmNlU3Bhbi5lbmQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciBpbm5lclRleHRFbmQgPSBlbGVtZW50LmVuZFNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gZWxlbWVudC5zdGFydFNvdXJjZVNwYW4uc3RhcnQuZmlsZS5jb250ZW50O1xuICAgICAgICAgICAgICAgIHZhciBpbm5lclRleHQgPSBjb250ZW50LnNsaWNlKGlubmVyVGV4dFN0YXJ0LCBpbm5lclRleHRFbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXRNbFN0cmluZyA9IGlubmVyVGV4dDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX0ZJTEVfVEFHOlxuICAgICAgICAgICAgICAgIHZhciBsb2NhbGVBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICd0YXJnZXQtbGFuZ3VhZ2UnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGVBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBhc3NlcnQgZmlsZSBzdHJ1Y3R1cmUsIHhsaWZmIHZlcnNpb25cbiAgICAgICAgICAgICAgICAvLyBGb3Igbm93IG9ubHkgcmVjdXJzZSBvbiB1bmhhbmRsZWQgbm9kZXNcbiAgICAgICAgICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IH07XG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IH07XG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IH07XG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyB9O1xuICAgIFhsaWZmUGFyc2VyLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkgeyB9O1xuICAgIFhsaWZmUGFyc2VyLnByb3RvdHlwZS5fYWRkRXJyb3IgPSBmdW5jdGlvbiAobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbWVzc2FnZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFhsaWZmUGFyc2VyO1xufSgpKTtcbi8vIENvbnZlcnQgbWwgbm9kZXMgKHhsaWZmIHN5bnRheCkgdG8gaTE4biBub2Rlc1xudmFyIFhtbFRvSTE4biA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbWxUb0kxOG4oKSB7XG4gICAgfVxuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChtZXNzYWdlLCB1cmwpIHtcbiAgICAgICAgdmFyIHhtbEljdSA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZShtZXNzYWdlLCB1cmwsIHsgdG9rZW5pemVFeHBhbnNpb25Gb3JtczogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sSWN1LmVycm9ycztcbiAgICAgICAgdmFyIGkxOG5Ob2RlcyA9IHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwIHx8IHhtbEljdS5yb290Tm9kZXMubGVuZ3RoID09IDAgP1xuICAgICAgICAgICAgW10gOiBbXS5jb25jYXQuYXBwbHkoW10sIF9fc3ByZWFkKHZpc2l0QWxsJDEodGhpcywgeG1sSWN1LnJvb3ROb2RlcykpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGkxOG5Ob2RlczogaTE4bk5vZGVzLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLl9lcnJvcnMsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiBuZXcgVGV4dCQxKHRleHQudmFsdWUsIHRleHQuc291cmNlU3Bhbik7IH07XG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGVsLm5hbWUgPT09IF9QTEFDRUhPTERFUl9UQUckMSkge1xuICAgICAgICAgICAgdmFyIG5hbWVBdHRyID0gZWwuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnaWQnOyB9KTtcbiAgICAgICAgICAgIGlmIChuYW1lQXR0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGxhY2Vob2xkZXIoJycsIG5hbWVBdHRyLnZhbHVlLCBlbC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBcIjxcIiArIF9QTEFDRUhPTERFUl9UQUckMSArIFwiPiBtaXNzZXMgdGhlIFxcXCJpZFxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLm5hbWUgPT09IF9NQVJLRVJfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBfX3NwcmVhZCh2aXNpdEFsbCQxKHRoaXMsIGVsLmNoaWxkcmVuKSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBcIlVuZXhwZWN0ZWQgdGFnXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjYXNlTWFwID0ge307XG4gICAgICAgIHZpc2l0QWxsJDEodGhpcywgaWN1LmNhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBjYXNlTWFwW2MudmFsdWVdID0gbmV3IENvbnRhaW5lcihjLm5vZGVzLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEljdSQxKGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGNhc2VNYXAsIGljdS5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBpY3VDYXNlLnZhbHVlLFxuICAgICAgICAgICAgbm9kZXM6IHZpc2l0QWxsJDEodGhpcywgaWN1Q2FzZS5leHByZXNzaW9uKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9O1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBYbWxUb0kxOG47XG59KCkpO1xuZnVuY3Rpb24gZ2V0Q3R5cGVGb3JUYWcodGFnKSB7XG4gICAgc3dpdGNoICh0YWcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgICByZXR1cm4gJ2xiJztcbiAgICAgICAgY2FzZSAnaW1nJzpcbiAgICAgICAgICAgIHJldHVybiAnaW1hZ2UnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwieC1cIiArIHRhZztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfVkVSU0lPTiQxID0gJzIuMCc7XG52YXIgX1hNTE5TJDEgPSAndXJuOm9hc2lzOm5hbWVzOnRjOnhsaWZmOmRvY3VtZW50OjIuMCc7XG4vLyBUT0RPKHZpY2IpOiBtYWtlIHRoaXMgYSBwYXJhbSAocy9fLy0vKVxudmFyIF9ERUZBVUxUX1NPVVJDRV9MQU5HJDEgPSAnZW4nO1xudmFyIF9QTEFDRUhPTERFUl9UQUckMiA9ICdwaCc7XG52YXIgX1BMQUNFSE9MREVSX1NQQU5OSU5HX1RBRyA9ICdwYyc7XG52YXIgX01BUktFUl9UQUckMSA9ICdtcmsnO1xudmFyIF9YTElGRl9UQUcgPSAneGxpZmYnO1xudmFyIF9TT1VSQ0VfVEFHJDIgPSAnc291cmNlJztcbnZhciBfVEFSR0VUX1RBRyQxID0gJ3RhcmdldCc7XG52YXIgX1VOSVRfVEFHJDEgPSAndW5pdCc7XG4vLyBodHRwOi8vZG9jcy5vYXNpcy1vcGVuLm9yZy94bGlmZi94bGlmZi1jb3JlL3YyLjAvb3MveGxpZmYtY29yZS12Mi4wLW9zLmh0bWxcbnZhciBYbGlmZjIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFhsaWZmMiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBYbGlmZjIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgWGxpZmYyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgbG9jYWxlKSB7XG4gICAgICAgIHZhciB2aXNpdG9yID0gbmV3IF9Xcml0ZVZpc2l0b3IkMSgpO1xuICAgICAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIHVuaXQgPSBuZXcgVGFnKF9VTklUX1RBRyQxLCB7IGlkOiBtZXNzYWdlLmlkIH0pO1xuICAgICAgICAgICAgdmFyIG5vdGVzID0gbmV3IFRhZygnbm90ZXMnKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlc2NyaXB0aW9uIHx8IG1lc3NhZ2UubWVhbmluZykge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGVzLmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBjYXRlZ29yeTogJ2Rlc2NyaXB0aW9uJyB9LCBbbmV3IFRleHQkMihtZXNzYWdlLmRlc2NyaXB0aW9uKV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWVhbmluZykge1xuICAgICAgICAgICAgICAgICAgICBub3Rlcy5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZygnbm90ZScsIHsgY2F0ZWdvcnk6ICdtZWFuaW5nJyB9LCBbbmV3IFRleHQkMihtZXNzYWdlLm1lYW5pbmcpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2Uuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBub3Rlcy5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZygnbm90ZScsIHsgY2F0ZWdvcnk6ICdsb2NhdGlvbicgfSwgW1xuICAgICAgICAgICAgICAgICAgICBuZXcgVGV4dCQyKHNvdXJjZS5maWxlUGF0aCArIFwiOlwiICsgc291cmNlLnN0YXJ0TGluZSArIChzb3VyY2UuZW5kTGluZSAhPT0gc291cmNlLnN0YXJ0TGluZSA/ICcsJyArIHNvdXJjZS5lbmRMaW5lIDogJycpKVxuICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbm90ZXMuY2hpbGRyZW4ucHVzaChuZXcgQ1IoNikpO1xuICAgICAgICAgICAgdW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig2KSwgbm90ZXMpO1xuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBuZXcgVGFnKCdzZWdtZW50Jyk7XG4gICAgICAgICAgICBzZWdtZW50LmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKF9TT1VSQ0VfVEFHJDIsIHt9LCB2aXNpdG9yLnNlcmlhbGl6ZShtZXNzYWdlLm5vZGVzKSksIG5ldyBDUig2KSk7XG4gICAgICAgICAgICB1bml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDYpLCBzZWdtZW50LCBuZXcgQ1IoNCkpO1xuICAgICAgICAgICAgdW5pdHMucHVzaChuZXcgQ1IoNCksIHVuaXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGZpbGUgPSBuZXcgVGFnKCdmaWxlJywgeyAnb3JpZ2luYWwnOiAnbmcudGVtcGxhdGUnLCBpZDogJ25naTE4bicgfSwgX19zcHJlYWQodW5pdHMsIFtuZXcgQ1IoMildKSk7XG4gICAgICAgIHZhciB4bGlmZiA9IG5ldyBUYWcoX1hMSUZGX1RBRywgeyB2ZXJzaW9uOiBfVkVSU0lPTiQxLCB4bWxuczogX1hNTE5TJDEsIHNyY0xhbmc6IGxvY2FsZSB8fCBfREVGQVVMVF9TT1VSQ0VfTEFORyQxIH0sIFtuZXcgQ1IoMiksIGZpbGUsIG5ldyBDUigpXSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemUoW1xuICAgICAgICAgICAgbmV3IERlY2xhcmF0aW9uKHsgdmVyc2lvbjogJzEuMCcsIGVuY29kaW5nOiAnVVRGLTgnIH0pLCBuZXcgQ1IoKSwgeGxpZmYsIG5ldyBDUigpXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgWGxpZmYyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCkge1xuICAgICAgICAvLyB4bGlmZiB0byB4bWwgbm9kZXNcbiAgICAgICAgdmFyIHhsaWZmMlBhcnNlciA9IG5ldyBYbGlmZjJQYXJzZXIoKTtcbiAgICAgICAgdmFyIF9hID0geGxpZmYyUGFyc2VyLnBhcnNlKGNvbnRlbnQsIHVybCksIGxvY2FsZSA9IF9hLmxvY2FsZSwgbXNnSWRUb0h0bWwgPSBfYS5tc2dJZFRvSHRtbCwgZXJyb3JzID0gX2EuZXJyb3JzO1xuICAgICAgICAvLyB4bWwgbm9kZXMgdG8gaTE4biBub2Rlc1xuICAgICAgICB2YXIgaTE4bk5vZGVzQnlNc2dJZCA9IHt9O1xuICAgICAgICB2YXIgY29udmVydGVyID0gbmV3IFhtbFRvSTE4biQxKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKG1zZ0lkVG9IdG1sKS5mb3JFYWNoKGZ1bmN0aW9uIChtc2dJZCkge1xuICAgICAgICAgICAgdmFyIF9hID0gY29udmVydGVyLmNvbnZlcnQobXNnSWRUb0h0bWxbbXNnSWRdLCB1cmwpLCBpMThuTm9kZXMgPSBfYS5pMThuTm9kZXMsIGUgPSBfYS5lcnJvcnM7XG4gICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIF9fc3ByZWFkKGUpKTtcbiAgICAgICAgICAgIGkxOG5Ob2Rlc0J5TXNnSWRbbXNnSWRdID0gaTE4bk5vZGVzO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInhsaWZmMiBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxvY2FsZTogbG9jYWxlLCBpMThuTm9kZXNCeU1zZ0lkOiBpMThuTm9kZXNCeU1zZ0lkIH07XG4gICAgfTtcbiAgICBYbGlmZjIucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBkZWNpbWFsRGlnZXN0KG1lc3NhZ2UpOyB9O1xuICAgIHJldHVybiBYbGlmZjI7XG59KFNlcmlhbGl6ZXIpKTtcbnZhciBfV3JpdGVWaXNpdG9yJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX1dyaXRlVmlzaXRvcigpIHtcbiAgICB9XG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIFtuZXcgVGV4dCQyKHRleHQudmFsdWUpXTsgfTtcbiAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBfX3NwcmVhZChub2RlLnZpc2l0KF90aGlzKSkpOyB9KTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub2RlcyA9IFtuZXcgVGV4dCQyKFwie1wiICsgaWN1LmV4cHJlc3Npb25QbGFjZWhvbGRlciArIFwiLCBcIiArIGljdS50eXBlICsgXCIsIFwiKV07XG4gICAgICAgIE9iamVjdC5rZXlzKGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgbm9kZXMucHVzaC5hcHBseShub2RlcywgX19zcHJlYWQoW25ldyBUZXh0JDIoYyArIFwiIHtcIildLCBpY3UuY2FzZXNbY10udmlzaXQoX3RoaXMpLCBbbmV3IFRleHQkMihcIn0gXCIpXSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQyKFwifVwiKSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9O1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlRm9yVGFnKHBoLnRhZyk7XG4gICAgICAgIGlmIChwaC5pc1ZvaWQpIHtcbiAgICAgICAgICAgIHZhciB0YWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQyLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICh0aGlzLl9uZXh0UGxhY2Vob2xkZXJJZCsrKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGVxdWl2OiBwaC5zdGFydE5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBkaXNwOiBcIjxcIiArIHBoLnRhZyArIFwiLz5cIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFt0YWdQaF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhZ1BjID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfU1BBTk5JTkdfVEFHLCB7XG4gICAgICAgICAgICBpZDogKHRoaXMuX25leHRQbGFjZWhvbGRlcklkKyspLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBlcXVpdlN0YXJ0OiBwaC5zdGFydE5hbWUsXG4gICAgICAgICAgICBlcXVpdkVuZDogcGguY2xvc2VOYW1lLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGRpc3BTdGFydDogXCI8XCIgKyBwaC50YWcgKyBcIj5cIixcbiAgICAgICAgICAgIGRpc3BFbmQ6IFwiPC9cIiArIHBoLnRhZyArIFwiPlwiLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG5vZGVzID0gW10uY29uY2F0LmFwcGx5KFtdLCBfX3NwcmVhZChwaC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KSkpO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiB0YWdQYy5jaGlsZHJlbi5wdXNoKG5vZGUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhZ1BjLmNoaWxkcmVuLnB1c2gobmV3IFRleHQkMignJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGFnUGNdO1xuICAgIH07XG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgaWRTdHIgPSAodGhpcy5fbmV4dFBsYWNlaG9sZGVySWQrKykudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMiwge1xuICAgICAgICAgICAgICAgIGlkOiBpZFN0cixcbiAgICAgICAgICAgICAgICBlcXVpdjogcGgubmFtZSxcbiAgICAgICAgICAgICAgICBkaXNwOiBcInt7XCIgKyBwaC52YWx1ZSArIFwifX1cIixcbiAgICAgICAgICAgIH0pXTtcbiAgICB9O1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGNhc2VzID0gT2JqZWN0LmtleXMocGgudmFsdWUuY2FzZXMpLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlICsgJyB7Li4ufSc7IH0pLmpvaW4oJyAnKTtcbiAgICAgICAgdmFyIGlkU3RyID0gKHRoaXMuX25leHRQbGFjZWhvbGRlcklkKyspLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDIsIHsgaWQ6IGlkU3RyLCBlcXVpdjogcGgubmFtZSwgZGlzcDogXCJ7XCIgKyBwaC52YWx1ZS5leHByZXNzaW9uICsgXCIsIFwiICsgcGgudmFsdWUudHlwZSArIFwiLCBcIiArIGNhc2VzICsgXCJ9XCIgfSldO1xuICAgIH07XG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX25leHRQbGFjZWhvbGRlcklkID0gMDtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgX19zcHJlYWQobm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfSkpKTtcbiAgICB9O1xuICAgIHJldHVybiBfV3JpdGVWaXNpdG9yO1xufSgpKTtcbi8vIEV4dHJhY3QgbWVzc2FnZXMgYXMgeG1sIG5vZGVzIGZyb20gdGhlIHhsaWZmIGZpbGVcbnZhciBYbGlmZjJQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWGxpZmYyUGFyc2VyKCkge1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBudWxsO1xuICAgIH1cbiAgICBYbGlmZjJQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHhsaWZmLCB1cmwpIHtcbiAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWwgPSB7fTtcbiAgICAgICAgdmFyIHhtbCA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZSh4bGlmZiwgdXJsKTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sLmVycm9ycztcbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCB4bWwucm9vdE5vZGVzLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1zZ0lkVG9IdG1sOiB0aGlzLl9tc2dJZFRvSHRtbCxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBYbGlmZjJQYXJzZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIF9VTklUX1RBRyQxOlxuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXRNbFN0cmluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnaWQnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9VTklUX1RBRyQxICsgXCI+IG1pc3NlcyB0aGUgXFxcImlkXFxcIiBhdHRyaWJ1dGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBpZEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tc2dJZFRvSHRtbC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiRHVwbGljYXRlZCB0cmFuc2xhdGlvbnMgZm9yIG1zZyBcIiArIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0QWxsJDEodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3VuaXRNbFN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tc2dJZFRvSHRtbFtpZF0gPSB0aGlzLl91bml0TWxTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIk1lc3NhZ2UgXCIgKyBpZCArIFwiIG1pc3NlcyBhIHRyYW5zbGF0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfU09VUkNFX1RBRyQyOlxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBzb3VyY2UgbWVzc2FnZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfVEFSR0VUX1RBRyQxOlxuICAgICAgICAgICAgICAgIHZhciBpbm5lclRleHRTdGFydCA9IGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLmVuZC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyVGV4dEVuZCA9IGVsZW1lbnQuZW5kU291cmNlU3Bhbi5zdGFydC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBlbGVtZW50LnN0YXJ0U291cmNlU3Bhbi5zdGFydC5maWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyVGV4dCA9IGNvbnRlbnQuc2xpY2UoaW5uZXJUZXh0U3RhcnQsIGlubmVyVGV4dEVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gaW5uZXJUZXh0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfWExJRkZfVEFHOlxuICAgICAgICAgICAgICAgIHZhciBsb2NhbGVBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICd0cmdMYW5nJzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZUF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZlcnNpb25BdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICd2ZXJzaW9uJzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcnNpb25BdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gdmVyc2lvbkF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uICE9PSAnMi4wJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCJUaGUgWExJRkYgZmlsZSB2ZXJzaW9uIFwiICsgdmVyc2lvbiArIFwiIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggWExJRkYgMi4wIHNlcmlhbGl6ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBYbGlmZjJQYXJzZXIucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9O1xuICAgIFhsaWZmMlBhcnNlci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgfTtcbiAgICBYbGlmZjJQYXJzZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IH07XG4gICAgWGxpZmYyUGFyc2VyLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGNvbnRleHQpIHsgfTtcbiAgICBYbGlmZjJQYXJzZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7IH07XG4gICAgWGxpZmYyUGFyc2VyLnByb3RvdHlwZS5fYWRkRXJyb3IgPSBmdW5jdGlvbiAobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbWVzc2FnZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFhsaWZmMlBhcnNlcjtcbn0oKSk7XG4vLyBDb252ZXJ0IG1sIG5vZGVzICh4bGlmZiBzeW50YXgpIHRvIGkxOG4gbm9kZXNcbnZhciBYbWxUb0kxOG4kMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbWxUb0kxOG4oKSB7XG4gICAgfVxuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChtZXNzYWdlLCB1cmwpIHtcbiAgICAgICAgdmFyIHhtbEljdSA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZShtZXNzYWdlLCB1cmwsIHsgdG9rZW5pemVFeHBhbnNpb25Gb3JtczogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sSWN1LmVycm9ycztcbiAgICAgICAgdmFyIGkxOG5Ob2RlcyA9IHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwIHx8IHhtbEljdS5yb290Tm9kZXMubGVuZ3RoID09IDAgP1xuICAgICAgICAgICAgW10gOiBbXS5jb25jYXQuYXBwbHkoW10sIF9fc3ByZWFkKHZpc2l0QWxsJDEodGhpcywgeG1sSWN1LnJvb3ROb2RlcykpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGkxOG5Ob2RlczogaTE4bk5vZGVzLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLl9lcnJvcnMsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiBuZXcgVGV4dCQxKHRleHQudmFsdWUsIHRleHQuc291cmNlU3Bhbik7IH07XG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3dpdGNoIChlbC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIF9QTEFDRUhPTERFUl9UQUckMjpcbiAgICAgICAgICAgICAgICB2YXIgbmFtZUF0dHIgPSBlbC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdlcXVpdic7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lQXR0cikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBQbGFjZWhvbGRlcignJywgbmFtZUF0dHIudmFsdWUsIGVsLnNvdXJjZVNwYW4pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiPFwiICsgX1BMQUNFSE9MREVSX1RBRyQyICsgXCI+IG1pc3NlcyB0aGUgXFxcImVxdWl2XFxcIiBhdHRyaWJ1dGVcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9QTEFDRUhPTERFUl9TUEFOTklOR19UQUc6XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0QXR0ciA9IGVsLmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ2VxdWl2U3RhcnQnOyB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kQXR0ciA9IGVsLmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ2VxdWl2RW5kJzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGFydEF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiPFwiICsgX1BMQUNFSE9MREVSX1RBRyQyICsgXCI+IG1pc3NlcyB0aGUgXFxcImVxdWl2U3RhcnRcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWVuZEF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiPFwiICsgX1BMQUNFSE9MREVSX1RBRyQyICsgXCI+IG1pc3NlcyB0aGUgXFxcImVxdWl2RW5kXFxcIiBhdHRyaWJ1dGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRJZCA9IHN0YXJ0QXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZElkID0gZW5kQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2Rlcy5jb25jYXQuYXBwbHkobm9kZXMsIF9fc3ByZWFkKFtuZXcgUGxhY2Vob2xkZXIoJycsIHN0YXJ0SWQsIGVsLnNvdXJjZVNwYW4pXSwgZWwuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzLCBudWxsKTsgfSksIFtuZXcgUGxhY2Vob2xkZXIoJycsIGVuZElkLCBlbC5zb3VyY2VTcGFuKV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9NQVJLRVJfVEFHJDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgX19zcHJlYWQodmlzaXRBbGwkMSh0aGlzLCBlbC5jaGlsZHJlbikpKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiVW5leHBlY3RlZCB0YWdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgY2FzZU1hcCA9IHt9O1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgY2FzZU1hcFtjLnZhbHVlXSA9IG5ldyBDb250YWluZXIoYy5ub2RlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJY3UkMShpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBjYXNlTWFwLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChpY3VDYXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogaWN1Q2FzZS52YWx1ZSxcbiAgICAgICAgICAgIG5vZGVzOiBbXS5jb25jYXQuYXBwbHkoW10sIF9fc3ByZWFkKHZpc2l0QWxsJDEodGhpcywgaWN1Q2FzZS5leHByZXNzaW9uKSkpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyB9O1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IH07XG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS5fYWRkRXJyb3IgPSBmdW5jdGlvbiAobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbWVzc2FnZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFhtbFRvSTE4bjtcbn0oKSk7XG5mdW5jdGlvbiBnZXRUeXBlRm9yVGFnKHRhZykge1xuICAgIHN3aXRjaCAodGFnLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnYnInOlxuICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgcmV0dXJuICdmbXQnO1xuICAgICAgICBjYXNlICdpbWcnOlxuICAgICAgICAgICAgcmV0dXJuICdpbWFnZSc7XG4gICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgcmV0dXJuICdsaW5rJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9UUkFOU0xBVElPTlNfVEFHID0gJ3RyYW5zbGF0aW9uYnVuZGxlJztcbnZhciBfVFJBTlNMQVRJT05fVEFHID0gJ3RyYW5zbGF0aW9uJztcbnZhciBfUExBQ0VIT0xERVJfVEFHJDMgPSAncGgnO1xudmFyIFh0YiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWHRiLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFh0YigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBYdGIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCBsb2NhbGUpIHsgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCcpOyB9O1xuICAgIFh0Yi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwpIHtcbiAgICAgICAgLy8geHRiIHRvIHhtbCBub2Rlc1xuICAgICAgICB2YXIgeHRiUGFyc2VyID0gbmV3IFh0YlBhcnNlcigpO1xuICAgICAgICB2YXIgX2EgPSB4dGJQYXJzZXIucGFyc2UoY29udGVudCwgdXJsKSwgbG9jYWxlID0gX2EubG9jYWxlLCBtc2dJZFRvSHRtbCA9IF9hLm1zZ0lkVG9IdG1sLCBlcnJvcnMgPSBfYS5lcnJvcnM7XG4gICAgICAgIC8vIHhtbCBub2RlcyB0byBpMThuIG5vZGVzXG4gICAgICAgIHZhciBpMThuTm9kZXNCeU1zZ0lkID0ge307XG4gICAgICAgIHZhciBjb252ZXJ0ZXIgPSBuZXcgWG1sVG9JMThuJDIoKTtcbiAgICAgICAgLy8gQmVjYXVzZSB3ZSBzaG91bGQgYmUgYWJsZSB0byBsb2FkIHh0YiBmaWxlcyB0aGF0IHJlbHkgb24gZmVhdHVyZXMgbm90IHN1cHBvcnRlZCBieSBhbmd1bGFyLFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGRlbGF5IHRoZSBjb252ZXJzaW9uIG9mIGh0bWwgdG8gaTE4biBub2RlcyBzbyB0aGF0IG5vbiBhbmd1bGFyIG1lc3NhZ2VzIGFyZSBub3RcbiAgICAgICAgLy8gY29udmVydGVkXG4gICAgICAgIE9iamVjdC5rZXlzKG1zZ0lkVG9IdG1sKS5mb3JFYWNoKGZ1bmN0aW9uIChtc2dJZCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gY29udmVydGVyLmNvbnZlcnQobXNnSWRUb0h0bWxbbXNnSWRdLCB1cmwpLCBpMThuTm9kZXMgPSBfYS5pMThuTm9kZXMsIGVycm9ycyA9IF9hLmVycm9ycztcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4dGIgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkxOG5Ob2RlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjcmVhdGVMYXp5UHJvcGVydHkoaTE4bk5vZGVzQnlNc2dJZCwgbXNnSWQsIHZhbHVlRm4pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInh0YiBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxvY2FsZTogbG9jYWxlLCBpMThuTm9kZXNCeU1zZ0lkOiBpMThuTm9kZXNCeU1zZ0lkIH07XG4gICAgfTtcbiAgICBYdGIucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBkaWdlc3QkMShtZXNzYWdlKTsgfTtcbiAgICBYdGIucHJvdG90eXBlLmNyZWF0ZU5hbWVNYXBwZXIgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyKG1lc3NhZ2UsIHRvUHVibGljTmFtZSk7XG4gICAgfTtcbiAgICByZXR1cm4gWHRiO1xufShTZXJpYWxpemVyKSk7XG5mdW5jdGlvbiBjcmVhdGVMYXp5UHJvcGVydHkobWVzc2FnZXMsIGlkLCB2YWx1ZUZuKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lc3NhZ2VzLCBpZCwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVGbigpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lc3NhZ2VzLCBpZCwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF8pIHsgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3Qgb3ZlcndyaXRlIGFuIFhUQiB0cmFuc2xhdGlvbicpOyB9LFxuICAgIH0pO1xufVxuLy8gRXh0cmFjdCBtZXNzYWdlcyBhcyB4bWwgbm9kZXMgZnJvbSB0aGUgeHRiIGZpbGVcbnZhciBYdGJQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWHRiUGFyc2VyKCkge1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBudWxsO1xuICAgIH1cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHh0YiwgdXJsKSB7XG4gICAgICAgIHRoaXMuX2J1bmRsZURlcHRoID0gMDtcbiAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWwgPSB7fTtcbiAgICAgICAgLy8gV2UgY2FuIG5vdCBwYXJzZSB0aGUgSUNVIG1lc3NhZ2VzIGF0IHRoaXMgcG9pbnQgYXMgc29tZSBtZXNzYWdlcyBtaWdodCBub3Qgb3JpZ2luYXRlXG4gICAgICAgIC8vIGZyb20gQW5ndWxhciB0aGF0IGNvdWxkIG5vdCBiZSBsZXgnZC5cbiAgICAgICAgdmFyIHhtbCA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZSh4dGIsIHVybCk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IHhtbC5lcnJvcnM7XG4gICAgICAgIHZpc2l0QWxsJDEodGhpcywgeG1sLnJvb3ROb2Rlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtc2dJZFRvSHRtbDogdGhpcy5fbXNnSWRUb0h0bWwsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgWHRiUGFyc2VyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBfVFJBTlNMQVRJT05TX1RBRzpcbiAgICAgICAgICAgICAgICB0aGlzLl9idW5kbGVEZXB0aCsrO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9idW5kbGVEZXB0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCI8XCIgKyBfVFJBTlNMQVRJT05TX1RBRyArIFwiPiBlbGVtZW50cyBjYW4gbm90IGJlIG5lc3RlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxhbmdBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdsYW5nJzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmdBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IGxhbmdBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1bmRsZURlcHRoLS07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9UUkFOU0xBVElPTl9UQUc6XG4gICAgICAgICAgICAgICAgdmFyIGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnaWQnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9UUkFOU0xBVElPTl9UQUcgKyBcIj4gbWlzc2VzIHRoZSBcXFwiaWRcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGlkQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21zZ0lkVG9IdG1sLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCJEdXBsaWNhdGVkIHRyYW5zbGF0aW9ucyBmb3IgbXNnIFwiICsgaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyVGV4dFN0YXJ0ID0gZWxlbWVudC5zdGFydFNvdXJjZVNwYW4uZW5kLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbm5lclRleHRFbmQgPSBlbGVtZW50LmVuZFNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBlbGVtZW50LnN0YXJ0U291cmNlU3Bhbi5zdGFydC5maWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5uZXJUZXh0ID0gY29udGVudC5zbGljZShpbm5lclRleHRTdGFydCwgaW5uZXJUZXh0RW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21zZ0lkVG9IdG1sW2lkXSA9IGlubmVyVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgJ1VuZXhwZWN0ZWQgdGFnJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IH07XG4gICAgWHRiUGFyc2VyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyB9O1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyB9O1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHsgfTtcbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtZXNzYWdlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gWHRiUGFyc2VyO1xufSgpKTtcbi8vIENvbnZlcnQgbWwgbm9kZXMgKHh0YiBzeW50YXgpIHRvIGkxOG4gbm9kZXNcbnZhciBYbWxUb0kxOG4kMiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbWxUb0kxOG4oKSB7XG4gICAgfVxuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChtZXNzYWdlLCB1cmwpIHtcbiAgICAgICAgdmFyIHhtbEljdSA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZShtZXNzYWdlLCB1cmwsIHsgdG9rZW5pemVFeHBhbnNpb25Gb3JtczogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sSWN1LmVycm9ycztcbiAgICAgICAgdmFyIGkxOG5Ob2RlcyA9IHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwIHx8IHhtbEljdS5yb290Tm9kZXMubGVuZ3RoID09IDAgP1xuICAgICAgICAgICAgW10gOlxuICAgICAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCB4bWxJY3Uucm9vdE5vZGVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGkxOG5Ob2RlczogaTE4bk5vZGVzLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLl9lcnJvcnMsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiBuZXcgVGV4dCQxKHRleHQudmFsdWUsIHRleHQuc291cmNlU3Bhbik7IH07XG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGNhc2VNYXAgPSB7fTtcbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCBpY3UuY2FzZXMpLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGNhc2VNYXBbYy52YWx1ZV0gPSBuZXcgQ29udGFpbmVyKGMubm9kZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSWN1JDEoaWN1LnN3aXRjaFZhbHVlLCBpY3UudHlwZSwgY2FzZU1hcCwgaWN1LnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoaWN1Q2FzZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGljdUNhc2UudmFsdWUsXG4gICAgICAgICAgICBub2RlczogdmlzaXRBbGwkMSh0aGlzLCBpY3VDYXNlLmV4cHJlc3Npb24pLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGVsLm5hbWUgPT09IF9QTEFDRUhPTERFUl9UQUckMykge1xuICAgICAgICAgICAgdmFyIG5hbWVBdHRyID0gZWwuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnbmFtZSc7IH0pO1xuICAgICAgICAgICAgaWYgKG5hbWVBdHRyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQbGFjZWhvbGRlcignJywgbmFtZUF0dHIudmFsdWUsIGVsLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiPFwiICsgX1BMQUNFSE9MREVSX1RBRyQzICsgXCI+IG1pc3NlcyB0aGUgXFxcIm5hbWVcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBcIlVuZXhwZWN0ZWQgdGFnXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyB9O1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IH07XG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS5fYWRkRXJyb3IgPSBmdW5jdGlvbiAobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbWVzc2FnZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFhtbFRvSTE4bjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSBjb250YWluZXIgZm9yIHRyYW5zbGF0ZWQgbWVzc2FnZXNcbiAqL1xudmFyIFRyYW5zbGF0aW9uQnVuZGxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zbGF0aW9uQnVuZGxlKF9pMThuTm9kZXNCeU1zZ0lkLCBsb2NhbGUsIGRpZ2VzdCwgbWFwcGVyRmFjdG9yeSwgbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3ksIGNvbnNvbGUpIHtcbiAgICAgICAgaWYgKF9pMThuTm9kZXNCeU1zZ0lkID09PSB2b2lkIDApIHsgX2kxOG5Ob2Rlc0J5TXNnSWQgPSB7fTsgfVxuICAgICAgICBpZiAobWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPT09IHZvaWQgMCkgeyBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5Lldhcm5pbmc7IH1cbiAgICAgICAgdGhpcy5faTE4bk5vZGVzQnlNc2dJZCA9IF9pMThuTm9kZXNCeU1zZ0lkO1xuICAgICAgICB0aGlzLmRpZ2VzdCA9IGRpZ2VzdDtcbiAgICAgICAgdGhpcy5tYXBwZXJGYWN0b3J5ID0gbWFwcGVyRmFjdG9yeTtcbiAgICAgICAgdGhpcy5faTE4blRvSHRtbCA9IG5ldyBJMThuVG9IdG1sVmlzaXRvcihfaTE4bk5vZGVzQnlNc2dJZCwgbG9jYWxlLCBkaWdlc3QsIG1hcHBlckZhY3RvcnksIG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LCBjb25zb2xlKTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlcyBhIGBUcmFuc2xhdGlvbkJ1bmRsZWAgYnkgcGFyc2luZyB0aGUgZ2l2ZW4gYGNvbnRlbnRgIHdpdGggdGhlIGBzZXJpYWxpemVyYC5cbiAgICBUcmFuc2xhdGlvbkJ1bmRsZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCwgc2VyaWFsaXplciwgbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3ksIGNvbnNvbGUpIHtcbiAgICAgICAgdmFyIF9hID0gc2VyaWFsaXplci5sb2FkKGNvbnRlbnQsIHVybCksIGxvY2FsZSA9IF9hLmxvY2FsZSwgaTE4bk5vZGVzQnlNc2dJZCA9IF9hLmkxOG5Ob2Rlc0J5TXNnSWQ7XG4gICAgICAgIHZhciBkaWdlc3RGbiA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBzZXJpYWxpemVyLmRpZ2VzdChtKTsgfTtcbiAgICAgICAgdmFyIG1hcHBlckZhY3RvcnkgPSBmdW5jdGlvbiAobSkgeyByZXR1cm4gc2VyaWFsaXplci5jcmVhdGVOYW1lTWFwcGVyKG0pOyB9O1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zbGF0aW9uQnVuZGxlKGkxOG5Ob2Rlc0J5TXNnSWQsIGxvY2FsZSwgZGlnZXN0Rm4sIG1hcHBlckZhY3RvcnksIG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LCBjb25zb2xlKTtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIGFzIEhUTUwgbm9kZXMgZnJvbSB0aGUgZ2l2ZW4gc291cmNlIG1lc3NhZ2UuXG4gICAgVHJhbnNsYXRpb25CdW5kbGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChzcmNNc2cpIHtcbiAgICAgICAgdmFyIGh0bWwgPSB0aGlzLl9pMThuVG9IdG1sLmNvbnZlcnQoc3JjTXNnKTtcbiAgICAgICAgaWYgKGh0bWwuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGh0bWwuZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbC5ub2RlcztcbiAgICB9O1xuICAgIFRyYW5zbGF0aW9uQnVuZGxlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoc3JjTXNnKSB7IHJldHVybiB0aGlzLmRpZ2VzdChzcmNNc2cpIGluIHRoaXMuX2kxOG5Ob2Rlc0J5TXNnSWQ7IH07XG4gICAgcmV0dXJuIFRyYW5zbGF0aW9uQnVuZGxlO1xufSgpKTtcbnZhciBJMThuVG9IdG1sVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJMThuVG9IdG1sVmlzaXRvcihfaTE4bk5vZGVzQnlNc2dJZCwgX2xvY2FsZSwgX2RpZ2VzdCwgX21hcHBlckZhY3RvcnksIF9taXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgX2NvbnNvbGUpIHtcbiAgICAgICAgaWYgKF9pMThuTm9kZXNCeU1zZ0lkID09PSB2b2lkIDApIHsgX2kxOG5Ob2Rlc0J5TXNnSWQgPSB7fTsgfVxuICAgICAgICB0aGlzLl9pMThuTm9kZXNCeU1zZ0lkID0gX2kxOG5Ob2Rlc0J5TXNnSWQ7XG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IF9sb2NhbGU7XG4gICAgICAgIHRoaXMuX2RpZ2VzdCA9IF9kaWdlc3Q7XG4gICAgICAgIHRoaXMuX21hcHBlckZhY3RvcnkgPSBfbWFwcGVyRmFjdG9yeTtcbiAgICAgICAgdGhpcy5fbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPSBfbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3k7XG4gICAgICAgIHRoaXMuX2NvbnNvbGUgPSBfY29uc29sZTtcbiAgICAgICAgdGhpcy5fY29udGV4dFN0YWNrID0gW107XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgIH1cbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChzcmNNc2cpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dFN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5sZW5ndGggPSAwO1xuICAgICAgICAvLyBpMThuIHRvIHRleHRcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLl9jb252ZXJ0VG9UZXh0KHNyY01zZyk7XG4gICAgICAgIC8vIHRleHQgdG8gaHRtbFxuICAgICAgICB2YXIgdXJsID0gc3JjTXNnLm5vZGVzWzBdLnNvdXJjZVNwYW4uc3RhcnQuZmlsZS51cmw7XG4gICAgICAgIHZhciBodG1sID0gbmV3IEh0bWxQYXJzZXIoKS5wYXJzZSh0ZXh0LCB1cmwsIHsgdG9rZW5pemVFeHBhbnNpb25Gb3JtczogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGVzOiBodG1sLnJvb3ROb2RlcyxcbiAgICAgICAgICAgIGVycm9yczogX19zcHJlYWQodGhpcy5fZXJyb3JzLCBodG1sLmVycm9ycyksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gYGNvbnZlcnQoKWAgdXNlcyBhbiBgSHRtbFBhcnNlcmAgdG8gcmV0dXJuIGBodG1sLk5vZGVgc1xuICAgICAgICAvLyB3ZSBzaG91bGQgdGhlbiBtYWtlIHN1cmUgdGhhdCBhbnkgc3BlY2lhbCBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkXG4gICAgICAgIHJldHVybiBlc2NhcGVYbWwodGV4dC52YWx1ZSk7XG4gICAgfTtcbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnZpc2l0KF90aGlzKTsgfSkuam9pbignJyk7XG4gICAgfTtcbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjYXNlcyA9IE9iamVjdC5rZXlzKGljdS5jYXNlcykubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBrICsgXCIge1wiICsgaWN1LmNhc2VzW2tdLnZpc2l0KF90aGlzKSArIFwifVwiOyB9KTtcbiAgICAgICAgLy8gVE9ETyh2aWNiKTogT25jZSBhbGwgZm9ybWF0IHN3aXRjaCB0byB1c2luZyBleHByZXNzaW9uIHBsYWNlaG9sZGVyc1xuICAgICAgICAvLyB3ZSBzaG91bGQgdGhyb3cgd2hlbiB0aGUgcGxhY2Vob2xkZXIgaXMgbm90IGluIHRoZSBzb3VyY2UgbWVzc2FnZVxuICAgICAgICB2YXIgZXhwID0gdGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVycy5oYXNPd25Qcm9wZXJ0eShpY3UuZXhwcmVzc2lvbikgP1xuICAgICAgICAgICAgdGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVyc1tpY3UuZXhwcmVzc2lvbl0gOlxuICAgICAgICAgICAgaWN1LmV4cHJlc3Npb247XG4gICAgICAgIHJldHVybiBcIntcIiArIGV4cCArIFwiLCBcIiArIGljdS50eXBlICsgXCIsIFwiICsgY2FzZXMuam9pbignICcpICsgXCJ9XCI7XG4gICAgfTtcbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgcGhOYW1lID0gdGhpcy5fbWFwcGVyKHBoLm5hbWUpO1xuICAgICAgICBpZiAodGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVycy5oYXNPd25Qcm9wZXJ0eShwaE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVyc1twaE5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJUb01lc3NhZ2UuaGFzT3duUHJvcGVydHkocGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRUb1RleHQodGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVyVG9NZXNzYWdlW3BoTmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZEVycm9yKHBoLCBcIlVua25vd24gcGxhY2Vob2xkZXIgXFxcIlwiICsgcGgubmFtZSArIFwiXFxcIlwiKTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH07XG4gICAgLy8gTG9hZGVkIG1lc3NhZ2UgY29udGFpbnMgb25seSBwbGFjZWhvbGRlcnMgKHZzIHRhZyBhbmQgaWN1IHBsYWNlaG9sZGVycykuXG4gICAgLy8gSG93ZXZlciB3aGVuIGEgdHJhbnNsYXRpb24gY2FuIG5vdCBiZSBmb3VuZCwgd2UgbmVlZCB0byBzZXJpYWxpemUgdGhlIHNvdXJjZSBtZXNzYWdlXG4gICAgLy8gd2hpY2ggY2FuIGNvbnRhaW4gdGFnIHBsYWNlaG9sZGVyc1xuICAgIEkxOG5Ub0h0bWxWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0YWcgPSBcIlwiICsgcGgudGFnO1xuICAgICAgICB2YXIgYXR0cnMgPSBPYmplY3Qua2V5cyhwaC5hdHRycykubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuYW1lICsgXCI9XFxcIlwiICsgcGguYXR0cnNbbmFtZV0gKyBcIlxcXCJcIjsgfSkuam9pbignICcpO1xuICAgICAgICBpZiAocGguaXNWb2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCI8XCIgKyB0YWcgKyBcIiBcIiArIGF0dHJzICsgXCIvPlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHBoLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy52aXNpdChfdGhpcyk7IH0pLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4gXCI8XCIgKyB0YWcgKyBcIiBcIiArIGF0dHJzICsgXCI+XCIgKyBjaGlsZHJlbiArIFwiPC9cIiArIHRhZyArIFwiPlwiO1xuICAgIH07XG4gICAgLy8gTG9hZGVkIG1lc3NhZ2UgY29udGFpbnMgb25seSBwbGFjZWhvbGRlcnMgKHZzIHRhZyBhbmQgaWN1IHBsYWNlaG9sZGVycykuXG4gICAgLy8gSG93ZXZlciB3aGVuIGEgdHJhbnNsYXRpb24gY2FuIG5vdCBiZSBmb3VuZCwgd2UgbmVlZCB0byBzZXJpYWxpemUgdGhlIHNvdXJjZSBtZXNzYWdlXG4gICAgLy8gd2hpY2ggY2FuIGNvbnRhaW4gdGFnIHBsYWNlaG9sZGVyc1xuICAgIEkxOG5Ub0h0bWxWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIEFuIElDVSBwbGFjZWhvbGRlciByZWZlcmVuY2VzIHRoZSBzb3VyY2UgbWVzc2FnZSB0byBiZSBzZXJpYWxpemVkXG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0VG9UZXh0KHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlclRvTWVzc2FnZVtwaC5uYW1lXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgc291cmNlIG1lc3NhZ2UgdG8gYSB0cmFuc2xhdGVkIHRleHQgc3RyaW5nOlxuICAgICAqIC0gdGV4dCBub2RlcyBhcmUgcmVwbGFjZWQgd2l0aCB0aGVpciB0cmFuc2xhdGlvbixcbiAgICAgKiAtIHBsYWNlaG9sZGVycyBhcmUgcmVwbGFjZWQgd2l0aCB0aGVpciBjb250ZW50LFxuICAgICAqIC0gSUNVIG5vZGVzIGFyZSBjb252ZXJ0ZWQgdG8gSUNVIGV4cHJlc3Npb25zLlxuICAgICAqL1xuICAgIEkxOG5Ub0h0bWxWaXNpdG9yLnByb3RvdHlwZS5fY29udmVydFRvVGV4dCA9IGZ1bmN0aW9uIChzcmNNc2cpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGlkID0gdGhpcy5fZGlnZXN0KHNyY01zZyk7XG4gICAgICAgIHZhciBtYXBwZXIgPSB0aGlzLl9tYXBwZXJGYWN0b3J5ID8gdGhpcy5fbWFwcGVyRmFjdG9yeShzcmNNc2cpIDogbnVsbDtcbiAgICAgICAgdmFyIG5vZGVzO1xuICAgICAgICB0aGlzLl9jb250ZXh0U3RhY2sucHVzaCh7IG1zZzogdGhpcy5fc3JjTXNnLCBtYXBwZXI6IHRoaXMuX21hcHBlciB9KTtcbiAgICAgICAgdGhpcy5fc3JjTXNnID0gc3JjTXNnO1xuICAgICAgICBpZiAodGhpcy5faTE4bk5vZGVzQnlNc2dJZC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlcmUgaXMgYSB0cmFuc2xhdGlvbiB1c2UgaXRzIG5vZGVzIGFzIHRoZSBzb3VyY2VcbiAgICAgICAgICAgIC8vIEFuZCBjcmVhdGUgYSBtYXBwZXIgdG8gY29udmVydCBzZXJpYWxpemVkIHBsYWNlaG9sZGVyIG5hbWVzIHRvIGludGVybmFsIG5hbWVzXG4gICAgICAgICAgICBub2RlcyA9IHRoaXMuX2kxOG5Ob2Rlc0J5TXNnSWRbaWRdO1xuICAgICAgICAgICAgdGhpcy5fbWFwcGVyID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hcHBlciA/IG1hcHBlci50b0ludGVybmFsTmFtZShuYW1lKSA6IG5hbWU7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXaGVuIG5vIHRyYW5zbGF0aW9uIGhhcyBiZWVuIGZvdW5kXG4gICAgICAgICAgICAvLyAtIHJlcG9ydCBhbiBlcnJvciAvIGEgd2FybmluZyAvIG5vdGhpbmcsXG4gICAgICAgICAgICAvLyAtIHVzZSB0aGUgbm9kZXMgZnJvbSB0aGUgb3JpZ2luYWwgbWVzc2FnZVxuICAgICAgICAgICAgLy8gLSBwbGFjZWhvbGRlcnMgYXJlIGFscmVhZHkgaW50ZXJuYWwgYW5kIG5lZWQgbm8gbWFwcGVyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPT09IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LkVycm9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2xvY2FsZSA/IFwiIGZvciBsb2NhbGUgXFxcIlwiICsgdGhpcy5fbG9jYWxlICsgXCJcXFwiXCIgOiAnJztcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihzcmNNc2cubm9kZXNbMF0sIFwiTWlzc2luZyB0cmFuc2xhdGlvbiBmb3IgbWVzc2FnZSBcXFwiXCIgKyBpZCArIFwiXFxcIlwiICsgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2NvbnNvbGUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9taXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9PT0gTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kuV2FybmluZykge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9sb2NhbGUgPyBcIiBmb3IgbG9jYWxlIFxcXCJcIiArIHRoaXMuX2xvY2FsZSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZS53YXJuKFwiTWlzc2luZyB0cmFuc2xhdGlvbiBmb3IgbWVzc2FnZSBcXFwiXCIgKyBpZCArIFwiXFxcIlwiICsgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzID0gc3JjTXNnLm5vZGVzO1xuICAgICAgICAgICAgdGhpcy5fbWFwcGVyID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWU7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHQgPSBub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KS5qb2luKCcnKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9jb250ZXh0U3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMuX3NyY01zZyA9IGNvbnRleHQubXNnO1xuICAgICAgICB0aGlzLl9tYXBwZXIgPSBjb250ZXh0Lm1hcHBlcjtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKGVsLCBtc2cpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihlbC5zb3VyY2VTcGFuLCBtc2cpKTtcbiAgICB9O1xuICAgIHJldHVybiBJMThuVG9IdG1sVmlzaXRvcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBJMThOSHRtbFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJMThOSHRtbFBhcnNlcihfaHRtbFBhcnNlciwgdHJhbnNsYXRpb25zLCB0cmFuc2xhdGlvbnNGb3JtYXQsIG1pc3NpbmdUcmFuc2xhdGlvbiwgY29uc29sZSkge1xuICAgICAgICBpZiAobWlzc2luZ1RyYW5zbGF0aW9uID09PSB2b2lkIDApIHsgbWlzc2luZ1RyYW5zbGF0aW9uID0gTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kuV2FybmluZzsgfVxuICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgIGlmICh0cmFuc2xhdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVyID0gY3JlYXRlU2VyaWFsaXplcih0cmFuc2xhdGlvbnNGb3JtYXQpO1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25CdW5kbGUgPVxuICAgICAgICAgICAgICAgIFRyYW5zbGF0aW9uQnVuZGxlLmxvYWQodHJhbnNsYXRpb25zLCAnaTE4bicsIHNlcmlhbGl6ZXIsIG1pc3NpbmdUcmFuc2xhdGlvbiwgY29uc29sZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbkJ1bmRsZSA9XG4gICAgICAgICAgICAgICAgbmV3IFRyYW5zbGF0aW9uQnVuZGxlKHt9LCBudWxsLCBkaWdlc3QsIHVuZGVmaW5lZCwgbWlzc2luZ1RyYW5zbGF0aW9uLCBjb25zb2xlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBJMThOSHRtbFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCB1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIGludGVycG9sYXRpb25Db25maWcgPSBvcHRpb25zLmludGVycG9sYXRpb25Db25maWcgfHwgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRztcbiAgICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gdGhpcy5faHRtbFBhcnNlci5wYXJzZShzb3VyY2UsIHVybCwgX19hc3NpZ24oeyBpbnRlcnBvbGF0aW9uQ29uZmlnOiBpbnRlcnBvbGF0aW9uQ29uZmlnIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgaWYgKHBhcnNlUmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHBhcnNlUmVzdWx0LnJvb3ROb2RlcywgcGFyc2VSZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VUcmFuc2xhdGlvbnMocGFyc2VSZXN1bHQucm9vdE5vZGVzLCB0aGlzLl90cmFuc2xhdGlvbkJ1bmRsZSwgaW50ZXJwb2xhdGlvbkNvbmZpZywgW10sIHt9KTtcbiAgICB9O1xuICAgIHJldHVybiBJMThOSHRtbFBhcnNlcjtcbn0oKSk7XG5mdW5jdGlvbiBjcmVhdGVTZXJpYWxpemVyKGZvcm1hdCkge1xuICAgIGZvcm1hdCA9IChmb3JtYXQgfHwgJ3hsZicpLnRvTG93ZXJDYXNlKCk7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgY2FzZSAneG1iJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgWG1iKCk7XG4gICAgICAgIGNhc2UgJ3h0Yic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFh0YigpO1xuICAgICAgICBjYXNlICd4bGlmZjInOlxuICAgICAgICBjYXNlICd4bGYyJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgWGxpZmYyKCk7XG4gICAgICAgIGNhc2UgJ3hsaWZmJzpcbiAgICAgICAgY2FzZSAneGxmJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgWGxpZmYoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBRVU9URURfS0VZUyA9ICckcXVvdGVkJCc7XG5mdW5jdGlvbiBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChjdHgsIHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgIHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCBuZXcgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIoY3R4KSwgdHlwZSk7XG59XG52YXIgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIoY3R4KSB7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIH1cbiAgICBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRBcnJheSA9IGZ1bmN0aW9uIChhcnIsIHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoYXJyLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZpc2l0VmFsdWUodmFsdWUsIF90aGlzLCBudWxsKTsgfSksIHR5cGUpO1xuICAgIH07XG4gICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwID0gZnVuY3Rpb24gKG1hcCwgdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICB2YXIgcXVvdGVkU2V0ID0gbmV3IFNldChtYXAgJiYgbWFwW1FVT1RFRF9LRVlTXSk7XG4gICAgICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2gobmV3IExpdGVyYWxNYXBFbnRyeShrZXksIHZpc2l0VmFsdWUobWFwW2tleV0sIF90aGlzLCBudWxsKSwgcXVvdGVkU2V0LmhhcyhrZXkpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXBFeHByKGVudHJpZXMsIHR5cGUpO1xuICAgIH07XG4gICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJpbWl0aXZlID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlKSB7IHJldHVybiBsaXRlcmFsKHZhbHVlLCB0eXBlKTsgfTtcbiAgICBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdHguaW1wb3J0RXhwcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIG1hcEVudHJ5JDEoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB7IGtleToga2V5LCB2YWx1ZTogdmFsdWUsIHF1b3RlZDogZmFsc2UgfTtcbn1cbnZhciBJbmplY3RhYmxlQ29tcGlsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5qZWN0YWJsZUNvbXBpbGVyKHJlZmxlY3RvciwgYWx3YXlzR2VuZXJhdGVEZWYpIHtcbiAgICAgICAgdGhpcy5yZWZsZWN0b3IgPSByZWZsZWN0b3I7XG4gICAgICAgIHRoaXMuYWx3YXlzR2VuZXJhdGVEZWYgPSBhbHdheXNHZW5lcmF0ZURlZjtcbiAgICAgICAgdGhpcy50b2tlbkluamVjdG9yID0gcmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShJZGVudGlmaWVycy5JbmplY3Rvcik7XG4gICAgfVxuICAgIEluamVjdGFibGVDb21waWxlci5wcm90b3R5cGUuZGVwc0FycmF5ID0gZnVuY3Rpb24gKGRlcHMsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gZGVwO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbdG9rZW5dO1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gMCAvKiBEZWZhdWx0ICovO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVwKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gZGVwW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYubmdNZXRhZGF0YU5hbWUgPT09ICdPcHRpb25hbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFncyB8PSA4IC8qIE9wdGlvbmFsICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodi5uZ01ldGFkYXRhTmFtZSA9PT0gJ1NraXBTZWxmJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzIHw9IDQgLyogU2tpcFNlbGYgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2Lm5nTWV0YWRhdGFOYW1lID09PSAnU2VsZicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFncyB8PSAyIC8qIFNlbGYgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2Lm5nTWV0YWRhdGFOYW1lID09PSAnSW5qZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdi50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b2tlbkV4cHI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRva2VuRXhwciA9IGxpdGVyYWwodG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IF90aGlzLnRva2VuSW5qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0b2tlbkV4cHIgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLklOSkVDVE9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRva2VuRXhwciA9IGN0eC5pbXBvcnRFeHByKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbGFncyAhPT0gMCAvKiBEZWZhdWx0ICovKSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IFt0b2tlbkV4cHIsIGxpdGVyYWwoZmxhZ3MpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBbdG9rZW5FeHByXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzLmluamVjdCkuY2FsbEZuKGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEluamVjdGFibGVDb21waWxlci5wcm90b3R5cGUuZmFjdG9yeUZvciA9IGZ1bmN0aW9uIChpbmplY3RhYmxlLCBjdHgpIHtcbiAgICAgICAgdmFyIHJldFZhbHVlO1xuICAgICAgICBpZiAoaW5qZWN0YWJsZS51c2VFeGlzdGluZykge1xuICAgICAgICAgICAgcmV0VmFsdWUgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLmluamVjdCkuY2FsbEZuKFtjdHguaW1wb3J0RXhwcihpbmplY3RhYmxlLnVzZUV4aXN0aW5nKV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluamVjdGFibGUudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgdmFyIGRlcHMgPSBpbmplY3RhYmxlLmRlcHMgfHwgW107XG4gICAgICAgICAgICBpZiAoZGVwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0VmFsdWUgPSBjdHguaW1wb3J0RXhwcihpbmplY3RhYmxlLnVzZUZhY3RvcnkpLmNhbGxGbih0aGlzLmRlcHNBcnJheShkZXBzLCBjdHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHguaW1wb3J0RXhwcihpbmplY3RhYmxlLnVzZUZhY3RvcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluamVjdGFibGUudXNlVmFsdWUpIHtcbiAgICAgICAgICAgIHJldFZhbHVlID0gY29udmVydFZhbHVlVG9PdXRwdXRBc3QoY3R4LCBpbmplY3RhYmxlLnVzZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjbGF6eiA9IGluamVjdGFibGUudXNlQ2xhc3MgfHwgaW5qZWN0YWJsZS5zeW1ib2w7XG4gICAgICAgICAgICB2YXIgZGVwQXJncyA9IHRoaXMuZGVwc0FycmF5KHRoaXMucmVmbGVjdG9yLnBhcmFtZXRlcnMoY2xhenopLCBjdHgpO1xuICAgICAgICAgICAgcmV0VmFsdWUgPSBuZXcgSW5zdGFudGlhdGVFeHByKGN0eC5pbXBvcnRFeHByKGNsYXp6KSwgZGVwQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuKFtdLCBbbmV3IFJldHVyblN0YXRlbWVudChyZXRWYWx1ZSldLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaW5qZWN0YWJsZS5zeW1ib2wubmFtZSArICdfRmFjdG9yeScpO1xuICAgIH07XG4gICAgSW5qZWN0YWJsZUNvbXBpbGVyLnByb3RvdHlwZS5pbmplY3RhYmxlRGVmID0gZnVuY3Rpb24gKGluamVjdGFibGUsIGN0eCkge1xuICAgICAgICB2YXIgcHJvdmlkZWRJbiA9IE5VTExfRVhQUjtcbiAgICAgICAgaWYgKGluamVjdGFibGUucHJvdmlkZWRJbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaW5qZWN0YWJsZS5wcm92aWRlZEluID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZWRJbiA9IE5VTExfRVhQUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbmplY3RhYmxlLnByb3ZpZGVkSW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZWRJbiA9IGxpdGVyYWwoaW5qZWN0YWJsZS5wcm92aWRlZEluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVkSW4gPSBjdHguaW1wb3J0RXhwcihpbmplY3RhYmxlLnByb3ZpZGVkSW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWYgPSBbXG4gICAgICAgICAgICBtYXBFbnRyeSQxKCdmYWN0b3J5JywgdGhpcy5mYWN0b3J5Rm9yKGluamVjdGFibGUsIGN0eCkpLFxuICAgICAgICAgICAgbWFwRW50cnkkMSgndG9rZW4nLCBjdHguaW1wb3J0RXhwcihpbmplY3RhYmxlLnR5cGUucmVmZXJlbmNlKSksXG4gICAgICAgICAgICBtYXBFbnRyeSQxKCdwcm92aWRlZEluJywgcHJvdmlkZWRJbiksXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzLsm1ybVkZWZpbmVJbmplY3RhYmxlKS5jYWxsRm4oW2xpdGVyYWxNYXAoZGVmKV0pO1xuICAgIH07XG4gICAgSW5qZWN0YWJsZUNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKGluamVjdGFibGUsIGN0eCkge1xuICAgICAgICBpZiAodGhpcy5hbHdheXNHZW5lcmF0ZURlZiB8fCBpbmplY3RhYmxlLnByb3ZpZGVkSW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGlkZW50aWZpZXJOYW1lKGluamVjdGFibGUudHlwZSk7XG4gICAgICAgICAgICB2YXIgY2xhenogPSBuZXcgQ2xhc3NTdG10KGNsYXNzTmFtZSwgbnVsbCwgW1xuICAgICAgICAgICAgICAgIG5ldyBDbGFzc0ZpZWxkKCduZ0luamVjdGFibGVEZWYnLCBJTkZFUlJFRF9UWVBFLCBbU3RtdE1vZGlmaWVyLlN0YXRpY10sIHRoaXMuaW5qZWN0YWJsZURlZihpbmplY3RhYmxlLCBjdHgpKSxcbiAgICAgICAgICAgIF0sIFtdLCBuZXcgQ2xhc3NNZXRob2QobnVsbCwgW10sIFtdKSwgW10pO1xuICAgICAgICAgICAgY3R4LnN0YXRlbWVudHMucHVzaChjbGF6eik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJbmplY3RhYmxlQ29tcGlsZXI7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgU1RSSVBfU1JDX0ZJTEVfU1VGRklYRVMgPSAvKFxcLnRzfFxcLmRcXC50c3xcXC5qc3xcXC5qc3h8XFwudHN4KSQvO1xudmFyIEdFTkVSQVRFRF9GSUxFID0gL1xcLm5nZmFjdG9yeVxcLnxcXC5uZ3N1bW1hcnlcXC4vO1xudmFyIEpJVF9TVU1NQVJZX0ZJTEUgPSAvXFwubmdzdW1tYXJ5XFwuLztcbnZhciBKSVRfU1VNTUFSWV9OQU1FID0gL05nU3VtbWFyeSQvO1xuZnVuY3Rpb24gbmdmYWN0b3J5RmlsZVBhdGgoZmlsZVBhdGgsIGZvcmNlU291cmNlRmlsZSkge1xuICAgIGlmIChmb3JjZVNvdXJjZUZpbGUgPT09IHZvaWQgMCkgeyBmb3JjZVNvdXJjZUZpbGUgPSBmYWxzZTsgfVxuICAgIHZhciB1cmxXaXRoU3VmZml4ID0gc3BsaXRUeXBlc2NyaXB0U3VmZml4KGZpbGVQYXRoLCBmb3JjZVNvdXJjZUZpbGUpO1xuICAgIHJldHVybiB1cmxXaXRoU3VmZml4WzBdICsgXCIubmdmYWN0b3J5XCIgKyBub3JtYWxpemVHZW5GaWxlU3VmZml4KHVybFdpdGhTdWZmaXhbMV0pO1xufVxuZnVuY3Rpb24gc3RyaXBHZW5lcmF0ZWRGaWxlU3VmZml4KGZpbGVQYXRoKSB7XG4gICAgcmV0dXJuIGZpbGVQYXRoLnJlcGxhY2UoR0VORVJBVEVEX0ZJTEUsICcuJyk7XG59XG5mdW5jdGlvbiBpc0dlbmVyYXRlZEZpbGUoZmlsZVBhdGgpIHtcbiAgICByZXR1cm4gR0VORVJBVEVEX0ZJTEUudGVzdChmaWxlUGF0aCk7XG59XG5mdW5jdGlvbiBzcGxpdFR5cGVzY3JpcHRTdWZmaXgocGF0aCwgZm9yY2VTb3VyY2VGaWxlKSB7XG4gICAgaWYgKGZvcmNlU291cmNlRmlsZSA9PT0gdm9pZCAwKSB7IGZvcmNlU291cmNlRmlsZSA9IGZhbHNlOyB9XG4gICAgaWYgKHBhdGguZW5kc1dpdGgoJy5kLnRzJykpIHtcbiAgICAgICAgcmV0dXJuIFtwYXRoLnNsaWNlKDAsIC01KSwgZm9yY2VTb3VyY2VGaWxlID8gJy50cycgOiAnLmQudHMnXTtcbiAgICB9XG4gICAgdmFyIGxhc3REb3QgPSBwYXRoLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGxhc3REb3QgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbcGF0aC5zdWJzdHJpbmcoMCwgbGFzdERvdCksIHBhdGguc3Vic3RyaW5nKGxhc3REb3QpXTtcbiAgICB9XG4gICAgcmV0dXJuIFtwYXRoLCAnJ107XG59XG5mdW5jdGlvbiBub3JtYWxpemVHZW5GaWxlU3VmZml4KHNyY0ZpbGVTdWZmaXgpIHtcbiAgICByZXR1cm4gc3JjRmlsZVN1ZmZpeCA9PT0gJy50c3gnID8gJy50cycgOiBzcmNGaWxlU3VmZml4O1xufVxuZnVuY3Rpb24gc3VtbWFyeUZpbGVOYW1lKGZpbGVOYW1lKSB7XG4gICAgdmFyIGZpbGVOYW1lV2l0aG91dFN1ZmZpeCA9IGZpbGVOYW1lLnJlcGxhY2UoU1RSSVBfU1JDX0ZJTEVfU1VGRklYRVMsICcnKTtcbiAgICByZXR1cm4gZmlsZU5hbWVXaXRob3V0U3VmZml4ICsgXCIubmdzdW1tYXJ5Lmpzb25cIjtcbn1cbmZ1bmN0aW9uIHN1bW1hcnlGb3JKaXRGaWxlTmFtZShmaWxlTmFtZSwgZm9yY2VTb3VyY2VGaWxlKSB7XG4gICAgaWYgKGZvcmNlU291cmNlRmlsZSA9PT0gdm9pZCAwKSB7IGZvcmNlU291cmNlRmlsZSA9IGZhbHNlOyB9XG4gICAgdmFyIHVybFdpdGhTdWZmaXggPSBzcGxpdFR5cGVzY3JpcHRTdWZmaXgoc3RyaXBHZW5lcmF0ZWRGaWxlU3VmZml4KGZpbGVOYW1lKSwgZm9yY2VTb3VyY2VGaWxlKTtcbiAgICByZXR1cm4gdXJsV2l0aFN1ZmZpeFswXSArIFwiLm5nc3VtbWFyeVwiICsgdXJsV2l0aFN1ZmZpeFsxXTtcbn1cbmZ1bmN0aW9uIHN0cmlwU3VtbWFyeUZvckppdEZpbGVTdWZmaXgoZmlsZVBhdGgpIHtcbiAgICByZXR1cm4gZmlsZVBhdGgucmVwbGFjZShKSVRfU1VNTUFSWV9GSUxFLCAnLicpO1xufVxuZnVuY3Rpb24gc3VtbWFyeUZvckppdE5hbWUoc3ltYm9sTmFtZSkge1xuICAgIHJldHVybiBzeW1ib2xOYW1lICsgXCJOZ1N1bW1hcnlcIjtcbn1cbmZ1bmN0aW9uIHN0cmlwU3VtbWFyeUZvckppdE5hbWVTdWZmaXgoc3ltYm9sTmFtZSkge1xuICAgIHJldHVybiBzeW1ib2xOYW1lLnJlcGxhY2UoSklUX1NVTU1BUllfTkFNRSwgJycpO1xufVxudmFyIExPV0VSRURfU1lNQk9MID0gL1xcdTAyNzVcXGQrLztcbmZ1bmN0aW9uIGlzTG93ZXJlZFN5bWJvbChuYW1lKSB7XG4gICAgcmV0dXJuIExPV0VSRURfU1lNQk9MLnRlc3QobmFtZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVMb3dlcmVkU3ltYm9sKGlkKSB7XG4gICAgcmV0dXJuIFwiXFx1MDI3NVwiICsgaWQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBMaWZlY3ljbGVIb29rcztcbihmdW5jdGlvbiAoTGlmZWN5Y2xlSG9va3MpIHtcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIk9uSW5pdFwiXSA9IDBdID0gXCJPbkluaXRcIjtcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIk9uRGVzdHJveVwiXSA9IDFdID0gXCJPbkRlc3Ryb3lcIjtcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkRvQ2hlY2tcIl0gPSAyXSA9IFwiRG9DaGVja1wiO1xuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiT25DaGFuZ2VzXCJdID0gM10gPSBcIk9uQ2hhbmdlc1wiO1xuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiQWZ0ZXJDb250ZW50SW5pdFwiXSA9IDRdID0gXCJBZnRlckNvbnRlbnRJbml0XCI7XG4gICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJBZnRlckNvbnRlbnRDaGVja2VkXCJdID0gNV0gPSBcIkFmdGVyQ29udGVudENoZWNrZWRcIjtcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkFmdGVyVmlld0luaXRcIl0gPSA2XSA9IFwiQWZ0ZXJWaWV3SW5pdFwiO1xuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiQWZ0ZXJWaWV3Q2hlY2tlZFwiXSA9IDddID0gXCJBZnRlclZpZXdDaGVja2VkXCI7XG59KShMaWZlY3ljbGVIb29rcyB8fCAoTGlmZWN5Y2xlSG9va3MgPSB7fSkpO1xudmFyIExJRkVDWUNMRV9IT09LU19WQUxVRVMgPSBbXG4gICAgTGlmZWN5Y2xlSG9va3MuT25Jbml0LCBMaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3ksIExpZmVjeWNsZUhvb2tzLkRvQ2hlY2ssIExpZmVjeWNsZUhvb2tzLk9uQ2hhbmdlcyxcbiAgICBMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRJbml0LCBMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkLCBMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdJbml0LFxuICAgIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0NoZWNrZWRcbl07XG5mdW5jdGlvbiBoYXNMaWZlY3ljbGVIb29rKHJlZmxlY3RvciwgaG9vaywgdG9rZW4pIHtcbiAgICByZXR1cm4gcmVmbGVjdG9yLmhhc0xpZmVjeWNsZUhvb2sodG9rZW4sIGdldEhvb2tOYW1lKGhvb2spKTtcbn1cbmZ1bmN0aW9uIGdldEFsbExpZmVjeWNsZUhvb2tzKHJlZmxlY3RvciwgdG9rZW4pIHtcbiAgICByZXR1cm4gTElGRUNZQ0xFX0hPT0tTX1ZBTFVFUy5maWx0ZXIoZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGhhc0xpZmVjeWNsZUhvb2socmVmbGVjdG9yLCBob29rLCB0b2tlbik7IH0pO1xufVxuZnVuY3Rpb24gZ2V0SG9va05hbWUoaG9vaykge1xuICAgIHN3aXRjaCAoaG9vaykge1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLk9uSW5pdDpcbiAgICAgICAgICAgIHJldHVybiAnbmdPbkluaXQnO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLk9uRGVzdHJveTpcbiAgICAgICAgICAgIHJldHVybiAnbmdPbkRlc3Ryb3knO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkRvQ2hlY2s6XG4gICAgICAgICAgICByZXR1cm4gJ25nRG9DaGVjayc7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuT25DaGFuZ2VzOlxuICAgICAgICAgICAgcmV0dXJuICduZ09uQ2hhbmdlcyc7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50SW5pdDpcbiAgICAgICAgICAgIHJldHVybiAnbmdBZnRlckNvbnRlbnRJbml0JztcbiAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkOlxuICAgICAgICAgICAgcmV0dXJuICduZ0FmdGVyQ29udGVudENoZWNrZWQnO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0luaXQ6XG4gICAgICAgICAgICByZXR1cm4gJ25nQWZ0ZXJWaWV3SW5pdCc7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZDpcbiAgICAgICAgICAgIHJldHVybiAnbmdBZnRlclZpZXdDaGVja2VkJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFRoaXMgZGVmYXVsdCBjYXNlIGlzIG5vdCBuZWVkZWQgYnkgVHlwZVNjcmlwdCBjb21waWxlciwgYXMgdGhlIHN3aXRjaCBpcyBleGhhdXN0aXZlLlxuICAgICAgICAgICAgLy8gSG93ZXZlciBDbG9zdXJlIENvbXBpbGVyIGRvZXMgbm90IHVuZGVyc3RhbmQgdGhhdCBhbmQgcmVwb3J0cyBhbiBlcnJvciBpbiB0eXBlZCBtb2RlLlxuICAgICAgICAgICAgLy8gVGhlIGB0aHJvdyBuZXcgRXJyb3JgIGJlbG93IHdvcmtzIGFyb3VuZCB0aGUgcHJvYmxlbSwgYW5kIHRoZSB1bmV4cGVjdGVkOiBuZXZlciB2YXJpYWJsZVxuICAgICAgICAgICAgLy8gbWFrZXMgc3VyZSB0c2Mgc3RpbGwgY2hlY2tzIHRoaXMgY29kZSBpcyB1bnJlYWNoYWJsZS5cbiAgICAgICAgICAgIHZhciB1bmV4cGVjdGVkID0gaG9vaztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgXCIgKyB1bmV4cGVjdGVkKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBFUlJPUl9DT01QT05FTlRfVFlQRSA9ICduZ0NvbXBvbmVudFR5cGUnO1xuLy8gRGVzaWduIG5vdGVzOlxuLy8gLSBkb24ndCBsYXppbHkgY3JlYXRlIG1ldGFkYXRhOlxuLy8gICBGb3Igc29tZSBtZXRhZGF0YSwgd2UgbmVlZCB0byBkbyBhc3luYyB3b3JrIHNvbWV0aW1lcyxcbi8vICAgc28gdGhlIHVzZXIgaGFzIHRvIGtpY2sgb2ZmIHRoaXMgbG9hZGluZy5cbi8vICAgQnV0IHdlIHdhbnQgdG8gcmVwb3J0IGVycm9ycyBldmVuIHdoZW4gdGhlIGFzeW5jIHdvcmsgaXNcbi8vICAgbm90IHJlcXVpcmVkIHRvIGNoZWNrIHRoYXQgdGhlIHVzZXIgd291bGQgaGF2ZSBiZWVuIGFibGVcbi8vICAgdG8gd2FpdCBjb3JyZWN0bHkuXG52YXIgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIoX2NvbmZpZywgX2h0bWxQYXJzZXIsIF9uZ01vZHVsZVJlc29sdmVyLCBfZGlyZWN0aXZlUmVzb2x2ZXIsIF9waXBlUmVzb2x2ZXIsIF9zdW1tYXJ5UmVzb2x2ZXIsIF9zY2hlbWFSZWdpc3RyeSwgX2RpcmVjdGl2ZU5vcm1hbGl6ZXIsIF9jb25zb2xlLCBfc3RhdGljU3ltYm9sQ2FjaGUsIF9yZWZsZWN0b3IsIF9lcnJvckNvbGxlY3Rvcikge1xuICAgICAgICB0aGlzLl9jb25maWcgPSBfY29uZmlnO1xuICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlUmVzb2x2ZXIgPSBfbmdNb2R1bGVSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlUmVzb2x2ZXIgPSBfZGlyZWN0aXZlUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3BpcGVSZXNvbHZlciA9IF9waXBlUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3N1bW1hcnlSZXNvbHZlciA9IF9zdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyID0gX2RpcmVjdGl2ZU5vcm1hbGl6ZXI7XG4gICAgICAgIHRoaXMuX2NvbnNvbGUgPSBfY29uc29sZTtcbiAgICAgICAgdGhpcy5fc3RhdGljU3ltYm9sQ2FjaGUgPSBfc3RhdGljU3ltYm9sQ2FjaGU7XG4gICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgICAgIHRoaXMuX2Vycm9yQ29sbGVjdG9yID0gX2Vycm9yQ29sbGVjdG9yO1xuICAgICAgICB0aGlzLl9ub25Ob3JtYWxpemVkRGlyZWN0aXZlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3BpcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVPZlR5cGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zaGFsbG93TW9kdWxlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRSZWZsZWN0b3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZWZsZWN0b3I7IH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGVGb3IgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgZGlyTWV0YSA9IHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlQ2FjaGUuZGVsZXRlKHR5cGUpO1xuICAgICAgICB0aGlzLl9ub25Ob3JtYWxpemVkRGlyZWN0aXZlQ2FjaGUuZGVsZXRlKHR5cGUpO1xuICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUuZGVsZXRlKHR5cGUpO1xuICAgICAgICB0aGlzLl9waXBlQ2FjaGUuZGVsZXRlKHR5cGUpO1xuICAgICAgICB0aGlzLl9uZ01vZHVsZU9mVHlwZXMuZGVsZXRlKHR5cGUpO1xuICAgICAgICAvLyBDbGVhciBhbGwgb2YgdGhlIE5nTW9kdWxlIGFzIHRoZXkgY29udGFpbiB0cmFuc2l0aXZlIGluZm9ybWF0aW9uIVxuICAgICAgICB0aGlzLl9uZ01vZHVsZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIGlmIChkaXJNZXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyLmNsZWFyQ2FjaGVGb3IoZGlyTWV0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9ub25Ob3JtYWxpemVkRGlyZWN0aXZlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fc3VtbWFyeUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3BpcGVDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9uZ01vZHVsZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyLmNsZWFyQ2FjaGUoKTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fY3JlYXRlUHJveHlDbGFzcyA9IGZ1bmN0aW9uIChiYXNlVHlwZSwgbmFtZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB2YXIgcHJveHlDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghZGVsZWdhdGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBDbGFzcyBcIiArIG5hbWUgKyBcIiBmb3IgdHlwZSBcIiArIHN0cmluZ2lmeShiYXNlVHlwZSkgKyBcIiBpcyBub3QgY29tcGlsZWQgeWV0IVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICBwcm94eUNsYXNzLnNldERlbGVnYXRlID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGRlbGVnYXRlID0gZDtcbiAgICAgICAgICAgIHByb3h5Q2xhc3MucHJvdG90eXBlID0gZC5wcm90b3R5cGU7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE1ha2Ugc3RyaW5naWZ5IHdvcmsgY29ycmVjdGx5XG4gICAgICAgIHByb3h5Q2xhc3Mub3ZlcnJpZGRlbk5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gcHJveHlDbGFzcztcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRHZW5lcmF0ZWRDbGFzcyA9IGZ1bmN0aW9uIChkaXJUeXBlLCBuYW1lKSB7XG4gICAgICAgIGlmIChkaXJUeXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGljU3ltYm9sQ2FjaGUuZ2V0KG5nZmFjdG9yeUZpbGVQYXRoKGRpclR5cGUuZmlsZVBhdGgpLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVQcm94eUNsYXNzKGRpclR5cGUsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0Q29tcG9uZW50Vmlld0NsYXNzID0gZnVuY3Rpb24gKGRpclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R2VuZXJhdGVkQ2xhc3MoZGlyVHlwZSwgdmlld0NsYXNzTmFtZShkaXJUeXBlLCAwKSk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0SG9zdENvbXBvbmVudFZpZXdDbGFzcyA9IGZ1bmN0aW9uIChkaXJUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdlbmVyYXRlZENsYXNzKGRpclR5cGUsIGhvc3RWaWV3Q2xhc3NOYW1lKGRpclR5cGUpKTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRIb3N0Q29tcG9uZW50VHlwZSA9IGZ1bmN0aW9uIChkaXJUeXBlKSB7XG4gICAgICAgIHZhciBuYW1lID0gaWRlbnRpZmllck5hbWUoeyByZWZlcmVuY2U6IGRpclR5cGUgfSkgKyBcIl9Ib3N0XCI7XG4gICAgICAgIGlmIChkaXJUeXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGljU3ltYm9sQ2FjaGUuZ2V0KGRpclR5cGUuZmlsZVBhdGgsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVQcm94eUNsYXNzKGRpclR5cGUsIG5hbWUpO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldFJlbmRlcmVyVHlwZSA9IGZ1bmN0aW9uIChkaXJUeXBlKSB7XG4gICAgICAgIGlmIChkaXJUeXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGljU3ltYm9sQ2FjaGUuZ2V0KG5nZmFjdG9yeUZpbGVQYXRoKGRpclR5cGUuZmlsZVBhdGgpLCByZW5kZXJlclR5cGVOYW1lKGRpclR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJldHVybmluZyBhbiBvYmplY3QgYXMgcHJveHksXG4gICAgICAgICAgICAvLyB0aGF0IHdlIGZpbGwgbGF0ZXIgZHVyaW5nIHJ1bnRpbWUgY29tcGlsYXRpb24uXG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRDb21wb25lbnRGYWN0b3J5ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBkaXJUeXBlLCBpbnB1dHMsIG91dHB1dHMpIHtcbiAgICAgICAgaWYgKGRpclR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0aWNTeW1ib2xDYWNoZS5nZXQobmdmYWN0b3J5RmlsZVBhdGgoZGlyVHlwZS5maWxlUGF0aCksIGNvbXBvbmVudEZhY3RvcnlOYW1lKGRpclR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBob3N0VmlldyA9IHRoaXMuZ2V0SG9zdENvbXBvbmVudFZpZXdDbGFzcyhkaXJUeXBlKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IG5nQ29udGVudFNlbGVjdG9ycyB3aWxsIGJlIGZpbGxlZCBsYXRlciBvbmNlIHRoZSB0ZW1wbGF0ZSBpc1xuICAgICAgICAgICAgLy8gbG9hZGVkLlxuICAgICAgICAgICAgdmFyIGNyZWF0ZUNvbXBvbmVudEZhY3RvcnkgPSB0aGlzLl9yZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKElkZW50aWZpZXJzLmNyZWF0ZUNvbXBvbmVudEZhY3RvcnkpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudEZhY3Rvcnkoc2VsZWN0b3IsIGRpclR5cGUsIGhvc3RWaWV3LCBpbnB1dHMsIG91dHB1dHMsIFtdKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmluaXRDb21wb25lbnRGYWN0b3J5ID0gZnVuY3Rpb24gKGZhY3RvcnksIG5nQ29udGVudFNlbGVjdG9ycykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghKGZhY3RvcnkgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpKSB7XG4gICAgICAgICAgICAoX2EgPSBmYWN0b3J5Lm5nQ29udGVudFNlbGVjdG9ycykucHVzaC5hcHBseShfYSwgX19zcHJlYWQobmdDb250ZW50U2VsZWN0b3JzKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fbG9hZFN1bW1hcnkgPSBmdW5jdGlvbiAodHlwZSwga2luZCkge1xuICAgICAgICB2YXIgdHlwZVN1bW1hcnkgPSB0aGlzLl9zdW1tYXJ5Q2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIXR5cGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICB2YXIgc3VtbWFyeSA9IHRoaXMuX3N1bW1hcnlSZXNvbHZlci5yZXNvbHZlU3VtbWFyeSh0eXBlKTtcbiAgICAgICAgICAgIHR5cGVTdW1tYXJ5ID0gc3VtbWFyeSA/IHN1bW1hcnkudHlwZSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUuc2V0KHR5cGUsIHR5cGVTdW1tYXJ5IHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlU3VtbWFyeSAmJiB0eXBlU3VtbWFyeS5zdW1tYXJ5S2luZCA9PT0ga2luZCA/IHR5cGVTdW1tYXJ5IDogbnVsbDtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRIb3N0Q29tcG9uZW50TWV0YWRhdGEgPSBmdW5jdGlvbiAoY29tcE1ldGEsIGhvc3RWaWV3VHlwZSkge1xuICAgICAgICB2YXIgaG9zdFR5cGUgPSB0aGlzLmdldEhvc3RDb21wb25lbnRUeXBlKGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgaWYgKCFob3N0Vmlld1R5cGUpIHtcbiAgICAgICAgICAgIGhvc3RWaWV3VHlwZSA9IHRoaXMuZ2V0SG9zdENvbXBvbmVudFZpZXdDbGFzcyhob3N0VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogISBpcyBvayBoZXJlIGFzIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aXRoIG5vcm1hbGl6ZWQgZGlyZWN0aXZlXG4gICAgICAgIC8vIG1ldGFkYXRhLCB3aGljaCBhbHdheXMgZmlsbHMgaW4gdGhlIHNlbGVjdG9yLlxuICAgICAgICB2YXIgdGVtcGxhdGUgPSBDc3NTZWxlY3Rvci5wYXJzZShjb21wTWV0YS5zZWxlY3RvcilbMF0uZ2V0TWF0Y2hpbmdFbGVtZW50VGVtcGxhdGUoKTtcbiAgICAgICAgdmFyIHRlbXBsYXRlVXJsID0gJyc7XG4gICAgICAgIHZhciBodG1sQXN0ID0gdGhpcy5faHRtbFBhcnNlci5wYXJzZSh0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwpO1xuICAgICAgICByZXR1cm4gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLmNyZWF0ZSh7XG4gICAgICAgICAgICBpc0hvc3Q6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiB7IHJlZmVyZW5jZTogaG9zdFR5cGUsIGRpRGVwczogW10sIGxpZmVjeWNsZUhvb2tzOiBbXSB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6IG5ldyBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6IHRlbXBsYXRlVXJsLFxuICAgICAgICAgICAgICAgIGh0bWxBc3Q6IGh0bWxBc3QsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXSxcbiAgICAgICAgICAgICAgICBzdHlsZVVybHM6IFtdLFxuICAgICAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogW10sXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogW10sXG4gICAgICAgICAgICAgICAgaXNJbmxpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxTdHlsZXNoZWV0czogW10sXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXhwb3J0QXM6IG51bGwsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsXG4gICAgICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgICAgICBob3N0OiB7fSxcbiAgICAgICAgICAgIGlzQ29tcG9uZW50OiB0cnVlLFxuICAgICAgICAgICAgc2VsZWN0b3I6ICcqJyxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW10sXG4gICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiBbXSxcbiAgICAgICAgICAgIHF1ZXJpZXM6IFtdLFxuICAgICAgICAgICAgZ3VhcmRzOiB7fSxcbiAgICAgICAgICAgIHZpZXdRdWVyaWVzOiBbXSxcbiAgICAgICAgICAgIGNvbXBvbmVudFZpZXdUeXBlOiBob3N0Vmlld1R5cGUsXG4gICAgICAgICAgICByZW5kZXJlclR5cGU6IHsgaWQ6ICdfX0hvc3RfXycsIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsIHN0eWxlczogW10sIGRhdGE6IHt9IH0sXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtdLFxuICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeTogbnVsbFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5sb2FkRGlyZWN0aXZlTWV0YWRhdGEgPSBmdW5jdGlvbiAobmdNb2R1bGVUeXBlLCBkaXJlY3RpdmVUeXBlLCBpc1N5bmMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmhhcyhkaXJlY3RpdmVUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGlyZWN0aXZlVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmKGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldE5vbk5vcm1hbGl6ZWREaXJlY3RpdmVNZXRhZGF0YShkaXJlY3RpdmVUeXBlKSwgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIG1ldGFkYXRhID0gX2EubWV0YWRhdGE7XG4gICAgICAgIHZhciBjcmVhdGVEaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZERpck1ldGEgPSBuZXcgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICBpc0hvc3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IG1ldGFkYXRhLnR5cGUsXG4gICAgICAgICAgICAgICAgaXNDb21wb25lbnQ6IG1ldGFkYXRhLmlzQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBtZXRhZGF0YS5zZWxlY3RvcixcbiAgICAgICAgICAgICAgICBleHBvcnRBczogbWV0YWRhdGEuZXhwb3J0QXMsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBtZXRhZGF0YS5jaGFuZ2VEZXRlY3Rpb24sXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBtZXRhZGF0YS5pbnB1dHMsXG4gICAgICAgICAgICAgICAgb3V0cHV0czogbWV0YWRhdGEub3V0cHV0cyxcbiAgICAgICAgICAgICAgICBob3N0TGlzdGVuZXJzOiBtZXRhZGF0YS5ob3N0TGlzdGVuZXJzLFxuICAgICAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzOiBtZXRhZGF0YS5ob3N0UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBob3N0QXR0cmlidXRlczogbWV0YWRhdGEuaG9zdEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBtZXRhZGF0YS5wcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogbWV0YWRhdGEudmlld1Byb3ZpZGVycyxcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiBtZXRhZGF0YS5xdWVyaWVzLFxuICAgICAgICAgICAgICAgIGd1YXJkczogbWV0YWRhdGEuZ3VhcmRzLFxuICAgICAgICAgICAgICAgIHZpZXdRdWVyaWVzOiBtZXRhZGF0YS52aWV3UXVlcmllcyxcbiAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IG1ldGFkYXRhLmVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRWaWV3VHlwZTogbWV0YWRhdGEuY29tcG9uZW50Vmlld1R5cGUsXG4gICAgICAgICAgICAgICAgcmVuZGVyZXJUeXBlOiBtZXRhZGF0YS5yZW5kZXJlclR5cGUsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeTogbWV0YWRhdGEuY29tcG9uZW50RmFjdG9yeSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGVNZXRhZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmluaXRDb21wb25lbnRGYWN0b3J5KG1ldGFkYXRhLmNvbXBvbmVudEZhY3RvcnksIHRlbXBsYXRlTWV0YWRhdGEubmdDb250ZW50U2VsZWN0b3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9kaXJlY3RpdmVDYWNoZS5zZXQoZGlyZWN0aXZlVHlwZSwgbm9ybWFsaXplZERpck1ldGEpO1xuICAgICAgICAgICAgX3RoaXMuX3N1bW1hcnlDYWNoZS5zZXQoZGlyZWN0aXZlVHlwZSwgbm9ybWFsaXplZERpck1ldGEudG9TdW1tYXJ5KCkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChtZXRhZGF0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gbWV0YWRhdGEudGVtcGxhdGU7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVNZXRhID0gdGhpcy5fZGlyZWN0aXZlTm9ybWFsaXplci5ub3JtYWxpemVUZW1wbGF0ZSh7XG4gICAgICAgICAgICAgICAgbmdNb2R1bGVUeXBlOiBuZ01vZHVsZVR5cGUsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50VHlwZTogZGlyZWN0aXZlVHlwZSxcbiAgICAgICAgICAgICAgICBtb2R1bGVVcmw6IHRoaXMuX3JlZmxlY3Rvci5jb21wb25lbnRNb2R1bGVVcmwoZGlyZWN0aXZlVHlwZSwgYW5ub3RhdGlvbiksXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogdGVtcGxhdGUuZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUudGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6IHRlbXBsYXRlLnRlbXBsYXRlVXJsLFxuICAgICAgICAgICAgICAgIHN0eWxlczogdGVtcGxhdGUuc3R5bGVzLFxuICAgICAgICAgICAgICAgIHN0eWxlVXJsczogdGVtcGxhdGUuc3R5bGVVcmxzLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IHRlbXBsYXRlLmFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogdGVtcGxhdGUuaW50ZXJwb2xhdGlvbixcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiB0ZW1wbGF0ZS5wcmVzZXJ2ZVdoaXRlc3BhY2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UodGVtcGxhdGVNZXRhKSAmJiBpc1N5bmMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihjb21wb25lbnRTdGlsbExvYWRpbmdFcnJvcihkaXJlY3RpdmVUeXBlKSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3luY0FzeW5jLnRoZW4odGVtcGxhdGVNZXRhLCBjcmVhdGVEaXJlY3RpdmVNZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVcbiAgICAgICAgICAgIGNyZWF0ZURpcmVjdGl2ZU1ldGFkYXRhKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXROb25Ob3JtYWxpemVkRGlyZWN0aXZlTWV0YWRhdGEgPSBmdW5jdGlvbiAoZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBkaXJlY3RpdmVUeXBlID0gcmVzb2x2ZUZvcndhcmRSZWYoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIGlmICghZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhY2hlRW50cnkgPSB0aGlzLl9ub25Ob3JtYWxpemVkRGlyZWN0aXZlQ2FjaGUuZ2V0KGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICBpZiAoY2FjaGVFbnRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlRW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpck1ldGEgPSB0aGlzLl9kaXJlY3RpdmVSZXNvbHZlci5yZXNvbHZlKGRpcmVjdGl2ZVR5cGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKCFkaXJNZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChjcmVhdGVDb21wb25lbnQuaXNUeXBlT2YoZGlyTWV0YSkpIHtcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgdmFyIGNvbXBNZXRhID0gZGlyTWV0YTtcbiAgICAgICAgICAgIGFzc2VydEFycmF5T2ZTdHJpbmdzKCdzdHlsZXMnLCBjb21wTWV0YS5zdHlsZXMpO1xuICAgICAgICAgICAgYXNzZXJ0QXJyYXlPZlN0cmluZ3MoJ3N0eWxlVXJscycsIGNvbXBNZXRhLnN0eWxlVXJscyk7XG4gICAgICAgICAgICBhc3NlcnRJbnRlcnBvbGF0aW9uU3ltYm9scygnaW50ZXJwb2xhdGlvbicsIGNvbXBNZXRhLmludGVycG9sYXRpb24pO1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSBjb21wTWV0YS5hbmltYXRpb25zO1xuICAgICAgICAgICAgbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEgPSBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IG5vVW5kZWZpbmVkKGNvbXBNZXRhLmVuY2Fwc3VsYXRpb24pLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBub1VuZGVmaW5lZChjb21wTWV0YS50ZW1wbGF0ZSksXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6IG5vVW5kZWZpbmVkKGNvbXBNZXRhLnRlbXBsYXRlVXJsKSxcbiAgICAgICAgICAgICAgICBodG1sQXN0OiBudWxsLFxuICAgICAgICAgICAgICAgIHN0eWxlczogY29tcE1ldGEuc3R5bGVzIHx8IFtdLFxuICAgICAgICAgICAgICAgIHN0eWxlVXJsczogY29tcE1ldGEuc3R5bGVVcmxzIHx8IFtdLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IGFuaW1hdGlvbnMgfHwgW10sXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogbm9VbmRlZmluZWQoY29tcE1ldGEuaW50ZXJwb2xhdGlvbiksXG4gICAgICAgICAgICAgICAgaXNJbmxpbmU6ICEhY29tcE1ldGEudGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxTdHlsZXNoZWV0czogW10sXG4gICAgICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiBbXSxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBub1VuZGVmaW5lZChkaXJNZXRhLnByZXNlcnZlV2hpdGVzcGFjZXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gbnVsbDtcbiAgICAgICAgdmFyIHZpZXdQcm92aWRlcnMgPSBbXTtcbiAgICAgICAgdmFyIGVudHJ5Q29tcG9uZW50TWV0YWRhdGEgPSBbXTtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gZGlyTWV0YS5zZWxlY3RvcjtcbiAgICAgICAgaWYgKGNyZWF0ZUNvbXBvbmVudC5pc1R5cGVPZihkaXJNZXRhKSkge1xuICAgICAgICAgICAgLy8gQ29tcG9uZW50XG4gICAgICAgICAgICB2YXIgY29tcE1ldGEgPSBkaXJNZXRhO1xuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBjb21wTWV0YS5jaGFuZ2VEZXRlY3Rpb247XG4gICAgICAgICAgICBpZiAoY29tcE1ldGEudmlld1Byb3ZpZGVycykge1xuICAgICAgICAgICAgICAgIHZpZXdQcm92aWRlcnMgPSB0aGlzLl9nZXRQcm92aWRlcnNNZXRhZGF0YShjb21wTWV0YS52aWV3UHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudE1ldGFkYXRhLCBcInZpZXdQcm92aWRlcnMgZm9yIFxcXCJcIiArIHN0cmluZ2lmeVR5cGUoZGlyZWN0aXZlVHlwZSkgKyBcIlxcXCJcIiwgW10sIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbXBNZXRhLmVudHJ5Q29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50TWV0YWRhdGEgPSBmbGF0dGVuQW5kRGVkdXBlQXJyYXkoY29tcE1ldGEuZW50cnlDb21wb25lbnRzKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBfdGhpcy5fZ2V0RW50cnlDb21wb25lbnRNZXRhZGF0YSh0eXBlKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChlbnRyeUNvbXBvbmVudE1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LmdldERlZmF1bHRDb21wb25lbnRFbGVtZW50TmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRGlyZWN0aXZlXG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJEaXJlY3RpdmUgXCIgKyBzdHJpbmdpZnlUeXBlKGRpcmVjdGl2ZVR5cGUpICsgXCIgaGFzIG5vIHNlbGVjdG9yLCBwbGVhc2UgYWRkIGl0IVwiKSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAnZXJyb3InO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBwcm92aWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKGRpck1ldGEucHJvdmlkZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHByb3ZpZGVycyA9IHRoaXMuX2dldFByb3ZpZGVyc01ldGFkYXRhKGRpck1ldGEucHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudE1ldGFkYXRhLCBcInByb3ZpZGVycyBmb3IgXFxcIlwiICsgc3RyaW5naWZ5VHlwZShkaXJlY3RpdmVUeXBlKSArIFwiXFxcIlwiLCBbXSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHF1ZXJpZXMgPSBbXTtcbiAgICAgICAgdmFyIHZpZXdRdWVyaWVzID0gW107XG4gICAgICAgIGlmIChkaXJNZXRhLnF1ZXJpZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcXVlcmllcyA9IHRoaXMuX2dldFF1ZXJpZXNNZXRhZGF0YShkaXJNZXRhLnF1ZXJpZXMsIGZhbHNlLCBkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgIHZpZXdRdWVyaWVzID0gdGhpcy5fZ2V0UXVlcmllc01ldGFkYXRhKGRpck1ldGEucXVlcmllcywgdHJ1ZSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1ldGFkYXRhID0gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLmNyZWF0ZSh7XG4gICAgICAgICAgICBpc0hvc3Q6IGZhbHNlLFxuICAgICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgICAgICAgZXhwb3J0QXM6IG5vVW5kZWZpbmVkKGRpck1ldGEuZXhwb3J0QXMpLFxuICAgICAgICAgICAgaXNDb21wb25lbnQ6ICEhbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLl9nZXRUeXBlTWV0YWRhdGEoZGlyZWN0aXZlVHlwZSksXG4gICAgICAgICAgICB0ZW1wbGF0ZTogbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IGNoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgICAgICAgICAgaW5wdXRzOiBkaXJNZXRhLmlucHV0cyB8fCBbXSxcbiAgICAgICAgICAgIG91dHB1dHM6IGRpck1ldGEub3V0cHV0cyB8fCBbXSxcbiAgICAgICAgICAgIGhvc3Q6IGRpck1ldGEuaG9zdCB8fCB7fSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogcHJvdmlkZXJzIHx8IFtdLFxuICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogdmlld1Byb3ZpZGVycyB8fCBbXSxcbiAgICAgICAgICAgIHF1ZXJpZXM6IHF1ZXJpZXMgfHwgW10sXG4gICAgICAgICAgICBndWFyZHM6IGRpck1ldGEuZ3VhcmRzIHx8IHt9LFxuICAgICAgICAgICAgdmlld1F1ZXJpZXM6IHZpZXdRdWVyaWVzIHx8IFtdLFxuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBlbnRyeUNvbXBvbmVudE1ldGFkYXRhLFxuICAgICAgICAgICAgY29tcG9uZW50Vmlld1R5cGU6IG5vbk5vcm1hbGl6ZWRUZW1wbGF0ZU1ldGFkYXRhID8gdGhpcy5nZXRDb21wb25lbnRWaWV3Q2xhc3MoZGlyZWN0aXZlVHlwZSkgOlxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICByZW5kZXJlclR5cGU6IG5vbk5vcm1hbGl6ZWRUZW1wbGF0ZU1ldGFkYXRhID8gdGhpcy5nZXRSZW5kZXJlclR5cGUoZGlyZWN0aXZlVHlwZSkgOiBudWxsLFxuICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5vbk5vcm1hbGl6ZWRUZW1wbGF0ZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICBtZXRhZGF0YS5jb21wb25lbnRGYWN0b3J5ID1cbiAgICAgICAgICAgICAgICB0aGlzLmdldENvbXBvbmVudEZhY3Rvcnkoc2VsZWN0b3IsIGRpcmVjdGl2ZVR5cGUsIG1ldGFkYXRhLmlucHV0cywgbWV0YWRhdGEub3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVFbnRyeSA9IHsgbWV0YWRhdGE6IG1ldGFkYXRhLCBhbm5vdGF0aW9uOiBkaXJNZXRhIH07XG4gICAgICAgIHRoaXMuX25vbk5vcm1hbGl6ZWREaXJlY3RpdmVDYWNoZS5zZXQoZGlyZWN0aXZlVHlwZSwgY2FjaGVFbnRyeSk7XG4gICAgICAgIHJldHVybiBjYWNoZUVudHJ5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWV0YWRhdGEgZm9yIHRoZSBnaXZlbiBkaXJlY3RpdmUuXG4gICAgICogVGhpcyBhc3N1bWVzIGBsb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGFgIGhhcyBiZWVuIGNhbGxlZCBmaXJzdC5cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0RGlyZWN0aXZlTWV0YWRhdGEgPSBmdW5jdGlvbiAoZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICB2YXIgZGlyTWV0YSA9IHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmdldChkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgaWYgKCFkaXJNZXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIklsbGVnYWwgc3RhdGU6IGdldERpcmVjdGl2ZU1ldGFkYXRhIGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciBsb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGEgZm9yIGEgbW9kdWxlIHRoYXQgZGVjbGFyZXMgaXQuIERpcmVjdGl2ZSBcIiArIHN0cmluZ2lmeVR5cGUoZGlyZWN0aXZlVHlwZSkgKyBcIi5cIiksIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJNZXRhO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldERpcmVjdGl2ZVN1bW1hcnkgPSBmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICB2YXIgZGlyU3VtbWFyeSA9IHRoaXMuX2xvYWRTdW1tYXJ5KGRpclR5cGUsIENvbXBpbGVTdW1tYXJ5S2luZC5EaXJlY3RpdmUpO1xuICAgICAgICBpZiAoIWRpclN1bW1hcnkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogQ291bGQgbm90IGxvYWQgdGhlIHN1bW1hcnkgZm9yIGRpcmVjdGl2ZSBcIiArIHN0cmluZ2lmeVR5cGUoZGlyVHlwZSkgKyBcIi5cIiksIGRpclR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJTdW1tYXJ5O1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmlzRGlyZWN0aXZlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fbG9hZFN1bW1hcnkodHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZSkgfHxcbiAgICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyLmlzRGlyZWN0aXZlKHR5cGUpO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmlzUGlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2xvYWRTdW1tYXJ5KHR5cGUsIENvbXBpbGVTdW1tYXJ5S2luZC5QaXBlKSB8fFxuICAgICAgICAgICAgdGhpcy5fcGlwZVJlc29sdmVyLmlzUGlwZSh0eXBlKTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5pc05nTW9kdWxlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fbG9hZFN1bW1hcnkodHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLk5nTW9kdWxlKSB8fFxuICAgICAgICAgICAgdGhpcy5fbmdNb2R1bGVSZXNvbHZlci5pc05nTW9kdWxlKHR5cGUpO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldE5nTW9kdWxlU3VtbWFyeSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCBhbHJlYWR5Q29sbGVjdGluZykge1xuICAgICAgICBpZiAoYWxyZWFkeUNvbGxlY3RpbmcgPT09IHZvaWQgMCkgeyBhbHJlYWR5Q29sbGVjdGluZyA9IG51bGw7IH1cbiAgICAgICAgdmFyIG1vZHVsZVN1bW1hcnkgPSB0aGlzLl9sb2FkU3VtbWFyeShtb2R1bGVUeXBlLCBDb21waWxlU3VtbWFyeUtpbmQuTmdNb2R1bGUpO1xuICAgICAgICBpZiAoIW1vZHVsZVN1bW1hcnkpIHtcbiAgICAgICAgICAgIHZhciBtb2R1bGVNZXRhID0gdGhpcy5nZXROZ01vZHVsZU1ldGFkYXRhKG1vZHVsZVR5cGUsIGZhbHNlLCBhbHJlYWR5Q29sbGVjdGluZyk7XG4gICAgICAgICAgICBtb2R1bGVTdW1tYXJ5ID0gbW9kdWxlTWV0YSA/IG1vZHVsZU1ldGEudG9TdW1tYXJ5KCkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKG1vZHVsZVN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUuc2V0KG1vZHVsZVR5cGUsIG1vZHVsZVN1bW1hcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVTdW1tYXJ5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIGRlY2xhcmVkIGRpcmVjdGl2ZXMgYW5kIHBpcGVzIG9mIGFuIE5nTW9kdWxlLlxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5sb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGEgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgaXNTeW5jLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIG5nTW9kdWxlID0gdGhpcy5nZXROZ01vZHVsZU1ldGFkYXRhKG1vZHVsZVR5cGUsIHRocm93SWZOb3RGb3VuZCk7XG4gICAgICAgIHZhciBsb2FkaW5nID0gW107XG4gICAgICAgIGlmIChuZ01vZHVsZSkge1xuICAgICAgICAgICAgbmdNb2R1bGUuZGVjbGFyZWREaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBfdGhpcy5sb2FkRGlyZWN0aXZlTWV0YWRhdGEobW9kdWxlVHlwZSwgaWQucmVmZXJlbmNlLCBpc1N5bmMpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmcucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5nTW9kdWxlLmRlY2xhcmVkUGlwZXMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIF90aGlzLl9sb2FkUGlwZU1ldGFkYXRhKGlkLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChsb2FkaW5nKTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRTaGFsbG93TW9kdWxlTWV0YWRhdGEgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICB2YXIgY29tcGlsZU1ldGEgPSB0aGlzLl9zaGFsbG93TW9kdWxlQ2FjaGUuZ2V0KG1vZHVsZVR5cGUpO1xuICAgICAgICBpZiAoY29tcGlsZU1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21waWxlTWV0YTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmdNb2R1bGVNZXRhID0gZmluZExhc3QodGhpcy5fcmVmbGVjdG9yLnNoYWxsb3dBbm5vdGF0aW9ucyhtb2R1bGVUeXBlKSwgY3JlYXRlTmdNb2R1bGUuaXNUeXBlT2YpO1xuICAgICAgICBjb21waWxlTWV0YSA9IHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX2dldFR5cGVNZXRhZGF0YShtb2R1bGVUeXBlKSxcbiAgICAgICAgICAgIHJhd0V4cG9ydHM6IG5nTW9kdWxlTWV0YS5leHBvcnRzLFxuICAgICAgICAgICAgcmF3SW1wb3J0czogbmdNb2R1bGVNZXRhLmltcG9ydHMsXG4gICAgICAgICAgICByYXdQcm92aWRlcnM6IG5nTW9kdWxlTWV0YS5wcm92aWRlcnMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NoYWxsb3dNb2R1bGVDYWNoZS5zZXQobW9kdWxlVHlwZSwgY29tcGlsZU1ldGEpO1xuICAgICAgICByZXR1cm4gY29tcGlsZU1ldGE7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0TmdNb2R1bGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCB0aHJvd0lmTm90Rm91bmQsIGFscmVhZHlDb2xsZWN0aW5nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgIGlmIChhbHJlYWR5Q29sbGVjdGluZyA9PT0gdm9pZCAwKSB7IGFscmVhZHlDb2xsZWN0aW5nID0gbnVsbDsgfVxuICAgICAgICBtb2R1bGVUeXBlID0gcmVzb2x2ZUZvcndhcmRSZWYobW9kdWxlVHlwZSk7XG4gICAgICAgIHZhciBjb21waWxlTWV0YSA9IHRoaXMuX25nTW9kdWxlQ2FjaGUuZ2V0KG1vZHVsZVR5cGUpO1xuICAgICAgICBpZiAoY29tcGlsZU1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21waWxlTWV0YTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWV0YSA9IHRoaXMuX25nTW9kdWxlUmVzb2x2ZXIucmVzb2x2ZShtb2R1bGVUeXBlLCB0aHJvd0lmTm90Rm91bmQpO1xuICAgICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWNsYXJlZERpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgdmFyIGV4cG9ydGVkTm9uTW9kdWxlSWRlbnRpZmllcnMgPSBbXTtcbiAgICAgICAgdmFyIGRlY2xhcmVkUGlwZXMgPSBbXTtcbiAgICAgICAgdmFyIGltcG9ydGVkTW9kdWxlcyA9IFtdO1xuICAgICAgICB2YXIgZXhwb3J0ZWRNb2R1bGVzID0gW107XG4gICAgICAgIHZhciBwcm92aWRlcnMgPSBbXTtcbiAgICAgICAgdmFyIGVudHJ5Q29tcG9uZW50cyA9IFtdO1xuICAgICAgICB2YXIgYm9vdHN0cmFwQ29tcG9uZW50cyA9IFtdO1xuICAgICAgICB2YXIgc2NoZW1hcyA9IFtdO1xuICAgICAgICBpZiAobWV0YS5pbXBvcnRzKSB7XG4gICAgICAgICAgICBmbGF0dGVuQW5kRGVkdXBlQXJyYXkobWV0YS5pbXBvcnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpbXBvcnRlZFR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1wb3J0ZWRNb2R1bGVUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkVHlwZShpbXBvcnRlZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlVHlwZSA9IGltcG9ydGVkVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW1wb3J0ZWRUeXBlICYmIGltcG9ydGVkVHlwZS5uZ01vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kdWxlV2l0aFByb3ZpZGVycyA9IGltcG9ydGVkVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWRNb2R1bGVUeXBlID0gbW9kdWxlV2l0aFByb3ZpZGVycy5uZ01vZHVsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZHVsZVdpdGhQcm92aWRlcnMucHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnMucHVzaC5hcHBseShwcm92aWRlcnMsIF9fc3ByZWFkKF90aGlzLl9nZXRQcm92aWRlcnNNZXRhZGF0YShtb2R1bGVXaXRoUHJvdmlkZXJzLnByb3ZpZGVycywgZW50cnlDb21wb25lbnRzLCBcInByb3ZpZGVyIGZvciB0aGUgTmdNb2R1bGUgJ1wiICsgc3RyaW5naWZ5VHlwZShpbXBvcnRlZE1vZHVsZVR5cGUpICsgXCInXCIsIFtdLCBpbXBvcnRlZFR5cGUpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltcG9ydGVkTW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2NoZWNrU2VsZkltcG9ydChtb2R1bGVUeXBlLCBpbXBvcnRlZE1vZHVsZVR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFscmVhZHlDb2xsZWN0aW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeUNvbGxlY3RpbmcgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5Q29sbGVjdGluZy5oYXMoaW1wb3J0ZWRNb2R1bGVUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKF90aGlzLl9nZXRUeXBlRGVzY3JpcHRvcihpbXBvcnRlZE1vZHVsZVR5cGUpICsgXCIgJ1wiICsgc3RyaW5naWZ5VHlwZShpbXBvcnRlZFR5cGUpICsgXCInIGlzIGltcG9ydGVkIHJlY3Vyc2l2ZWx5IGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiJy5cIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlDb2xsZWN0aW5nLmFkZChpbXBvcnRlZE1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW1wb3J0ZWRNb2R1bGVTdW1tYXJ5ID0gX3RoaXMuZ2V0TmdNb2R1bGVTdW1tYXJ5KGltcG9ydGVkTW9kdWxlVHlwZSwgYWxyZWFkeUNvbGxlY3RpbmcpO1xuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5Q29sbGVjdGluZy5kZWxldGUoaW1wb3J0ZWRNb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbXBvcnRlZE1vZHVsZVN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyBfdGhpcy5fZ2V0VHlwZURlc2NyaXB0b3IoaW1wb3J0ZWRUeXBlKSArIFwiICdcIiArIHN0cmluZ2lmeVR5cGUoaW1wb3J0ZWRUeXBlKSArIFwiJyBpbXBvcnRlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIicuIFBsZWFzZSBhZGQgYSBATmdNb2R1bGUgYW5ub3RhdGlvbi5cIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlcy5wdXNoKGltcG9ydGVkTW9kdWxlU3VtbWFyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlICdcIiArIHN0cmluZ2lmeVR5cGUoaW1wb3J0ZWRUeXBlKSArIFwiJyBpbXBvcnRlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIidcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuZXhwb3J0cykge1xuICAgICAgICAgICAgZmxhdHRlbkFuZERlZHVwZUFycmF5KG1ldGEuZXhwb3J0cykuZm9yRWFjaChmdW5jdGlvbiAoZXhwb3J0ZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVHlwZShleHBvcnRlZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgJ1wiICsgc3RyaW5naWZ5VHlwZShleHBvcnRlZFR5cGUpICsgXCInIGV4cG9ydGVkIGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiJ1wiKSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFhbHJlYWR5Q29sbGVjdGluZylcbiAgICAgICAgICAgICAgICAgICAgYWxyZWFkeUNvbGxlY3RpbmcgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGFscmVhZHlDb2xsZWN0aW5nLmhhcyhleHBvcnRlZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihfdGhpcy5fZ2V0VHlwZURlc2NyaXB0b3IoZXhwb3J0ZWRUeXBlKSArIFwiICdcIiArIHN0cmluZ2lmeShleHBvcnRlZFR5cGUpICsgXCInIGlzIGV4cG9ydGVkIHJlY3Vyc2l2ZWx5IGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiJ1wiKSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWxyZWFkeUNvbGxlY3RpbmcuYWRkKGV4cG9ydGVkVHlwZSk7XG4gICAgICAgICAgICAgICAgdmFyIGV4cG9ydGVkTW9kdWxlU3VtbWFyeSA9IF90aGlzLmdldE5nTW9kdWxlU3VtbWFyeShleHBvcnRlZFR5cGUsIGFscmVhZHlDb2xsZWN0aW5nKTtcbiAgICAgICAgICAgICAgICBhbHJlYWR5Q29sbGVjdGluZy5kZWxldGUoZXhwb3J0ZWRUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb3J0ZWRNb2R1bGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydGVkTW9kdWxlcy5wdXNoKGV4cG9ydGVkTW9kdWxlU3VtbWFyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRlZE5vbk1vZHVsZUlkZW50aWZpZXJzLnB1c2goX3RoaXMuX2dldElkZW50aWZpZXJNZXRhZGF0YShleHBvcnRlZFR5cGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBUaGlzIHdpbGwgYmUgbW9kaWZpZWQgbGF0ZXIsIHNvIHdlIHJlbHkgb25cbiAgICAgICAgLy8gZ2V0dGluZyBhIG5ldyBpbnN0YW5jZSBldmVyeSB0aW1lIVxuICAgICAgICB2YXIgdHJhbnNpdGl2ZU1vZHVsZSA9IHRoaXMuX2dldFRyYW5zaXRpdmVOZ01vZHVsZU1ldGFkYXRhKGltcG9ydGVkTW9kdWxlcywgZXhwb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgaWYgKG1ldGEuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICBmbGF0dGVuQW5kRGVkdXBlQXJyYXkobWV0YS5kZWNsYXJhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGRlY2xhcmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFR5cGUoZGVjbGFyZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlICdcIiArIHN0cmluZ2lmeVR5cGUoZGVjbGFyZWRUeXBlKSArIFwiJyBkZWNsYXJlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIidcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZWNsYXJlZElkZW50aWZpZXIgPSBfdGhpcy5fZ2V0SWRlbnRpZmllck1ldGFkYXRhKGRlY2xhcmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzRGlyZWN0aXZlKGRlY2xhcmVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5hZGREaXJlY3RpdmUoZGVjbGFyZWRJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyZWREaXJlY3RpdmVzLnB1c2goZGVjbGFyZWRJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZFR5cGVUb01vZHVsZShkZWNsYXJlZFR5cGUsIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5pc1BpcGUoZGVjbGFyZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLmFkZFBpcGUoZGVjbGFyZWRJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5waXBlcy5wdXNoKGRlY2xhcmVkSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmVkUGlwZXMucHVzaChkZWNsYXJlZElkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkVHlwZVRvTW9kdWxlKGRlY2xhcmVkVHlwZSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIFwiICsgX3RoaXMuX2dldFR5cGVEZXNjcmlwdG9yKGRlY2xhcmVkVHlwZSkgKyBcIiAnXCIgKyBzdHJpbmdpZnlUeXBlKGRlY2xhcmVkVHlwZSkgKyBcIicgZGVjbGFyZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInLiBQbGVhc2UgYWRkIGEgQFBpcGUvQERpcmVjdGl2ZS9AQ29tcG9uZW50IGFubm90YXRpb24uXCIpLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHBvcnRlZERpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgdmFyIGV4cG9ydGVkUGlwZXMgPSBbXTtcbiAgICAgICAgZXhwb3J0ZWROb25Nb2R1bGVJZGVudGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChleHBvcnRlZElkKSB7XG4gICAgICAgICAgICBpZiAodHJhbnNpdGl2ZU1vZHVsZS5kaXJlY3RpdmVzU2V0LmhhcyhleHBvcnRlZElkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICBleHBvcnRlZERpcmVjdGl2ZXMucHVzaChleHBvcnRlZElkKTtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLmFkZEV4cG9ydGVkRGlyZWN0aXZlKGV4cG9ydGVkSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNpdGl2ZU1vZHVsZS5waXBlc1NldC5oYXMoZXhwb3J0ZWRJZC5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0ZWRQaXBlcy5wdXNoKGV4cG9ydGVkSWQpO1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGUuYWRkRXhwb3J0ZWRQaXBlKGV4cG9ydGVkSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiQ2FuJ3QgZXhwb3J0IFwiICsgX3RoaXMuX2dldFR5cGVEZXNjcmlwdG9yKGV4cG9ydGVkSWQucmVmZXJlbmNlKSArIFwiIFwiICsgc3RyaW5naWZ5VHlwZShleHBvcnRlZElkLnJlZmVyZW5jZSkgKyBcIiBmcm9tIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiIGFzIGl0IHdhcyBuZWl0aGVyIGRlY2xhcmVkIG5vciBpbXBvcnRlZCFcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoZSBwcm92aWRlcnMgb2YgdGhlIG1vZHVsZSBoYXZlIHRvIGdvIGxhc3RcbiAgICAgICAgLy8gc28gdGhhdCB0aGV5IG92ZXJ3cml0ZSBhbnkgb3RoZXIgcHJvdmlkZXIgd2UgYWxyZWFkeSBhZGRlZC5cbiAgICAgICAgaWYgKG1ldGEucHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaC5hcHBseShwcm92aWRlcnMsIF9fc3ByZWFkKHRoaXMuX2dldFByb3ZpZGVyc01ldGFkYXRhKG1ldGEucHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudHMsIFwicHJvdmlkZXIgZm9yIHRoZSBOZ01vZHVsZSAnXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInXCIsIFtdLCBtb2R1bGVUeXBlKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmVudHJ5Q29tcG9uZW50cykge1xuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzLnB1c2guYXBwbHkoZW50cnlDb21wb25lbnRzLCBfX3NwcmVhZChmbGF0dGVuQW5kRGVkdXBlQXJyYXkobWV0YS5lbnRyeUNvbXBvbmVudHMpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMuX2dldEVudHJ5Q29tcG9uZW50TWV0YWRhdGEodHlwZSk7IH0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuYm9vdHN0cmFwKSB7XG4gICAgICAgICAgICBmbGF0dGVuQW5kRGVkdXBlQXJyYXkobWV0YS5ib290c3RyYXApLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgJ1wiICsgc3RyaW5naWZ5VHlwZSh0eXBlKSArIFwiJyB1c2VkIGluIHRoZSBib290c3RyYXAgcHJvcGVydHkgb2YgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIidcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvb3RzdHJhcENvbXBvbmVudHMucHVzaChfdGhpcy5fZ2V0SWRlbnRpZmllck1ldGFkYXRhKHR5cGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5Q29tcG9uZW50cy5wdXNoLmFwcGx5KGVudHJ5Q29tcG9uZW50cywgX19zcHJlYWQoYm9vdHN0cmFwQ29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLl9nZXRFbnRyeUNvbXBvbmVudE1ldGFkYXRhKHR5cGUucmVmZXJlbmNlKTsgfSkpKTtcbiAgICAgICAgaWYgKG1ldGEuc2NoZW1hcykge1xuICAgICAgICAgICAgc2NoZW1hcy5wdXNoLmFwcGx5KHNjaGVtYXMsIF9fc3ByZWFkKGZsYXR0ZW5BbmREZWR1cGVBcnJheShtZXRhLnNjaGVtYXMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcGlsZU1ldGEgPSBuZXcgQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEoe1xuICAgICAgICAgICAgdHlwZTogdGhpcy5fZ2V0VHlwZU1ldGFkYXRhKG1vZHVsZVR5cGUpLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBwcm92aWRlcnMsXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgIGJvb3RzdHJhcENvbXBvbmVudHM6IGJvb3RzdHJhcENvbXBvbmVudHMsXG4gICAgICAgICAgICBzY2hlbWFzOiBzY2hlbWFzLFxuICAgICAgICAgICAgZGVjbGFyZWREaXJlY3RpdmVzOiBkZWNsYXJlZERpcmVjdGl2ZXMsXG4gICAgICAgICAgICBleHBvcnRlZERpcmVjdGl2ZXM6IGV4cG9ydGVkRGlyZWN0aXZlcyxcbiAgICAgICAgICAgIGRlY2xhcmVkUGlwZXM6IGRlY2xhcmVkUGlwZXMsXG4gICAgICAgICAgICBleHBvcnRlZFBpcGVzOiBleHBvcnRlZFBpcGVzLFxuICAgICAgICAgICAgaW1wb3J0ZWRNb2R1bGVzOiBpbXBvcnRlZE1vZHVsZXMsXG4gICAgICAgICAgICBleHBvcnRlZE1vZHVsZXM6IGV4cG9ydGVkTW9kdWxlcyxcbiAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGU6IHRyYW5zaXRpdmVNb2R1bGUsXG4gICAgICAgICAgICBpZDogbWV0YS5pZCB8fCBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgZW50cnlDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7IHJldHVybiB0cmFuc2l0aXZlTW9kdWxlLmFkZEVudHJ5Q29tcG9uZW50KGlkKTsgfSk7XG4gICAgICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikgeyByZXR1cm4gdHJhbnNpdGl2ZU1vZHVsZS5hZGRQcm92aWRlcihwcm92aWRlciwgY29tcGlsZU1ldGEudHlwZSk7IH0pO1xuICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLmFkZE1vZHVsZShjb21waWxlTWV0YS50eXBlKTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVDYWNoZS5zZXQobW9kdWxlVHlwZSwgY29tcGlsZU1ldGEpO1xuICAgICAgICByZXR1cm4gY29tcGlsZU1ldGE7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2NoZWNrU2VsZkltcG9ydCA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCBpbXBvcnRlZE1vZHVsZVR5cGUpIHtcbiAgICAgICAgaWYgKG1vZHVsZVR5cGUgPT09IGltcG9ydGVkTW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCInXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInIG1vZHVsZSBjYW4ndCBpbXBvcnQgaXRzZWxmXCIpLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0VHlwZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAoaXNWYWxpZFR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlyZWN0aXZlKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkaXJlY3RpdmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNQaXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwaXBlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmdNb2R1bGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21vZHVsZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUucHJvdmlkZSkge1xuICAgICAgICAgICAgcmV0dXJuICdwcm92aWRlcic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd2YWx1ZSc7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2FkZFR5cGVUb01vZHVsZSA9IGZ1bmN0aW9uICh0eXBlLCBtb2R1bGVUeXBlKSB7XG4gICAgICAgIHZhciBvbGRNb2R1bGUgPSB0aGlzLl9uZ01vZHVsZU9mVHlwZXMuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAob2xkTW9kdWxlICYmIG9sZE1vZHVsZSAhPT0gbW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJUeXBlIFwiICsgc3RyaW5naWZ5VHlwZSh0eXBlKSArIFwiIGlzIHBhcnQgb2YgdGhlIGRlY2xhcmF0aW9ucyBvZiAyIG1vZHVsZXM6IFwiICsgc3RyaW5naWZ5VHlwZShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiISBcIiArXG4gICAgICAgICAgICAgICAgKFwiUGxlYXNlIGNvbnNpZGVyIG1vdmluZyBcIiArIHN0cmluZ2lmeVR5cGUodHlwZSkgKyBcIiB0byBhIGhpZ2hlciBtb2R1bGUgdGhhdCBpbXBvcnRzIFwiICsgc3RyaW5naWZ5VHlwZShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiLiBcIikgK1xuICAgICAgICAgICAgICAgIChcIllvdSBjYW4gYWxzbyBjcmVhdGUgYSBuZXcgTmdNb2R1bGUgdGhhdCBleHBvcnRzIGFuZCBpbmNsdWRlcyBcIiArIHN0cmluZ2lmeVR5cGUodHlwZSkgKyBcIiB0aGVuIGltcG9ydCB0aGF0IE5nTW9kdWxlIGluIFwiICsgc3RyaW5naWZ5VHlwZShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiLlwiKSksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcy5zZXQodHlwZSwgbW9kdWxlVHlwZSk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFRyYW5zaXRpdmVOZ01vZHVsZU1ldGFkYXRhID0gZnVuY3Rpb24gKGltcG9ydGVkTW9kdWxlcywgZXhwb3J0ZWRNb2R1bGVzKSB7XG4gICAgICAgIC8vIGNvbGxlY3QgYHByb3ZpZGVyc2AgLyBgZW50cnlDb21wb25lbnRzYCBmcm9tIGFsbCBpbXBvcnRlZCBhbmQgYWxsIGV4cG9ydGVkIG1vZHVsZXNcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEoKTtcbiAgICAgICAgdmFyIG1vZHVsZXNCeVRva2VuID0gbmV3IE1hcCgpO1xuICAgICAgICBpbXBvcnRlZE1vZHVsZXMuY29uY2F0KGV4cG9ydGVkTW9kdWxlcykuZm9yRWFjaChmdW5jdGlvbiAobW9kU3VtbWFyeSkge1xuICAgICAgICAgICAgbW9kU3VtbWFyeS5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZCkgeyByZXR1cm4gcmVzdWx0LmFkZE1vZHVsZShtb2QpOyB9KTtcbiAgICAgICAgICAgIG1vZFN1bW1hcnkuZW50cnlDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXApIHsgcmV0dXJuIHJlc3VsdC5hZGRFbnRyeUNvbXBvbmVudChjb21wKTsgfSk7XG4gICAgICAgICAgICB2YXIgYWRkZWRUb2tlbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LnByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlblJlZiA9IHRva2VuUmVmZXJlbmNlKGVudHJ5LnByb3ZpZGVyLnRva2VuKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldk1vZHVsZXMgPSBtb2R1bGVzQnlUb2tlbi5nZXQodG9rZW5SZWYpO1xuICAgICAgICAgICAgICAgIGlmICghcHJldk1vZHVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldk1vZHVsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZXNCeVRva2VuLnNldCh0b2tlblJlZiwgcHJldk1vZHVsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbW9kdWxlUmVmID0gZW50cnkubW9kdWxlLnJlZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiB0aGUgcHJvdmlkZXJzIG9mIG9uZSBtb2R1bGUgbWF5IHN0aWxsIGNvbnRhaW4gbXVsdGlwbGUgcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgLy8gcGVyIHRva2VuIChlLmcuIGZvciBtdWx0aSBwcm92aWRlcnMpLCBhbmQgd2UgbmVlZCB0byBwcmVzZXJ2ZSB0aGVzZS5cbiAgICAgICAgICAgICAgICBpZiAoYWRkZWRUb2tlbnMuaGFzKHRva2VuUmVmKSB8fCAhcHJldk1vZHVsZXMuaGFzKG1vZHVsZVJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldk1vZHVsZXMuYWRkKG1vZHVsZVJlZik7XG4gICAgICAgICAgICAgICAgICAgIGFkZGVkVG9rZW5zLmFkZCh0b2tlblJlZik7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRQcm92aWRlcihlbnRyeS5wcm92aWRlciwgZW50cnkubW9kdWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cG9ydGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RTdW1tYXJ5KSB7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmV4cG9ydGVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gcmVzdWx0LmFkZEV4cG9ydGVkRGlyZWN0aXZlKGlkKTsgfSk7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmV4cG9ydGVkUGlwZXMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHJlc3VsdC5hZGRFeHBvcnRlZFBpcGUoaWQpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGltcG9ydGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RTdW1tYXJ5KSB7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmV4cG9ydGVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gcmVzdWx0LmFkZERpcmVjdGl2ZShpZCk7IH0pO1xuICAgICAgICAgICAgbW9kU3VtbWFyeS5leHBvcnRlZFBpcGVzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7IHJldHVybiByZXN1bHQuYWRkUGlwZShpZCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0SWRlbnRpZmllck1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmKHR5cGUpO1xuICAgICAgICByZXR1cm4geyByZWZlcmVuY2U6IHR5cGUgfTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5pc0luamVjdGFibGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSB0aGlzLl9yZWZsZWN0b3IudHJ5QW5ub3RhdGlvbnModHlwZSk7XG4gICAgICAgIHJldHVybiBhbm5vdGF0aW9ucy5zb21lKGZ1bmN0aW9uIChhbm4pIHsgcmV0dXJuIGNyZWF0ZUluamVjdGFibGUuaXNUeXBlT2YoYW5uKTsgfSk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0SW5qZWN0YWJsZVN1bW1hcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VtbWFyeUtpbmQ6IENvbXBpbGVTdW1tYXJ5S2luZC5JbmplY3RhYmxlLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5fZ2V0VHlwZU1ldGFkYXRhKHR5cGUsIG51bGwsIGZhbHNlKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEluamVjdGFibGVNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlLCBkZXBlbmRlbmNpZXMsIHRocm93T25Vbmtub3duRGVwcykge1xuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzID09PSB2b2lkIDApIHsgZGVwZW5kZW5jaWVzID0gbnVsbDsgfVxuICAgICAgICBpZiAodGhyb3dPblVua25vd25EZXBzID09PSB2b2lkIDApIHsgdGhyb3dPblVua25vd25EZXBzID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgdHlwZVN1bW1hcnkgPSB0aGlzLl9sb2FkU3VtbWFyeSh0eXBlLCBDb21waWxlU3VtbWFyeUtpbmQuSW5qZWN0YWJsZSk7XG4gICAgICAgIHZhciB0eXBlTWV0YWRhdGEgPSB0eXBlU3VtbWFyeSA/XG4gICAgICAgICAgICB0eXBlU3VtbWFyeS50eXBlIDpcbiAgICAgICAgICAgIHRoaXMuX2dldFR5cGVNZXRhZGF0YSh0eXBlLCBkZXBlbmRlbmNpZXMsIHRocm93T25Vbmtub3duRGVwcyk7XG4gICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyh0eXBlKS5maWx0ZXIoZnVuY3Rpb24gKGFubikgeyByZXR1cm4gY3JlYXRlSW5qZWN0YWJsZS5pc1R5cGVPZihhbm4pOyB9KTtcbiAgICAgICAgaWYgKGFubm90YXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1ldGEgPSBhbm5vdGF0aW9uc1thbm5vdGF0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN5bWJvbDogdHlwZSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGVNZXRhZGF0YSxcbiAgICAgICAgICAgIHByb3ZpZGVkSW46IG1ldGEucHJvdmlkZWRJbixcbiAgICAgICAgICAgIHVzZVZhbHVlOiBtZXRhLnVzZVZhbHVlLFxuICAgICAgICAgICAgdXNlQ2xhc3M6IG1ldGEudXNlQ2xhc3MsXG4gICAgICAgICAgICB1c2VFeGlzdGluZzogbWV0YS51c2VFeGlzdGluZyxcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IG1ldGEudXNlRmFjdG9yeSxcbiAgICAgICAgICAgIGRlcHM6IG1ldGEuZGVwcyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0VHlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGUsIGRlcGVuZGVuY2llcywgdGhyb3dPblVua25vd25EZXBzKSB7XG4gICAgICAgIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkgeyBkZXBlbmRlbmNpZXMgPSBudWxsOyB9XG4gICAgICAgIGlmICh0aHJvd09uVW5rbm93bkRlcHMgPT09IHZvaWQgMCkgeyB0aHJvd09uVW5rbm93bkRlcHMgPSB0cnVlOyB9XG4gICAgICAgIHZhciBpZGVudGlmaWVyID0gdGhpcy5fZ2V0SWRlbnRpZmllck1ldGFkYXRhKHR5cGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVmZXJlbmNlOiBpZGVudGlmaWVyLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIGRpRGVwczogdGhpcy5fZ2V0RGVwZW5kZW5jaWVzTWV0YWRhdGEoaWRlbnRpZmllci5yZWZlcmVuY2UsIGRlcGVuZGVuY2llcywgdGhyb3dPblVua25vd25EZXBzKSxcbiAgICAgICAgICAgIGxpZmVjeWNsZUhvb2tzOiBnZXRBbGxMaWZlY3ljbGVIb29rcyh0aGlzLl9yZWZsZWN0b3IsIGlkZW50aWZpZXIucmVmZXJlbmNlKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0RmFjdG9yeU1ldGFkYXRhID0gZnVuY3Rpb24gKGZhY3RvcnksIGRlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzID09PSB2b2lkIDApIHsgZGVwZW5kZW5jaWVzID0gbnVsbDsgfVxuICAgICAgICBmYWN0b3J5ID0gcmVzb2x2ZUZvcndhcmRSZWYoZmFjdG9yeSk7XG4gICAgICAgIHJldHVybiB7IHJlZmVyZW5jZTogZmFjdG9yeSwgZGlEZXBzOiB0aGlzLl9nZXREZXBlbmRlbmNpZXNNZXRhZGF0YShmYWN0b3J5LCBkZXBlbmRlbmNpZXMpIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSBmb3IgdGhlIGdpdmVuIHBpcGUuXG4gICAgICogVGhpcyBhc3N1bWVzIGBsb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGFgIGhhcyBiZWVuIGNhbGxlZCBmaXJzdC5cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0UGlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHBpcGVUeXBlKSB7XG4gICAgICAgIHZhciBwaXBlTWV0YSA9IHRoaXMuX3BpcGVDYWNoZS5nZXQocGlwZVR5cGUpO1xuICAgICAgICBpZiAoIXBpcGVNZXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIklsbGVnYWwgc3RhdGU6IGdldFBpcGVNZXRhZGF0YSBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgbG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhIGZvciBhIG1vZHVsZSB0aGF0IGRlY2xhcmVzIGl0LiBQaXBlIFwiICsgc3RyaW5naWZ5VHlwZShwaXBlVHlwZSkgKyBcIi5cIiksIHBpcGVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZU1ldGEgfHwgbnVsbDtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRQaXBlU3VtbWFyeSA9IGZ1bmN0aW9uIChwaXBlVHlwZSkge1xuICAgICAgICB2YXIgcGlwZVN1bW1hcnkgPSB0aGlzLl9sb2FkU3VtbWFyeShwaXBlVHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLlBpcGUpO1xuICAgICAgICBpZiAoIXBpcGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIklsbGVnYWwgc3RhdGU6IENvdWxkIG5vdCBsb2FkIHRoZSBzdW1tYXJ5IGZvciBwaXBlIFwiICsgc3RyaW5naWZ5VHlwZShwaXBlVHlwZSkgKyBcIi5cIiksIHBpcGVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZVN1bW1hcnk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0T3JMb2FkUGlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHBpcGVUeXBlKSB7XG4gICAgICAgIHZhciBwaXBlTWV0YSA9IHRoaXMuX3BpcGVDYWNoZS5nZXQocGlwZVR5cGUpO1xuICAgICAgICBpZiAoIXBpcGVNZXRhKSB7XG4gICAgICAgICAgICBwaXBlTWV0YSA9IHRoaXMuX2xvYWRQaXBlTWV0YWRhdGEocGlwZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaXBlTWV0YTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fbG9hZFBpcGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChwaXBlVHlwZSkge1xuICAgICAgICBwaXBlVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmKHBpcGVUeXBlKTtcbiAgICAgICAgdmFyIHBpcGVBbm5vdGF0aW9uID0gdGhpcy5fcGlwZVJlc29sdmVyLnJlc29sdmUocGlwZVR5cGUpO1xuICAgICAgICB2YXIgcGlwZU1ldGEgPSBuZXcgQ29tcGlsZVBpcGVNZXRhZGF0YSh7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLl9nZXRUeXBlTWV0YWRhdGEocGlwZVR5cGUpLFxuICAgICAgICAgICAgbmFtZTogcGlwZUFubm90YXRpb24ubmFtZSxcbiAgICAgICAgICAgIHB1cmU6ICEhcGlwZUFubm90YXRpb24ucHVyZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcGlwZUNhY2hlLnNldChwaXBlVHlwZSwgcGlwZU1ldGEpO1xuICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUuc2V0KHBpcGVUeXBlLCBwaXBlTWV0YS50b1N1bW1hcnkoKSk7XG4gICAgICAgIHJldHVybiBwaXBlTWV0YTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0RGVwZW5kZW5jaWVzTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZU9yRnVuYywgZGVwZW5kZW5jaWVzLCB0aHJvd09uVW5rbm93bkRlcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRocm93T25Vbmtub3duRGVwcyA9PT0gdm9pZCAwKSB7IHRocm93T25Vbmtub3duRGVwcyA9IHRydWU7IH1cbiAgICAgICAgdmFyIGhhc1Vua25vd25EZXBzID0gZmFsc2U7XG4gICAgICAgIHZhciBwYXJhbXMgPSBkZXBlbmRlbmNpZXMgfHwgdGhpcy5fcmVmbGVjdG9yLnBhcmFtZXRlcnModHlwZU9yRnVuYykgfHwgW107XG4gICAgICAgIHZhciBkZXBlbmRlbmNpZXNNZXRhZGF0YSA9IHBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICB2YXIgaXNBdHRyaWJ1dGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpc0hvc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpc1NlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpc1NraXBTZWxmID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaXNPcHRpb25hbCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHRva2VuID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWF0ZUhvc3QuaXNUeXBlT2YocGFyYW1FbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSG9zdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3JlYXRlU2VsZi5pc1R5cGVPZihwYXJhbUVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTZWxmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjcmVhdGVTa2lwU2VsZi5pc1R5cGVPZihwYXJhbUVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTa2lwU2VsZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3JlYXRlT3B0aW9uYWwuaXNUeXBlT2YocGFyYW1FbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNyZWF0ZUF0dHJpYnV0ZS5pc1R5cGVPZihwYXJhbUVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNBdHRyaWJ1dGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbUVudHJ5LmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3JlYXRlSW5qZWN0LmlzVHlwZU9mKHBhcmFtRW50cnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtRW50cnkudG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3JlYXRlSW5qZWN0aW9uVG9rZW4uaXNUeXBlT2YocGFyYW1FbnRyeSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtRW50cnkgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1FbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbGlkVHlwZShwYXJhbUVudHJ5KSAmJiB0b2tlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtRW50cnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhhc1Vua25vd25EZXBzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzQXR0cmlidXRlOiBpc0F0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICBpc0hvc3Q6IGlzSG9zdCxcbiAgICAgICAgICAgICAgICBpc1NlbGY6IGlzU2VsZixcbiAgICAgICAgICAgICAgICBpc1NraXBTZWxmOiBpc1NraXBTZWxmLFxuICAgICAgICAgICAgICAgIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgdG9rZW46IF90aGlzLl9nZXRUb2tlbk1ldGFkYXRhKHRva2VuKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNVbmtub3duRGVwcykge1xuICAgICAgICAgICAgdmFyIGRlcHNUb2tlbnMgPSBkZXBlbmRlbmNpZXNNZXRhZGF0YS5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gZGVwLnRva2VuID8gc3RyaW5naWZ5VHlwZShkZXAudG9rZW4pIDogJz8nOyB9KS5qb2luKCcsICcpO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIkNhbid0IHJlc29sdmUgYWxsIHBhcmFtZXRlcnMgZm9yIFwiICsgc3RyaW5naWZ5VHlwZSh0eXBlT3JGdW5jKSArIFwiOiAoXCIgKyBkZXBzVG9rZW5zICsgXCIpLlwiO1xuICAgICAgICAgICAgaWYgKHRocm93T25Vbmtub3duRGVwcyB8fCB0aGlzLl9jb25maWcuc3RyaWN0SW5qZWN0aW9uUGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKG1lc3NhZ2UpLCB0eXBlT3JGdW5jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUud2FybihcIldhcm5pbmc6IFwiICsgbWVzc2FnZSArIFwiIFRoaXMgd2lsbCBiZWNvbWUgYW4gZXJyb3IgaW4gQW5ndWxhciB2Ni54XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXNNZXRhZGF0YTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0VG9rZW5NZXRhZGF0YSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB0b2tlbiA9IHJlc29sdmVGb3J3YXJkUmVmKHRva2VuKTtcbiAgICAgICAgdmFyIGNvbXBpbGVUb2tlbjtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbXBpbGVUb2tlbiA9IHsgdmFsdWU6IHRva2VuIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb21waWxlVG9rZW4gPSB7IGlkZW50aWZpZXI6IHsgcmVmZXJlbmNlOiB0b2tlbiB9IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBpbGVUb2tlbjtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEgPSBmdW5jdGlvbiAocHJvdmlkZXJzLCB0YXJnZXRFbnRyeUNvbXBvbmVudHMsIGRlYnVnSW5mbywgY29tcGlsZVByb3ZpZGVycywgdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29tcGlsZVByb3ZpZGVycyA9PT0gdm9pZCAwKSB7IGNvbXBpbGVQcm92aWRlcnMgPSBbXTsgfVxuICAgICAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIsIHByb3ZpZGVySWR4KSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEocHJvdmlkZXIsIHRhcmdldEVudHJ5Q29tcG9uZW50cywgZGVidWdJbmZvLCBjb21waWxlUHJvdmlkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIHZhciBwcm92aWRlck1ldGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyICYmIHR5cGVvZiBwcm92aWRlciA9PT0gJ29iamVjdCcgJiYgcHJvdmlkZXIuaGFzT3duUHJvcGVydHkoJ3Byb3ZpZGUnKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdmFsaWRhdGVQcm92aWRlcihwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YSA9IG5ldyBQcm92aWRlck1ldGEocHJvdmlkZXIucHJvdmlkZSwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbGlkVHlwZShwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhID0gbmV3IFByb3ZpZGVyTWV0YShwcm92aWRlciwgeyB1c2VDbGFzczogcHJvdmlkZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiRW5jb3VudGVyZWQgdW5kZWZpbmVkIHByb3ZpZGVyISBVc3VhbGx5IHRoaXMgbWVhbnMgeW91IGhhdmUgYSBjaXJjdWxhciBkZXBlbmRlbmNpZXMuIFRoaXMgbWlnaHQgYmUgY2F1c2VkIGJ5IHVzaW5nICdiYXJyZWwnIGluZGV4LnRzIGZpbGVzLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm92aWRlcnNJbmZvID0gcHJvdmlkZXJzLnJlZHVjZShmdW5jdGlvbiAoc29GYXIsIHNlZW5Qcm92aWRlciwgc2VlblByb3ZpZGVySWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VlblByb3ZpZGVySWR4IDwgcHJvdmlkZXJJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb0Zhci5wdXNoKFwiXCIgKyBzdHJpbmdpZnlUeXBlKHNlZW5Qcm92aWRlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VlblByb3ZpZGVySWR4ID09IHByb3ZpZGVySWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIucHVzaChcIj9cIiArIHN0cmluZ2lmeVR5cGUoc2VlblByb3ZpZGVyKSArIFwiP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlZW5Qcm92aWRlcklkeCA9PSBwcm92aWRlcklkeCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb0Zhci5wdXNoKCcuLi4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb0ZhcjtcbiAgICAgICAgICAgICAgICAgICAgfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiSW52YWxpZCBcIiArIChkZWJ1Z0luZm8gPyBkZWJ1Z0luZm8gOiAncHJvdmlkZXInKSArIFwiIC0gb25seSBpbnN0YW5jZXMgb2YgUHJvdmlkZXIgYW5kIFR5cGUgYXJlIGFsbG93ZWQsIGdvdDogW1wiICsgcHJvdmlkZXJzSW5mbyArIFwiXVwiKSwgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyTWV0YS50b2tlbiA9PT1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RW50cnlDb21wb25lbnRzLnB1c2guYXBwbHkodGFyZ2V0RW50cnlDb21wb25lbnRzLCBfX3NwcmVhZChfdGhpcy5fZ2V0RW50cnlDb21wb25lbnRzRnJvbVByb3ZpZGVyKHByb3ZpZGVyTWV0YSwgdHlwZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVQcm92aWRlcnMucHVzaChfdGhpcy5nZXRQcm92aWRlck1ldGFkYXRhKHByb3ZpZGVyTWV0YSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21waWxlUHJvdmlkZXJzO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl92YWxpZGF0ZVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgIGlmIChwcm92aWRlci5oYXNPd25Qcm9wZXJ0eSgndXNlQ2xhc3MnKSAmJiBwcm92aWRlci51c2VDbGFzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIkludmFsaWQgcHJvdmlkZXIgZm9yIFwiICsgc3RyaW5naWZ5VHlwZShwcm92aWRlci5wcm92aWRlKSArIFwiLiB1c2VDbGFzcyBjYW5ub3QgYmUgXCIgKyBwcm92aWRlci51c2VDbGFzcyArIFwiLlxcbiAgICAgICAgICAgVXN1YWxseSBpdCBoYXBwZW5zIHdoZW46XFxuICAgICAgICAgICAxLiBUaGVyZSdzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSAobWlnaHQgYmUgY2F1c2VkIGJ5IHVzaW5nIGluZGV4LnRzIChiYXJyZWwpIGZpbGVzKS5cXG4gICAgICAgICAgIDIuIENsYXNzIHdhcyB1c2VkIGJlZm9yZSBpdCB3YXMgZGVjbGFyZWQuIFVzZSBmb3J3YXJkUmVmIGluIHRoaXMgY2FzZS5cIikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldEVudHJ5Q29tcG9uZW50c0Zyb21Qcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlciwgdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB2YXIgY29sbGVjdGVkSWRlbnRpZmllcnMgPSBbXTtcbiAgICAgICAgaWYgKHByb3ZpZGVyLnVzZUZhY3RvcnkgfHwgcHJvdmlkZXIudXNlRXhpc3RpbmcgfHwgcHJvdmlkZXIudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiVGhlIEFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMgdG9rZW4gb25seSBzdXBwb3J0cyB1c2VWYWx1ZSFcIiksIHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJvdmlkZXIubXVsdGkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiVGhlIEFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMgdG9rZW4gb25seSBzdXBwb3J0cyAnbXVsdGkgPSB0cnVlJyFcIiksIHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGV4dHJhY3RJZGVudGlmaWVycyhwcm92aWRlci51c2VWYWx1ZSwgY29sbGVjdGVkSWRlbnRpZmllcnMpO1xuICAgICAgICBjb2xsZWN0ZWRJZGVudGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBfdGhpcy5fZ2V0RW50cnlDb21wb25lbnRNZXRhZGF0YShpZGVudGlmaWVyLnJlZmVyZW5jZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRFbnRyeUNvbXBvbmVudE1ldGFkYXRhID0gZnVuY3Rpb24gKGRpclR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgZGlyTWV0YSA9IHRoaXMuZ2V0Tm9uTm9ybWFsaXplZERpcmVjdGl2ZU1ldGFkYXRhKGRpclR5cGUpO1xuICAgICAgICBpZiAoZGlyTWV0YSAmJiBkaXJNZXRhLm1ldGFkYXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4geyBjb21wb25lbnRUeXBlOiBkaXJUeXBlLCBjb21wb25lbnRGYWN0b3J5OiBkaXJNZXRhLm1ldGFkYXRhLmNvbXBvbmVudEZhY3RvcnkgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlyU3VtbWFyeSA9IHRoaXMuX2xvYWRTdW1tYXJ5KGRpclR5cGUsIENvbXBpbGVTdW1tYXJ5S2luZC5EaXJlY3RpdmUpO1xuICAgICAgICBpZiAoZGlyU3VtbWFyeSAmJiBkaXJTdW1tYXJ5LmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4geyBjb21wb25lbnRUeXBlOiBkaXJUeXBlLCBjb21wb25lbnRGYWN0b3J5OiBkaXJTdW1tYXJ5LmNvbXBvbmVudEZhY3RvcnkgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihkaXJUeXBlLm5hbWUgKyBcIiBjYW5ub3QgYmUgdXNlZCBhcyBhbiBlbnRyeSBjb21wb25lbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRJbmplY3RhYmxlVHlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGUsIGRlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzID09PSB2b2lkIDApIHsgZGVwZW5kZW5jaWVzID0gbnVsbDsgfVxuICAgICAgICB2YXIgdHlwZVN1bW1hcnkgPSB0aGlzLl9sb2FkU3VtbWFyeSh0eXBlLCBDb21waWxlU3VtbWFyeUtpbmQuSW5qZWN0YWJsZSk7XG4gICAgICAgIGlmICh0eXBlU3VtbWFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVTdW1tYXJ5LnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFR5cGVNZXRhZGF0YSh0eXBlLCBkZXBlbmRlbmNpZXMpO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldFByb3ZpZGVyTWV0YWRhdGEgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIGNvbXBpbGVEZXBzID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgY29tcGlsZVR5cGVNZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHZhciBjb21waWxlRmFjdG9yeU1ldGFkYXRhID0gbnVsbDtcbiAgICAgICAgdmFyIHRva2VuID0gdGhpcy5fZ2V0VG9rZW5NZXRhZGF0YShwcm92aWRlci50b2tlbik7XG4gICAgICAgIGlmIChwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICAgICAgY29tcGlsZVR5cGVNZXRhZGF0YSA9XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0SW5qZWN0YWJsZVR5cGVNZXRhZGF0YShwcm92aWRlci51c2VDbGFzcywgcHJvdmlkZXIuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgIGNvbXBpbGVEZXBzID0gY29tcGlsZVR5cGVNZXRhZGF0YS5kaURlcHM7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXIudG9rZW4gPT09IHByb3ZpZGVyLnVzZUNsYXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjb21waWxlVHlwZU1ldGFkYXRhIGFzIGl0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGxpZmVjeWNsZUhvb2tzLi4uXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB7IGlkZW50aWZpZXI6IGNvbXBpbGVUeXBlTWV0YWRhdGEgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VGYWN0b3J5KSB7XG4gICAgICAgICAgICBjb21waWxlRmFjdG9yeU1ldGFkYXRhID0gdGhpcy5fZ2V0RmFjdG9yeU1ldGFkYXRhKHByb3ZpZGVyLnVzZUZhY3RvcnksIHByb3ZpZGVyLmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICBjb21waWxlRGVwcyA9IGNvbXBpbGVGYWN0b3J5TWV0YWRhdGEuZGlEZXBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbjogdG9rZW4sXG4gICAgICAgICAgICB1c2VDbGFzczogY29tcGlsZVR5cGVNZXRhZGF0YSxcbiAgICAgICAgICAgIHVzZVZhbHVlOiBwcm92aWRlci51c2VWYWx1ZSxcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGNvbXBpbGVGYWN0b3J5TWV0YWRhdGEsXG4gICAgICAgICAgICB1c2VFeGlzdGluZzogcHJvdmlkZXIudXNlRXhpc3RpbmcgPyB0aGlzLl9nZXRUb2tlbk1ldGFkYXRhKHByb3ZpZGVyLnVzZUV4aXN0aW5nKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRlcHM6IGNvbXBpbGVEZXBzLFxuICAgICAgICAgICAgbXVsdGk6IHByb3ZpZGVyLm11bHRpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFF1ZXJpZXNNZXRhZGF0YSA9IGZ1bmN0aW9uIChxdWVyaWVzLCBpc1ZpZXdRdWVyeSwgZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKHF1ZXJpZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gcXVlcmllc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LmlzVmlld1F1ZXJ5ID09PSBpc1ZpZXdRdWVyeSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKF90aGlzLl9nZXRRdWVyeU1ldGFkYXRhKHF1ZXJ5LCBwcm9wZXJ0eU5hbWUsIGRpcmVjdGl2ZVR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX3F1ZXJ5VmFyQmluZGluZ3MgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHsgcmV0dXJuIHNlbGVjdG9yLnNwbGl0KC9cXHMqLFxccyovKTsgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFF1ZXJ5TWV0YWRhdGEgPSBmdW5jdGlvbiAocSwgcHJvcGVydHlOYW1lLCB0eXBlT3JGdW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxlY3RvcnM7XG4gICAgICAgIGlmICh0eXBlb2YgcS5zZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNlbGVjdG9ycyA9XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVlcnlWYXJCaW5kaW5ncyhxLnNlbGVjdG9yKS5tYXAoZnVuY3Rpb24gKHZhck5hbWUpIHsgcmV0dXJuIF90aGlzLl9nZXRUb2tlbk1ldGFkYXRhKHZhck5hbWUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcS5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiQ2FuJ3QgY29uc3RydWN0IGEgcXVlcnkgZm9yIHRoZSBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIlxcXCIgb2YgXFxcIlwiICsgc3RyaW5naWZ5VHlwZSh0eXBlT3JGdW5jKSArIFwiXFxcIiBzaW5jZSB0aGUgcXVlcnkgc2VsZWN0b3Igd2Fzbid0IGRlZmluZWQuXCIpLCB0eXBlT3JGdW5jKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IFt0aGlzLl9nZXRUb2tlbk1ldGFkYXRhKHEuc2VsZWN0b3IpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VsZWN0b3JzOiBzZWxlY3RvcnMsXG4gICAgICAgICAgICBmaXJzdDogcS5maXJzdCxcbiAgICAgICAgICAgIGRlc2NlbmRhbnRzOiBxLmRlc2NlbmRhbnRzLCBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgIHJlYWQ6IHEucmVhZCA/IHRoaXMuX2dldFRva2VuTWV0YWRhdGEocS5yZWFkKSA6IG51bGwsXG4gICAgICAgICAgICBzdGF0aWM6IHEuc3RhdGljXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKGVycm9yLCB0eXBlLCBvdGhlclR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Vycm9yQ29sbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvckNvbGxlY3RvcihlcnJvciwgdHlwZSk7XG4gICAgICAgICAgICBpZiAob3RoZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JDb2xsZWN0b3IoZXJyb3IsIG90aGVyVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyO1xufSgpKTtcbmZ1bmN0aW9uIGZsYXR0ZW5BcnJheSh0cmVlLCBvdXQpIHtcbiAgICBpZiAob3V0ID09PSB2b2lkIDApIHsgb3V0ID0gW107IH1cbiAgICBpZiAodHJlZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gcmVzb2x2ZUZvcndhcmRSZWYodHJlZVtpXSk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICAgIGZsYXR0ZW5BcnJheShpdGVtLCBvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGRlZHVwZUFycmF5KGFycmF5KSB7XG4gICAgaWYgKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoYXJyYXkpKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gZmxhdHRlbkFuZERlZHVwZUFycmF5KHRyZWUpIHtcbiAgICByZXR1cm4gZGVkdXBlQXJyYXkoZmxhdHRlbkFycmF5KHRyZWUpKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRUeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkgfHwgKHZhbHVlIGluc3RhbmNlb2YgVHlwZSk7XG59XG5mdW5jdGlvbiBleHRyYWN0SWRlbnRpZmllcnModmFsdWUsIHRhcmdldElkZW50aWZpZXJzKSB7XG4gICAgdmlzaXRWYWx1ZSh2YWx1ZSwgbmV3IF9Db21waWxlVmFsdWVDb252ZXJ0ZXIoKSwgdGFyZ2V0SWRlbnRpZmllcnMpO1xufVxudmFyIF9Db21waWxlVmFsdWVDb252ZXJ0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9Db21waWxlVmFsdWVDb252ZXJ0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX0NvbXBpbGVWYWx1ZUNvbnZlcnRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBfQ29tcGlsZVZhbHVlQ29udmVydGVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCB0YXJnZXRJZGVudGlmaWVycykge1xuICAgICAgICB0YXJnZXRJZGVudGlmaWVycy5wdXNoKHsgcmVmZXJlbmNlOiB2YWx1ZSB9KTtcbiAgICB9O1xuICAgIHJldHVybiBfQ29tcGlsZVZhbHVlQ29udmVydGVyO1xufShWYWx1ZVRyYW5zZm9ybWVyKSk7XG5mdW5jdGlvbiBzdHJpbmdpZnlUeXBlKHR5cGUpIHtcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICByZXR1cm4gdHlwZS5uYW1lICsgXCIgaW4gXCIgKyB0eXBlLmZpbGVQYXRoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeSh0eXBlKTtcbiAgICB9XG59XG4vKipcbiAqIEluZGljYXRlcyB0aGF0IGEgY29tcG9uZW50IGlzIHN0aWxsIGJlaW5nIGxvYWRlZCBpbiBhIHN5bmNocm9ub3VzIGNvbXBpbGUuXG4gKi9cbmZ1bmN0aW9uIGNvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yKGNvbXBUeXBlKSB7XG4gICAgdmFyIGVycm9yID0gRXJyb3IoXCJDYW4ndCBjb21waWxlIHN5bmNocm9ub3VzbHkgYXMgXCIgKyBzdHJpbmdpZnkoY29tcFR5cGUpICsgXCIgaXMgc3RpbGwgYmVpbmcgbG9hZGVkIVwiKTtcbiAgICBlcnJvcltFUlJPUl9DT01QT05FTlRfVFlQRV0gPSBjb21wVHlwZTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIHByb3ZpZGVyRGVmKGN0eCwgcHJvdmlkZXJBc3QpIHtcbiAgICB2YXIgZmxhZ3MgPSAwIC8qIE5vbmUgKi87XG4gICAgaWYgKCFwcm92aWRlckFzdC5lYWdlcikge1xuICAgICAgICBmbGFncyB8PSA0MDk2IC8qIExhenlQcm92aWRlciAqLztcbiAgICB9XG4gICAgaWYgKHByb3ZpZGVyQXN0LnByb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLlByaXZhdGVTZXJ2aWNlKSB7XG4gICAgICAgIGZsYWdzIHw9IDgxOTIgLyogUHJpdmF0ZVByb3ZpZGVyICovO1xuICAgIH1cbiAgICBpZiAocHJvdmlkZXJBc3QuaXNNb2R1bGUpIHtcbiAgICAgICAgZmxhZ3MgfD0gMTA3Mzc0MTgyNCAvKiBUeXBlTW9kdWxlUHJvdmlkZXIgKi87XG4gICAgfVxuICAgIHByb3ZpZGVyQXN0LmxpZmVjeWNsZUhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGxpZmVjeWNsZUhvb2spIHtcbiAgICAgICAgLy8gZm9yIHJlZ3VsYXIgcHJvdmlkZXJzLCB3ZSBvbmx5IHN1cHBvcnQgbmdPbkRlc3Ryb3lcbiAgICAgICAgaWYgKGxpZmVjeWNsZUhvb2sgPT09IExpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSB8fFxuICAgICAgICAgICAgcHJvdmlkZXJBc3QucHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICBwcm92aWRlckFzdC5wcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5Db21wb25lbnQpIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IGxpZmVjeWNsZUhvb2tUb05vZGVGbGFnKGxpZmVjeWNsZUhvb2spO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIF9hID0gcHJvdmlkZXJBc3QubXVsdGlQcm92aWRlciA/XG4gICAgICAgIG11bHRpUHJvdmlkZXJEZWYoY3R4LCBmbGFncywgcHJvdmlkZXJBc3QucHJvdmlkZXJzKSA6XG4gICAgICAgIHNpbmdsZVByb3ZpZGVyRGVmKGN0eCwgZmxhZ3MsIHByb3ZpZGVyQXN0LnByb3ZpZGVyVHlwZSwgcHJvdmlkZXJBc3QucHJvdmlkZXJzWzBdKSwgcHJvdmlkZXJFeHByID0gX2EucHJvdmlkZXJFeHByLCBwcm92aWRlckZsYWdzID0gX2EuZmxhZ3MsIGRlcHNFeHByID0gX2EuZGVwc0V4cHI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvdmlkZXJFeHByOiBwcm92aWRlckV4cHIsXG4gICAgICAgIGZsYWdzOiBwcm92aWRlckZsYWdzLCBkZXBzRXhwcjogZGVwc0V4cHIsXG4gICAgICAgIHRva2VuRXhwcjogdG9rZW5FeHByKGN0eCwgcHJvdmlkZXJBc3QudG9rZW4pLFxuICAgIH07XG59XG5mdW5jdGlvbiBtdWx0aVByb3ZpZGVyRGVmKGN0eCwgZmxhZ3MsIHByb3ZpZGVycykge1xuICAgIHZhciBhbGxEZXBEZWZzID0gW107XG4gICAgdmFyIGFsbFBhcmFtcyA9IFtdO1xuICAgIHZhciBleHBycyA9IHByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyLCBwcm92aWRlckluZGV4KSB7XG4gICAgICAgIHZhciBleHByO1xuICAgICAgICBpZiAocHJvdmlkZXIudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgIHZhciBkZXBFeHBycyA9IGNvbnZlcnREZXBzKHByb3ZpZGVySW5kZXgsIHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlQ2xhc3MuZGlEZXBzKTtcbiAgICAgICAgICAgIGV4cHIgPSBjdHguaW1wb3J0RXhwcihwcm92aWRlci51c2VDbGFzcy5yZWZlcmVuY2UpLmluc3RhbnRpYXRlKGRlcEV4cHJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VGYWN0b3J5KSB7XG4gICAgICAgICAgICB2YXIgZGVwRXhwcnMgPSBjb252ZXJ0RGVwcyhwcm92aWRlckluZGV4LCBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUZhY3RvcnkuZGlEZXBzKTtcbiAgICAgICAgICAgIGV4cHIgPSBjdHguaW1wb3J0RXhwcihwcm92aWRlci51c2VGYWN0b3J5LnJlZmVyZW5jZSkuY2FsbEZuKGRlcEV4cHJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VFeGlzdGluZykge1xuICAgICAgICAgICAgdmFyIGRlcEV4cHJzID0gY29udmVydERlcHMocHJvdmlkZXJJbmRleCwgW3sgdG9rZW46IHByb3ZpZGVyLnVzZUV4aXN0aW5nIH1dKTtcbiAgICAgICAgICAgIGV4cHIgPSBkZXBFeHByc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4cHIgPSBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChjdHgsIHByb3ZpZGVyLnVzZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9KTtcbiAgICB2YXIgcHJvdmlkZXJFeHByID0gZm4oYWxsUGFyYW1zLCBbbmV3IFJldHVyblN0YXRlbWVudChsaXRlcmFsQXJyKGV4cHJzKSldLCBJTkZFUlJFRF9UWVBFKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm92aWRlckV4cHI6IHByb3ZpZGVyRXhwcixcbiAgICAgICAgZmxhZ3M6IGZsYWdzIHwgMTAyNCAvKiBUeXBlRmFjdG9yeVByb3ZpZGVyICovLFxuICAgICAgICBkZXBzRXhwcjogbGl0ZXJhbEFycihhbGxEZXBEZWZzKVxuICAgIH07XG4gICAgZnVuY3Rpb24gY29udmVydERlcHMocHJvdmlkZXJJbmRleCwgZGVwcykge1xuICAgICAgICByZXR1cm4gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCwgZGVwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbU5hbWUgPSBcInBcIiArIHByb3ZpZGVySW5kZXggKyBcIl9cIiArIGRlcEluZGV4O1xuICAgICAgICAgICAgYWxsUGFyYW1zLnB1c2gobmV3IEZuUGFyYW0ocGFyYW1OYW1lLCBEWU5BTUlDX1RZUEUpKTtcbiAgICAgICAgICAgIGFsbERlcERlZnMucHVzaChkZXBEZWYoY3R4LCBkZXApKTtcbiAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZShwYXJhbU5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBzaW5nbGVQcm92aWRlckRlZihjdHgsIGZsYWdzLCBwcm92aWRlclR5cGUsIHByb3ZpZGVyTWV0YSkge1xuICAgIHZhciBwcm92aWRlckV4cHI7XG4gICAgdmFyIGRlcHM7XG4gICAgaWYgKHByb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSB8fCBwcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5Db21wb25lbnQpIHtcbiAgICAgICAgcHJvdmlkZXJFeHByID0gY3R4LmltcG9ydEV4cHIocHJvdmlkZXJNZXRhLnVzZUNsYXNzLnJlZmVyZW5jZSk7XG4gICAgICAgIGZsYWdzIHw9IDE2Mzg0IC8qIFR5cGVEaXJlY3RpdmUgKi87XG4gICAgICAgIGRlcHMgPSBwcm92aWRlck1ldGEuZGVwcyB8fCBwcm92aWRlck1ldGEudXNlQ2xhc3MuZGlEZXBzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHByb3ZpZGVyTWV0YS51c2VDbGFzcykge1xuICAgICAgICAgICAgcHJvdmlkZXJFeHByID0gY3R4LmltcG9ydEV4cHIocHJvdmlkZXJNZXRhLnVzZUNsYXNzLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICBmbGFncyB8PSA1MTIgLyogVHlwZUNsYXNzUHJvdmlkZXIgKi87XG4gICAgICAgICAgICBkZXBzID0gcHJvdmlkZXJNZXRhLmRlcHMgfHwgcHJvdmlkZXJNZXRhLnVzZUNsYXNzLmRpRGVwcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlck1ldGEudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgcHJvdmlkZXJFeHByID0gY3R4LmltcG9ydEV4cHIocHJvdmlkZXJNZXRhLnVzZUZhY3RvcnkucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IDEwMjQgLyogVHlwZUZhY3RvcnlQcm92aWRlciAqLztcbiAgICAgICAgICAgIGRlcHMgPSBwcm92aWRlck1ldGEuZGVwcyB8fCBwcm92aWRlck1ldGEudXNlRmFjdG9yeS5kaURlcHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXJNZXRhLnVzZUV4aXN0aW5nKSB7XG4gICAgICAgICAgICBwcm92aWRlckV4cHIgPSBOVUxMX0VYUFI7XG4gICAgICAgICAgICBmbGFncyB8PSAyMDQ4IC8qIFR5cGVVc2VFeGlzdGluZ1Byb3ZpZGVyICovO1xuICAgICAgICAgICAgZGVwcyA9IFt7IHRva2VuOiBwcm92aWRlck1ldGEudXNlRXhpc3RpbmcgfV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm92aWRlckV4cHIgPSBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChjdHgsIHByb3ZpZGVyTWV0YS51c2VWYWx1ZSk7XG4gICAgICAgICAgICBmbGFncyB8PSAyNTYgLyogVHlwZVZhbHVlUHJvdmlkZXIgKi87XG4gICAgICAgICAgICBkZXBzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGRlcHNFeHByID0gbGl0ZXJhbEFycihkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBkZXBEZWYoY3R4LCBkZXApOyB9KSk7XG4gICAgcmV0dXJuIHsgcHJvdmlkZXJFeHByOiBwcm92aWRlckV4cHIsIGZsYWdzOiBmbGFncywgZGVwc0V4cHI6IGRlcHNFeHByIH07XG59XG5mdW5jdGlvbiB0b2tlbkV4cHIoY3R4LCB0b2tlbk1ldGEpIHtcbiAgICByZXR1cm4gdG9rZW5NZXRhLmlkZW50aWZpZXIgPyBjdHguaW1wb3J0RXhwcih0b2tlbk1ldGEuaWRlbnRpZmllci5yZWZlcmVuY2UpIDpcbiAgICAgICAgbGl0ZXJhbCh0b2tlbk1ldGEudmFsdWUpO1xufVxuZnVuY3Rpb24gZGVwRGVmKGN0eCwgZGVwKSB7XG4gICAgLy8gTm90ZTogdGhlIGZvbGxvd2luZyBmaWVsZHMgaGF2ZSBhbHJlYWR5IGJlZW4gbm9ybWFsaXplZCBvdXQgYnkgcHJvdmlkZXJfYW5hbHl6ZXI6XG4gICAgLy8gLSBpc0F0dHJpYnV0ZSwgaXNIb3N0XG4gICAgdmFyIGV4cHIgPSBkZXAuaXNWYWx1ZSA/IGNvbnZlcnRWYWx1ZVRvT3V0cHV0QXN0KGN0eCwgZGVwLnZhbHVlKSA6IHRva2VuRXhwcihjdHgsIGRlcC50b2tlbik7XG4gICAgdmFyIGZsYWdzID0gMCAvKiBOb25lICovO1xuICAgIGlmIChkZXAuaXNTa2lwU2VsZikge1xuICAgICAgICBmbGFncyB8PSAxIC8qIFNraXBTZWxmICovO1xuICAgIH1cbiAgICBpZiAoZGVwLmlzT3B0aW9uYWwpIHtcbiAgICAgICAgZmxhZ3MgfD0gMiAvKiBPcHRpb25hbCAqLztcbiAgICB9XG4gICAgaWYgKGRlcC5pc1NlbGYpIHtcbiAgICAgICAgZmxhZ3MgfD0gNCAvKiBTZWxmICovO1xuICAgIH1cbiAgICBpZiAoZGVwLmlzVmFsdWUpIHtcbiAgICAgICAgZmxhZ3MgfD0gOCAvKiBWYWx1ZSAqLztcbiAgICB9XG4gICAgcmV0dXJuIGZsYWdzID09PSAwIC8qIE5vbmUgKi8gPyBleHByIDogbGl0ZXJhbEFycihbbGl0ZXJhbChmbGFncyksIGV4cHJdKTtcbn1cbmZ1bmN0aW9uIGxpZmVjeWNsZUhvb2tUb05vZGVGbGFnKGxpZmVjeWNsZUhvb2spIHtcbiAgICB2YXIgbm9kZUZsYWcgPSAwIC8qIE5vbmUgKi87XG4gICAgc3dpdGNoIChsaWZlY3ljbGVIb29rKSB7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50Q2hlY2tlZDpcbiAgICAgICAgICAgIG5vZGVGbGFnID0gMjA5NzE1MiAvKiBBZnRlckNvbnRlbnRDaGVja2VkICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50SW5pdDpcbiAgICAgICAgICAgIG5vZGVGbGFnID0gMTA0ODU3NiAvKiBBZnRlckNvbnRlbnRJbml0ICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZDpcbiAgICAgICAgICAgIG5vZGVGbGFnID0gODM4ODYwOCAvKiBBZnRlclZpZXdDaGVja2VkICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3SW5pdDpcbiAgICAgICAgICAgIG5vZGVGbGFnID0gNDE5NDMwNCAvKiBBZnRlclZpZXdJbml0ICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuRG9DaGVjazpcbiAgICAgICAgICAgIG5vZGVGbGFnID0gMjYyMTQ0IC8qIERvQ2hlY2sgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5PbkNoYW5nZXM6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDUyNDI4OCAvKiBPbkNoYW5nZXMgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3k6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDEzMTA3MiAvKiBPbkRlc3Ryb3kgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5PbkluaXQ6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDY1NTM2IC8qIE9uSW5pdCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZUZsYWc7XG59XG5mdW5jdGlvbiBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJQcm92aWRlckRlZihyZWZsZWN0b3IsIGN0eCwgZmxhZ3MsIGVudHJ5Q29tcG9uZW50cykge1xuICAgIHZhciBlbnRyeUNvbXBvbmVudEZhY3RvcmllcyA9IGVudHJ5Q29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50KSB7IHJldHVybiBjdHguaW1wb3J0RXhwcihlbnRyeUNvbXBvbmVudC5jb21wb25lbnRGYWN0b3J5KTsgfSk7XG4gICAgdmFyIHRva2VuID0gY3JlYXRlVG9rZW5Gb3JFeHRlcm5hbFJlZmVyZW5jZShyZWZsZWN0b3IsIElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcik7XG4gICAgdmFyIGNsYXNzTWV0YSA9IHtcbiAgICAgICAgZGlEZXBzOiBbXG4gICAgICAgICAgICB7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBsaXRlcmFsQXJyKGVudHJ5Q29tcG9uZW50RmFjdG9yaWVzKSB9LFxuICAgICAgICAgICAgeyB0b2tlbjogdG9rZW4sIGlzU2tpcFNlbGY6IHRydWUsIGlzT3B0aW9uYWw6IHRydWUgfSxcbiAgICAgICAgICAgIHsgdG9rZW46IGNyZWF0ZVRva2VuRm9yRXh0ZXJuYWxSZWZlcmVuY2UocmVmbGVjdG9yLCBJZGVudGlmaWVycy5OZ01vZHVsZVJlZikgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbGlmZWN5Y2xlSG9va3M6IFtdLFxuICAgICAgICByZWZlcmVuY2U6IHJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcilcbiAgICB9O1xuICAgIHZhciBfYSA9IHNpbmdsZVByb3ZpZGVyRGVmKGN0eCwgZmxhZ3MsIFByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSwge1xuICAgICAgICB0b2tlbjogdG9rZW4sXG4gICAgICAgIG11bHRpOiBmYWxzZSxcbiAgICAgICAgdXNlQ2xhc3M6IGNsYXNzTWV0YSxcbiAgICB9KSwgcHJvdmlkZXJFeHByID0gX2EucHJvdmlkZXJFeHByLCBwcm92aWRlckZsYWdzID0gX2EuZmxhZ3MsIGRlcHNFeHByID0gX2EuZGVwc0V4cHI7XG4gICAgcmV0dXJuIHsgcHJvdmlkZXJFeHByOiBwcm92aWRlckV4cHIsIGZsYWdzOiBwcm92aWRlckZsYWdzLCBkZXBzRXhwcjogZGVwc0V4cHIsIHRva2VuRXhwcjogdG9rZW5FeHByKGN0eCwgdG9rZW4pIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBOZ01vZHVsZUNvbXBpbGVSZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmdNb2R1bGVDb21waWxlUmVzdWx0KG5nTW9kdWxlRmFjdG9yeVZhcikge1xuICAgICAgICB0aGlzLm5nTW9kdWxlRmFjdG9yeVZhciA9IG5nTW9kdWxlRmFjdG9yeVZhcjtcbiAgICB9XG4gICAgcmV0dXJuIE5nTW9kdWxlQ29tcGlsZVJlc3VsdDtcbn0oKSk7XG52YXIgTE9HX1ZBUiA9IHZhcmlhYmxlKCdfbCcpO1xudmFyIE5nTW9kdWxlQ29tcGlsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmdNb2R1bGVDb21waWxlcihyZWZsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5yZWZsZWN0b3IgPSByZWZsZWN0b3I7XG4gICAgfVxuICAgIE5nTW9kdWxlQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoY3R4LCBuZ01vZHVsZU1ldGEsIGV4dHJhUHJvdmlkZXJzKSB7XG4gICAgICAgIHZhciBzb3VyY2VTcGFuID0gdHlwZVNvdXJjZVNwYW4oJ05nTW9kdWxlJywgbmdNb2R1bGVNZXRhLnR5cGUpO1xuICAgICAgICB2YXIgZW50cnlDb21wb25lbnRGYWN0b3JpZXMgPSBuZ01vZHVsZU1ldGEudHJhbnNpdGl2ZU1vZHVsZS5lbnRyeUNvbXBvbmVudHM7XG4gICAgICAgIHZhciBib290c3RyYXBDb21wb25lbnRzID0gbmdNb2R1bGVNZXRhLmJvb3RzdHJhcENvbXBvbmVudHM7XG4gICAgICAgIHZhciBwcm92aWRlclBhcnNlciA9IG5ldyBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXIodGhpcy5yZWZsZWN0b3IsIG5nTW9kdWxlTWV0YSwgZXh0cmFQcm92aWRlcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICB2YXIgcHJvdmlkZXJEZWZzID0gW2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlclByb3ZpZGVyRGVmKHRoaXMucmVmbGVjdG9yLCBjdHgsIDAgLyogTm9uZSAqLywgZW50cnlDb21wb25lbnRGYWN0b3JpZXMpXVxuICAgICAgICAgICAgLmNvbmNhdChwcm92aWRlclBhcnNlci5wYXJzZSgpLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIHByb3ZpZGVyRGVmKGN0eCwgcHJvdmlkZXIpOyB9KSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXJFeHByID0gX2EucHJvdmlkZXJFeHByLCBkZXBzRXhwciA9IF9hLmRlcHNFeHByLCBmbGFncyA9IF9hLmZsYWdzLCB0b2tlbkV4cHIgPSBfYS50b2tlbkV4cHI7XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihJZGVudGlmaWVycy5tb2R1bGVQcm92aWRlckRlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGZsYWdzKSwgdG9rZW5FeHByLCBwcm92aWRlckV4cHIsIGRlcHNFeHByXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuZ01vZHVsZURlZiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMubW9kdWxlRGVmKS5jYWxsRm4oW2xpdGVyYWxBcnIocHJvdmlkZXJEZWZzKV0pO1xuICAgICAgICB2YXIgbmdNb2R1bGVEZWZGYWN0b3J5ID0gZm4oW25ldyBGblBhcmFtKExPR19WQVIubmFtZSldLCBbbmV3IFJldHVyblN0YXRlbWVudChuZ01vZHVsZURlZildLCBJTkZFUlJFRF9UWVBFKTtcbiAgICAgICAgdmFyIG5nTW9kdWxlRmFjdG9yeVZhciA9IGlkZW50aWZpZXJOYW1lKG5nTW9kdWxlTWV0YS50eXBlKSArIFwiTmdGYWN0b3J5XCI7XG4gICAgICAgIHRoaXMuX2NyZWF0ZU5nTW9kdWxlRmFjdG9yeShjdHgsIG5nTW9kdWxlTWV0YS50eXBlLnJlZmVyZW5jZSwgaW1wb3J0RXhwcihJZGVudGlmaWVycy5jcmVhdGVNb2R1bGVGYWN0b3J5KS5jYWxsRm4oW1xuICAgICAgICAgICAgY3R4LmltcG9ydEV4cHIobmdNb2R1bGVNZXRhLnR5cGUucmVmZXJlbmNlKSxcbiAgICAgICAgICAgIGxpdGVyYWxBcnIoYm9vdHN0cmFwQ29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBjdHguaW1wb3J0RXhwcihpZC5yZWZlcmVuY2UpOyB9KSksXG4gICAgICAgICAgICBuZ01vZHVsZURlZkZhY3RvcnlcbiAgICAgICAgXSkpO1xuICAgICAgICBpZiAobmdNb2R1bGVNZXRhLmlkKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSB0eXBlb2YgbmdNb2R1bGVNZXRhLmlkID09PSAnc3RyaW5nJyA/IGxpdGVyYWwobmdNb2R1bGVNZXRhLmlkKSA6XG4gICAgICAgICAgICAgICAgY3R4LmltcG9ydEV4cHIobmdNb2R1bGVNZXRhLmlkKTtcbiAgICAgICAgICAgIHZhciByZWdpc3RlckZhY3RvcnlTdG10ID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy5SZWdpc3Rlck1vZHVsZUZhY3RvcnlGbilcbiAgICAgICAgICAgICAgICAuY2FsbEZuKFtpZCwgdmFyaWFibGUobmdNb2R1bGVGYWN0b3J5VmFyKV0pXG4gICAgICAgICAgICAgICAgLnRvU3RtdCgpO1xuICAgICAgICAgICAgY3R4LnN0YXRlbWVudHMucHVzaChyZWdpc3RlckZhY3RvcnlTdG10KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE5nTW9kdWxlQ29tcGlsZVJlc3VsdChuZ01vZHVsZUZhY3RvcnlWYXIpO1xuICAgIH07XG4gICAgTmdNb2R1bGVDb21waWxlci5wcm90b3R5cGUuY3JlYXRlU3R1YiA9IGZ1bmN0aW9uIChjdHgsIG5nTW9kdWxlUmVmZXJlbmNlKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZU5nTW9kdWxlRmFjdG9yeShjdHgsIG5nTW9kdWxlUmVmZXJlbmNlLCBOVUxMX0VYUFIpO1xuICAgIH07XG4gICAgTmdNb2R1bGVDb21waWxlci5wcm90b3R5cGUuX2NyZWF0ZU5nTW9kdWxlRmFjdG9yeSA9IGZ1bmN0aW9uIChjdHgsIHJlZmVyZW5jZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG5nTW9kdWxlRmFjdG9yeVZhciA9IGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiByZWZlcmVuY2UgfSkgKyBcIk5nRmFjdG9yeVwiO1xuICAgICAgICB2YXIgbmdNb2R1bGVGYWN0b3J5U3RtdCA9IHZhcmlhYmxlKG5nTW9kdWxlRmFjdG9yeVZhcilcbiAgICAgICAgICAgIC5zZXQodmFsdWUpXG4gICAgICAgICAgICAudG9EZWNsU3RtdChpbXBvcnRUeXBlKElkZW50aWZpZXJzLk5nTW9kdWxlRmFjdG9yeSwgW2V4cHJlc3Npb25UeXBlKGN0eC5pbXBvcnRFeHByKHJlZmVyZW5jZSkpXSwgW1R5cGVNb2RpZmllci5Db25zdF0pLCBbU3RtdE1vZGlmaWVyLkZpbmFsLCBTdG10TW9kaWZpZXIuRXhwb3J0ZWRdKTtcbiAgICAgICAgY3R4LnN0YXRlbWVudHMucHVzaChuZ01vZHVsZUZhY3RvcnlTdG10KTtcbiAgICB9O1xuICAgIHJldHVybiBOZ01vZHVsZUNvbXBpbGVyO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBSZXNvbHZlcyB0eXBlcyB0byB7QGxpbmsgTmdNb2R1bGV9LlxuICovXG52YXIgTmdNb2R1bGVSZXNvbHZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZ01vZHVsZVJlc29sdmVyKF9yZWZsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gX3JlZmxlY3RvcjtcbiAgICB9XG4gICAgTmdNb2R1bGVSZXNvbHZlci5wcm90b3R5cGUuaXNOZ01vZHVsZSA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnModHlwZSkuc29tZShjcmVhdGVOZ01vZHVsZS5pc1R5cGVPZik7IH07XG4gICAgTmdNb2R1bGVSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh0eXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIG5nTW9kdWxlTWV0YSA9IGZpbmRMYXN0KHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyh0eXBlKSwgY3JlYXRlTmdNb2R1bGUuaXNUeXBlT2YpO1xuICAgICAgICBpZiAobmdNb2R1bGVNZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmdNb2R1bGVNZXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5nTW9kdWxlIG1ldGFkYXRhIGZvdW5kIGZvciAnXCIgKyBzdHJpbmdpZnkodHlwZSkgKyBcIicuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOZ01vZHVsZVJlc29sdmVyO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9kZWJ1Z0ZpbGVQYXRoID0gJy9kZWJ1Zy9saWInO1xuZnVuY3Rpb24gZGVidWdPdXRwdXRBc3RBc1R5cGVTY3JpcHQoYXN0KSB7XG4gICAgdmFyIGNvbnZlcnRlciA9IG5ldyBfVHNFbWl0dGVyVmlzaXRvcigpO1xuICAgIHZhciBjdHggPSBFbWl0dGVyVmlzaXRvckNvbnRleHQuY3JlYXRlUm9vdCgpO1xuICAgIHZhciBhc3RzID0gQXJyYXkuaXNBcnJheShhc3QpID8gYXN0IDogW2FzdF07XG4gICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgaWYgKGFzdCBpbnN0YW5jZW9mIFN0YXRlbWVudCkge1xuICAgICAgICAgICAgYXN0LnZpc2l0U3RhdGVtZW50KGNvbnZlcnRlciwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QgaW5zdGFuY2VvZiBFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBhc3QudmlzaXRFeHByZXNzaW9uKGNvbnZlcnRlciwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QgaW5zdGFuY2VvZiBUeXBlJDEpIHtcbiAgICAgICAgICAgIGFzdC52aXNpdFR5cGUoY29udmVydGVyLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG9uJ3Qga25vdyBob3cgdG8gcHJpbnQgZGVidWcgaW5mbyBmb3IgXCIgKyBhc3QpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGN0eC50b1NvdXJjZSgpO1xufVxudmFyIFR5cGVTY3JpcHRFbWl0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGVTY3JpcHRFbWl0dGVyKCkge1xuICAgIH1cbiAgICBUeXBlU2NyaXB0RW1pdHRlci5wcm90b3R5cGUuZW1pdFN0YXRlbWVudHNBbmRDb250ZXh0ID0gZnVuY3Rpb24gKGdlbkZpbGVQYXRoLCBzdG10cywgcHJlYW1ibGUsIGVtaXRTb3VyY2VNYXBzLCByZWZlcmVuY2VGaWx0ZXIsIGltcG9ydEZpbHRlcikge1xuICAgICAgICBpZiAocHJlYW1ibGUgPT09IHZvaWQgMCkgeyBwcmVhbWJsZSA9ICcnOyB9XG4gICAgICAgIGlmIChlbWl0U291cmNlTWFwcyA9PT0gdm9pZCAwKSB7IGVtaXRTb3VyY2VNYXBzID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgY29udmVydGVyID0gbmV3IF9Uc0VtaXR0ZXJWaXNpdG9yKHJlZmVyZW5jZUZpbHRlciwgaW1wb3J0RmlsdGVyKTtcbiAgICAgICAgdmFyIGN0eCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KCk7XG4gICAgICAgIGNvbnZlcnRlci52aXNpdEFsbFN0YXRlbWVudHMoc3RtdHMsIGN0eCk7XG4gICAgICAgIHZhciBwcmVhbWJsZUxpbmVzID0gcHJlYW1ibGUgPyBwcmVhbWJsZS5zcGxpdCgnXFxuJykgOiBbXTtcbiAgICAgICAgY29udmVydGVyLnJlZXhwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWV4cG9ydHMsIGV4cG9ydGVkTW9kdWxlTmFtZSkge1xuICAgICAgICAgICAgdmFyIHJlZXhwb3J0c0NvZGUgPSByZWV4cG9ydHMubWFwKGZ1bmN0aW9uIChyZWV4cG9ydCkgeyByZXR1cm4gcmVleHBvcnQubmFtZSArIFwiIGFzIFwiICsgcmVleHBvcnQuYXM7IH0pLmpvaW4oJywnKTtcbiAgICAgICAgICAgIHByZWFtYmxlTGluZXMucHVzaChcImV4cG9ydCB7XCIgKyByZWV4cG9ydHNDb2RlICsgXCJ9IGZyb20gJ1wiICsgZXhwb3J0ZWRNb2R1bGVOYW1lICsgXCInO1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnZlcnRlci5pbXBvcnRzV2l0aFByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCwgaW1wb3J0ZWRNb2R1bGVOYW1lKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBjYW4ndCB3cml0ZSB0aGUgcmVhbCB3b3JkIGZvciBpbXBvcnQgYXMgaXQgc2NyZXdzIHVwIHN5c3RlbS5qcyBhdXRvIGRldGVjdGlvbi4uLlxuICAgICAgICAgICAgcHJlYW1ibGVMaW5lcy5wdXNoKFwiaW1wXCIgK1xuICAgICAgICAgICAgICAgIChcIm9ydCAqIGFzIFwiICsgcHJlZml4ICsgXCIgZnJvbSAnXCIgKyBpbXBvcnRlZE1vZHVsZU5hbWUgKyBcIic7XCIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzbSA9IGVtaXRTb3VyY2VNYXBzID9cbiAgICAgICAgICAgIGN0eC50b1NvdXJjZU1hcEdlbmVyYXRvcihnZW5GaWxlUGF0aCwgcHJlYW1ibGVMaW5lcy5sZW5ndGgpLnRvSnNDb21tZW50KCkgOlxuICAgICAgICAgICAgJyc7XG4gICAgICAgIHZhciBsaW5lcyA9IF9fc3ByZWFkKHByZWFtYmxlTGluZXMsIFtjdHgudG9Tb3VyY2UoKSwgc21dKTtcbiAgICAgICAgaWYgKHNtKSB7XG4gICAgICAgICAgICAvLyBhbHdheXMgYWRkIGEgbmV3bGluZSBhdCB0aGUgZW5kLCBhcyBzb21lIHRvb2xzIGhhdmUgYnVncyB3aXRob3V0IGl0LlxuICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnNldFByZWFtYmxlTGluZUNvdW50KHByZWFtYmxlTGluZXMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHsgc291cmNlVGV4dDogbGluZXMuam9pbignXFxuJyksIGNvbnRleHQ6IGN0eCB9O1xuICAgIH07XG4gICAgVHlwZVNjcmlwdEVtaXR0ZXIucHJvdG90eXBlLmVtaXRTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKGdlbkZpbGVQYXRoLCBzdG10cywgcHJlYW1ibGUpIHtcbiAgICAgICAgaWYgKHByZWFtYmxlID09PSB2b2lkIDApIHsgcHJlYW1ibGUgPSAnJzsgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbWl0U3RhdGVtZW50c0FuZENvbnRleHQoZ2VuRmlsZVBhdGgsIHN0bXRzLCBwcmVhbWJsZSkuc291cmNlVGV4dDtcbiAgICB9O1xuICAgIHJldHVybiBUeXBlU2NyaXB0RW1pdHRlcjtcbn0oKSk7XG52YXIgX1RzRW1pdHRlclZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9Uc0VtaXR0ZXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIF9Uc0VtaXR0ZXJWaXNpdG9yKHJlZmVyZW5jZUZpbHRlciwgaW1wb3J0RmlsdGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZhbHNlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWZlcmVuY2VGaWx0ZXIgPSByZWZlcmVuY2VGaWx0ZXI7XG4gICAgICAgIF90aGlzLmltcG9ydEZpbHRlciA9IGltcG9ydEZpbHRlcjtcbiAgICAgICAgX3RoaXMudHlwZUV4cHJlc3Npb24gPSAwO1xuICAgICAgICBfdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBfdGhpcy5yZWV4cG9ydHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh0LCBjdHgsIGRlZmF1bHRUeXBlKSB7XG4gICAgICAgIGlmIChkZWZhdWx0VHlwZSA9PT0gdm9pZCAwKSB7IGRlZmF1bHRUeXBlID0gJ2FueSc7IH1cbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24rKztcbiAgICAgICAgICAgIHQudmlzaXRUeXBlKHRoaXMsIGN0eCk7XG4gICAgICAgICAgICB0aGlzLnR5cGVFeHByZXNzaW9uLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgZGVmYXVsdFR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhc3QudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIGFzdC50eXBlICE9IElORkVSUkVEX1RZUEUpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIFwiKFwiICsgdmFsdWUgKyBcIiBhcyBhbnkpXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwci5jYWxsKHRoaXMsIGFzdCwgY3R4KTtcbiAgICB9O1xuICAgIC8vIFRlbXBvcmFyeSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgc3RyaWN0TnVsbENoZWNrIGVuYWJsZWQgY29uc3VtZXJzIG9mIG5nYyBlbWl0LlxuICAgIC8vIEluIFNOQyBtb2RlLCBbXSBoYXZlIHRoZSB0eXBlIG5ldmVyW10sIHNvIHdlIGNhc3QgaGVyZSB0byBhbnlbXS5cbiAgICAvLyBUT0RPOiBuYXJyb3cgdGhlIGNhc3QgdG8gYSBtb3JlIGV4cGxpY2l0IHR5cGUsIG9yIHVzZSBhIHBhdHRlcm4gdGhhdCBkb2VzIG5vdFxuICAgIC8vIHN0YXJ0IHdpdGggW10uY29uY2F0LiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9wdWxsLzExODQ2XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBpZiAoYXN0LmVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCAnKCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwci5jYWxsKHRoaXMsIGFzdCwgY3R4KTtcbiAgICAgICAgaWYgKGFzdC5lbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgJyBhcyBhbnlbXSknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHRoaXMuX3Zpc2l0SWRlbnRpZmllcihhc3QudmFsdWUsIGFzdC50eXBlUGFyYW1zLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFzc2VydE5vdE51bGxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLnZpc2l0QXNzZXJ0Tm90TnVsbEV4cHIuY2FsbCh0aGlzLCBhc3QsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICchJyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgaWYgKHN0bXQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLkV4cG9ydGVkKSAmJiBzdG10LnZhbHVlIGluc3RhbmNlb2YgRXh0ZXJuYWxFeHByICYmXG4gICAgICAgICAgICAhc3RtdC50eXBlKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgYSByZWV4cG9ydFxuICAgICAgICAgICAgdmFyIF9hID0gc3RtdC52YWx1ZS52YWx1ZSwgbmFtZV8xID0gX2EubmFtZSwgbW9kdWxlTmFtZSA9IF9hLm1vZHVsZU5hbWU7XG4gICAgICAgICAgICBpZiAobW9kdWxlTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciByZWV4cG9ydHMgPSB0aGlzLnJlZXhwb3J0cy5nZXQobW9kdWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVleHBvcnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVleHBvcnRzLnNldChtb2R1bGVOYW1lLCByZWV4cG9ydHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWV4cG9ydHMucHVzaCh7IG5hbWU6IG5hbWVfMSwgYXM6IHN0bXQubmFtZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRXhwb3J0ZWQpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJleHBvcnQgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG10Lmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5GaW5hbCkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBcImNvbnN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwidmFyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcIiBcIiArIHN0bXQubmFtZSk7XG4gICAgICAgIHRoaXMuX3ByaW50Q29sb25UeXBlKHN0bXQudHlwZSwgY3R4KTtcbiAgICAgICAgaWYgKHN0bXQudmFsdWUpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBcIiA9IFwiKTtcbiAgICAgICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCI7XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyYXBwZWROb2RlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB2aXNpdCBhIFdyYXBwZWROb2RlRXhwciB3aGVuIG91dHB1dHRpbmcgVHlwZXNjcmlwdC4nKTtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKDxcIik7XG4gICAgICAgIGFzdC50eXBlLnZpc2l0VHlwZSh0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIj5cIik7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEluc3RhbnRpYXRlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIm5ldyBcIik7XG4gICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24rKztcbiAgICAgICAgYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdGhpcy50eXBlRXhwcmVzc2lvbi0tO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIihcIik7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY3R4LCAnLCcpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIilcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY3R4LnB1c2hDbGFzcyhzdG10KTtcbiAgICAgICAgaWYgKHN0bXQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLkV4cG9ydGVkKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiZXhwb3J0IFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJjbGFzcyBcIiArIHN0bXQubmFtZSk7XG4gICAgICAgIGlmIChzdG10LnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCIgZXh0ZW5kcyBcIik7XG4gICAgICAgICAgICB0aGlzLnR5cGVFeHByZXNzaW9uKys7XG4gICAgICAgICAgICBzdG10LnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24tLTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIiB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHN0bXQuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc0ZpZWxkKGZpZWxkLCBjdHgpOyB9KTtcbiAgICAgICAgaWYgKHN0bXQuY29uc3RydWN0b3JNZXRob2QgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yKHN0bXQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NHZXR0ZXIoZ2V0dGVyLCBjdHgpOyB9KTtcbiAgICAgICAgc3RtdC5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NNZXRob2QobWV0aG9kLCBjdHgpOyB9KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn1cIik7XG4gICAgICAgIGN0eC5wb3BDbGFzcygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0ZpZWxkID0gZnVuY3Rpb24gKGZpZWxkLCBjdHgpIHtcbiAgICAgICAgaWYgKGZpZWxkLmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5Qcml2YXRlKSkge1xuICAgICAgICAgICAgLy8gY29tbWVudCBvdXQgYXMgYSB3b3JrYXJvdW5kIGZvciAjMTA5NjdcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBcIi8qcHJpdmF0ZSovIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLlN0YXRpYykpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCAnc3RhdGljICcpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChudWxsLCBmaWVsZC5uYW1lKTtcbiAgICAgICAgdGhpcy5fcHJpbnRDb2xvblR5cGUoZmllbGQudHlwZSwgY3R4KTtcbiAgICAgICAgaWYgKGZpZWxkLmluaXRpYWxpemVyKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgJyA9ICcpO1xuICAgICAgICAgICAgZmllbGQuaW5pdGlhbGl6ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50bG4obnVsbCwgXCI7XCIpO1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzR2V0dGVyID0gZnVuY3Rpb24gKGdldHRlciwgY3R4KSB7XG4gICAgICAgIGlmIChnZXR0ZXIuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLlByaXZhdGUpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgXCJwcml2YXRlIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQobnVsbCwgXCJnZXQgXCIgKyBnZXR0ZXIubmFtZSArIFwiKClcIik7XG4gICAgICAgIHRoaXMuX3ByaW50Q29sb25UeXBlKGdldHRlci50eXBlLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihudWxsLCBcIiB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGdldHRlci5ib2R5LCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKG51bGwsIFwifVwiKTtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJjb25zdHJ1Y3RvcihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCwgY3R4KSB7XG4gICAgICAgIGlmIChtZXRob2QuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLlByaXZhdGUpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgXCJwcml2YXRlIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQobnVsbCwgbWV0aG9kLm5hbWUgKyBcIihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKG1ldGhvZC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChudWxsLCBcIilcIik7XG4gICAgICAgIHRoaXMuX3ByaW50Q29sb25UeXBlKG1ldGhvZC50eXBlLCBjdHgsICd2b2lkJyk7XG4gICAgICAgIGN0eC5wcmludGxuKG51bGwsIFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4obnVsbCwgXCJ9XCIpO1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGlmIChhc3QubmFtZSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgJ2Z1bmN0aW9uICcpO1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgYXN0Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoYXN0LnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICB0aGlzLl9wcmludENvbG9uVHlwZShhc3QudHlwZSwgY3R4LCAndm9pZCcpO1xuICAgICAgICBpZiAoIWFzdC5uYW1lKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBcIiA9PiBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50bG4oYXN0LCAneycpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGFzdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRXhwb3J0ZWQpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJleHBvcnQgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcImZ1bmN0aW9uIFwiICsgc3RtdC5uYW1lICsgXCIoXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhzdG10LnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiKVwiKTtcbiAgICAgICAgdGhpcy5fcHJpbnRDb2xvblR5cGUoc3RtdC50eXBlLCBjdHgsICd2b2lkJyk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwidHJ5IHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5ib2R5U3RtdHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9IGNhdGNoIChcIiArIENBVENIX0VSUk9SX1ZBUiQxLm5hbWUgKyBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB2YXIgY2F0Y2hTdG10cyA9IFtDQVRDSF9TVEFDS19WQVIkMS5zZXQoQ0FUQ0hfRVJST1JfVkFSJDEucHJvcCgnc3RhY2snLCBudWxsKSkudG9EZWNsU3RtdChudWxsLCBbXG4gICAgICAgICAgICAgICAgU3RtdE1vZGlmaWVyLkZpbmFsXG4gICAgICAgICAgICBdKV0uY29uY2F0KHN0bXQuY2F0Y2hTdG10cyk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGNhdGNoU3RtdHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJ1aWx0aW5UeXBlID0gZnVuY3Rpb24gKHR5cGUsIGN0eCkge1xuICAgICAgICB2YXIgdHlwZVN0cjtcbiAgICAgICAgc3dpdGNoICh0eXBlLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLkJvb2w6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdib29sZWFuJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLkR5bmFtaWM6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdhbnknO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuRnVuY3Rpb246XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdGdW5jdGlvbic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdudW1iZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuSW50OlxuICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnbnVtYmVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLlN0cmluZzpcbiAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5Ob25lOlxuICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnbmV2ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBidWlsdGluIHR5cGUgXCIgKyB0eXBlLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChudWxsLCB0eXBlU3RyKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uVHlwZSA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmIChhc3QudHlwZVBhcmFtcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY3R4LnByaW50KG51bGwsICc8Jyk7XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMudmlzaXRUeXBlKHR5cGUsIGN0eCk7IH0sIGFzdC50eXBlUGFyYW1zLCBjdHgsICcsJyk7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgJz4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFycmF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgpIHtcbiAgICAgICAgdGhpcy52aXNpdFR5cGUodHlwZS5vZiwgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KG51bGwsIFwiW11cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWFwVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KG51bGwsIFwie1trZXk6IHN0cmluZ106XCIpO1xuICAgICAgICB0aGlzLnZpc2l0VHlwZSh0eXBlLnZhbHVlVHlwZSwgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KG51bGwsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuZ2V0QnVpbHRpbk1ldGhvZE5hbWUgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHZhciBuYW1lO1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5OlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnY29uY2F0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5TdWJzY3JpYmVPYnNlcnZhYmxlOlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnc3Vic2NyaWJlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5CaW5kOlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnYmluZCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiBtZXRob2Q6IFwiICsgbWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgcGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBfdGhpcy5fcHJpbnRDb2xvblR5cGUocGFyYW0udHlwZSwgY3R4KTtcbiAgICAgICAgfSwgcGFyYW1zLCBjdHgsICcsJyk7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0SWRlbnRpZmllciA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZVBhcmFtcywgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSwgbW9kdWxlTmFtZSA9IHZhbHVlLm1vZHVsZU5hbWU7XG4gICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZUZpbHRlciAmJiB0aGlzLnJlZmVyZW5jZUZpbHRlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCAnKG51bGwgYXMgYW55KScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2R1bGVOYW1lICYmICghdGhpcy5pbXBvcnRGaWx0ZXIgfHwgIXRoaXMuaW1wb3J0RmlsdGVyKHZhbHVlKSkpIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuZ2V0KG1vZHVsZU5hbWUpO1xuICAgICAgICAgICAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gXCJpXCIgKyB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuc2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuc2V0KG1vZHVsZU5hbWUsIHByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgcHJlZml4ICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChudWxsLCBuYW1lKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZUV4cHJlc3Npb24gPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgaW4gYSB0eXBlIGV4cHJlc3Npb24gdGhhdCByZWZlcnMgdG8gYSBnZW5lcmljIHR5cGUgdGhlbiBzdXBwbHlcbiAgICAgICAgICAgIC8vIHRoZSByZXF1aXJlZCB0eXBlIHBhcmFtZXRlcnMuIElmIHRoZXJlIHdlcmUgbm90IGVub3VnaCB0eXBlIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIC8vIHN1cHBsaWVkLCBzdXBwbHkgYW55IGFzIHRoZSB0eXBlLiBPdXRzaWRlIGEgdHlwZSBleHByZXNzaW9uIHRoZSByZWZlcmVuY2VcbiAgICAgICAgICAgIC8vIHNob3VsZCBub3Qgc3VwcGx5IHR5cGUgcGFyYW1ldGVycyBhbmQgYmUgdHJlYXRlZCBhcyBhIHNpbXBsZSB2YWx1ZSByZWZlcmVuY2VcbiAgICAgICAgICAgIC8vIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBpdHNlbGYuXG4gICAgICAgICAgICB2YXIgc3VwcGxpZWRQYXJhbWV0ZXJzID0gdHlwZVBhcmFtcyB8fCBbXTtcbiAgICAgICAgICAgIGlmIChzdXBwbGllZFBhcmFtZXRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBcIjxcIik7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUudmlzaXRUeXBlKF90aGlzLCBjdHgpOyB9LCB0eXBlUGFyYW1zLCBjdHgsICcsJyk7XG4gICAgICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIFwiPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl9wcmludENvbG9uVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgsIGRlZmF1bHRUeXBlKSB7XG4gICAgICAgIGlmICh0eXBlICE9PSBJTkZFUlJFRF9UWVBFKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgJzonKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRUeXBlKHR5cGUsIGN0eCwgZGVmYXVsdFR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX1RzRW1pdHRlclZpc2l0b3I7XG59KEFic3RyYWN0RW1pdHRlclZpc2l0b3IpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBSZXNvbHZlIGEgYFR5cGVgIGZvciB7QGxpbmsgUGlwZX0uXG4gKlxuICogVGhpcyBpbnRlcmZhY2UgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGFwcGxpY2F0aW9uIGRldmVsb3BlciB0byBjcmVhdGUgY3VzdG9tIGJlaGF2aW9yLlxuICpcbiAqIFNlZSB7QGxpbmsgQ29tcGlsZXJ9XG4gKi9cbnZhciBQaXBlUmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGlwZVJlc29sdmVyKF9yZWZsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gX3JlZmxlY3RvcjtcbiAgICB9XG4gICAgUGlwZVJlc29sdmVyLnByb3RvdHlwZS5pc1BpcGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgdHlwZU1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKHJlc29sdmVGb3J3YXJkUmVmKHR5cGUpKTtcbiAgICAgICAgcmV0dXJuIHR5cGVNZXRhZGF0YSAmJiB0eXBlTWV0YWRhdGEuc29tZShjcmVhdGVQaXBlLmlzVHlwZU9mKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB7QGxpbmsgUGlwZX0gZm9yIGEgZ2l2ZW4gYFR5cGVgLlxuICAgICAqL1xuICAgIFBpcGVSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh0eXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIG1ldGFzID0gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKHJlc29sdmVGb3J3YXJkUmVmKHR5cGUpKTtcbiAgICAgICAgaWYgKG1ldGFzKSB7XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGZpbmRMYXN0KG1ldGFzLCBjcmVhdGVQaXBlLmlzVHlwZU9mKTtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUGlwZSBkZWNvcmF0b3IgZm91bmQgb24gXCIgKyBzdHJpbmdpZnkodHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFBpcGVSZXNvbHZlcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogR2VuZXJhdGVzIGNvZGUgdGhhdCBpcyB1c2VkIHRvIHR5cGUgY2hlY2sgdGVtcGxhdGVzLlxuICovXG52YXIgVHlwZUNoZWNrQ29tcGlsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHlwZUNoZWNrQ29tcGlsZXIob3B0aW9ucywgcmVmbGVjdG9yKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucmVmbGVjdG9yID0gcmVmbGVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBvcnRhbnQgbm90ZXM6XG4gICAgICogLSBUaGlzIG11c3Qgbm90IHByb2R1Y2UgbmV3IGBpbXBvcnRgIHN0YXRlbWVudHMsIGJ1dCBvbmx5IHJlZmVyIHRvIHR5cGVzIG91dHNpZGVcbiAgICAgKiAgIG9mIHRoZSBmaWxlIHZpYSB0aGUgdmFyaWFibGVzIHByb3ZpZGVkIHZpYSBleHRlcm5hbFJlZmVyZW5jZVZhcnMuXG4gICAgICogICBUaGlzIGFsbG93cyBUeXBlc2NyaXB0IHRvIHJldXNlIHRoZSBvbGQgcHJvZ3JhbSdzIHN0cnVjdHVyZSBhcyBubyBpbXBvcnRzIGhhdmUgY2hhbmdlZC5cbiAgICAgKiAtIFRoaXMgbXVzdCBub3QgcHJvZHVjZSBhbnkgZXhwb3J0cywgYXMgdGhpcyB3b3VsZCBwb2xsdXRlIHRoZSAuZC50cyBmaWxlXG4gICAgICogICBhbmQgYWxzbyB2aW9sYXRlIHRoZSBwb2ludCBhYm92ZS5cbiAgICAgKi9cbiAgICBUeXBlQ2hlY2tDb21waWxlci5wcm90b3R5cGUuY29tcGlsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRJZCwgY29tcG9uZW50LCB0ZW1wbGF0ZSwgdXNlZFBpcGVzLCBleHRlcm5hbFJlZmVyZW5jZVZhcnMsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcGlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHVzZWRQaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwaXBlcy5zZXQocC5uYW1lLCBwLnR5cGUucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgIHZhciBlbWJlZGRlZFZpZXdDb3VudCA9IDA7XG4gICAgICAgIHZhciB2aWV3QnVpbGRlckZhY3RvcnkgPSBmdW5jdGlvbiAocGFyZW50LCBndWFyZHMpIHtcbiAgICAgICAgICAgIHZhciBlbWJlZGRlZFZpZXdJbmRleCA9IGVtYmVkZGVkVmlld0NvdW50Kys7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZpZXdCdWlsZGVyKF90aGlzLm9wdGlvbnMsIF90aGlzLnJlZmxlY3RvciwgZXh0ZXJuYWxSZWZlcmVuY2VWYXJzLCBwYXJlbnQsIGNvbXBvbmVudC50eXBlLnJlZmVyZW5jZSwgY29tcG9uZW50LmlzSG9zdCwgZW1iZWRkZWRWaWV3SW5kZXgsIHBpcGVzLCBndWFyZHMsIGN0eCwgdmlld0J1aWxkZXJGYWN0b3J5KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHZpc2l0b3IgPSB2aWV3QnVpbGRlckZhY3RvcnkobnVsbCwgW10pO1xuICAgICAgICB2aXNpdG9yLnZpc2l0QWxsKFtdLCB0ZW1wbGF0ZSk7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLmJ1aWxkKGNvbXBvbmVudElkKTtcbiAgICB9O1xuICAgIHJldHVybiBUeXBlQ2hlY2tDb21waWxlcjtcbn0oKSk7XG52YXIgRFlOQU1JQ19WQVJfTkFNRSA9ICdfYW55JztcbnZhciBUeXBlQ2hlY2tMb2NhbFJlc29sdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGVDaGVja0xvY2FsUmVzb2x2ZXIoKSB7XG4gICAgfVxuICAgIFR5cGVDaGVja0xvY2FsUmVzb2x2ZXIucHJvdG90eXBlLm5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgVHlwZUNoZWNrTG9jYWxSZXNvbHZlci5wcm90b3R5cGUuZ2V0TG9jYWwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gRXZlbnRIYW5kbGVyVmFycy5ldmVudC5uYW1lKSB7XG4gICAgICAgICAgICAvLyBSZWZlcmVuY2VzIHRvIHRoZSBldmVudCBzaG91bGQgbm90IGJlIHR5cGUtY2hlY2tlZC5cbiAgICAgICAgICAgIC8vIFRPRE8oY2h1Y2tqKTogZGV0ZXJtaW5lIGEgYmV0dGVyIHR5cGUgZm9yIHRoZSBldmVudC5cbiAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZShEWU5BTUlDX1ZBUl9OQU1FKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBUeXBlQ2hlY2tMb2NhbFJlc29sdmVyO1xufSgpKTtcbnZhciBkZWZhdWx0UmVzb2x2ZXIgPSBuZXcgVHlwZUNoZWNrTG9jYWxSZXNvbHZlcigpO1xudmFyIFZpZXdCdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdCdWlsZGVyKG9wdGlvbnMsIHJlZmxlY3RvciwgZXh0ZXJuYWxSZWZlcmVuY2VWYXJzLCBwYXJlbnQsIGNvbXBvbmVudCwgaXNIb3N0Q29tcG9uZW50LCBlbWJlZGRlZFZpZXdJbmRleCwgcGlwZXMsIGd1YXJkcywgY3R4LCB2aWV3QnVpbGRlckZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5yZWZsZWN0b3IgPSByZWZsZWN0b3I7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxSZWZlcmVuY2VWYXJzID0gZXh0ZXJuYWxSZWZlcmVuY2VWYXJzO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIHRoaXMuaXNIb3N0Q29tcG9uZW50ID0gaXNIb3N0Q29tcG9uZW50O1xuICAgICAgICB0aGlzLmVtYmVkZGVkVmlld0luZGV4ID0gZW1iZWRkZWRWaWV3SW5kZXg7XG4gICAgICAgIHRoaXMucGlwZXMgPSBwaXBlcztcbiAgICAgICAgdGhpcy5ndWFyZHMgPSBndWFyZHM7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgICB0aGlzLnZpZXdCdWlsZGVyRmFjdG9yeSA9IHZpZXdCdWlsZGVyRmFjdG9yeTtcbiAgICAgICAgdGhpcy5yZWZPdXRwdXRWYXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMudXBkYXRlcyA9IFtdO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLmdldE91dHB1dFZhciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciB2YXJOYW1lO1xuICAgICAgICBpZiAodHlwZSA9PT0gdGhpcy5jb21wb25lbnQgJiYgdGhpcy5pc0hvc3RDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhck5hbWUgPSBEWU5BTUlDX1ZBUl9OQU1FO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHZhck5hbWUgPSB0aGlzLmV4dGVybmFsUmVmZXJlbmNlVmFycy5nZXQodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXJOYW1lID0gRFlOQU1JQ19WQVJfTkFNRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhck5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgU3RhdGU6IHJlZmVycmluZyB0byBhIHR5cGUgd2l0aG91dCBhIHZhcmlhYmxlIFwiICsgSlNPTi5zdHJpbmdpZnkodHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXJOYW1lO1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLmdldFR5cGVHdWFyZEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9fc3ByZWFkKHRoaXMuZ3VhcmRzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXMoYXN0LmRpcmVjdGl2ZXMpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9lID0gKGVfMiA9IHZvaWQgMCwgX192YWx1ZXMoZGlyZWN0aXZlLmlucHV0cykpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBfZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBndWFyZCA9IGRpcmVjdGl2ZS5kaXJlY3RpdmUuZ3VhcmRzW2lucHV0LmRpcmVjdGl2ZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGd1YXJkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZUlmID0gZ3VhcmQgPT09ICdVc2VJZic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWFyZDogZ3VhcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUlmOiB1c2VJZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogeyBjb250ZXh0OiB0aGlzLmNvbXBvbmVudCwgdmFsdWU6IGlucHV0LnZhbHVlIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYiA9IF9lLnJldHVybikpIF9iLmNhbGwoX2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKHZhcmlhYmxlcywgYXN0Tm9kZXMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgICAgIHRlbXBsYXRlVmlzaXRBbGwodGhpcywgYXN0Tm9kZXMpO1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGNvbXBvbmVudElkLCB0YXJnZXRTdGF0ZW1lbnRzKSB7XG4gICAgICAgIHZhciBlXzMsIF9hO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGFyZ2V0U3RhdGVtZW50cyA9PT0gdm9pZCAwKSB7IHRhcmdldFN0YXRlbWVudHMgPSBbXTsgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5idWlsZChjb21wb25lbnRJZCwgdGFyZ2V0U3RhdGVtZW50cyk7IH0pO1xuICAgICAgICB2YXIgdmlld1N0bXRzID0gW3ZhcmlhYmxlKERZTkFNSUNfVkFSX05BTUUpLnNldChOVUxMX0VYUFIpLnRvRGVjbFN0bXQoRFlOQU1JQ19UWVBFKV07XG4gICAgICAgIHZhciBiaW5kaW5nQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnVwZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJlcHJvY2Vzc1VwZGF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbiksIHNvdXJjZVNwYW4gPSBfYS5zb3VyY2VTcGFuLCBjb250ZXh0ID0gX2EuY29udGV4dCwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nSWQgPSBcIlwiICsgYmluZGluZ0NvdW50Kys7XG4gICAgICAgICAgICB2YXIgbmFtZVJlc29sdmVyID0gY29udGV4dCA9PT0gX3RoaXMuY29tcG9uZW50ID8gX3RoaXMgOiBkZWZhdWx0UmVzb2x2ZXI7XG4gICAgICAgICAgICB2YXIgX2IgPSBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKG5hbWVSZXNvbHZlciwgdmFyaWFibGUoX3RoaXMuZ2V0T3V0cHV0VmFyKGNvbnRleHQpKSwgdmFsdWUsIGJpbmRpbmdJZCwgQmluZGluZ0Zvcm0uR2VuZXJhbCksIHN0bXRzID0gX2Iuc3RtdHMsIGN1cnJWYWxFeHByID0gX2IuY3VyclZhbEV4cHI7XG4gICAgICAgICAgICBzdG10cy5wdXNoKG5ldyBFeHByZXNzaW9uU3RhdGVtZW50KGN1cnJWYWxFeHByKSk7XG4gICAgICAgICAgICB2aWV3U3RtdHMucHVzaC5hcHBseSh2aWV3U3RtdHMsIF9fc3ByZWFkKHN0bXRzLm1hcChmdW5jdGlvbiAoc3RtdCkgeyByZXR1cm4gYXBwbHlTb3VyY2VTcGFuVG9TdGF0ZW1lbnRJZk5lZWRlZChzdG10LCBzb3VyY2VTcGFuKTsgfSkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBfYS5zb3VyY2VTcGFuLCBjb250ZXh0ID0gX2EuY29udGV4dCwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nSWQgPSBcIlwiICsgYmluZGluZ0NvdW50Kys7XG4gICAgICAgICAgICB2YXIgbmFtZVJlc29sdmVyID0gY29udGV4dCA9PT0gX3RoaXMuY29tcG9uZW50ID8gX3RoaXMgOiBkZWZhdWx0UmVzb2x2ZXI7XG4gICAgICAgICAgICB2YXIgc3RtdHMgPSBjb252ZXJ0QWN0aW9uQmluZGluZyhuYW1lUmVzb2x2ZXIsIHZhcmlhYmxlKF90aGlzLmdldE91dHB1dFZhcihjb250ZXh0KSksIHZhbHVlLCBiaW5kaW5nSWQpLnN0bXRzO1xuICAgICAgICAgICAgdmlld1N0bXRzLnB1c2guYXBwbHkodmlld1N0bXRzLCBfX3NwcmVhZChzdG10cy5tYXAoZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIGFwcGx5U291cmNlU3BhblRvU3RhdGVtZW50SWZOZWVkZWQoc3RtdCwgc291cmNlU3Bhbik7IH0pKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5ndWFyZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZ3VhcmRFeHByZXNzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHRoaXMuZ3VhcmRzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3VhcmQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9kID0gdGhpcy5wcmVwcm9jZXNzVXBkYXRlRXhwcmVzc2lvbihndWFyZC5leHByZXNzaW9uKSwgY29udGV4dCA9IF9kLmNvbnRleHQsIHZhbHVlID0gX2QudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nSWQgPSBcIlwiICsgYmluZGluZ0NvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lUmVzb2x2ZXIgPSBjb250ZXh0ID09PSB0aGlzLmNvbXBvbmVudCA/IHRoaXMgOiBkZWZhdWx0UmVzb2x2ZXI7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCBzdXBwb3J0IHNpbXBsZSBleHByZXNzaW9ucyBhbmQgaWdub3JlIG90aGVycyBhcyB0aGV5XG4gICAgICAgICAgICAgICAgICAgIC8vIGFyZSB1bmxpa2VseSB0byBhZmZlY3QgdHlwZSBuYXJyb3dpbmcuXG4gICAgICAgICAgICAgICAgICAgIHZhciBfZSA9IGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcobmFtZVJlc29sdmVyLCB2YXJpYWJsZSh0aGlzLmdldE91dHB1dFZhcihjb250ZXh0KSksIHZhbHVlLCBiaW5kaW5nSWQsIEJpbmRpbmdGb3JtLlRyeVNpbXBsZSksIHN0bXRzID0gX2Uuc3RtdHMsIGN1cnJWYWxFeHByID0gX2UuY3VyclZhbEV4cHI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG10cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGd1YXJkQ2xhdXNlID0gZ3VhcmQudXNlSWYgPyBjdXJyVmFsRXhwciA6IHRoaXMuY3R4LmltcG9ydEV4cHIoZ3VhcmQuZ3VhcmQpLmNhbGxGbihbY3VyclZhbEV4cHJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGd1YXJkRXhwcmVzc2lvbiA9IGd1YXJkRXhwcmVzc2lvbiA/IGd1YXJkRXhwcmVzc2lvbi5hbmQoZ3VhcmRDbGF1c2UpIDogZ3VhcmRDbGF1c2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3VhcmRFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdmlld1N0bXRzID0gW25ldyBJZlN0bXQoZ3VhcmRFeHByZXNzaW9uLCB2aWV3U3RtdHMpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdmlld05hbWUgPSBcIl9WaWV3X1wiICsgY29tcG9uZW50SWQgKyBcIl9cIiArIHRoaXMuZW1iZWRkZWRWaWV3SW5kZXg7XG4gICAgICAgIHZhciB2aWV3RmFjdG9yeSA9IG5ldyBEZWNsYXJlRnVuY3Rpb25TdG10KHZpZXdOYW1lLCBbXSwgdmlld1N0bXRzKTtcbiAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoKHZpZXdGYWN0b3J5KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFN0YXRlbWVudHM7XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRCb3VuZFRleHQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhc3RXaXRoU291cmNlID0gYXN0LnZhbHVlO1xuICAgICAgICB2YXIgaW50ZXIgPSBhc3RXaXRoU291cmNlLmFzdDtcbiAgICAgICAgaW50ZXIuZXhwcmVzc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZXhwcikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZXMucHVzaCh7IGNvbnRleHQ6IF90aGlzLmNvbXBvbmVudCwgdmFsdWU6IGV4cHIsIHNvdXJjZVNwYW46IGFzdC5zb3VyY2VTcGFuIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEVtYmVkZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRFbGVtZW50T3JUZW1wbGF0ZShhc3QpO1xuICAgICAgICAvLyBOb3RlOiBUaGUgb2xkIHZpZXcgY29tcGlsZXIgdXNlZCB0byB1c2UgYW4gYGFueWAgdHlwZVxuICAgICAgICAvLyBmb3IgdGhlIGNvbnRleHQgaW4gYW55IGVtYmVkZGVkIHZpZXcuXG4gICAgICAgIC8vIFdlIGtlZXAgdGhpcyBiZWhhaXZvciBiZWhpbmQgYSBmbGFnIGZvciBub3cuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZnVsbFRlbXBsYXRlVHlwZUNoZWNrKSB7XG4gICAgICAgICAgICAvLyBGaW5kIGFueSBhcHBsaWNhYmxlIHR5cGUgZ3VhcmRzLiBGb3IgZXhhbXBsZSwgTmdJZiBoYXMgYSB0eXBlIGd1YXJkIG9uIG5nSWZcbiAgICAgICAgICAgIC8vIChzZWUgTmdJZi5uZ0lmVHlwZUd1YXJkKSB0aGF0IGNhbiBiZSB1c2VkIHRvIGluZGljYXRlIHRoYXQgYSB0ZW1wbGF0ZSBpcyBvbmx5XG4gICAgICAgICAgICAvLyBzdGFtcGVkIG91dCBpZiBuZ0lmIGlzIHRydXRoeSBzbyBhbnkgYmluZGluZ3MgaW4gdGhlIHRlbXBsYXRlIGNhbiBhc3N1bWUgdGhhdCxcbiAgICAgICAgICAgIC8vIGlmIGEgbnVsbGFibGUgdHlwZSBpcyB1c2VkIGZvciBuZ0lmLCB0aGF0IGV4cHJlc3Npb24gaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkLlxuICAgICAgICAgICAgdmFyIGd1YXJkcyA9IHRoaXMuZ2V0VHlwZUd1YXJkRXhwcmVzc2lvbnMoYXN0KTtcbiAgICAgICAgICAgIHZhciBjaGlsZFZpc2l0b3IgPSB0aGlzLnZpZXdCdWlsZGVyRmFjdG9yeSh0aGlzLCBndWFyZHMpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkVmlzaXRvcik7XG4gICAgICAgICAgICBjaGlsZFZpc2l0b3IudmlzaXRBbGwoYXN0LnZhcmlhYmxlcywgYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aXNpdEVsZW1lbnRPclRlbXBsYXRlKGFzdCk7XG4gICAgICAgIHZhciBpbnB1dERlZnMgPSBbXTtcbiAgICAgICAgdmFyIHVwZGF0ZVJlbmRlcmVyRXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgdmFyIG91dHB1dERlZnMgPSBbXTtcbiAgICAgICAgYXN0LmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dEFzdCkge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlcy5wdXNoKHsgY29udGV4dDogX3RoaXMuY29tcG9uZW50LCB2YWx1ZTogaW5wdXRBc3QudmFsdWUsIHNvdXJjZVNwYW46IGlucHV0QXN0LnNvdXJjZVNwYW4gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdC5jaGlsZHJlbik7XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRFbGVtZW50T3JUZW1wbGF0ZSA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYXN0LmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyQXN0KSB7IF90aGlzLnZpc2l0RGlyZWN0aXZlKGRpckFzdCk7IH0pO1xuICAgICAgICBhc3QucmVmZXJlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRWYXJUeXBlID0gbnVsbDtcbiAgICAgICAgICAgIC8vIE5vdGU6IFRoZSBvbGQgdmlldyBjb21waWxlciB1c2VkIHRvIHVzZSBhbiBgYW55YCB0eXBlXG4gICAgICAgICAgICAvLyBmb3IgZGlyZWN0aXZlcyBleHBvc2VkIHZpYSBgZXhwb3J0QXNgLlxuICAgICAgICAgICAgLy8gV2Uga2VlcCB0aGlzIGJlaGFpdm9yIGJlaGluZCBhIGZsYWcgZm9yIG5vdy5cbiAgICAgICAgICAgIGlmIChyZWYudmFsdWUgJiYgcmVmLnZhbHVlLmlkZW50aWZpZXIgJiYgX3RoaXMub3B0aW9ucy5mdWxsVGVtcGxhdGVUeXBlQ2hlY2spIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRWYXJUeXBlID0gcmVmLnZhbHVlLmlkZW50aWZpZXIucmVmZXJlbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0VmFyVHlwZSA9IEJ1aWx0aW5UeXBlTmFtZS5EeW5hbWljO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucmVmT3V0cHV0VmFycy5zZXQocmVmLm5hbWUsIG91dHB1dFZhclR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXN0Lm91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAob3V0cHV0QXN0KSB7XG4gICAgICAgICAgICBfdGhpcy5hY3Rpb25zLnB1c2goeyBjb250ZXh0OiBfdGhpcy5jb21wb25lbnQsIHZhbHVlOiBvdXRwdXRBc3QuaGFuZGxlciwgc291cmNlU3Bhbjogb3V0cHV0QXN0LnNvdXJjZVNwYW4gfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlID0gZnVuY3Rpb24gKGRpckFzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGlyVHlwZSA9IGRpckFzdC5kaXJlY3RpdmUudHlwZS5yZWZlcmVuY2U7XG4gICAgICAgIGRpckFzdC5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZXMucHVzaCh7IGNvbnRleHQ6IF90aGlzLmNvbXBvbmVudCwgdmFsdWU6IGlucHV0LnZhbHVlLCBzb3VyY2VTcGFuOiBpbnB1dC5zb3VyY2VTcGFuIH0pOyB9KTtcbiAgICAgICAgLy8gTm90ZTogVGhlIG9sZCB2aWV3IGNvbXBpbGVyIHVzZWQgdG8gdXNlIGFuIGBhbnlgIHR5cGVcbiAgICAgICAgLy8gZm9yIGV4cHJlc3Npb25zIGluIGhvc3QgcHJvcGVydGllcyAvIGV2ZW50cy5cbiAgICAgICAgLy8gV2Uga2VlcCB0aGlzIGJlaGFpdm9yIGJlaGluZCBhIGZsYWcgZm9yIG5vdy5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mdWxsVGVtcGxhdGVUeXBlQ2hlY2spIHtcbiAgICAgICAgICAgIGRpckFzdC5ob3N0UHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dEFzdCkgeyByZXR1cm4gX3RoaXMudXBkYXRlcy5wdXNoKHsgY29udGV4dDogZGlyVHlwZSwgdmFsdWU6IGlucHV0QXN0LnZhbHVlLCBzb3VyY2VTcGFuOiBpbnB1dEFzdC5zb3VyY2VTcGFuIH0pOyB9KTtcbiAgICAgICAgICAgIGRpckFzdC5ob3N0RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGhvc3RFdmVudEFzdCkgeyByZXR1cm4gX3RoaXMuYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBkaXJUeXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBob3N0RXZlbnRBc3QuaGFuZGxlcixcbiAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBob3N0RXZlbnRBc3Quc291cmNlU3BhblxuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUubm90aWZ5SW1wbGljaXRSZWNlaXZlclVzZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuZ2V0TG9jYWwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PSBFdmVudEhhbmRsZXJWYXJzLmV2ZW50Lm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZSh0aGlzLmdldE91dHB1dFZhcihCdWlsdGluVHlwZU5hbWUuRHluYW1pYykpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGN1cnJCdWlsZGVyID0gdGhpczsgY3VyckJ1aWxkZXI7IGN1cnJCdWlsZGVyID0gY3VyckJ1aWxkZXIucGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0VmFyVHlwZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIC8vIGNoZWNrIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIG91dHB1dFZhclR5cGUgPSBjdXJyQnVpbGRlci5yZWZPdXRwdXRWYXJzLmdldChuYW1lKTtcbiAgICAgICAgICAgIGlmIChvdXRwdXRWYXJUeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICB2YXIgdmFyQXN0ID0gY3VyckJ1aWxkZXIudmFyaWFibGVzLmZpbmQoZnVuY3Rpb24gKHZhckFzdCkgeyByZXR1cm4gdmFyQXN0Lm5hbWUgPT09IG5hbWU7IH0pO1xuICAgICAgICAgICAgICAgIGlmICh2YXJBc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0VmFyVHlwZSA9IEJ1aWx0aW5UeXBlTmFtZS5EeW5hbWljO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdXRwdXRWYXJUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyaWFibGUodGhpcy5nZXRPdXRwdXRWYXIob3V0cHV0VmFyVHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnBpcGVPdXRwdXRWYXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgcGlwZSA9IHRoaXMucGlwZXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIXBpcGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgU3RhdGU6IENvdWxkIG5vdCBmaW5kIHBpcGUgXCIgKyBuYW1lICsgXCIgaW4gdGVtcGxhdGUgb2YgXCIgKyB0aGlzLmNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0cHV0VmFyKHBpcGUpO1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnByZXByb2Nlc3NVcGRhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGV4cHJlc3Npb24uc291cmNlU3BhbixcbiAgICAgICAgICAgIGNvbnRleHQ6IGV4cHJlc3Npb24uY29udGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiBjb252ZXJ0UHJvcGVydHlCaW5kaW5nQnVpbHRpbnMoe1xuICAgICAgICAgICAgICAgIGNyZWF0ZUxpdGVyYWxBcnJheUNvbnZlcnRlcjogZnVuY3Rpb24gKGFyZ0NvdW50KSB7IHJldHVybiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyID0gbGl0ZXJhbEFycihhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogVGhlIG9sZCB2aWV3IGNvbXBpbGVyIHVzZWQgdG8gdXNlIGFuIGBhbnlgIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9wdGlvbnMuZnVsbFRlbXBsYXRlVHlwZUNoZWNrID8gYXJyIDogYXJyLmNhc3QoRFlOQU1JQ19UWVBFKTtcbiAgICAgICAgICAgICAgICB9OyB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUxpdGVyYWxNYXBDb252ZXJ0ZXI6IGZ1bmN0aW9uIChrZXlzKSB7IHJldHVybiBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyaWVzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGssIGkpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGsua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlZDogay5xdW90ZWQsXG4gICAgICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IGxpdGVyYWxNYXAoZW50cmllcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFRoZSBvbGQgdmlldyBjb21waWxlciB1c2VkIHRvIHVzZSBhbiBgYW55YCB0eXBlXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBtYXBzLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy5mdWxsVGVtcGxhdGVUeXBlQ2hlY2sgPyBtYXAgOiBtYXAuY2FzdChEWU5BTUlDX1RZUEUpO1xuICAgICAgICAgICAgICAgIH07IH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlUGlwZUNvbnZlcnRlcjogZnVuY3Rpb24gKG5hbWUsIGFyZ0NvdW50KSB7IHJldHVybiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBUaGUgb2xkIHZpZXcgY29tcGlsZXIgdXNlZCB0byB1c2UgYW4gYGFueWAgdHlwZVxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgcGlwZXMuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwaXBlRXhwciA9IF90aGlzLm9wdGlvbnMuZnVsbFRlbXBsYXRlVHlwZUNoZWNrID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlKF90aGlzLnBpcGVPdXRwdXRWYXIobmFtZSkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlKF90aGlzLmdldE91dHB1dFZhcihCdWlsdGluVHlwZU5hbWUuRHluYW1pYykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGlwZUV4cHIuY2FsbE1ldGhvZCgndHJhbnNmb3JtJywgYXJncyk7XG4gICAgICAgICAgICAgICAgfTsgfSxcbiAgICAgICAgICAgIH0sIGV4cHJlc3Npb24udmFsdWUpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXROZ0NvbnRlbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0VmFyaWFibGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RXZlbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudFByb3BlcnR5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEF0dHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgcmV0dXJuIFZpZXdCdWlsZGVyO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIENMQVNTX0FUVFIkMSA9ICdjbGFzcyc7XG52YXIgU1RZTEVfQVRUUiA9ICdzdHlsZSc7XG52YXIgSU1QTElDSVRfVEVNUExBVEVfVkFSID0gJ1xcJGltcGxpY2l0JztcbnZhciBWaWV3Q29tcGlsZVJlc3VsdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3Q29tcGlsZVJlc3VsdCh2aWV3Q2xhc3NWYXIsIHJlbmRlcmVyVHlwZVZhcikge1xuICAgICAgICB0aGlzLnZpZXdDbGFzc1ZhciA9IHZpZXdDbGFzc1ZhcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlclR5cGVWYXIgPSByZW5kZXJlclR5cGVWYXI7XG4gICAgfVxuICAgIHJldHVybiBWaWV3Q29tcGlsZVJlc3VsdDtcbn0oKSk7XG52YXIgVmlld0NvbXBpbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdDb21waWxlcihfcmVmbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgfVxuICAgIFZpZXdDb21waWxlci5wcm90b3R5cGUuY29tcGlsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChvdXRwdXRDdHgsIGNvbXBvbmVudCwgdGVtcGxhdGUsIHN0eWxlcywgdXNlZFBpcGVzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGVtYmVkZGVkVmlld0NvdW50ID0gMDtcbiAgICAgICAgdmFyIHN0YXRpY1F1ZXJ5SWRzID0gZmluZFN0YXRpY1F1ZXJ5SWRzKHRlbXBsYXRlKTtcbiAgICAgICAgdmFyIHJlbmRlckNvbXBvbmVudFZhck5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghY29tcG9uZW50LmlzSG9zdCkge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlXzEgPSBjb21wb25lbnQudGVtcGxhdGU7XG4gICAgICAgICAgICB2YXIgY3VzdG9tUmVuZGVyRGF0YSA9IFtdO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlXzEuYW5pbWF0aW9ucyAmJiB0ZW1wbGF0ZV8xLmFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tUmVuZGVyRGF0YS5wdXNoKG5ldyBMaXRlcmFsTWFwRW50cnkoJ2FuaW1hdGlvbicsIGNvbnZlcnRWYWx1ZVRvT3V0cHV0QXN0KG91dHB1dEN0eCwgdGVtcGxhdGVfMS5hbmltYXRpb25zKSwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlbmRlckNvbXBvbmVudFZhciA9IHZhcmlhYmxlKHJlbmRlcmVyVHlwZU5hbWUoY29tcG9uZW50LnR5cGUucmVmZXJlbmNlKSk7XG4gICAgICAgICAgICByZW5kZXJDb21wb25lbnRWYXJOYW1lID0gcmVuZGVyQ29tcG9uZW50VmFyLm5hbWU7XG4gICAgICAgICAgICBvdXRwdXRDdHguc3RhdGVtZW50cy5wdXNoKHJlbmRlckNvbXBvbmVudFZhclxuICAgICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihJZGVudGlmaWVycy5jcmVhdGVSZW5kZXJlclR5cGUyKS5jYWxsRm4oW25ldyBMaXRlcmFsTWFwRXhwcihbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBMaXRlcmFsTWFwRW50cnkoJ2VuY2Fwc3VsYXRpb24nLCBsaXRlcmFsKHRlbXBsYXRlXzEuZW5jYXBzdWxhdGlvbiksIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IExpdGVyYWxNYXBFbnRyeSgnc3R5bGVzJywgc3R5bGVzLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBMaXRlcmFsTWFwRW50cnkoJ2RhdGEnLCBuZXcgTGl0ZXJhbE1hcEV4cHIoY3VzdG9tUmVuZGVyRGF0YSksIGZhbHNlKVxuICAgICAgICAgICAgICAgIF0pXSkpXG4gICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQoaW1wb3J0VHlwZShJZGVudGlmaWVycy5SZW5kZXJlclR5cGUyKSwgW1N0bXRNb2RpZmllci5GaW5hbCwgU3RtdE1vZGlmaWVyLkV4cG9ydGVkXSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aWV3QnVpbGRlckZhY3RvcnkgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgZW1iZWRkZWRWaWV3SW5kZXggPSBlbWJlZGRlZFZpZXdDb3VudCsrO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWV3QnVpbGRlciQxKF90aGlzLl9yZWZsZWN0b3IsIG91dHB1dEN0eCwgcGFyZW50LCBjb21wb25lbnQsIGVtYmVkZGVkVmlld0luZGV4LCB1c2VkUGlwZXMsIHN0YXRpY1F1ZXJ5SWRzLCB2aWV3QnVpbGRlckZhY3RvcnkpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdmlzaXRvciA9IHZpZXdCdWlsZGVyRmFjdG9yeShudWxsKTtcbiAgICAgICAgdmlzaXRvci52aXNpdEFsbChbXSwgdGVtcGxhdGUpO1xuICAgICAgICAoX2EgPSBvdXRwdXRDdHguc3RhdGVtZW50cykucHVzaC5hcHBseShfYSwgX19zcHJlYWQodmlzaXRvci5idWlsZCgpKSk7XG4gICAgICAgIHJldHVybiBuZXcgVmlld0NvbXBpbGVSZXN1bHQodmlzaXRvci52aWV3TmFtZSwgcmVuZGVyQ29tcG9uZW50VmFyTmFtZSk7XG4gICAgfTtcbiAgICByZXR1cm4gVmlld0NvbXBpbGVyO1xufSgpKTtcbnZhciBMT0dfVkFSJDEgPSB2YXJpYWJsZSgnX2wnKTtcbnZhciBWSUVXX1ZBUiA9IHZhcmlhYmxlKCdfdicpO1xudmFyIENIRUNLX1ZBUiA9IHZhcmlhYmxlKCdfY2snKTtcbnZhciBDT01QX1ZBUiA9IHZhcmlhYmxlKCdfY28nKTtcbnZhciBFVkVOVF9OQU1FX1ZBUiA9IHZhcmlhYmxlKCdlbicpO1xudmFyIEFMTE9XX0RFRkFVTFRfVkFSID0gdmFyaWFibGUoXCJhZFwiKTtcbnZhciBWaWV3QnVpbGRlciQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdCdWlsZGVyKHJlZmxlY3Rvciwgb3V0cHV0Q3R4LCBwYXJlbnQsIGNvbXBvbmVudCwgZW1iZWRkZWRWaWV3SW5kZXgsIHVzZWRQaXBlcywgc3RhdGljUXVlcnlJZHMsIHZpZXdCdWlsZGVyRmFjdG9yeSkge1xuICAgICAgICB0aGlzLnJlZmxlY3RvciA9IHJlZmxlY3RvcjtcbiAgICAgICAgdGhpcy5vdXRwdXRDdHggPSBvdXRwdXRDdHg7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5lbWJlZGRlZFZpZXdJbmRleCA9IGVtYmVkZGVkVmlld0luZGV4O1xuICAgICAgICB0aGlzLnVzZWRQaXBlcyA9IHVzZWRQaXBlcztcbiAgICAgICAgdGhpcy5zdGF0aWNRdWVyeUlkcyA9IHN0YXRpY1F1ZXJ5SWRzO1xuICAgICAgICB0aGlzLnZpZXdCdWlsZGVyRmFjdG9yeSA9IHZpZXdCdWlsZGVyRmFjdG9yeTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLnB1cmVQaXBlTm9kZUluZGljZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvLyBOZWVkIE9iamVjdC5jcmVhdGUgc28gdGhhdCB3ZSBkb24ndCBoYXZlIGJ1aWx0aW4gdmFsdWVzLi4uXG4gICAgICAgIHRoaXMucmVmTm9kZUluZGljZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8vIFRPRE8odGJvc2NoKTogVGhlIG9sZCB2aWV3IGNvbXBpbGVyIHVzZWQgdG8gdXNlIGFuIGBhbnlgIHR5cGVcbiAgICAgICAgLy8gZm9yIHRoZSBjb250ZXh0IGluIGFueSBlbWJlZGRlZCB2aWV3LiBXZSBrZWVwIHRoaXMgYmVoYWl2b3IgZm9yIG5vd1xuICAgICAgICAvLyB0byBiZSBhYmxlIHRvIGludHJvZHVjZSB0aGUgbmV3IHZpZXcgY29tcGlsZXIgd2l0aG91dCB0b28gbWFueSBlcnJvcnMuXG4gICAgICAgIHRoaXMuY29tcFR5cGUgPSB0aGlzLmVtYmVkZGVkVmlld0luZGV4ID4gMCA/XG4gICAgICAgICAgICBEWU5BTUlDX1RZUEUgOlxuICAgICAgICAgICAgZXhwcmVzc2lvblR5cGUob3V0cHV0Q3R4LmltcG9ydEV4cHIodGhpcy5jb21wb25lbnQudHlwZS5yZWZlcmVuY2UpKTtcbiAgICAgICAgdGhpcy52aWV3TmFtZSA9IHZpZXdDbGFzc05hbWUodGhpcy5jb21wb25lbnQudHlwZS5yZWZlcmVuY2UsIHRoaXMuZW1iZWRkZWRWaWV3SW5kZXgpO1xuICAgIH1cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAodmFyaWFibGVzLCBhc3ROb2Rlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBwaXBlcyBmb3IgdGhlIHB1cmUgcGlwZXMgaW1tZWRpYXRlbHksIHNvIHRoYXQgd2Uga25vdyB0aGVpciBpbmRpY2VzLlxuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnVzZWRQaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBpcGUucHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wdXJlUGlwZU5vZGVJbmRpY2VzW3BpcGUubmFtZV0gPSBfdGhpcy5fY3JlYXRlUGlwZShudWxsLCBwaXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgcXVlcnlJZHNfMSA9IHN0YXRpY1ZpZXdRdWVyeUlkcyh0aGlzLnN0YXRpY1F1ZXJ5SWRzKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnZpZXdRdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5LCBxdWVyeUluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogcXVlcmllcyBzdGFydCB3aXRoIGlkIDEgc28gd2UgY2FuIHVzZSB0aGUgbnVtYmVyIGluIGEgQmxvb20gZmlsdGVyIVxuICAgICAgICAgICAgICAgIHZhciBxdWVyeUlkID0gcXVlcnlJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgdmFyIGJpbmRpbmdUeXBlID0gcXVlcnkuZmlyc3QgPyAwIC8qIEZpcnN0ICovIDogMSAvKiBBbGwgKi87XG4gICAgICAgICAgICAgICAgdmFyIGZsYWdzID0gMTM0MjE3NzI4IC8qIFR5cGVWaWV3UXVlcnkgKi8gfCBjYWxjU3RhdGljRHluYW1pY1F1ZXJ5RmxhZ3MocXVlcnlJZHNfMSwgcXVlcnlJZCwgcXVlcnkpO1xuICAgICAgICAgICAgICAgIF90aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU3BhbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUZsYWdzOiBmbGFncyxcbiAgICAgICAgICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihJZGVudGlmaWVycy5xdWVyeURlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpdGVyYWwoZmxhZ3MpLCBsaXRlcmFsKHF1ZXJ5SWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IExpdGVyYWxNYXBFeHByKFtuZXcgTGl0ZXJhbE1hcEVudHJ5KHF1ZXJ5LnByb3BlcnR5TmFtZSwgbGl0ZXJhbChiaW5kaW5nVHlwZSksIGZhbHNlKV0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3ROb2Rlcyk7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiAoYXN0Tm9kZXMubGVuZ3RoID09PSAwIHx8IG5lZWRzQWRkaXRpb25hbFJvb3ROb2RlKGFzdE5vZGVzKSkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSB2aWV3IGlzIGFuIGVtYmVkZGVkIHZpZXcsIHRoZW4gd2UgbmVlZCB0byBhZGQgYW4gYWRkaXRpb25hbCByb290IG5vZGUgaW4gc29tZSBjYXNlc1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgc291cmNlU3BhbjogbnVsbCxcbiAgICAgICAgICAgICAgICBub2RlRmxhZ3M6IDEgLyogVHlwZUVsZW1lbnQgKi8sXG4gICAgICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihJZGVudGlmaWVycy5hbmNob3JEZWYpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWwoMCAvKiBOb25lICovKSwgTlVMTF9FWFBSLCBOVUxMX0VYUFIsIGxpdGVyYWwoMClcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAodGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgICBpZiAodGFyZ2V0U3RhdGVtZW50cyA9PT0gdm9pZCAwKSB7IHRhcmdldFN0YXRlbWVudHMgPSBbXTsgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5idWlsZCh0YXJnZXRTdGF0ZW1lbnRzKTsgfSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX2NyZWF0ZU5vZGVFeHByZXNzaW9ucygpLCB1cGRhdGVSZW5kZXJlclN0bXRzID0gX2EudXBkYXRlUmVuZGVyZXJTdG10cywgdXBkYXRlRGlyZWN0aXZlc1N0bXRzID0gX2EudXBkYXRlRGlyZWN0aXZlc1N0bXRzLCBub2RlRGVmRXhwcnMgPSBfYS5ub2RlRGVmRXhwcnM7XG4gICAgICAgIHZhciB1cGRhdGVSZW5kZXJlckZuID0gdGhpcy5fY3JlYXRlVXBkYXRlRm4odXBkYXRlUmVuZGVyZXJTdG10cyk7XG4gICAgICAgIHZhciB1cGRhdGVEaXJlY3RpdmVzRm4gPSB0aGlzLl9jcmVhdGVVcGRhdGVGbih1cGRhdGVEaXJlY3RpdmVzU3RtdHMpO1xuICAgICAgICB2YXIgdmlld0ZsYWdzID0gMCAvKiBOb25lICovO1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50ICYmIHRoaXMuY29tcG9uZW50LmNoYW5nZURldGVjdGlvbiA9PT0gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoKSB7XG4gICAgICAgICAgICB2aWV3RmxhZ3MgfD0gMiAvKiBPblB1c2ggKi87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpZXdGYWN0b3J5ID0gbmV3IERlY2xhcmVGdW5jdGlvblN0bXQodGhpcy52aWV3TmFtZSwgW25ldyBGblBhcmFtKExPR19WQVIkMS5uYW1lKV0sIFtuZXcgUmV0dXJuU3RhdGVtZW50KGltcG9ydEV4cHIoSWRlbnRpZmllcnMudmlld0RlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKHZpZXdGbGFncyksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbEFycihub2RlRGVmRXhwcnMpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZURpcmVjdGl2ZXNGbixcbiAgICAgICAgICAgICAgICB1cGRhdGVSZW5kZXJlckZuLFxuICAgICAgICAgICAgXSkpXSwgaW1wb3J0VHlwZShJZGVudGlmaWVycy5WaWV3RGVmaW5pdGlvbiksIHRoaXMuZW1iZWRkZWRWaWV3SW5kZXggPT09IDAgPyBbU3RtdE1vZGlmaWVyLkV4cG9ydGVkXSA6IFtdKTtcbiAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoKHZpZXdGYWN0b3J5KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFN0YXRlbWVudHM7XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZVVwZGF0ZUZuID0gZnVuY3Rpb24gKHVwZGF0ZVN0bXRzKSB7XG4gICAgICAgIHZhciB1cGRhdGVGbjtcbiAgICAgICAgaWYgKHVwZGF0ZVN0bXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwcmVTdG10cyA9IFtdO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudC5pc0hvc3QgJiYgZmluZFJlYWRWYXJOYW1lcyh1cGRhdGVTdG10cykuaGFzKENPTVBfVkFSLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcHJlU3RtdHMucHVzaChDT01QX1ZBUi5zZXQoVklFV19WQVIucHJvcCgnY29tcG9uZW50JykpLnRvRGVjbFN0bXQodGhpcy5jb21wVHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlRm4gPSBmbihbXG4gICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oQ0hFQ0tfVkFSLm5hbWUsIElORkVSUkVEX1RZUEUpLFxuICAgICAgICAgICAgICAgIG5ldyBGblBhcmFtKFZJRVdfVkFSLm5hbWUsIElORkVSUkVEX1RZUEUpXG4gICAgICAgICAgICBdLCBfX3NwcmVhZChwcmVTdG10cywgdXBkYXRlU3RtdHMpLCBJTkZFUlJFRF9UWVBFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZUZuID0gTlVMTF9FWFBSO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cGRhdGVGbjtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdE5nQ29udGVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gbmdDb250ZW50RGVmKG5nQ29udGVudEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXIpOiBOb2RlRGVmO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGFzdC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgbm9kZUZsYWdzOiA4IC8qIFR5cGVOZ0NvbnRlbnQgKi8sXG4gICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKElkZW50aWZpZXJzLm5nQ29udGVudERlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGFzdC5uZ0NvbnRlbnRJbmRleCksIGxpdGVyYWwoYXN0LmluZGV4KVxuICAgICAgICAgICAgXSlcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gU3RhdGljIHRleHQgbm9kZXMgaGF2ZSBubyBjaGVjayBmdW5jdGlvblxuICAgICAgICB2YXIgY2hlY2tJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGFzdC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgbm9kZUZsYWdzOiAyIC8qIFR5cGVUZXh0ICovLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihJZGVudGlmaWVycy50ZXh0RGVmKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoY2hlY2tJbmRleCksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChhc3QubmdDb250ZW50SW5kZXgpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWxBcnIoW2xpdGVyYWwoYXN0LnZhbHVlKV0pLFxuICAgICAgICAgICAgXSlcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbm9kZUluZGV4ID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIC8vIHJlc2VydmUgdGhlIHNwYWNlIGluIHRoZSBub2RlRGVmcyBhcnJheVxuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgIHZhciBhc3RXaXRoU291cmNlID0gYXN0LnZhbHVlO1xuICAgICAgICB2YXIgaW50ZXIgPSBhc3RXaXRoU291cmNlLmFzdDtcbiAgICAgICAgdmFyIHVwZGF0ZVJlbmRlcmVyRXhwcmVzc2lvbnMgPSBpbnRlci5leHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKGV4cHIsIGJpbmRpbmdJbmRleCkgeyByZXR1cm4gX3RoaXMuX3ByZXByb2Nlc3NVcGRhdGVFeHByZXNzaW9uKHsgbm9kZUluZGV4OiBub2RlSW5kZXgsIGJpbmRpbmdJbmRleDogYmluZGluZ0luZGV4LCBzb3VyY2VTcGFuOiBhc3Quc291cmNlU3BhbiwgY29udGV4dDogQ09NUF9WQVIsIHZhbHVlOiBleHByIH0pOyB9KTtcbiAgICAgICAgLy8gQ2hlY2sgaW5kZXggaXMgdGhlIHNhbWUgYXMgdGhlIG5vZGUgaW5kZXggZHVyaW5nIGNvbXBpbGF0aW9uXG4gICAgICAgIC8vIFRoZXkgbWlnaHQgb25seSBkaWZmZXIgYXQgcnVudGltZVxuICAgICAgICB2YXIgY2hlY2tJbmRleCA9IG5vZGVJbmRleDtcbiAgICAgICAgdGhpcy5ub2Rlc1tub2RlSW5kZXhdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGFzdC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgbm9kZUZsYWdzOiAyIC8qIFR5cGVUZXh0ICovLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihJZGVudGlmaWVycy50ZXh0RGVmKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoY2hlY2tJbmRleCksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChhc3QubmdDb250ZW50SW5kZXgpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWxBcnIoaW50ZXIuc3RyaW5ncy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIGxpdGVyYWwocyk7IH0pKSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgdXBkYXRlUmVuZGVyZXI6IHVwZGF0ZVJlbmRlcmVyRXhwcmVzc2lvbnNcbiAgICAgICAgfSk7IH07XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRFbWJlZGRlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbm9kZUluZGV4ID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIC8vIHJlc2VydmUgdGhlIHNwYWNlIGluIHRoZSBub2RlRGVmcyBhcnJheVxuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3Zpc2l0RWxlbWVudE9yVGVtcGxhdGUobm9kZUluZGV4LCBhc3QpLCBmbGFncyA9IF9hLmZsYWdzLCBxdWVyeU1hdGNoZXNFeHByID0gX2EucXVlcnlNYXRjaGVzRXhwciwgaG9zdEV2ZW50cyA9IF9hLmhvc3RFdmVudHM7XG4gICAgICAgIHZhciBjaGlsZFZpc2l0b3IgPSB0aGlzLnZpZXdCdWlsZGVyRmFjdG9yeSh0aGlzKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkVmlzaXRvcik7XG4gICAgICAgIGNoaWxkVmlzaXRvci52aXNpdEFsbChhc3QudmFyaWFibGVzLCBhc3QuY2hpbGRyZW4pO1xuICAgICAgICB2YXIgY2hpbGRDb3VudCA9IHRoaXMubm9kZXMubGVuZ3RoIC0gbm9kZUluZGV4IC0gMTtcbiAgICAgICAgLy8gYW5jaG9yRGVmKFxuICAgICAgICAvLyAgIGZsYWdzOiBOb2RlRmxhZ3MsIG1hdGNoZWRRdWVyaWVzOiBbc3RyaW5nLCBRdWVyeVZhbHVlVHlwZV1bXSwgbmdDb250ZW50SW5kZXg6IG51bWJlcixcbiAgICAgICAgLy8gICBjaGlsZENvdW50OiBudW1iZXIsIGhhbmRsZUV2ZW50Rm4/OiBFbGVtZW50SGFuZGxlRXZlbnRGbiwgdGVtcGxhdGVGYWN0b3J5PzpcbiAgICAgICAgLy8gICBWaWV3RGVmaW5pdGlvbkZhY3RvcnkpOiBOb2RlRGVmO1xuICAgICAgICB0aGlzLm5vZGVzW25vZGVJbmRleF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3BhbjogYXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDEgLyogVHlwZUVsZW1lbnQgKi8gfCBmbGFncyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuYW5jaG9yRGVmKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoZmxhZ3MpLFxuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlc0V4cHIsXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChhc3QubmdDb250ZW50SW5kZXgpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoY2hpbGRDb3VudCksXG4gICAgICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZUVsZW1lbnRIYW5kbGVFdmVudEZuKG5vZGVJbmRleCwgaG9zdEV2ZW50cyksXG4gICAgICAgICAgICAgICAgdmFyaWFibGUoY2hpbGRWaXNpdG9yLnZpZXdOYW1lKSxcbiAgICAgICAgICAgIF0pXG4gICAgICAgIH0pOyB9O1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyByZXNlcnZlIHRoZSBzcGFjZSBpbiB0aGUgbm9kZURlZnMgYXJyYXkgc28gd2UgY2FuIGFkZCBjaGlsZHJlblxuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgIC8vIFVzaW5nIGEgbnVsbCBlbGVtZW50IG5hbWUgY3JlYXRlcyBhbiBhbmNob3IuXG4gICAgICAgIHZhciBlbE5hbWUgPSBpc05nQ29udGFpbmVyKGFzdC5uYW1lKSA/IG51bGwgOiBhc3QubmFtZTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fdmlzaXRFbGVtZW50T3JUZW1wbGF0ZShub2RlSW5kZXgsIGFzdCksIGZsYWdzID0gX2EuZmxhZ3MsIHVzZWRFdmVudHMgPSBfYS51c2VkRXZlbnRzLCBxdWVyeU1hdGNoZXNFeHByID0gX2EucXVlcnlNYXRjaGVzRXhwciwgZGlySG9zdEJpbmRpbmdzID0gX2EuaG9zdEJpbmRpbmdzLCBob3N0RXZlbnRzID0gX2EuaG9zdEV2ZW50cztcbiAgICAgICAgdmFyIGlucHV0RGVmcyA9IFtdO1xuICAgICAgICB2YXIgdXBkYXRlUmVuZGVyZXJFeHByZXNzaW9ucyA9IFtdO1xuICAgICAgICB2YXIgb3V0cHV0RGVmcyA9IFtdO1xuICAgICAgICBpZiAoZWxOYW1lKSB7XG4gICAgICAgICAgICB2YXIgaG9zdEJpbmRpbmdzID0gYXN0LmlucHV0c1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGlucHV0QXN0KSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IENPTVBfVkFSLFxuICAgICAgICAgICAgICAgIGlucHV0QXN0OiBpbnB1dEFzdCxcbiAgICAgICAgICAgICAgICBkaXJBc3Q6IG51bGwsXG4gICAgICAgICAgICB9KTsgfSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KGRpckhvc3RCaW5kaW5ncyk7XG4gICAgICAgICAgICBpZiAoaG9zdEJpbmRpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVJlbmRlcmVyRXhwcmVzc2lvbnMgPVxuICAgICAgICAgICAgICAgICAgICBob3N0QmluZGluZ3MubWFwKGZ1bmN0aW9uIChob3N0QmluZGluZywgYmluZGluZ0luZGV4KSB7IHJldHVybiBfdGhpcy5fcHJlcHJvY2Vzc1VwZGF0ZUV4cHJlc3Npb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogaG9zdEJpbmRpbmcuY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleDogbm9kZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZ0luZGV4OiBiaW5kaW5nSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBob3N0QmluZGluZy5pbnB1dEFzdC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGhvc3RCaW5kaW5nLmlucHV0QXN0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICBpbnB1dERlZnMgPSBob3N0QmluZGluZ3MubWFwKGZ1bmN0aW9uIChob3N0QmluZGluZykgeyByZXR1cm4gZWxlbWVudEJpbmRpbmdEZWYoaG9zdEJpbmRpbmcuaW5wdXRBc3QsIGhvc3RCaW5kaW5nLmRpckFzdCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0RGVmcyA9IHVzZWRFdmVudHMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHRhcmdldCA9IF9iWzBdLCBldmVudE5hbWUgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGl0ZXJhbEFycihbbGl0ZXJhbCh0YXJnZXQpLCBsaXRlcmFsKGV2ZW50TmFtZSldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlVmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgdmFyIGNoaWxkQ291bnQgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIG5vZGVJbmRleCAtIDE7XG4gICAgICAgIHZhciBjb21wQXN0ID0gYXN0LmRpcmVjdGl2ZXMuZmluZChmdW5jdGlvbiAoZGlyQXN0KSB7IHJldHVybiBkaXJBc3QuZGlyZWN0aXZlLmlzQ29tcG9uZW50OyB9KTtcbiAgICAgICAgdmFyIGNvbXBSZW5kZXJlclR5cGUgPSBOVUxMX0VYUFI7XG4gICAgICAgIHZhciBjb21wVmlldyA9IE5VTExfRVhQUjtcbiAgICAgICAgaWYgKGNvbXBBc3QpIHtcbiAgICAgICAgICAgIGNvbXBWaWV3ID0gdGhpcy5vdXRwdXRDdHguaW1wb3J0RXhwcihjb21wQXN0LmRpcmVjdGl2ZS5jb21wb25lbnRWaWV3VHlwZSk7XG4gICAgICAgICAgICBjb21wUmVuZGVyZXJUeXBlID0gdGhpcy5vdXRwdXRDdHguaW1wb3J0RXhwcihjb21wQXN0LmRpcmVjdGl2ZS5yZW5kZXJlclR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGluZGV4IGlzIHRoZSBzYW1lIGFzIHRoZSBub2RlIGluZGV4IGR1cmluZyBjb21waWxhdGlvblxuICAgICAgICAvLyBUaGV5IG1pZ2h0IG9ubHkgZGlmZmVyIGF0IHJ1bnRpbWVcbiAgICAgICAgdmFyIGNoZWNrSW5kZXggPSBub2RlSW5kZXg7XG4gICAgICAgIHRoaXMubm9kZXNbbm9kZUluZGV4XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBhc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogMSAvKiBUeXBlRWxlbWVudCAqLyB8IGZsYWdzLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihJZGVudGlmaWVycy5lbGVtZW50RGVmKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoY2hlY2tJbmRleCksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChmbGFncyksXG4gICAgICAgICAgICAgICAgcXVlcnlNYXRjaGVzRXhwcixcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGFzdC5uZ0NvbnRlbnRJbmRleCksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChjaGlsZENvdW50KSxcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGVsTmFtZSksXG4gICAgICAgICAgICAgICAgZWxOYW1lID8gZml4ZWRBdHRyc0RlZihhc3QpIDogTlVMTF9FWFBSLFxuICAgICAgICAgICAgICAgIGlucHV0RGVmcy5sZW5ndGggPyBsaXRlcmFsQXJyKGlucHV0RGVmcykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICAgICAgb3V0cHV0RGVmcy5sZW5ndGggPyBsaXRlcmFsQXJyKG91dHB1dERlZnMpIDogTlVMTF9FWFBSLFxuICAgICAgICAgICAgICAgIF90aGlzLl9jcmVhdGVFbGVtZW50SGFuZGxlRXZlbnRGbihub2RlSW5kZXgsIGhvc3RFdmVudHMpLFxuICAgICAgICAgICAgICAgIGNvbXBWaWV3LFxuICAgICAgICAgICAgICAgIGNvbXBSZW5kZXJlclR5cGUsXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHVwZGF0ZVJlbmRlcmVyOiB1cGRhdGVSZW5kZXJlckV4cHJlc3Npb25zXG4gICAgICAgIH0pOyB9O1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl92aXNpdEVsZW1lbnRPclRlbXBsYXRlID0gZnVuY3Rpb24gKG5vZGVJbmRleCwgYXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmbGFncyA9IDAgLyogTm9uZSAqLztcbiAgICAgICAgaWYgKGFzdC5oYXNWaWV3Q29udGFpbmVyKSB7XG4gICAgICAgICAgICBmbGFncyB8PSAxNjc3NzIxNiAvKiBFbWJlZGRlZFZpZXdzICovO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1c2VkRXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICBhc3Qub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hID0gZWxlbWVudEV2ZW50TmFtZUFuZFRhcmdldChldmVudCwgbnVsbCksIG5hbWUgPSBfYS5uYW1lLCB0YXJnZXQgPSBfYS50YXJnZXQ7XG4gICAgICAgICAgICB1c2VkRXZlbnRzLnNldChlbGVtZW50RXZlbnRGdWxsTmFtZSh0YXJnZXQsIG5hbWUpLCBbdGFyZ2V0LCBuYW1lXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhc3QuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJBc3QpIHtcbiAgICAgICAgICAgIGRpckFzdC5ob3N0RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gZWxlbWVudEV2ZW50TmFtZUFuZFRhcmdldChldmVudCwgZGlyQXN0KSwgbmFtZSA9IF9hLm5hbWUsIHRhcmdldCA9IF9hLnRhcmdldDtcbiAgICAgICAgICAgICAgICB1c2VkRXZlbnRzLnNldChlbGVtZW50RXZlbnRGdWxsTmFtZSh0YXJnZXQsIG5hbWUpLCBbdGFyZ2V0LCBuYW1lXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBob3N0QmluZGluZ3MgPSBbXTtcbiAgICAgICAgdmFyIGhvc3RFdmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5fdmlzaXRDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJQcm92aWRlcihhc3QuZGlyZWN0aXZlcyk7XG4gICAgICAgIGFzdC5wcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXJBc3QsIHByb3ZpZGVySW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBkaXJBc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgZGlySW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBhc3QuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChsb2NhbERpckFzdCwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbERpckFzdC5kaXJlY3RpdmUudHlwZS5yZWZlcmVuY2UgPT09IHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyQXN0LnRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJBc3QgPSBsb2NhbERpckFzdDtcbiAgICAgICAgICAgICAgICAgICAgZGlySW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGRpckFzdCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLl92aXNpdERpcmVjdGl2ZShwcm92aWRlckFzdCwgZGlyQXN0LCBkaXJJbmRleCwgbm9kZUluZGV4LCBhc3QucmVmZXJlbmNlcywgYXN0LnF1ZXJ5TWF0Y2hlcywgdXNlZEV2ZW50cywgX3RoaXMuc3RhdGljUXVlcnlJZHMuZ2V0KGFzdCkpLCBkaXJIb3N0QmluZGluZ3MgPSBfYS5ob3N0QmluZGluZ3MsIGRpckhvc3RFdmVudHMgPSBfYS5ob3N0RXZlbnRzO1xuICAgICAgICAgICAgICAgIGhvc3RCaW5kaW5ncy5wdXNoLmFwcGx5KGhvc3RCaW5kaW5ncywgX19zcHJlYWQoZGlySG9zdEJpbmRpbmdzKSk7XG4gICAgICAgICAgICAgICAgaG9zdEV2ZW50cy5wdXNoLmFwcGx5KGhvc3RFdmVudHMsIF9fc3ByZWFkKGRpckhvc3RFdmVudHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLl92aXNpdFByb3ZpZGVyKHByb3ZpZGVyQXN0LCBhc3QucXVlcnlNYXRjaGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBxdWVyeU1hdGNoRXhwcnMgPSBbXTtcbiAgICAgICAgYXN0LnF1ZXJ5TWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlVHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0b2tlblJlZmVyZW5jZShtYXRjaC52YWx1ZSkgPT09XG4gICAgICAgICAgICAgICAgX3RoaXMucmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShJZGVudGlmaWVycy5FbGVtZW50UmVmKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IDAgLyogRWxlbWVudFJlZiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuUmVmZXJlbmNlKG1hdGNoLnZhbHVlKSA9PT1cbiAgICAgICAgICAgICAgICBfdGhpcy5yZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKElkZW50aWZpZXJzLlZpZXdDb250YWluZXJSZWYpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gMyAvKiBWaWV3Q29udGFpbmVyUmVmICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW5SZWZlcmVuY2UobWF0Y2gudmFsdWUpID09PVxuICAgICAgICAgICAgICAgIF90aGlzLnJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gMiAvKiBUZW1wbGF0ZVJlZiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hFeHBycy5wdXNoKGxpdGVyYWxBcnIoW2xpdGVyYWwobWF0Y2gucXVlcnlJZCksIGxpdGVyYWwodmFsdWVUeXBlKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFzdC5yZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIHZhbHVlVHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICghcmVmLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gMSAvKiBSZW5kZXJFbGVtZW50ICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW5SZWZlcmVuY2UocmVmLnZhbHVlKSA9PT1cbiAgICAgICAgICAgICAgICBfdGhpcy5yZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKElkZW50aWZpZXJzLlRlbXBsYXRlUmVmKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IDIgLyogVGVtcGxhdGVSZWYgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWZOb2RlSW5kaWNlc1tyZWYubmFtZV0gPSBub2RlSW5kZXg7XG4gICAgICAgICAgICAgICAgcXVlcnlNYXRjaEV4cHJzLnB1c2gobGl0ZXJhbEFycihbbGl0ZXJhbChyZWYubmFtZSksIGxpdGVyYWwodmFsdWVUeXBlKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFzdC5vdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dEFzdCkge1xuICAgICAgICAgICAgaG9zdEV2ZW50cy5wdXNoKHsgY29udGV4dDogQ09NUF9WQVIsIGV2ZW50QXN0OiBvdXRwdXRBc3QsIGRpckFzdDogbnVsbCB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmbGFnczogZmxhZ3MsXG4gICAgICAgICAgICB1c2VkRXZlbnRzOiBBcnJheS5mcm9tKHVzZWRFdmVudHMudmFsdWVzKCkpLFxuICAgICAgICAgICAgcXVlcnlNYXRjaGVzRXhwcjogcXVlcnlNYXRjaEV4cHJzLmxlbmd0aCA/IGxpdGVyYWxBcnIocXVlcnlNYXRjaEV4cHJzKSA6IE5VTExfRVhQUixcbiAgICAgICAgICAgIGhvc3RCaW5kaW5nczogaG9zdEJpbmRpbmdzLFxuICAgICAgICAgICAgaG9zdEV2ZW50czogaG9zdEV2ZW50c1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl92aXNpdERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChwcm92aWRlckFzdCwgZGlyQXN0LCBkaXJlY3RpdmVJbmRleCwgZWxlbWVudE5vZGVJbmRleCwgcmVmcywgcXVlcnlNYXRjaGVzLCB1c2VkRXZlbnRzLCBxdWVyeUlkcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbm9kZUluZGV4ID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIC8vIHJlc2VydmUgdGhlIHNwYWNlIGluIHRoZSBub2RlRGVmcyBhcnJheSBzbyB3ZSBjYW4gYWRkIGNoaWxkcmVuXG4gICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgZGlyQXN0LmRpcmVjdGl2ZS5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5LCBxdWVyeUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcXVlcnlJZCA9IGRpckFzdC5jb250ZW50UXVlcnlTdGFydElkICsgcXVlcnlJbmRleDtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IDY3MTA4ODY0IC8qIFR5cGVDb250ZW50UXVlcnkgKi8gfCBjYWxjU3RhdGljRHluYW1pY1F1ZXJ5RmxhZ3MocXVlcnlJZHMsIHF1ZXJ5SWQsIHF1ZXJ5KTtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nVHlwZSA9IHF1ZXJ5LmZpcnN0ID8gMCAvKiBGaXJzdCAqLyA6IDEgLyogQWxsICovO1xuICAgICAgICAgICAgX3RoaXMubm9kZXMucHVzaChmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGRpckFzdC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgIG5vZGVGbGFnczogZmxhZ3MsXG4gICAgICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihJZGVudGlmaWVycy5xdWVyeURlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbChmbGFncyksIGxpdGVyYWwocXVlcnlJZCksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBMaXRlcmFsTWFwRXhwcihbbmV3IExpdGVyYWxNYXBFbnRyeShxdWVyeS5wcm9wZXJ0eU5hbWUsIGxpdGVyYWwoYmluZGluZ1R5cGUpLCBmYWxzZSldKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTm90ZTogdGhlIG9wZXJhdGlvbiBiZWxvdyBtaWdodCBhbHNvIGNyZWF0ZSBuZXcgbm9kZURlZnMsXG4gICAgICAgIC8vIGJ1dCB3ZSBkb24ndCB3YW50IHRoZW0gdG8gYmUgYSBjaGlsZCBvZiBhIGRpcmVjdGl2ZSxcbiAgICAgICAgLy8gYXMgdGhleSBtaWdodCBiZSBhIHByb3ZpZGVyL3BpcGUgb24gdGhlaXIgb3duLlxuICAgICAgICAvLyBJLmUuIHdlIG9ubHkgYWxsb3cgcXVlcmllcyBhcyBjaGlsZHJlbiBvZiBkaXJlY3RpdmVzIG5vZGVzLlxuICAgICAgICB2YXIgY2hpbGRDb3VudCA9IHRoaXMubm9kZXMubGVuZ3RoIC0gbm9kZUluZGV4IC0gMTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fdmlzaXRQcm92aWRlck9yRGlyZWN0aXZlKHByb3ZpZGVyQXN0LCBxdWVyeU1hdGNoZXMpLCBmbGFncyA9IF9hLmZsYWdzLCBxdWVyeU1hdGNoRXhwcnMgPSBfYS5xdWVyeU1hdGNoRXhwcnMsIHByb3ZpZGVyRXhwciA9IF9hLnByb3ZpZGVyRXhwciwgZGVwc0V4cHIgPSBfYS5kZXBzRXhwcjtcbiAgICAgICAgcmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIGlmIChyZWYudmFsdWUgJiYgdG9rZW5SZWZlcmVuY2UocmVmLnZhbHVlKSA9PT0gdG9rZW5SZWZlcmVuY2UocHJvdmlkZXJBc3QudG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVmTm9kZUluZGljZXNbcmVmLm5hbWVdID0gbm9kZUluZGV4O1xuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hFeHBycy5wdXNoKGxpdGVyYWxBcnIoW2xpdGVyYWwocmVmLm5hbWUpLCBsaXRlcmFsKDQgLyogUHJvdmlkZXIgKi8pXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRpckFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IDMyNzY4IC8qIENvbXBvbmVudCAqLztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXREZWZzID0gZGlyQXN0LmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0QXN0LCBpbnB1dEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbWFwVmFsdWUgPSBsaXRlcmFsQXJyKFtsaXRlcmFsKGlucHV0SW5kZXgpLCBsaXRlcmFsKGlucHV0QXN0LmRpcmVjdGl2ZU5hbWUpXSk7XG4gICAgICAgICAgICAvLyBOb3RlOiBpdCdzIGltcG9ydGFudCB0byBub3QgcXVvdGUgdGhlIGtleSBzbyB0aGF0IHdlIGNhbiBjYXB0dXJlIHJlbmFtZXMgYnkgbWluaWZpZXJzIVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRW50cnkoaW5wdXRBc3QuZGlyZWN0aXZlTmFtZSwgbWFwVmFsdWUsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvdXRwdXREZWZzID0gW107XG4gICAgICAgIHZhciBkaXJNZXRhID0gZGlyQXN0LmRpcmVjdGl2ZTtcbiAgICAgICAgT2JqZWN0LmtleXMoZGlyTWV0YS5vdXRwdXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGRpck1ldGEub3V0cHV0c1twcm9wTmFtZV07XG4gICAgICAgICAgICBpZiAodXNlZEV2ZW50cy5oYXMoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IGl0J3MgaW1wb3J0YW50IHRvIG5vdCBxdW90ZSB0aGUga2V5IHNvIHRoYXQgd2UgY2FuIGNhcHR1cmUgcmVuYW1lcyBieSBtaW5pZmllcnMhXG4gICAgICAgICAgICAgICAgb3V0cHV0RGVmcy5wdXNoKG5ldyBMaXRlcmFsTWFwRW50cnkocHJvcE5hbWUsIGxpdGVyYWwoZXZlbnROYW1lKSwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB1cGRhdGVEaXJlY3RpdmVFeHByZXNzaW9ucyA9IFtdO1xuICAgICAgICBpZiAoZGlyQXN0LmlucHV0cy5sZW5ndGggfHwgKGZsYWdzICYgKDI2MjE0NCAvKiBEb0NoZWNrICovIHwgNjU1MzYgLyogT25Jbml0ICovKSkgPiAwKSB7XG4gICAgICAgICAgICB1cGRhdGVEaXJlY3RpdmVFeHByZXNzaW9ucyA9XG4gICAgICAgICAgICAgICAgZGlyQXN0LmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0LCBiaW5kaW5nSW5kZXgpIHsgcmV0dXJuIF90aGlzLl9wcmVwcm9jZXNzVXBkYXRlRXhwcmVzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleDogbm9kZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nSW5kZXg6IGJpbmRpbmdJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU3BhbjogaW5wdXQuc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogQ09NUF9WQVIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dC52YWx1ZVxuICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlyQ29udGV4dEV4cHIgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLm5vZGVWYWx1ZSkuY2FsbEZuKFtWSUVXX1ZBUiwgbGl0ZXJhbChub2RlSW5kZXgpXSk7XG4gICAgICAgIHZhciBob3N0QmluZGluZ3MgPSBkaXJBc3QuaG9zdFByb3BlcnRpZXMubWFwKGZ1bmN0aW9uIChpbnB1dEFzdCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGRpckNvbnRleHRFeHByLFxuICAgICAgICAgICAgZGlyQXN0OiBkaXJBc3QsXG4gICAgICAgICAgICBpbnB1dEFzdDogaW5wdXRBc3QsXG4gICAgICAgIH0pOyB9KTtcbiAgICAgICAgdmFyIGhvc3RFdmVudHMgPSBkaXJBc3QuaG9zdEV2ZW50cy5tYXAoZnVuY3Rpb24gKGhvc3RFdmVudEFzdCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGRpckNvbnRleHRFeHByLFxuICAgICAgICAgICAgZXZlbnRBc3Q6IGhvc3RFdmVudEFzdCwgZGlyQXN0OiBkaXJBc3QsXG4gICAgICAgIH0pOyB9KTtcbiAgICAgICAgLy8gQ2hlY2sgaW5kZXggaXMgdGhlIHNhbWUgYXMgdGhlIG5vZGUgaW5kZXggZHVyaW5nIGNvbXBpbGF0aW9uXG4gICAgICAgIC8vIFRoZXkgbWlnaHQgb25seSBkaWZmZXIgYXQgcnVudGltZVxuICAgICAgICB2YXIgY2hlY2tJbmRleCA9IG5vZGVJbmRleDtcbiAgICAgICAgdGhpcy5ub2Rlc1tub2RlSW5kZXhdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGRpckFzdC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgbm9kZUZsYWdzOiAxNjM4NCAvKiBUeXBlRGlyZWN0aXZlICovIHwgZmxhZ3MsXG4gICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKElkZW50aWZpZXJzLmRpcmVjdGl2ZURlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGNoZWNrSW5kZXgpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoZmxhZ3MpLFxuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hFeHBycy5sZW5ndGggPyBsaXRlcmFsQXJyKHF1ZXJ5TWF0Y2hFeHBycykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChjaGlsZENvdW50KSxcbiAgICAgICAgICAgICAgICBwcm92aWRlckV4cHIsXG4gICAgICAgICAgICAgICAgZGVwc0V4cHIsXG4gICAgICAgICAgICAgICAgaW5wdXREZWZzLmxlbmd0aCA/IG5ldyBMaXRlcmFsTWFwRXhwcihpbnB1dERlZnMpIDogTlVMTF9FWFBSLFxuICAgICAgICAgICAgICAgIG91dHB1dERlZnMubGVuZ3RoID8gbmV3IExpdGVyYWxNYXBFeHByKG91dHB1dERlZnMpIDogTlVMTF9FWFBSLFxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICB1cGRhdGVEaXJlY3RpdmVzOiB1cGRhdGVEaXJlY3RpdmVFeHByZXNzaW9ucyxcbiAgICAgICAgICAgIGRpcmVjdGl2ZTogZGlyQXN0LmRpcmVjdGl2ZS50eXBlLFxuICAgICAgICB9KTsgfTtcbiAgICAgICAgcmV0dXJuIHsgaG9zdEJpbmRpbmdzOiBob3N0QmluZGluZ3MsIGhvc3RFdmVudHM6IGhvc3RFdmVudHMgfTtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fdmlzaXRQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlckFzdCwgcXVlcnlNYXRjaGVzKSB7XG4gICAgICAgIHRoaXMuX2FkZFByb3ZpZGVyTm9kZSh0aGlzLl92aXNpdFByb3ZpZGVyT3JEaXJlY3RpdmUocHJvdmlkZXJBc3QsIHF1ZXJ5TWF0Y2hlcykpO1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl92aXNpdENvbXBvbmVudEZhY3RvcnlSZXNvbHZlclByb3ZpZGVyID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudERpck1ldGEgPSBkaXJlY3RpdmVzLmZpbmQoZnVuY3Rpb24gKGRpckFzdCkgeyByZXR1cm4gZGlyQXN0LmRpcmVjdGl2ZS5pc0NvbXBvbmVudDsgfSk7XG4gICAgICAgIGlmIChjb21wb25lbnREaXJNZXRhICYmIGNvbXBvbmVudERpck1ldGEuZGlyZWN0aXZlLmVudHJ5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlclByb3ZpZGVyRGVmKHRoaXMucmVmbGVjdG9yLCB0aGlzLm91dHB1dEN0eCwgODE5MiAvKiBQcml2YXRlUHJvdmlkZXIgKi8sIGNvbXBvbmVudERpck1ldGEuZGlyZWN0aXZlLmVudHJ5Q29tcG9uZW50cyksIHByb3ZpZGVyRXhwciA9IF9hLnByb3ZpZGVyRXhwciwgZGVwc0V4cHIgPSBfYS5kZXBzRXhwciwgZmxhZ3MgPSBfYS5mbGFncywgdG9rZW5FeHByID0gX2EudG9rZW5FeHByO1xuICAgICAgICAgICAgdGhpcy5fYWRkUHJvdmlkZXJOb2RlKHtcbiAgICAgICAgICAgICAgICBwcm92aWRlckV4cHI6IHByb3ZpZGVyRXhwcixcbiAgICAgICAgICAgICAgICBkZXBzRXhwcjogZGVwc0V4cHIsXG4gICAgICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLFxuICAgICAgICAgICAgICAgIHRva2VuRXhwcjogdG9rZW5FeHByLFxuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hFeHByczogW10sXG4gICAgICAgICAgICAgICAgc291cmNlU3BhbjogY29tcG9uZW50RGlyTWV0YS5zb3VyY2VTcGFuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl9hZGRQcm92aWRlck5vZGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgbm9kZUluZGV4ID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIC8vIHByb3ZpZGVyRGVmKFxuICAgICAgICAvLyAgIGZsYWdzOiBOb2RlRmxhZ3MsIG1hdGNoZWRRdWVyaWVzOiBbc3RyaW5nLCBRdWVyeVZhbHVlVHlwZV1bXSwgdG9rZW46YW55LFxuICAgICAgICAvLyAgIHZhbHVlOiBhbnksIGRlcHM6IChbRGVwRmxhZ3MsIGFueV0gfCBhbnkpW10pOiBOb2RlRGVmO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGRhdGEuc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogZGF0YS5mbGFncyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoSWRlbnRpZmllcnMucHJvdmlkZXJEZWYpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChkYXRhLmZsYWdzKSxcbiAgICAgICAgICAgICAgICBkYXRhLnF1ZXJ5TWF0Y2hFeHBycy5sZW5ndGggPyBsaXRlcmFsQXJyKGRhdGEucXVlcnlNYXRjaEV4cHJzKSA6IE5VTExfRVhQUixcbiAgICAgICAgICAgICAgICBkYXRhLnRva2VuRXhwciwgZGF0YS5wcm92aWRlckV4cHIsIGRhdGEuZGVwc0V4cHJcbiAgICAgICAgICAgIF0pXG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fdmlzaXRQcm92aWRlck9yRGlyZWN0aXZlID0gZnVuY3Rpb24gKHByb3ZpZGVyQXN0LCBxdWVyeU1hdGNoZXMpIHtcbiAgICAgICAgdmFyIGZsYWdzID0gMCAvKiBOb25lICovO1xuICAgICAgICB2YXIgcXVlcnlNYXRjaEV4cHJzID0gW107XG4gICAgICAgIHF1ZXJ5TWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRva2VuUmVmZXJlbmNlKG1hdGNoLnZhbHVlKSA9PT0gdG9rZW5SZWZlcmVuY2UocHJvdmlkZXJBc3QudG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlNYXRjaEV4cHJzLnB1c2gobGl0ZXJhbEFycihbbGl0ZXJhbChtYXRjaC5xdWVyeUlkKSwgbGl0ZXJhbCg0IC8qIFByb3ZpZGVyICovKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfYSA9IHByb3ZpZGVyRGVmKHRoaXMub3V0cHV0Q3R4LCBwcm92aWRlckFzdCksIHByb3ZpZGVyRXhwciA9IF9hLnByb3ZpZGVyRXhwciwgZGVwc0V4cHIgPSBfYS5kZXBzRXhwciwgcHJvdmlkZXJGbGFncyA9IF9hLmZsYWdzLCB0b2tlbkV4cHIgPSBfYS50b2tlbkV4cHI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmbGFnczogZmxhZ3MgfCBwcm92aWRlckZsYWdzLFxuICAgICAgICAgICAgcXVlcnlNYXRjaEV4cHJzOiBxdWVyeU1hdGNoRXhwcnMsXG4gICAgICAgICAgICBwcm92aWRlckV4cHI6IHByb3ZpZGVyRXhwcixcbiAgICAgICAgICAgIGRlcHNFeHByOiBkZXBzRXhwcixcbiAgICAgICAgICAgIHRva2VuRXhwcjogdG9rZW5FeHByLFxuICAgICAgICAgICAgc291cmNlU3BhbjogcHJvdmlkZXJBc3Quc291cmNlU3BhblxuICAgICAgICB9O1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLmdldExvY2FsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gRXZlbnRIYW5kbGVyVmFycy5ldmVudC5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gRXZlbnRIYW5kbGVyVmFycy5ldmVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VyclZpZXdFeHByID0gVklFV19WQVI7XG4gICAgICAgIGZvciAodmFyIGN1cnJCdWlsZGVyID0gdGhpczsgY3VyckJ1aWxkZXI7IGN1cnJCdWlsZGVyID0gY3VyckJ1aWxkZXIucGFyZW50LFxuICAgICAgICAgICAgY3VyclZpZXdFeHByID0gY3VyclZpZXdFeHByLnByb3AoJ3BhcmVudCcpLmNhc3QoRFlOQU1JQ19UWVBFKSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgcmVmZXJlbmNlc1xuICAgICAgICAgICAgdmFyIHJlZk5vZGVJbmRleCA9IGN1cnJCdWlsZGVyLnJlZk5vZGVJbmRpY2VzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHJlZk5vZGVJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMubm9kZVZhbHVlKS5jYWxsRm4oW2N1cnJWaWV3RXhwciwgbGl0ZXJhbChyZWZOb2RlSW5kZXgpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayB2YXJpYWJsZXNcbiAgICAgICAgICAgIHZhciB2YXJBc3QgPSBjdXJyQnVpbGRlci52YXJpYWJsZXMuZmluZChmdW5jdGlvbiAodmFyQXN0KSB7IHJldHVybiB2YXJBc3QubmFtZSA9PT0gbmFtZTsgfSk7XG4gICAgICAgICAgICBpZiAodmFyQXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhclZhbHVlID0gdmFyQXN0LnZhbHVlIHx8IElNUExJQ0lUX1RFTVBMQVRFX1ZBUjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyclZpZXdFeHByLnByb3AoJ2NvbnRleHQnKS5wcm9wKHZhclZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5ub3RpZnlJbXBsaWNpdFJlY2VpdmVyVXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBOb3QgbmVlZGVkIGluIFZpZXcgRW5naW5lIGFzIFZpZXcgRW5naW5lIHdhbGtzIHRocm91Z2ggdGhlIGdlbmVyYXRlZFxuICAgICAgICAvLyBleHByZXNzaW9ucyB0byBmaWd1cmUgb3V0IGlmIHRoZSBpbXBsaWNpdCByZWNlaXZlciBpcyB1c2VkIGFuZCBuZWVkc1xuICAgICAgICAvLyB0byBiZSBnZW5lcmF0ZWQgYXMgcGFydCBvZiB0aGUgcHJlLXVwZGF0ZSBzdGF0ZW1lbnRzLlxuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVMaXRlcmFsQXJyYXlDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoc291cmNlU3BhbiwgYXJnQ291bnQpIHtcbiAgICAgICAgaWYgKGFyZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVFeHByXzEgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLkVNUFRZX0FSUkFZKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZUV4cHJfMTsgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hlY2tJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IHNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDMyIC8qIFR5cGVQdXJlQXJyYXkgKi8sXG4gICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKElkZW50aWZpZXJzLnB1cmVBcnJheURlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGNoZWNrSW5kZXgpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoYXJnQ291bnQpLFxuICAgICAgICAgICAgXSlcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGNhbGxDaGVja1N0bXQoY2hlY2tJbmRleCwgYXJncyk7IH07XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZUxpdGVyYWxNYXBDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoc291cmNlU3Bhbiwga2V5cykge1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZUV4cHJfMiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuRU1QVFlfTUFQKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZUV4cHJfMjsgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFwID0gbGl0ZXJhbE1hcChrZXlzLm1hcChmdW5jdGlvbiAoZSwgaSkgeyByZXR1cm4gKF9fYXNzaWduKHt9LCBlLCB7IHZhbHVlOiBsaXRlcmFsKGkpIH0pKTsgfSkpO1xuICAgICAgICB2YXIgY2hlY2tJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IHNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDY0IC8qIFR5cGVQdXJlT2JqZWN0ICovLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihJZGVudGlmaWVycy5wdXJlT2JqZWN0RGVmKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoY2hlY2tJbmRleCksXG4gICAgICAgICAgICAgICAgbWFwLFxuICAgICAgICAgICAgXSlcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGNhbGxDaGVja1N0bXQoY2hlY2tJbmRleCwgYXJncyk7IH07XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZVBpcGVDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgbmFtZSwgYXJnQ291bnQpIHtcbiAgICAgICAgdmFyIHBpcGUgPSB0aGlzLnVzZWRQaXBlcy5maW5kKGZ1bmN0aW9uIChwaXBlU3VtbWFyeSkgeyByZXR1cm4gcGlwZVN1bW1hcnkubmFtZSA9PT0gbmFtZTsgfSk7XG4gICAgICAgIGlmIChwaXBlLnB1cmUpIHtcbiAgICAgICAgICAgIHZhciBjaGVja0luZGV4XzEgPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGV4cHJlc3Npb24uc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICBub2RlRmxhZ3M6IDEyOCAvKiBUeXBlUHVyZVBpcGUgKi8sXG4gICAgICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihJZGVudGlmaWVycy5wdXJlUGlwZURlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbChjaGVja0luZGV4XzEpLFxuICAgICAgICAgICAgICAgICAgICBsaXRlcmFsKGFyZ0NvdW50KSxcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgLy8gZmluZCB1bmRlcmx5aW5nIHBpcGUgaW4gdGhlIGNvbXBvbmVudCB2aWV3XG4gICAgICAgICAgICB2YXIgY29tcFZpZXdFeHByID0gVklFV19WQVI7XG4gICAgICAgICAgICB2YXIgY29tcEJ1aWxkZXIgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBCdWlsZGVyLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvbXBCdWlsZGVyID0gY29tcEJ1aWxkZXIucGFyZW50O1xuICAgICAgICAgICAgICAgIGNvbXBWaWV3RXhwciA9IGNvbXBWaWV3RXhwci5wcm9wKCdwYXJlbnQnKS5jYXN0KERZTkFNSUNfVFlQRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGlwZU5vZGVJbmRleCA9IGNvbXBCdWlsZGVyLnB1cmVQaXBlTm9kZUluZGljZXNbbmFtZV07XG4gICAgICAgICAgICB2YXIgcGlwZVZhbHVlRXhwcl8xID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy5ub2RlVmFsdWUpLmNhbGxGbihbY29tcFZpZXdFeHByLCBsaXRlcmFsKHBpcGVOb2RlSW5kZXgpXSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGNhbGxVbndyYXBWYWx1ZShleHByZXNzaW9uLm5vZGVJbmRleCwgZXhwcmVzc2lvbi5iaW5kaW5nSW5kZXgsIGNhbGxDaGVja1N0bXQoY2hlY2tJbmRleF8xLCBbcGlwZVZhbHVlRXhwcl8xXS5jb25jYXQoYXJncykpKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSB0aGlzLl9jcmVhdGVQaXBlKGV4cHJlc3Npb24uc291cmNlU3BhbiwgcGlwZSk7XG4gICAgICAgICAgICB2YXIgbm9kZVZhbHVlRXhwcl8xID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy5ub2RlVmFsdWUpLmNhbGxGbihbVklFV19WQVIsIGxpdGVyYWwobm9kZUluZGV4KV0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcmdzKSB7IHJldHVybiBjYWxsVW53cmFwVmFsdWUoZXhwcmVzc2lvbi5ub2RlSW5kZXgsIGV4cHJlc3Npb24uYmluZGluZ0luZGV4LCBub2RlVmFsdWVFeHByXzEuY2FsbE1ldGhvZCgndHJhbnNmb3JtJywgYXJncykpOyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZVBpcGUgPSBmdW5jdGlvbiAoc291cmNlU3BhbiwgcGlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbm9kZUluZGV4ID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIHZhciBmbGFncyA9IDAgLyogTm9uZSAqLztcbiAgICAgICAgcGlwZS50eXBlLmxpZmVjeWNsZUhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGxpZmVjeWNsZUhvb2spIHtcbiAgICAgICAgICAgIC8vIGZvciBwaXBlcywgd2Ugb25seSBzdXBwb3J0IG5nT25EZXN0cm95XG4gICAgICAgICAgICBpZiAobGlmZWN5Y2xlSG9vayA9PT0gTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gbGlmZWN5Y2xlSG9va1RvTm9kZUZsYWcobGlmZWN5Y2xlSG9vayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZGVwRXhwcnMgPSBwaXBlLnR5cGUuZGlEZXBzLm1hcChmdW5jdGlvbiAoZGlEZXApIHsgcmV0dXJuIGRlcERlZihfdGhpcy5vdXRwdXRDdHgsIGRpRGVwKTsgfSk7XG4gICAgICAgIC8vIGZ1bmN0aW9uIHBpcGVEZWYoXG4gICAgICAgIC8vICAgZmxhZ3M6IE5vZGVGbGFncywgY3RvcjogYW55LCBkZXBzOiAoW0RlcEZsYWdzLCBhbnldIHwgYW55KVtdKTogTm9kZURlZlxuICAgICAgICB0aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IHNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDE2IC8qIFR5cGVQaXBlICovLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihJZGVudGlmaWVycy5waXBlRGVmKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoZmxhZ3MpLCBfdGhpcy5vdXRwdXRDdHguaW1wb3J0RXhwcihwaXBlLnR5cGUucmVmZXJlbmNlKSwgbGl0ZXJhbEFycihkZXBFeHBycylcbiAgICAgICAgICAgIF0pXG4gICAgICAgIH0pOyB9KTtcbiAgICAgICAgcmV0dXJuIG5vZGVJbmRleDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvciB0aGUgQVNUIGluIGBVcGRhdGVFeHByZXNzaW9uLnZhbHVlYDpcbiAgICAgKiAtIGNyZWF0ZSBub2RlcyBmb3IgcGlwZXMsIGxpdGVyYWwgYXJyYXlzIGFuZCwgbGl0ZXJhbCBtYXBzLFxuICAgICAqIC0gdXBkYXRlIHRoZSBBU1QgdG8gcmVwbGFjZSBwaXBlcywgbGl0ZXJhbCBhcnJheXMgYW5kLCBsaXRlcmFsIG1hcHMgd2l0aCBjYWxscyB0byBjaGVjayBmbi5cbiAgICAgKlxuICAgICAqIFdBUk5JTkc6IFRoaXMgbWlnaHQgY3JlYXRlIG5ldyBub2RlRGVmcyAoZm9yIHBpcGVzIGFuZCBsaXRlcmFsIGFycmF5cyBhbmQgbGl0ZXJhbCBtYXBzKSFcbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX3ByZXByb2Nlc3NVcGRhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGVJbmRleDogZXhwcmVzc2lvbi5ub2RlSW5kZXgsXG4gICAgICAgICAgICBiaW5kaW5nSW5kZXg6IGV4cHJlc3Npb24uYmluZGluZ0luZGV4LFxuICAgICAgICAgICAgc291cmNlU3BhbjogZXhwcmVzc2lvbi5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgY29udGV4dDogZXhwcmVzc2lvbi5jb250ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmdCdWlsdGlucyh7XG4gICAgICAgICAgICAgICAgY3JlYXRlTGl0ZXJhbEFycmF5Q29udmVydGVyOiBmdW5jdGlvbiAoYXJnQ291bnQpIHsgcmV0dXJuIF90aGlzLl9jcmVhdGVMaXRlcmFsQXJyYXlDb252ZXJ0ZXIoZXhwcmVzc2lvbi5zb3VyY2VTcGFuLCBhcmdDb3VudCk7IH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlTGl0ZXJhbE1hcENvbnZlcnRlcjogZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jcmVhdGVMaXRlcmFsTWFwQ29udmVydGVyKGV4cHJlc3Npb24uc291cmNlU3Bhbiwga2V5cyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVQaXBlQ29udmVydGVyOiBmdW5jdGlvbiAobmFtZSwgYXJnQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jcmVhdGVQaXBlQ29udmVydGVyKGV4cHJlc3Npb24sIG5hbWUsIGFyZ0NvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBleHByZXNzaW9uLnZhbHVlKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVOb2RlRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHVwZGF0ZUJpbmRpbmdDb3VudCA9IDA7XG4gICAgICAgIHZhciB1cGRhdGVSZW5kZXJlclN0bXRzID0gW107XG4gICAgICAgIHZhciB1cGRhdGVEaXJlY3RpdmVzU3RtdHMgPSBbXTtcbiAgICAgICAgdmFyIG5vZGVEZWZFeHBycyA9IHRoaXMubm9kZXMubWFwKGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGZhY3RvcnkoKSwgbm9kZURlZiA9IF9hLm5vZGVEZWYsIG5vZGVGbGFncyA9IF9hLm5vZGVGbGFncywgdXBkYXRlRGlyZWN0aXZlcyA9IF9hLnVwZGF0ZURpcmVjdGl2ZXMsIHVwZGF0ZVJlbmRlcmVyID0gX2EudXBkYXRlUmVuZGVyZXIsIHNvdXJjZVNwYW4gPSBfYS5zb3VyY2VTcGFuO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZVJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlUmVuZGVyZXJTdG10cy5wdXNoLmFwcGx5KHVwZGF0ZVJlbmRlcmVyU3RtdHMsIF9fc3ByZWFkKGNyZWF0ZVVwZGF0ZVN0YXRlbWVudHMobm9kZUluZGV4LCBzb3VyY2VTcGFuLCB1cGRhdGVSZW5kZXJlciwgZmFsc2UpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlRGlyZWN0aXZlcykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZURpcmVjdGl2ZXNTdG10cy5wdXNoLmFwcGx5KHVwZGF0ZURpcmVjdGl2ZXNTdG10cywgX19zcHJlYWQoY3JlYXRlVXBkYXRlU3RhdGVtZW50cyhub2RlSW5kZXgsIHNvdXJjZVNwYW4sIHVwZGF0ZURpcmVjdGl2ZXMsIChub2RlRmxhZ3MgJiAoMjYyMTQ0IC8qIERvQ2hlY2sgKi8gfCA2NTUzNiAvKiBPbkluaXQgKi8pKSA+IDApKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB1c2UgYSBjb21tYSBleHByZXNzaW9uIHRvIGNhbGwgdGhlIGxvZyBmdW5jdGlvbiBiZWZvcmVcbiAgICAgICAgICAgIC8vIHRoZSBub2RlRGVmIGZ1bmN0aW9uLCBidXQgc3RpbGwgdXNlIHRoZSByZXN1bHQgb2YgdGhlIG5vZGVEZWYgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIGFzIHRoZSB2YWx1ZS5cbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIG9ubHkgYWRkIHRoZSBsb2dnZXIgdG8gZWxlbWVudHMgLyB0ZXh0IG5vZGVzLFxuICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgZ2VuZXJhdGUgdG9vIG11Y2ggY29kZS5cbiAgICAgICAgICAgIHZhciBsb2dXaXRoTm9kZURlZiA9IG5vZGVGbGFncyAmIDMgLyogQ2F0UmVuZGVyTm9kZSAqLyA/XG4gICAgICAgICAgICAgICAgbmV3IENvbW1hRXhwcihbTE9HX1ZBUiQxLmNhbGxGbihbXSkuY2FsbEZuKFtdKSwgbm9kZURlZl0pIDpcbiAgICAgICAgICAgICAgICBub2RlRGVmO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5U291cmNlU3BhblRvRXhwcmVzc2lvbklmTmVlZGVkKGxvZ1dpdGhOb2RlRGVmLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IHVwZGF0ZVJlbmRlcmVyU3RtdHM6IHVwZGF0ZVJlbmRlcmVyU3RtdHMsIHVwZGF0ZURpcmVjdGl2ZXNTdG10czogdXBkYXRlRGlyZWN0aXZlc1N0bXRzLCBub2RlRGVmRXhwcnM6IG5vZGVEZWZFeHBycyB9O1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVVcGRhdGVTdGF0ZW1lbnRzKG5vZGVJbmRleCwgc291cmNlU3BhbiwgZXhwcmVzc2lvbnMsIGFsbG93RW1wdHlFeHBycykge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVN0bXRzID0gW107XG4gICAgICAgICAgICB2YXIgZXhwcnMgPSBleHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBfYS5zb3VyY2VTcGFuLCBjb250ZXh0ID0gX2EuY29udGV4dCwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgYmluZGluZ0lkID0gXCJcIiArIHVwZGF0ZUJpbmRpbmdDb3VudCsrO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lUmVzb2x2ZXIgPSBjb250ZXh0ID09PSBDT01QX1ZBUiA/IHNlbGYgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcobmFtZVJlc29sdmVyLCBjb250ZXh0LCB2YWx1ZSwgYmluZGluZ0lkLCBCaW5kaW5nRm9ybS5HZW5lcmFsKSwgc3RtdHMgPSBfYi5zdG10cywgY3VyclZhbEV4cHIgPSBfYi5jdXJyVmFsRXhwcjtcbiAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoLmFwcGx5KHVwZGF0ZVN0bXRzLCBfX3NwcmVhZChzdG10cy5tYXAoZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIGFwcGx5U291cmNlU3BhblRvU3RhdGVtZW50SWZOZWVkZWQoc3RtdCwgc291cmNlU3Bhbik7IH0pKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5U291cmNlU3BhblRvRXhwcmVzc2lvbklmTmVlZGVkKGN1cnJWYWxFeHByLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCB8fCBhbGxvd0VtcHR5RXhwcnMpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoKGFwcGx5U291cmNlU3BhblRvU3RhdGVtZW50SWZOZWVkZWQoY2FsbENoZWNrU3RtdChub2RlSW5kZXgsIGV4cHJzKS50b1N0bXQoKSwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN0bXRzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZUVsZW1lbnRIYW5kbGVFdmVudEZuID0gZnVuY3Rpb24gKG5vZGVJbmRleCwgaGFuZGxlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGhhbmRsZUV2ZW50U3RtdHMgPSBbXTtcbiAgICAgICAgdmFyIGhhbmRsZUV2ZW50QmluZGluZ0NvdW50ID0gMDtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gX2EuY29udGV4dCwgZXZlbnRBc3QgPSBfYS5ldmVudEFzdCwgZGlyQXN0ID0gX2EuZGlyQXN0O1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdJZCA9IFwiXCIgKyBoYW5kbGVFdmVudEJpbmRpbmdDb3VudCsrO1xuICAgICAgICAgICAgdmFyIG5hbWVSZXNvbHZlciA9IGNvbnRleHQgPT09IENPTVBfVkFSID8gX3RoaXMgOiBudWxsO1xuICAgICAgICAgICAgdmFyIF9iID0gY29udmVydEFjdGlvbkJpbmRpbmcobmFtZVJlc29sdmVyLCBjb250ZXh0LCBldmVudEFzdC5oYW5kbGVyLCBiaW5kaW5nSWQpLCBzdG10cyA9IF9iLnN0bXRzLCBhbGxvd0RlZmF1bHQgPSBfYi5hbGxvd0RlZmF1bHQ7XG4gICAgICAgICAgICB2YXIgdHJ1ZVN0bXRzID0gc3RtdHM7XG4gICAgICAgICAgICBpZiAoYWxsb3dEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgdHJ1ZVN0bXRzLnB1c2goQUxMT1dfREVGQVVMVF9WQVIuc2V0KGFsbG93RGVmYXVsdC5hbmQoQUxMT1dfREVGQVVMVF9WQVIpKS50b1N0bXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2MgPSBlbGVtZW50RXZlbnROYW1lQW5kVGFyZ2V0KGV2ZW50QXN0LCBkaXJBc3QpLCBldmVudFRhcmdldCA9IF9jLnRhcmdldCwgZXZlbnROYW1lID0gX2MubmFtZTtcbiAgICAgICAgICAgIHZhciBmdWxsRXZlbnROYW1lID0gZWxlbWVudEV2ZW50RnVsbE5hbWUoZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBoYW5kbGVFdmVudFN0bXRzLnB1c2goYXBwbHlTb3VyY2VTcGFuVG9TdGF0ZW1lbnRJZk5lZWRlZChuZXcgSWZTdG10KGxpdGVyYWwoZnVsbEV2ZW50TmFtZSkuaWRlbnRpY2FsKEVWRU5UX05BTUVfVkFSKSwgdHJ1ZVN0bXRzKSwgZXZlbnRBc3Quc291cmNlU3BhbikpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGhhbmRsZUV2ZW50Rm47XG4gICAgICAgIGlmIChoYW5kbGVFdmVudFN0bXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwcmVTdG10cyA9IFtBTExPV19ERUZBVUxUX1ZBUi5zZXQobGl0ZXJhbCh0cnVlKSkudG9EZWNsU3RtdChCT09MX1RZUEUpXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb21wb25lbnQuaXNIb3N0ICYmIGZpbmRSZWFkVmFyTmFtZXMoaGFuZGxlRXZlbnRTdG10cykuaGFzKENPTVBfVkFSLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcHJlU3RtdHMucHVzaChDT01QX1ZBUi5zZXQoVklFV19WQVIucHJvcCgnY29tcG9uZW50JykpLnRvRGVjbFN0bXQodGhpcy5jb21wVHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlRXZlbnRGbiA9IGZuKFtcbiAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbShWSUVXX1ZBUi5uYW1lLCBJTkZFUlJFRF9UWVBFKSxcbiAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbShFVkVOVF9OQU1FX1ZBUi5uYW1lLCBJTkZFUlJFRF9UWVBFKSxcbiAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbShFdmVudEhhbmRsZXJWYXJzLmV2ZW50Lm5hbWUsIElORkVSUkVEX1RZUEUpXG4gICAgICAgICAgICBdLCBfX3NwcmVhZChwcmVTdG10cywgaGFuZGxlRXZlbnRTdG10cywgW25ldyBSZXR1cm5TdGF0ZW1lbnQoQUxMT1dfREVGQVVMVF9WQVIpXSksIElORkVSUkVEX1RZUEUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlRXZlbnRGbiA9IE5VTExfRVhQUjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlRXZlbnRGbjtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0VmFyaWFibGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RXZlbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudFByb3BlcnR5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEF0dHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgcmV0dXJuIFZpZXdCdWlsZGVyO1xufSgpKTtcbmZ1bmN0aW9uIG5lZWRzQWRkaXRpb25hbFJvb3ROb2RlKGFzdE5vZGVzKSB7XG4gICAgdmFyIGxhc3RBc3ROb2RlID0gYXN0Tm9kZXNbYXN0Tm9kZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RBc3ROb2RlIGluc3RhbmNlb2YgRW1iZWRkZWRUZW1wbGF0ZUFzdCkge1xuICAgICAgICByZXR1cm4gbGFzdEFzdE5vZGUuaGFzVmlld0NvbnRhaW5lcjtcbiAgICB9XG4gICAgaWYgKGxhc3RBc3ROb2RlIGluc3RhbmNlb2YgRWxlbWVudEFzdCkge1xuICAgICAgICBpZiAoaXNOZ0NvbnRhaW5lcihsYXN0QXN0Tm9kZS5uYW1lKSAmJiBsYXN0QXN0Tm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZWVkc0FkZGl0aW9uYWxSb290Tm9kZShsYXN0QXN0Tm9kZS5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhc3RBc3ROb2RlLmhhc1ZpZXdDb250YWluZXI7XG4gICAgfVxuICAgIHJldHVybiBsYXN0QXN0Tm9kZSBpbnN0YW5jZW9mIE5nQ29udGVudEFzdDtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRCaW5kaW5nRGVmKGlucHV0QXN0LCBkaXJBc3QpIHtcbiAgICB2YXIgaW5wdXRUeXBlID0gaW5wdXRBc3QudHlwZTtcbiAgICBzd2l0Y2ggKGlucHV0VHlwZSkge1xuICAgICAgICBjYXNlIDEgLyogQXR0cmlidXRlICovOlxuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoMSAvKiBUeXBlRWxlbWVudEF0dHJpYnV0ZSAqLyksIGxpdGVyYWwoaW5wdXRBc3QubmFtZSksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChpbnB1dEFzdC5zZWN1cml0eUNvbnRleHQpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgY2FzZSAwIC8qIFByb3BlcnR5ICovOlxuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoOCAvKiBUeXBlUHJvcGVydHkgKi8pLCBsaXRlcmFsKGlucHV0QXN0Lm5hbWUpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoaW5wdXRBc3Quc2VjdXJpdHlDb250ZXh0KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIGNhc2UgNCAvKiBBbmltYXRpb24gKi86XG4gICAgICAgICAgICB2YXIgYmluZGluZ1R5cGUgPSA4IC8qIFR5cGVQcm9wZXJ0eSAqLyB8XG4gICAgICAgICAgICAgICAgKGRpckFzdCAmJiBkaXJBc3QuZGlyZWN0aXZlLmlzQ29tcG9uZW50ID8gMzIgLyogU3ludGhldGljSG9zdFByb3BlcnR5ICovIDpcbiAgICAgICAgICAgICAgICAgICAgMTYgLyogU3ludGhldGljUHJvcGVydHkgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoYmluZGluZ1R5cGUpLCBsaXRlcmFsKCdAJyArIGlucHV0QXN0Lm5hbWUpLCBsaXRlcmFsKGlucHV0QXN0LnNlY3VyaXR5Q29udGV4dClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICBjYXNlIDIgLyogQ2xhc3MgKi86XG4gICAgICAgICAgICByZXR1cm4gbGl0ZXJhbEFycihbbGl0ZXJhbCgyIC8qIFR5cGVFbGVtZW50Q2xhc3MgKi8pLCBsaXRlcmFsKGlucHV0QXN0Lm5hbWUpLCBOVUxMX0VYUFJdKTtcbiAgICAgICAgY2FzZSAzIC8qIFN0eWxlICovOlxuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoNCAvKiBUeXBlRWxlbWVudFN0eWxlICovKSwgbGl0ZXJhbChpbnB1dEFzdC5uYW1lKSwgbGl0ZXJhbChpbnB1dEFzdC51bml0KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBUaGlzIGRlZmF1bHQgY2FzZSBpcyBub3QgbmVlZGVkIGJ5IFR5cGVTY3JpcHQgY29tcGlsZXIsIGFzIHRoZSBzd2l0Y2ggaXMgZXhoYXVzdGl2ZS5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIgQ2xvc3VyZSBDb21waWxlciBkb2VzIG5vdCB1bmRlcnN0YW5kIHRoYXQgYW5kIHJlcG9ydHMgYW4gZXJyb3IgaW4gdHlwZWQgbW9kZS5cbiAgICAgICAgICAgIC8vIFRoZSBgdGhyb3cgbmV3IEVycm9yYCBiZWxvdyB3b3JrcyBhcm91bmQgdGhlIHByb2JsZW0sIGFuZCB0aGUgdW5leHBlY3RlZDogbmV2ZXIgdmFyaWFibGVcbiAgICAgICAgICAgIC8vIG1ha2VzIHN1cmUgdHNjIHN0aWxsIGNoZWNrcyB0aGlzIGNvZGUgaXMgdW5yZWFjaGFibGUuXG4gICAgICAgICAgICB2YXIgdW5leHBlY3RlZCA9IGlucHV0VHlwZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgXCIgKyB1bmV4cGVjdGVkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaXhlZEF0dHJzRGVmKGVsZW1lbnRBc3QpIHtcbiAgICB2YXIgbWFwUmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBlbGVtZW50QXN0LmF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHJBc3QpIHsgbWFwUmVzdWx0W2F0dHJBc3QubmFtZV0gPSBhdHRyQXN0LnZhbHVlOyB9KTtcbiAgICBlbGVtZW50QXN0LmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyQXN0KSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGRpckFzdC5kaXJlY3RpdmUuaG9zdEF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRpckFzdC5kaXJlY3RpdmUuaG9zdEF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gbWFwUmVzdWx0W25hbWVdO1xuICAgICAgICAgICAgbWFwUmVzdWx0W25hbWVdID0gcHJldlZhbHVlICE9IG51bGwgPyBtZXJnZUF0dHJpYnV0ZVZhbHVlKG5hbWUsIHByZXZWYWx1ZSwgdmFsdWUpIDogdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIE5vdGU6IFdlIG5lZWQgdG8gc29ydCB0byBnZXQgYSBkZWZpbmVkIG91dHB1dCBvcmRlclxuICAgIC8vIGZvciB0ZXN0cyBhbmQgZm9yIGNhY2hpbmcgZ2VuZXJhdGVkIGFydGlmYWN0cy4uLlxuICAgIHJldHVybiBsaXRlcmFsQXJyKE9iamVjdC5rZXlzKG1hcFJlc3VsdCkuc29ydCgpLm1hcChmdW5jdGlvbiAoYXR0ck5hbWUpIHsgcmV0dXJuIGxpdGVyYWxBcnIoW2xpdGVyYWwoYXR0ck5hbWUpLCBsaXRlcmFsKG1hcFJlc3VsdFthdHRyTmFtZV0pXSk7IH0pKTtcbn1cbmZ1bmN0aW9uIG1lcmdlQXR0cmlidXRlVmFsdWUoYXR0ck5hbWUsIGF0dHJWYWx1ZTEsIGF0dHJWYWx1ZTIpIHtcbiAgICBpZiAoYXR0ck5hbWUgPT0gQ0xBU1NfQVRUUiQxIHx8IGF0dHJOYW1lID09IFNUWUxFX0FUVFIpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJWYWx1ZTEgKyBcIiBcIiArIGF0dHJWYWx1ZTI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYXR0clZhbHVlMjtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWxsQ2hlY2tTdG10KG5vZGVJbmRleCwgZXhwcnMpIHtcbiAgICBpZiAoZXhwcnMubGVuZ3RoID4gMTApIHtcbiAgICAgICAgcmV0dXJuIENIRUNLX1ZBUi5jYWxsRm4oW1ZJRVdfVkFSLCBsaXRlcmFsKG5vZGVJbmRleCksIGxpdGVyYWwoMSAvKiBEeW5hbWljICovKSwgbGl0ZXJhbEFycihleHBycyldKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBDSEVDS19WQVIuY2FsbEZuKF9fc3ByZWFkKFtWSUVXX1ZBUiwgbGl0ZXJhbChub2RlSW5kZXgpLCBsaXRlcmFsKDAgLyogSW5saW5lICovKV0sIGV4cHJzKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsbFVud3JhcFZhbHVlKG5vZGVJbmRleCwgYmluZGluZ0lkeCwgZXhwcikge1xuICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzLnVud3JhcFZhbHVlKS5jYWxsRm4oW1xuICAgICAgICBWSUVXX1ZBUiwgbGl0ZXJhbChub2RlSW5kZXgpLCBsaXRlcmFsKGJpbmRpbmdJZHgpLCBleHByXG4gICAgXSk7XG59XG5mdW5jdGlvbiBmaW5kU3RhdGljUXVlcnlJZHMobm9kZXMsIHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgeyByZXN1bHQgPSBuZXcgTWFwKCk7IH1cbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBzdGF0aWNRdWVyeUlkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIGR5bmFtaWNRdWVyeUlkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIHF1ZXJ5TWF0Y2hlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50QXN0KSB7XG4gICAgICAgICAgICBmaW5kU3RhdGljUXVlcnlJZHMobm9kZS5jaGlsZHJlbiwgcmVzdWx0KTtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGREYXRhID0gcmVzdWx0LmdldChjaGlsZCk7XG4gICAgICAgICAgICAgICAgY2hpbGREYXRhLnN0YXRpY1F1ZXJ5SWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SWQpIHsgcmV0dXJuIHN0YXRpY1F1ZXJ5SWRzLmFkZChxdWVyeUlkKTsgfSk7XG4gICAgICAgICAgICAgICAgY2hpbGREYXRhLmR5bmFtaWNRdWVyeUlkcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeUlkKSB7IHJldHVybiBkeW5hbWljUXVlcnlJZHMuYWRkKHF1ZXJ5SWQpOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcXVlcnlNYXRjaGVzID0gbm9kZS5xdWVyeU1hdGNoZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEVtYmVkZGVkVGVtcGxhdGVBc3QpIHtcbiAgICAgICAgICAgIGZpbmRTdGF0aWNRdWVyeUlkcyhub2RlLmNoaWxkcmVuLCByZXN1bHQpO1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZERhdGEgPSByZXN1bHQuZ2V0KGNoaWxkKTtcbiAgICAgICAgICAgICAgICBjaGlsZERhdGEuc3RhdGljUXVlcnlJZHMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlJZCkgeyByZXR1cm4gZHluYW1pY1F1ZXJ5SWRzLmFkZChxdWVyeUlkKTsgfSk7XG4gICAgICAgICAgICAgICAgY2hpbGREYXRhLmR5bmFtaWNRdWVyeUlkcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeUlkKSB7IHJldHVybiBkeW5hbWljUXVlcnlJZHMuYWRkKHF1ZXJ5SWQpOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcXVlcnlNYXRjaGVzID0gbm9kZS5xdWVyeU1hdGNoZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5TWF0Y2hlcykge1xuICAgICAgICAgICAgcXVlcnlNYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBzdGF0aWNRdWVyeUlkcy5hZGQobWF0Y2gucXVlcnlJZCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGR5bmFtaWNRdWVyeUlkcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeUlkKSB7IHJldHVybiBzdGF0aWNRdWVyeUlkcy5kZWxldGUocXVlcnlJZCk7IH0pO1xuICAgICAgICByZXN1bHQuc2V0KG5vZGUsIHsgc3RhdGljUXVlcnlJZHM6IHN0YXRpY1F1ZXJ5SWRzLCBkeW5hbWljUXVlcnlJZHM6IGR5bmFtaWNRdWVyeUlkcyB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc3RhdGljVmlld1F1ZXJ5SWRzKG5vZGVTdGF0aWNRdWVyeUlkcykge1xuICAgIHZhciBzdGF0aWNRdWVyeUlkcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZHluYW1pY1F1ZXJ5SWRzID0gbmV3IFNldCgpO1xuICAgIEFycmF5LmZyb20obm9kZVN0YXRpY1F1ZXJ5SWRzLnZhbHVlcygpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBlbnRyeS5zdGF0aWNRdWVyeUlkcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeUlkKSB7IHJldHVybiBzdGF0aWNRdWVyeUlkcy5hZGQocXVlcnlJZCk7IH0pO1xuICAgICAgICBlbnRyeS5keW5hbWljUXVlcnlJZHMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlJZCkgeyByZXR1cm4gZHluYW1pY1F1ZXJ5SWRzLmFkZChxdWVyeUlkKTsgfSk7XG4gICAgfSk7XG4gICAgZHluYW1pY1F1ZXJ5SWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SWQpIHsgcmV0dXJuIHN0YXRpY1F1ZXJ5SWRzLmRlbGV0ZShxdWVyeUlkKTsgfSk7XG4gICAgcmV0dXJuIHsgc3RhdGljUXVlcnlJZHM6IHN0YXRpY1F1ZXJ5SWRzLCBkeW5hbWljUXVlcnlJZHM6IGR5bmFtaWNRdWVyeUlkcyB9O1xufVxuZnVuY3Rpb24gZWxlbWVudEV2ZW50TmFtZUFuZFRhcmdldChldmVudEFzdCwgZGlyQXN0KSB7XG4gICAgaWYgKGV2ZW50QXN0LmlzQW5pbWF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBcIkBcIiArIGV2ZW50QXN0Lm5hbWUgKyBcIi5cIiArIGV2ZW50QXN0LnBoYXNlLFxuICAgICAgICAgICAgdGFyZ2V0OiBkaXJBc3QgJiYgZGlyQXN0LmRpcmVjdGl2ZS5pc0NvbXBvbmVudCA/ICdjb21wb25lbnQnIDogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50QXN0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGNTdGF0aWNEeW5hbWljUXVlcnlGbGFncyhxdWVyeUlkcywgcXVlcnlJZCwgcXVlcnkpIHtcbiAgICB2YXIgZmxhZ3MgPSAwIC8qIE5vbmUgKi87XG4gICAgLy8gTm90ZTogV2Ugb25seSBtYWtlIHF1ZXJpZXMgc3RhdGljIHRoYXQgcXVlcnkgZm9yIGEgc2luZ2xlIGl0ZW0uXG4gICAgLy8gVGhpcyBpcyBiZWNhdXNlIG9mIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIG9sZCB2aWV3IGNvbXBpbGVyLi4uXG4gICAgaWYgKHF1ZXJ5LmZpcnN0ICYmIHNob3VsZFJlc29sdmVBc1N0YXRpY1F1ZXJ5KHF1ZXJ5SWRzLCBxdWVyeUlkLCBxdWVyeSkpIHtcbiAgICAgICAgZmxhZ3MgfD0gMjY4NDM1NDU2IC8qIFN0YXRpY1F1ZXJ5ICovO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmxhZ3MgfD0gNTM2ODcwOTEyIC8qIER5bmFtaWNRdWVyeSAqLztcbiAgICB9XG4gICAgcmV0dXJuIGZsYWdzO1xufVxuZnVuY3Rpb24gc2hvdWxkUmVzb2x2ZUFzU3RhdGljUXVlcnkocXVlcnlJZHMsIHF1ZXJ5SWQsIHF1ZXJ5KSB7XG4gICAgLy8gSWYgcXVlcnkuc3RhdGljIGhhcyBiZWVuIHNldCBieSB0aGUgdXNlciwgdXNlIHRoYXQgdmFsdWUgdG8gZGV0ZXJtaW5lIHdoZXRoZXJcbiAgICAvLyB0aGUgcXVlcnkgaXMgc3RhdGljLiBJZiBub25lIGhhcyBiZWVuIHNldCwgc29ydCB0aGUgcXVlcnkgaW50byBzdGF0aWMvZHluYW1pY1xuICAgIC8vIGJhc2VkIG9uIHF1ZXJ5IHJlc3VsdHMgKGkuZS4gZHluYW1pYyBpZiBDRCBuZWVkcyB0byBydW4gdG8gZ2V0IGFsbCByZXN1bHRzKS5cbiAgICByZXR1cm4gcXVlcnkuc3RhdGljIHx8XG4gICAgICAgIHF1ZXJ5LnN0YXRpYyA9PSBudWxsICYmXG4gICAgICAgICAgICAocXVlcnlJZHMuc3RhdGljUXVlcnlJZHMuaGFzKHF1ZXJ5SWQpIHx8ICFxdWVyeUlkcy5keW5hbWljUXVlcnlJZHMuaGFzKHF1ZXJ5SWQpKTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRFdmVudEZ1bGxOYW1lKHRhcmdldCwgbmFtZSkge1xuICAgIHJldHVybiB0YXJnZXQgPyB0YXJnZXQgKyBcIjpcIiArIG5hbWUgOiBuYW1lO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciBtZXNzYWdlIGV4dHJhY3RlZCBmcm9tIHRoZSB0ZW1wbGF0ZXMuXG4gKi9cbnZhciBNZXNzYWdlQnVuZGxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VCdW5kbGUoX2h0bWxQYXJzZXIsIF9pbXBsaWNpdFRhZ3MsIF9pbXBsaWNpdEF0dHJzLCBfbG9jYWxlKSB7XG4gICAgICAgIGlmIChfbG9jYWxlID09PSB2b2lkIDApIHsgX2xvY2FsZSA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdFRhZ3MgPSBfaW1wbGljaXRUYWdzO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdEF0dHJzID0gX2ltcGxpY2l0QXR0cnM7XG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IF9sb2NhbGU7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzID0gW107XG4gICAgfVxuICAgIE1lc3NhZ2VCdW5kbGUucHJvdG90eXBlLnVwZGF0ZUZyb21UZW1wbGF0ZSA9IGZ1bmN0aW9uIChodG1sLCB1cmwsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgaHRtbFBhcnNlclJlc3VsdCA9IHRoaXMuX2h0bWxQYXJzZXIucGFyc2UoaHRtbCwgdXJsLCB7IHRva2VuaXplRXhwYW5zaW9uRm9ybXM6IHRydWUsIGludGVycG9sYXRpb25Db25maWc6IGludGVycG9sYXRpb25Db25maWcgfSk7XG4gICAgICAgIGlmIChodG1sUGFyc2VyUmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sUGFyc2VyUmVzdWx0LmVycm9ycztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaTE4blBhcnNlclJlc3VsdCA9IGV4dHJhY3RNZXNzYWdlcyhodG1sUGFyc2VyUmVzdWx0LnJvb3ROb2RlcywgaW50ZXJwb2xhdGlvbkNvbmZpZywgdGhpcy5faW1wbGljaXRUYWdzLCB0aGlzLl9pbXBsaWNpdEF0dHJzKTtcbiAgICAgICAgaWYgKGkxOG5QYXJzZXJSZXN1bHQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGkxOG5QYXJzZXJSZXN1bHQuZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuX21lc3NhZ2VzKS5wdXNoLmFwcGx5KF9hLCBfX3NwcmVhZChpMThuUGFyc2VyUmVzdWx0Lm1lc3NhZ2VzKSk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIC8vIFJldHVybiB0aGUgbWVzc2FnZSBpbiB0aGUgaW50ZXJuYWwgZm9ybWF0XG4gICAgLy8gVGhlIHB1YmxpYyAoc2VyaWFsaXplZCkgZm9ybWF0IG1pZ2h0IGJlIGRpZmZlcmVudCwgc2VlIHRoZSBgd3JpdGVgIG1ldGhvZC5cbiAgICBNZXNzYWdlQnVuZGxlLnByb3RvdHlwZS5nZXRNZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21lc3NhZ2VzOyB9O1xuICAgIE1lc3NhZ2VCdW5kbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHNlcmlhbGl6ZXIsIGZpbHRlclNvdXJjZXMpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VzID0ge307XG4gICAgICAgIHZhciBtYXBwZXJWaXNpdG9yID0gbmV3IE1hcFBsYWNlaG9sZGVyTmFtZXMoKTtcbiAgICAgICAgLy8gRGVkdXBsaWNhdGUgbWVzc2FnZXMgYmFzZWQgb24gdGhlaXIgSURcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGlkID0gc2VyaWFsaXplci5kaWdlc3QobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2VzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzW2lkXSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoX2EgPSBtZXNzYWdlc1tpZF0uc291cmNlcykucHVzaC5hcHBseShfYSwgX19zcHJlYWQobWVzc2FnZS5zb3VyY2VzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmFuc2Zvcm0gcGxhY2Vob2xkZXIgbmFtZXMgdXNpbmcgdGhlIHNlcmlhbGl6ZXIgbWFwcGluZ1xuICAgICAgICB2YXIgbXNnTGlzdCA9IE9iamVjdC5rZXlzKG1lc3NhZ2VzKS5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgbWFwcGVyID0gc2VyaWFsaXplci5jcmVhdGVOYW1lTWFwcGVyKG1lc3NhZ2VzW2lkXSk7XG4gICAgICAgICAgICB2YXIgc3JjID0gbWVzc2FnZXNbaWRdO1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gbWFwcGVyID8gbWFwcGVyVmlzaXRvci5jb252ZXJ0KHNyYy5ub2RlcywgbWFwcGVyKSA6IHNyYy5ub2RlcztcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZE1lc3NhZ2UgPSBuZXcgTWVzc2FnZShub2Rlcywge30sIHt9LCBzcmMubWVhbmluZywgc3JjLmRlc2NyaXB0aW9uLCBpZCk7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZE1lc3NhZ2Uuc291cmNlcyA9IHNyYy5zb3VyY2VzO1xuICAgICAgICAgICAgaWYgKGZpbHRlclNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZE1lc3NhZ2Uuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5maWxlUGF0aCA9IGZpbHRlclNvdXJjZXMoc291cmNlLmZpbGVQYXRoKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRNZXNzYWdlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIud3JpdGUobXNnTGlzdCwgdGhpcy5fbG9jYWxlKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlQnVuZGxlO1xufSgpKTtcbi8vIFRyYW5zZm9ybSBhbiBpMThuIEFTVCBieSByZW5hbWluZyB0aGUgcGxhY2Vob2xkZXIgbm9kZXMgd2l0aCB0aGUgZ2l2ZW4gbWFwcGVyXG52YXIgTWFwUGxhY2Vob2xkZXJOYW1lcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFwUGxhY2Vob2xkZXJOYW1lcywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXBQbGFjZWhvbGRlck5hbWVzKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE1hcFBsYWNlaG9sZGVyTmFtZXMucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAobm9kZXMsIG1hcHBlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbWFwcGVyID8gbm9kZXMubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnZpc2l0KF90aGlzLCBtYXBwZXIpOyB9KSA6IG5vZGVzO1xuICAgIH07XG4gICAgTWFwUGxhY2Vob2xkZXJOYW1lcy5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgbWFwcGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdGFydE5hbWUgPSBtYXBwZXIudG9QdWJsaWNOYW1lKHBoLnN0YXJ0TmFtZSk7XG4gICAgICAgIHZhciBjbG9zZU5hbWUgPSBwaC5jbG9zZU5hbWUgPyBtYXBwZXIudG9QdWJsaWNOYW1lKHBoLmNsb3NlTmFtZSkgOiBwaC5jbG9zZU5hbWU7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHBoLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi52aXNpdChfdGhpcywgbWFwcGVyKTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgVGFnUGxhY2Vob2xkZXIocGgudGFnLCBwaC5hdHRycywgc3RhcnROYW1lLCBjbG9zZU5hbWUsIGNoaWxkcmVuLCBwaC5pc1ZvaWQsIHBoLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgTWFwUGxhY2Vob2xkZXJOYW1lcy5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgbWFwcGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGxhY2Vob2xkZXIocGgudmFsdWUsIG1hcHBlci50b1B1YmxpY05hbWUocGgubmFtZSksIHBoLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgTWFwUGxhY2Vob2xkZXJOYW1lcy5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgbWFwcGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSWN1UGxhY2Vob2xkZXIocGgudmFsdWUsIG1hcHBlci50b1B1YmxpY05hbWUocGgubmFtZSksIHBoLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcFBsYWNlaG9sZGVyTmFtZXM7XG59KENsb25lVmlzaXRvcikpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgR2VuZXJhdGVkRmlsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHZW5lcmF0ZWRGaWxlKHNyY0ZpbGVVcmwsIGdlbkZpbGVVcmwsIHNvdXJjZU9yU3RtdHMpIHtcbiAgICAgICAgdGhpcy5zcmNGaWxlVXJsID0gc3JjRmlsZVVybDtcbiAgICAgICAgdGhpcy5nZW5GaWxlVXJsID0gZ2VuRmlsZVVybDtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VPclN0bXRzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2VPclN0bXRzO1xuICAgICAgICAgICAgdGhpcy5zdG10cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnN0bXRzID0gc291cmNlT3JTdG10cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBHZW5lcmF0ZWRGaWxlLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2VuRmlsZVVybCAhPT0gb3RoZXIuZ2VuRmlsZVVybCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlID09PSBvdGhlci5zb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyLnN0bXRzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiB0aGUgY29uc3RydWN0b3IgZ3VhcmFudGVlcyB0aGF0IGlmIHRoaXMuc291cmNlIGlzIG5vdCBmaWxsZWQsXG4gICAgICAgIC8vIHRoZW4gdGhpcy5zdG10cyBpcy5cbiAgICAgICAgcmV0dXJuIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5zdG10cywgb3RoZXIuc3RtdHMpO1xuICAgIH07XG4gICAgcmV0dXJuIEdlbmVyYXRlZEZpbGU7XG59KCkpO1xuZnVuY3Rpb24gdG9UeXBlU2NyaXB0KGZpbGUsIHByZWFtYmxlKSB7XG4gICAgaWYgKHByZWFtYmxlID09PSB2b2lkIDApIHsgcHJlYW1ibGUgPSAnJzsgfVxuICAgIGlmICghZmlsZS5zdG10cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBObyBzdG10cyBwcmVzZW50IG9uIEdlbmVyYXRlZEZpbGUgXCIgKyBmaWxlLmdlbkZpbGVVcmwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFR5cGVTY3JpcHRFbWl0dGVyKCkuZW1pdFN0YXRlbWVudHMoZmlsZS5nZW5GaWxlVXJsLCBmaWxlLnN0bXRzLCBwcmVhbWJsZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGxpc3RMYXp5Um91dGVzKG1vZHVsZU1ldGEsIHJlZmxlY3Rvcikge1xuICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iO1xuICAgIHZhciBhbGxMYXp5Um91dGVzID0gW107XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhtb2R1bGVNZXRhLnRyYW5zaXRpdmVNb2R1bGUucHJvdmlkZXJzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIF9lID0gX2QudmFsdWUsIHByb3ZpZGVyID0gX2UucHJvdmlkZXIsIG1vZHVsZSA9IF9lLm1vZHVsZTtcbiAgICAgICAgICAgIGlmICh0b2tlblJlZmVyZW5jZShwcm92aWRlci50b2tlbikgPT09IHJlZmxlY3Rvci5ST1VURVMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9hZENoaWxkcmVuID0gX2NvbGxlY3RMb2FkQ2hpbGRyZW4ocHJvdmlkZXIudXNlVmFsdWUpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGxvYWRDaGlsZHJlbl8xID0gKGVfMiA9IHZvaWQgMCwgX192YWx1ZXMobG9hZENoaWxkcmVuKSksIGxvYWRDaGlsZHJlbl8xXzEgPSBsb2FkQ2hpbGRyZW5fMS5uZXh0KCk7ICFsb2FkQ2hpbGRyZW5fMV8xLmRvbmU7IGxvYWRDaGlsZHJlbl8xXzEgPSBsb2FkQ2hpbGRyZW5fMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3V0ZSA9IGxvYWRDaGlsZHJlbl8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxMYXp5Um91dGVzLnB1c2gocGFyc2VMYXp5Um91dGUocm91dGUsIHJlZmxlY3RvciwgbW9kdWxlLnJlZmVyZW5jZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9hZENoaWxkcmVuXzFfMSAmJiAhbG9hZENoaWxkcmVuXzFfMS5kb25lICYmIChfYiA9IGxvYWRDaGlsZHJlbl8xLnJldHVybikpIF9iLmNhbGwobG9hZENoaWxkcmVuXzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhbGxMYXp5Um91dGVzO1xufVxuZnVuY3Rpb24gX2NvbGxlY3RMb2FkQ2hpbGRyZW4ocm91dGVzLCB0YXJnZXQpIHtcbiAgICB2YXIgZV8zLCBfYTtcbiAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsgdGFyZ2V0ID0gW107IH1cbiAgICBpZiAodHlwZW9mIHJvdXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGFyZ2V0LnB1c2gocm91dGVzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyb3V0ZXMpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciByb3V0ZXNfMSA9IF9fdmFsdWVzKHJvdXRlcyksIHJvdXRlc18xXzEgPSByb3V0ZXNfMS5uZXh0KCk7ICFyb3V0ZXNfMV8xLmRvbmU7IHJvdXRlc18xXzEgPSByb3V0ZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm91dGUgPSByb3V0ZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIF9jb2xsZWN0TG9hZENoaWxkcmVuKHJvdXRlLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVzXzFfMSAmJiAhcm91dGVzXzFfMS5kb25lICYmIChfYSA9IHJvdXRlc18xLnJldHVybikpIF9hLmNhbGwocm91dGVzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHJvdXRlcy5sb2FkQ2hpbGRyZW4pIHtcbiAgICAgICAgX2NvbGxlY3RMb2FkQ2hpbGRyZW4ocm91dGVzLmxvYWRDaGlsZHJlbiwgdGFyZ2V0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAocm91dGVzLmNoaWxkcmVuKSB7XG4gICAgICAgIF9jb2xsZWN0TG9hZENoaWxkcmVuKHJvdXRlcy5jaGlsZHJlbiwgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHBhcnNlTGF6eVJvdXRlKHJvdXRlLCByZWZsZWN0b3IsIG1vZHVsZSkge1xuICAgIHZhciBfYSA9IF9fcmVhZChyb3V0ZS5zcGxpdCgnIycpLCAyKSwgcm91dGVQYXRoID0gX2FbMF0sIHJvdXRlTmFtZSA9IF9hWzFdO1xuICAgIHZhciByZWZlcmVuY2VkTW9kdWxlID0gcmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZSh7XG4gICAgICAgIG1vZHVsZU5hbWU6IHJvdXRlUGF0aCxcbiAgICAgICAgbmFtZTogcm91dGVOYW1lLFxuICAgIH0sIG1vZHVsZSA/IG1vZHVsZS5maWxlUGF0aCA6IHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHsgcm91dGU6IHJvdXRlLCBtb2R1bGU6IG1vZHVsZSB8fCByZWZlcmVuY2VkTW9kdWxlLCByZWZlcmVuY2VkTW9kdWxlOiByZWZlcmVuY2VkTW9kdWxlIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUUyA9IC9eKD8hLipcXC5kXFwudHMkKS4qXFwudHMkLztcbnZhciBSZXNvbHZlZFN0YXRpY1N5bWJvbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNvbHZlZFN0YXRpY1N5bWJvbChzeW1ib2wsIG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgfVxuICAgIHJldHVybiBSZXNvbHZlZFN0YXRpY1N5bWJvbDtcbn0oKSk7XG52YXIgU1VQUE9SVEVEX1NDSEVNQV9WRVJTSU9OID0gNDtcbi8qKlxuICogVGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgbG9hZGluZyBtZXRhZGF0YSBwZXIgc3ltYm9sLFxuICogYW5kIG5vcm1hbGl6aW5nIHJlZmVyZW5jZXMgYmV0d2VlbiBzeW1ib2xzLlxuICpcbiAqIEludGVybmFsbHksIGl0IG9ubHkgdXNlcyBzeW1ib2xzIHdpdGhvdXQgbWVtYmVycyxcbiAqIGFuZCBkZWR1Y2VzIHRoZSB2YWx1ZXMgZm9yIHN5bWJvbHMgd2l0aCBtZW1iZXJzIGJhc2VkXG4gKiBvbiB0aGVzZSBzeW1ib2xzLlxuICovXG52YXIgU3RhdGljU3ltYm9sUmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljU3ltYm9sUmVzb2x2ZXIoaG9zdCwgc3RhdGljU3ltYm9sQ2FjaGUsIHN1bW1hcnlSZXNvbHZlciwgZXJyb3JSZWNvcmRlcikge1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLnN0YXRpY1N5bWJvbENhY2hlID0gc3RhdGljU3ltYm9sQ2FjaGU7XG4gICAgICAgIHRoaXMuc3VtbWFyeVJlc29sdmVyID0gc3VtbWFyeVJlc29sdmVyO1xuICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIgPSBlcnJvclJlY29yZGVyO1xuICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE5vdGU6IHRoaXMgd2lsbCBvbmx5IGNvbnRhaW4gU3RhdGljU3ltYm9scyB3aXRob3V0IG1lbWJlcnMhXG4gICAgICAgIHRoaXMucmVzb2x2ZWRTeW1ib2xzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlc29sdmVkRmlsZVBhdGhzID0gbmV3IFNldCgpO1xuICAgICAgICAvLyBOb3RlOiB0aGlzIHdpbGwgb25seSBjb250YWluIFN0YXRpY1N5bWJvbHMgd2l0aG91dCBtZW1iZXJzIVxuICAgICAgICB0aGlzLmltcG9ydEFzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN5bWJvbFJlc291cmNlUGF0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc3ltYm9sRnJvbUZpbGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMua25vd25GaWxlTmFtZVRvTW9kdWxlTmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlU3ltYm9sID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICBpZiAoc3RhdGljU3ltYm9sLm1lbWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVTeW1ib2xNZW1iZXJzKHN0YXRpY1N5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogYWx3YXlzIGFzayBmb3IgYSBzdW1tYXJ5IGZpcnN0LFxuICAgICAgICAvLyBhcyB3ZSBtaWdodCBoYXZlIHJlYWQgc2hhbGxvdyBtZXRhZGF0YSB2aWEgYSAuZC50cyBmaWxlXG4gICAgICAgIC8vIGZvciB0aGUgc3ltYm9sLlxuICAgICAgICB2YXIgcmVzdWx0RnJvbVN1bW1hcnkgPSB0aGlzLl9yZXNvbHZlU3ltYm9sRnJvbVN1bW1hcnkoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgaWYgKHJlc3VsdEZyb21TdW1tYXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0RnJvbVN1bW1hcnk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdEZyb21DYWNoZSA9IHRoaXMucmVzb2x2ZWRTeW1ib2xzLmdldChzdGF0aWNTeW1ib2wpO1xuICAgICAgICBpZiAocmVzdWx0RnJvbUNhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0RnJvbUNhY2hlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IFNvbWUgdXNlcnMgdXNlIGxpYnJhcmllcyB0aGF0IHdlcmUgbm90IGNvbXBpbGVkIHdpdGggbmdjLCBpLmUuIHRoZXkgZG9uJ3RcbiAgICAgICAgLy8gaGF2ZSBzdW1tYXJpZXMsIG9ubHkgLmQudHMgZmlsZXMuIFNvIHdlIGFsd2F5cyBuZWVkIHRvIGNoZWNrIGJvdGgsIHRoZSBzdW1tYXJ5XG4gICAgICAgIC8vIGFuZCBtZXRhZGF0YS5cbiAgICAgICAgdGhpcy5fY3JlYXRlU3ltYm9sc09mKHN0YXRpY1N5bWJvbC5maWxlUGF0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkU3ltYm9scy5nZXQoc3RhdGljU3ltYm9sKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldEltcG9ydEFzIHByb2R1Y2VzIGEgc3ltYm9sIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW1wb3J0IHRoZSBnaXZlbiBzeW1ib2wuXG4gICAgICogVGhlIGltcG9ydCBtaWdodCBiZSBkaWZmZXJlbnQgdGhhbiB0aGUgc3ltYm9sIGlmIHRoZSBzeW1ib2wgaXMgZXhwb3J0ZWQgZnJvbVxuICAgICAqIGEgbGlicmFyeSB3aXRoIGEgc3VtbWFyeTsgaW4gd2hpY2ggY2FzZSB3ZSB3YW50IHRvIGltcG9ydCB0aGUgc3ltYm9sIGZyb20gdGhlXG4gICAgICogbmdmYWN0b3J5IHJlLWV4cG9ydCBpbnN0ZWFkIG9mIGRpcmVjdGx5IHRvIGF2b2lkIGludHJvZHVjaW5nIGEgZGlyZWN0IGRlcGVuZGVuY3lcbiAgICAgKiBvbiBhbiBvdGhlcndpc2UgaW5kaXJlY3QgZGVwZW5kZW5jeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0aWNTeW1ib2wgdGhlIHN5bWJvbCBmb3Igd2hpY2ggdG8gZ2VuZXJhdGUgYSBpbXBvcnQgc3ltYm9sXG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmdldEltcG9ydEFzID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCwgdXNlU3VtbWFyaWVzKSB7XG4gICAgICAgIGlmICh1c2VTdW1tYXJpZXMgPT09IHZvaWQgMCkgeyB1c2VTdW1tYXJpZXMgPSB0cnVlOyB9XG4gICAgICAgIGlmIChzdGF0aWNTeW1ib2wubWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBiYXNlU3ltYm9sID0gdGhpcy5nZXRTdGF0aWNTeW1ib2woc3RhdGljU3ltYm9sLmZpbGVQYXRoLCBzdGF0aWNTeW1ib2wubmFtZSk7XG4gICAgICAgICAgICB2YXIgYmFzZUltcG9ydEFzID0gdGhpcy5nZXRJbXBvcnRBcyhiYXNlU3ltYm9sLCB1c2VTdW1tYXJpZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VJbXBvcnRBcyA/XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRTdGF0aWNTeW1ib2woYmFzZUltcG9ydEFzLmZpbGVQYXRoLCBiYXNlSW1wb3J0QXMubmFtZSwgc3RhdGljU3ltYm9sLm1lbWJlcnMpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdW1tYXJpemVkRmlsZU5hbWUgPSBzdHJpcFN1bW1hcnlGb3JKaXRGaWxlU3VmZml4KHN0YXRpY1N5bWJvbC5maWxlUGF0aCk7XG4gICAgICAgIGlmIChzdW1tYXJpemVkRmlsZU5hbWUgIT09IHN0YXRpY1N5bWJvbC5maWxlUGF0aCkge1xuICAgICAgICAgICAgdmFyIHN1bW1hcml6ZWROYW1lID0gc3RyaXBTdW1tYXJ5Rm9ySml0TmFtZVN1ZmZpeChzdGF0aWNTeW1ib2wubmFtZSk7XG4gICAgICAgICAgICB2YXIgYmFzZVN5bWJvbCA9IHRoaXMuZ2V0U3RhdGljU3ltYm9sKHN1bW1hcml6ZWRGaWxlTmFtZSwgc3VtbWFyaXplZE5hbWUsIHN0YXRpY1N5bWJvbC5tZW1iZXJzKTtcbiAgICAgICAgICAgIHZhciBiYXNlSW1wb3J0QXMgPSB0aGlzLmdldEltcG9ydEFzKGJhc2VTeW1ib2wsIHVzZVN1bW1hcmllcyk7XG4gICAgICAgICAgICByZXR1cm4gYmFzZUltcG9ydEFzID9cbiAgICAgICAgICAgICAgICB0aGlzLmdldFN0YXRpY1N5bWJvbChzdW1tYXJ5Rm9ySml0RmlsZU5hbWUoYmFzZUltcG9ydEFzLmZpbGVQYXRoKSwgc3VtbWFyeUZvckppdE5hbWUoYmFzZUltcG9ydEFzLm5hbWUpLCBiYXNlU3ltYm9sLm1lbWJlcnMpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAodXNlU3VtbWFyaWVzICYmIHRoaXMuc3VtbWFyeVJlc29sdmVyLmdldEltcG9ydEFzKHN0YXRpY1N5bWJvbCkpIHx8IG51bGw7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmltcG9ydEFzLmdldChzdGF0aWNTeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRSZXNvdXJjZVBhdGggcHJvZHVjZXMgdGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIHRoZSBzeW1ib2wgYW5kIHNob3VsZFxuICAgICAqIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSByZWxhdGl2ZSBsb2NhdGlvbiBvZiByZXNvdXJjZSByZWZlcmVuY2VzIHJlY29yZGVkIGluXG4gICAgICogc3ltYm9sIG1ldGFkYXRhLlxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRSZXNvdXJjZVBhdGggPSBmdW5jdGlvbiAoc3RhdGljU3ltYm9sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFJlc291cmNlUGF0aHMuZ2V0KHN0YXRpY1N5bWJvbCkgfHwgc3RhdGljU3ltYm9sLmZpbGVQYXRoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2V0VHlwZUFyaXR5IHJldHVybnMgdGhlIG51bWJlciBvZiBnZW5lcmljIHR5cGUgcGFyYW1ldGVycyB0aGUgZ2l2ZW4gc3ltYm9sXG4gICAgICogaGFzLiBJZiB0aGUgc3ltYm9sIGlzIG5vdCBhIHR5cGUgdGhlIHJlc3VsdCBpcyBudWxsLlxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRUeXBlQXJpdHkgPSBmdW5jdGlvbiAoc3RhdGljU3ltYm9sKSB7XG4gICAgICAgIC8vIElmIHRoZSBmaWxlIGlzIGEgZmFjdG9yeS9uZ3N1bW1hcnkgZmlsZSwgZG9uJ3QgcmVzb2x2ZSB0aGUgc3ltYm9sIGFzIGRvaW5nIHNvIHdvdWxkXG4gICAgICAgIC8vIGNhdXNlIHRoZSBtZXRhZGF0YSBmb3IgYW4gZmFjdG9yeS9uZ3N1bW1hcnkgZmlsZSB0byBiZSBsb2FkZWQgd2hpY2ggZG9lc24ndCBleGlzdC5cbiAgICAgICAgLy8gQWxsIHJlZmVyZW5jZXMgdG8gZ2VuZXJhdGVkIGNsYXNzZXMgbXVzdCBpbmNsdWRlIHRoZSBjb3JyZWN0IGFyaXR5IHdoZW5ldmVyXG4gICAgICAgIC8vIGdlbmVyYXRpbmcgY29kZS5cbiAgICAgICAgaWYgKGlzR2VuZXJhdGVkRmlsZShzdGF0aWNTeW1ib2wuZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzb2x2ZWRTeW1ib2wgPSB1bndyYXBSZXNvbHZlZE1ldGFkYXRhKHRoaXMucmVzb2x2ZVN5bWJvbChzdGF0aWNTeW1ib2wpKTtcbiAgICAgICAgd2hpbGUgKHJlc29sdmVkU3ltYm9sICYmIHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXNvbHZlZFN5bWJvbCA9IHVud3JhcFJlc29sdmVkTWV0YWRhdGEodGhpcy5yZXNvbHZlU3ltYm9sKHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChyZXNvbHZlZFN5bWJvbCAmJiByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YSAmJiByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YS5hcml0eSkgfHwgbnVsbDtcbiAgICB9O1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRLbm93bk1vZHVsZU5hbWUgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua25vd25GaWxlTmFtZVRvTW9kdWxlTmFtZXMuZ2V0KGZpbGVQYXRoKSB8fCBudWxsO1xuICAgIH07XG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLnJlY29yZEltcG9ydEFzID0gZnVuY3Rpb24gKHNvdXJjZVN5bWJvbCwgdGFyZ2V0U3ltYm9sKSB7XG4gICAgICAgIHNvdXJjZVN5bWJvbC5hc3NlcnROb01lbWJlcnMoKTtcbiAgICAgICAgdGFyZ2V0U3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICB0aGlzLmltcG9ydEFzLnNldChzb3VyY2VTeW1ib2wsIHRhcmdldFN5bWJvbCk7XG4gICAgfTtcbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUucmVjb3JkTW9kdWxlTmFtZUZvckZpbGVOYW1lID0gZnVuY3Rpb24gKGZpbGVOYW1lLCBtb2R1bGVOYW1lKSB7XG4gICAgICAgIHRoaXMua25vd25GaWxlTmFtZVRvTW9kdWxlTmFtZXMuc2V0KGZpbGVOYW1lLCBtb2R1bGVOYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGUgYWxsIGluZm9ybWF0aW9uIGRlcml2ZWQgZnJvbSB0aGUgZ2l2ZW4gZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlTmFtZSB0aGUgZmlsZSB0byBpbnZhbGlkYXRlXG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmludmFsaWRhdGVGaWxlID0gZnVuY3Rpb24gKGZpbGVOYW1lKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGUuZGVsZXRlKGZpbGVOYW1lKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZEZpbGVQYXRocy5kZWxldGUoZmlsZU5hbWUpO1xuICAgICAgICB2YXIgc3ltYm9scyA9IHRoaXMuc3ltYm9sRnJvbUZpbGUuZ2V0KGZpbGVOYW1lKTtcbiAgICAgICAgaWYgKHN5bWJvbHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sRnJvbUZpbGUuZGVsZXRlKGZpbGVOYW1lKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc3ltYm9sc18xID0gX192YWx1ZXMoc3ltYm9scyksIHN5bWJvbHNfMV8xID0gc3ltYm9sc18xLm5leHQoKTsgIXN5bWJvbHNfMV8xLmRvbmU7IHN5bWJvbHNfMV8xID0gc3ltYm9sc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRTeW1ib2xzLmRlbGV0ZShzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydEFzLmRlbGV0ZShzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bWJvbFJlc291cmNlUGF0aHMuZGVsZXRlKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzeW1ib2xzXzFfMSAmJiAhc3ltYm9sc18xXzEuZG9uZSAmJiAoX2EgPSBzeW1ib2xzXzEucmV0dXJuKSkgX2EuY2FsbChzeW1ib2xzXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuaWdub3JlRXJyb3JzRm9yID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciByZWNvcmRlciA9IHRoaXMuZXJyb3JSZWNvcmRlcjtcbiAgICAgICAgdGhpcy5lcnJvclJlY29yZGVyID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIgPSByZWNvcmRlcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLl9yZXNvbHZlU3ltYm9sTWVtYmVycyA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgdmFyIG1lbWJlcnMgPSBzdGF0aWNTeW1ib2wubWVtYmVycztcbiAgICAgICAgdmFyIGJhc2VSZXNvbHZlZFN5bWJvbCA9IHRoaXMucmVzb2x2ZVN5bWJvbCh0aGlzLmdldFN0YXRpY1N5bWJvbChzdGF0aWNTeW1ib2wuZmlsZVBhdGgsIHN0YXRpY1N5bWJvbC5uYW1lKSk7XG4gICAgICAgIGlmICghYmFzZVJlc29sdmVkU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzZU1ldGFkYXRhID0gdW53cmFwUmVzb2x2ZWRNZXRhZGF0YShiYXNlUmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEpO1xuICAgICAgICBpZiAoYmFzZU1ldGFkYXRhIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkU3RhdGljU3ltYm9sKHN0YXRpY1N5bWJvbCwgdGhpcy5nZXRTdGF0aWNTeW1ib2woYmFzZU1ldGFkYXRhLmZpbGVQYXRoLCBiYXNlTWV0YWRhdGEubmFtZSwgbWVtYmVycykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJhc2VNZXRhZGF0YSAmJiBiYXNlTWV0YWRhdGEuX19zeW1ib2xpYyA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgaWYgKGJhc2VNZXRhZGF0YS5zdGF0aWNzICYmIG1lbWJlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzdGF0aWNTeW1ib2wsIGJhc2VNZXRhZGF0YS5zdGF0aWNzW21lbWJlcnNbMF1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGJhc2VNZXRhZGF0YTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVtYmVycy5sZW5ndGggJiYgdmFsdWU7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbbWVtYmVyc1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkU3RhdGljU3ltYm9sKHN0YXRpY1N5bWJvbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLl9yZXNvbHZlU3ltYm9sRnJvbVN1bW1hcnkgPSBmdW5jdGlvbiAoc3RhdGljU3ltYm9sKSB7XG4gICAgICAgIHZhciBzdW1tYXJ5ID0gdGhpcy5zdW1tYXJ5UmVzb2x2ZXIucmVzb2x2ZVN1bW1hcnkoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgcmV0dXJuIHN1bW1hcnkgPyBuZXcgUmVzb2x2ZWRTdGF0aWNTeW1ib2woc3RhdGljU3ltYm9sLCBzdW1tYXJ5Lm1ldGFkYXRhKSA6IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRTdGF0aWNTeW1ib2wgcHJvZHVjZXMgYSBUeXBlIHdob3NlIG1ldGFkYXRhIGlzIGtub3duIGJ1dCB3aG9zZSBpbXBsZW1lbnRhdGlvbiBpcyBub3QgbG9hZGVkLlxuICAgICAqIEFsbCB0eXBlcyBwYXNzZWQgdG8gdGhlIFN0YXRpY1Jlc29sdmVyIHNob3VsZCBiZSBwc2V1ZG8tdHlwZXMgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVjbGFyYXRpb25GaWxlIHRoZSBhYnNvbHV0ZSBwYXRoIG9mIHRoZSBmaWxlIHdoZXJlIHRoZSBzeW1ib2wgaXMgZGVjbGFyZWRcbiAgICAgKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgdHlwZS5cbiAgICAgKiBAcGFyYW0gbWVtYmVycyBhIHN5bWJvbCBmb3IgYSBzdGF0aWMgbWVtYmVyIG9mIHRoZSBuYW1lZCB0eXBlXG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmdldFN0YXRpY1N5bWJvbCA9IGZ1bmN0aW9uIChkZWNsYXJhdGlvbkZpbGUsIG5hbWUsIG1lbWJlcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGljU3ltYm9sQ2FjaGUuZ2V0KGRlY2xhcmF0aW9uRmlsZSwgbmFtZSwgbWVtYmVycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBoYXNEZWNvcmF0b3JzIGNoZWNrcyBhIGZpbGUncyBtZXRhZGF0YSBmb3IgdGhlIHByZXNlbmNlIG9mIGRlY29yYXRvcnMgd2l0aG91dCBldmFsdWF0aW5nIHRoZVxuICAgICAqIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIHRoZSBhYnNvbHV0ZSBwYXRoIHRvIGV4YW1pbmUgZm9yIGRlY29yYXRvcnMuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBhbnkgY2xhc3MgaW4gdGhlIGZpbGUgaGFzIGEgZGVjb3JhdG9yLlxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5oYXNEZWNvcmF0b3JzID0gZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IHRoaXMuZ2V0TW9kdWxlTWV0YWRhdGEoZmlsZVBhdGgpO1xuICAgICAgICBpZiAobWV0YWRhdGFbJ21ldGFkYXRhJ10pIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtZXRhZGF0YVsnbWV0YWRhdGEnXSkuc29tZShmdW5jdGlvbiAobWV0YWRhdGFLZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBtZXRhZGF0YVsnbWV0YWRhdGEnXVttZXRhZGF0YUtleV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5Ll9fc3ltYm9saWMgPT09ICdjbGFzcycgJiYgZW50cnkuZGVjb3JhdG9ycztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRTeW1ib2xzT2YgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgdmFyIHN1bW1hcnlTeW1ib2xzID0gdGhpcy5zdW1tYXJ5UmVzb2x2ZXIuZ2V0U3ltYm9sc09mKGZpbGVQYXRoKTtcbiAgICAgICAgaWYgKHN1bW1hcnlTeW1ib2xzKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VtbWFyeVN5bWJvbHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogU29tZSB1c2VycyB1c2UgbGlicmFyaWVzIHRoYXQgd2VyZSBub3QgY29tcGlsZWQgd2l0aCBuZ2MsIGkuZS4gdGhleSBkb24ndFxuICAgICAgICAvLyBoYXZlIHN1bW1hcmllcywgb25seSAuZC50cyBmaWxlcywgYnV0IGBzdW1tYXJ5UmVzb2x2ZXIuaXNMaWJyYXJ5RmlsZWAgcmV0dXJucyB0cnVlLlxuICAgICAgICB0aGlzLl9jcmVhdGVTeW1ib2xzT2YoZmlsZVBhdGgpO1xuICAgICAgICB2YXIgbWV0YWRhdGFTeW1ib2xzID0gW107XG4gICAgICAgIHRoaXMucmVzb2x2ZWRTeW1ib2xzLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmVkU3ltYm9sKSB7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRTeW1ib2wuc3ltYm9sLmZpbGVQYXRoID09PSBmaWxlUGF0aCkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhU3ltYm9scy5wdXNoKHJlc29sdmVkU3ltYm9sLnN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWV0YWRhdGFTeW1ib2xzO1xuICAgIH07XG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLl9jcmVhdGVTeW1ib2xzT2YgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgdmFyIGVfMiwgX2E7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnJlc29sdmVkRmlsZVBhdGhzLmhhcyhmaWxlUGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc29sdmVkRmlsZVBhdGhzLmFkZChmaWxlUGF0aCk7XG4gICAgICAgIHZhciByZXNvbHZlZFN5bWJvbHMgPSBbXTtcbiAgICAgICAgdmFyIG1ldGFkYXRhID0gdGhpcy5nZXRNb2R1bGVNZXRhZGF0YShmaWxlUGF0aCk7XG4gICAgICAgIGlmIChtZXRhZGF0YVsnaW1wb3J0QXMnXSkge1xuICAgICAgICAgICAgLy8gSW5kZXggYnVuZGxlIGluZGljZXMgc2hvdWxkIHVzZSB0aGUgaW1wb3J0QXMgbW9kdWxlIG5hbWUgZGVmaW5lZFxuICAgICAgICAgICAgLy8gaW4gdGhlIGJ1bmRsZS5cbiAgICAgICAgICAgIHRoaXMua25vd25GaWxlTmFtZVRvTW9kdWxlTmFtZXMuc2V0KGZpbGVQYXRoLCBtZXRhZGF0YVsnaW1wb3J0QXMnXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBzeW1ib2xzIGluIG9uZSBvZiB0aGUgcmUtZXhwb3J0IGxvY2F0aW9uXG4gICAgICAgIGlmIChtZXRhZGF0YVsnZXhwb3J0cyddKSB7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChtb2R1bGVFeHBvcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdGhlIHN5bWJvbHMgaW4gdGhlIGxpc3Qgb2YgZXhwbGljaXRseSByZS1leHBvcnRlZCBzeW1ib2xzLlxuICAgICAgICAgICAgICAgIGlmIChtb2R1bGVFeHBvcnQuZXhwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUV4cG9ydC5leHBvcnQuZm9yRWFjaChmdW5jdGlvbiAoZXhwb3J0U3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9sTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwb3J0U3ltYm9sID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbE5hbWUgPSBleHBvcnRTeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xOYW1lID0gZXhwb3J0U3ltYm9sLmFzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sTmFtZSA9IHVuZXNjYXBlSWRlbnRpZmllcihzeW1ib2xOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW1OYW1lID0gc3ltYm9sTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwb3J0U3ltYm9sICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bU5hbWUgPSB1bmVzY2FwZUlkZW50aWZpZXIoZXhwb3J0U3ltYm9sLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkTW9kdWxlID0gX3RoaXMucmVzb2x2ZU1vZHVsZShtb2R1bGVFeHBvcnQuZnJvbSwgZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldFN5bWJvbCA9IF90aGlzLmdldFN0YXRpY1N5bWJvbChyZXNvbHZlZE1vZHVsZSwgc3ltTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZVN5bWJvbCA9IF90aGlzLmdldFN0YXRpY1N5bWJvbChmaWxlUGF0aCwgc3ltYm9sTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRTeW1ib2xzLnB1c2goX3RoaXMuY3JlYXRlRXhwb3J0KHNvdXJjZVN5bWJvbCwgdGFyZ2V0U3ltYm9sKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBzeW1ib2xzIHZpYSBleHBvcnQgKiBkaXJlY3RpdmVzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZWRNb2R1bGUgPSB0aGlzXzEucmVzb2x2ZU1vZHVsZShtb2R1bGVFeHBvcnQuZnJvbSwgZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXN0ZWRFeHBvcnRzID0gdGhpc18xLmdldFN5bWJvbHNPZihyZXNvbHZlZE1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRFeHBvcnRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldFN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VTeW1ib2wgPSBfdGhpcy5nZXRTdGF0aWNTeW1ib2woZmlsZVBhdGgsIHRhcmdldFN5bWJvbC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFN5bWJvbHMucHVzaChfdGhpcy5jcmVhdGVFeHBvcnQoc291cmNlU3ltYm9sLCB0YXJnZXRTeW1ib2wpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKG1ldGFkYXRhWydleHBvcnRzJ10pLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2R1bGVFeHBvcnQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2xvb3BfMShtb2R1bGVFeHBvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgdGhlIGFjdHVhbCBtZXRhZGF0YS4gSGFzIHRvIGJlIGFmdGVyIHRoZSBleHBvcnRzXG4gICAgICAgIC8vIGFzIHRoZXJlIG1pZ2h0IGJlIGNvbGxpc2lvbnMgaW4gdGhlIG5hbWVzLCBhbmQgd2Ugd2FudCB0aGUgc3ltYm9sc1xuICAgICAgICAvLyBvZiB0aGUgY3VycmVudCBtb2R1bGUgdG8gd2luIG9mdGVyIHJlZXhwb3J0cy5cbiAgICAgICAgaWYgKG1ldGFkYXRhWydtZXRhZGF0YSddKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgZGlyZWN0IGRlY2xhcmF0aW9ucyBvZiB0aGUgc3ltYm9sXG4gICAgICAgICAgICB2YXIgdG9wTGV2ZWxTeW1ib2xOYW1lc18xID0gbmV3IFNldChPYmplY3Qua2V5cyhtZXRhZGF0YVsnbWV0YWRhdGEnXSkubWFwKHVuZXNjYXBlSWRlbnRpZmllcikpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbnNfMSA9IG1ldGFkYXRhWydvcmlnaW5zJ10gfHwge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhtZXRhZGF0YVsnbWV0YWRhdGEnXSkuZm9yRWFjaChmdW5jdGlvbiAobWV0YWRhdGFLZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sTWV0YSA9IG1ldGFkYXRhWydtZXRhZGF0YSddW21ldGFkYXRhS2V5XTtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHVuZXNjYXBlSWRlbnRpZmllcihtZXRhZGF0YUtleSk7XG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IF90aGlzLmdldFN0YXRpY1N5bWJvbChmaWxlUGF0aCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IG9yaWdpbnNfMS5oYXNPd25Qcm9wZXJ0eShtZXRhZGF0YUtleSkgJiYgb3JpZ2luc18xW21ldGFkYXRhS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzeW1ib2wgaXMgZnJvbSBhIGJ1bmRsZWQgaW5kZXgsIHVzZSB0aGUgZGVjbGFyYXRpb24gbG9jYXRpb24gb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN5bWJvbCBzbyByZWxhdGl2ZSByZWZlcmVuY2VzIChzdWNoIGFzICcuL215Lmh0bWwnKSB3aWxsIGJlIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luRmlsZVBhdGggPSBfdGhpcy5yZXNvbHZlTW9kdWxlKG9yaWdpbiwgZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbkZpbGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBvcnRFcnJvcihuZXcgRXJyb3IoXCJDb3VsZG4ndCByZXNvbHZlIG9yaWdpbmFsIHN5bWJvbCBmb3IgXCIgKyBvcmlnaW4gKyBcIiBmcm9tIFwiICsgX3RoaXMuaG9zdC5nZXRPdXRwdXROYW1lKGZpbGVQYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3ltYm9sUmVzb3VyY2VQYXRocy5zZXQoc3ltYm9sLCBvcmlnaW5GaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRTeW1ib2xzLnB1c2goX3RoaXMuY3JlYXRlUmVzb2x2ZWRTeW1ib2woc3ltYm9sLCBmaWxlUGF0aCwgdG9wTGV2ZWxTeW1ib2xOYW1lc18xLCBzeW1ib2xNZXRhKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlZFN5bWJvbHMuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZWRTeW1ib2wpIHsgcmV0dXJuIF90aGlzLnJlc29sdmVkU3ltYm9scy5zZXQocmVzb2x2ZWRTeW1ib2wuc3ltYm9sLCByZXNvbHZlZFN5bWJvbCk7IH0pO1xuICAgICAgICB0aGlzLnN5bWJvbEZyb21GaWxlLnNldChmaWxlUGF0aCwgcmVzb2x2ZWRTeW1ib2xzLm1hcChmdW5jdGlvbiAocmVzb2x2ZWRTeW1ib2wpIHsgcmV0dXJuIHJlc29sdmVkU3ltYm9sLnN5bWJvbDsgfSkpO1xuICAgIH07XG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmNyZWF0ZVJlc29sdmVkU3ltYm9sID0gZnVuY3Rpb24gKHNvdXJjZVN5bWJvbCwgdG9wTGV2ZWxQYXRoLCB0b3BMZXZlbFN5bWJvbE5hbWVzLCBtZXRhZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBGb3IgY2xhc3NlcyB0aGF0IGRvbid0IGhhdmUgQW5ndWxhciBzdW1tYXJpZXMgLyBtZXRhZGF0YSxcbiAgICAgICAgLy8gd2Ugb25seSBrZWVwIHRoZWlyIGFyaXR5LCBidXQgbm90aGluZyBlbHNlXG4gICAgICAgIC8vIChlLmcuIHRoZWlyIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMpLlxuICAgICAgICAvLyBXZSBkbyB0aGlzIHRvIHByZXZlbnQgaW50cm9kdWNpbmcgZGVlcCBpbXBvcnRzXG4gICAgICAgIC8vIGFzIHdlIGRpZG4ndCBnZW5lcmF0ZSAubmdmYWN0b3J5LnRzIGZpbGVzIHdpdGggcHJvcGVyIHJlZXhwb3J0cy5cbiAgICAgICAgdmFyIGlzVHNGaWxlID0gVFMudGVzdChzb3VyY2VTeW1ib2wuZmlsZVBhdGgpO1xuICAgICAgICBpZiAodGhpcy5zdW1tYXJ5UmVzb2x2ZXIuaXNMaWJyYXJ5RmlsZShzb3VyY2VTeW1ib2wuZmlsZVBhdGgpICYmICFpc1RzRmlsZSAmJiBtZXRhZGF0YSAmJlxuICAgICAgICAgICAgbWV0YWRhdGFbJ19fc3ltYm9saWMnXSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkTWV0YV8xID0geyBfX3N5bWJvbGljOiAnY2xhc3MnLCBhcml0eTogbWV0YWRhdGEuYXJpdHkgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRTdGF0aWNTeW1ib2woc291cmNlU3ltYm9sLCB0cmFuc2Zvcm1lZE1ldGFfMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9vcmlnaW5hbEZpbGVNZW1vO1xuICAgICAgICB2YXIgZ2V0T3JpZ2luYWxOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfb3JpZ2luYWxGaWxlTWVtbykge1xuICAgICAgICAgICAgICAgIC8vIEd1ZXNzIHdoYXQgdGhlIG9yaWdpbmFsIGZpbGUgbmFtZSBpcyBmcm9tIHRoZSByZWZlcmVuY2UuIElmIGl0IGhhcyBhIGAuZC50c2AgZXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBpdCB3aXRoIGAudHNgLiBJZiBpdCBhbHJlYWR5IGhhcyBgLnRzYCBqdXN0IGxlYXZlIGl0IGluIHBsYWNlLiBJZiBpdCBkb2Vzbid0IGhhdmVcbiAgICAgICAgICAgICAgICAvLyAudHMgb3IgLmQudHMsIGFwcGVuZCBgLnRzJy4gQWxzbywgaWYgaXQgaXMgaW4gYG5vZGVfbW9kdWxlc2AsIHRyaW0gdGhlIGBub2RlX21vZHVsZWBcbiAgICAgICAgICAgICAgICAvLyBsb2NhdGlvbiBhcyBpdCBpcyBub3QgaW1wb3J0YW50IHRvIGZpbmRpbmcgdGhlIGZpbGUuXG4gICAgICAgICAgICAgICAgX29yaWdpbmFsRmlsZU1lbW8gPVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ob3N0LmdldE91dHB1dE5hbWUodG9wTGV2ZWxQYXRoLnJlcGxhY2UoLygoXFwudHMpfChcXC5kXFwudHMpfCkkLywgJy50cycpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXi4qbm9kZV9tb2R1bGVzWy9cXFxcXS8sICcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX29yaWdpbmFsRmlsZU1lbW87XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIFJlZmVyZW5jZVRyYW5zZm9ybWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKFJlZmVyZW5jZVRyYW5zZm9ybWVyLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gUmVmZXJlbmNlVHJhbnNmb3JtZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVmZXJlbmNlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwID0gZnVuY3Rpb24gKG1hcCwgZnVuY3Rpb25QYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9saWMgPSBtYXBbJ19fc3ltYm9saWMnXTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9saWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZExlbiA9IGZ1bmN0aW9uUGFyYW1zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25QYXJhbXMucHVzaC5hcHBseShmdW5jdGlvblBhcmFtcywgX19zcHJlYWQoKG1hcFsncGFyYW1ldGVycyddIHx8IFtdKSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcC5jYWxsKHRoaXMsIG1hcCwgZnVuY3Rpb25QYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblBhcmFtcy5sZW5ndGggPSBvbGRMZW47XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN5bWJvbGljID09PSAncmVmZXJlbmNlJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kdWxlID0gbWFwWydtb2R1bGUnXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IG1hcFsnbmFtZSddID8gdW5lc2NhcGVJZGVudGlmaWVyKG1hcFsnbmFtZSddKSA6IG1hcFsnbmFtZSddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWVfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVQYXRoID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlUGF0aCA9IHNlbGYucmVzb2x2ZU1vZHVsZShtb2R1bGUsIHNvdXJjZVN5bWJvbC5maWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19zeW1ib2xpYzogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJDb3VsZCBub3QgcmVzb2x2ZSBcIiArIG1vZHVsZSArIFwiIHJlbGF0aXZlIHRvIFwiICsgc2VsZi5ob3N0LmdldE1ldGFkYXRhRm9yKHNvdXJjZVN5bWJvbC5maWxlUGF0aCkgKyBcIi5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbWFwWydsaW5lJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlcjogbWFwWydjaGFyYWN0ZXInXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IGdldE9yaWdpbmFsTmFtZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19zeW1ib2xpYzogJ3Jlc29sdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IHNlbGYuZ2V0U3RhdGljU3ltYm9sKGZpbGVQYXRoLCBuYW1lXzEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IG1hcFsnbGluZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlcjogbWFwWydjaGFyYWN0ZXInXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogZ2V0T3JpZ2luYWxOYW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnVuY3Rpb25QYXJhbXMuaW5kZXhPZihuYW1lXzEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIHBhcmFtZXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgX19zeW1ib2xpYzogJ3JlZmVyZW5jZScsIG5hbWU6IG5hbWVfMSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvcExldmVsU3ltYm9sTmFtZXMuaGFzKG5hbWVfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRTdGF0aWNTeW1ib2wodG9wTGV2ZWxQYXRoLCBuYW1lXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW1iaWVudCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzeW1ib2xpYyA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIG1hcCwgeyBmaWxlTmFtZTogZ2V0T3JpZ2luYWxOYW1lKCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcC5jYWxsKHRoaXMsIG1hcCwgZnVuY3Rpb25QYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gUmVmZXJlbmNlVHJhbnNmb3JtZXI7XG4gICAgICAgIH0oVmFsdWVUcmFuc2Zvcm1lcikpO1xuICAgICAgICB2YXIgdHJhbnNmb3JtZWRNZXRhID0gdmlzaXRWYWx1ZShtZXRhZGF0YSwgbmV3IFJlZmVyZW5jZVRyYW5zZm9ybWVyKCksIFtdKTtcbiAgICAgICAgdmFyIHVud3JhcHBlZFRyYW5zZm9ybWVkTWV0YSA9IHVud3JhcFJlc29sdmVkTWV0YWRhdGEodHJhbnNmb3JtZWRNZXRhKTtcbiAgICAgICAgaWYgKHVud3JhcHBlZFRyYW5zZm9ybWVkTWV0YSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhwb3J0KHNvdXJjZVN5bWJvbCwgdW53cmFwcGVkVHJhbnNmb3JtZWRNZXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkU3RhdGljU3ltYm9sKHNvdXJjZVN5bWJvbCwgdHJhbnNmb3JtZWRNZXRhKTtcbiAgICB9O1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5jcmVhdGVFeHBvcnQgPSBmdW5jdGlvbiAoc291cmNlU3ltYm9sLCB0YXJnZXRTeW1ib2wpIHtcbiAgICAgICAgc291cmNlU3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICB0YXJnZXRTeW1ib2wuYXNzZXJ0Tm9NZW1iZXJzKCk7XG4gICAgICAgIGlmICh0aGlzLnN1bW1hcnlSZXNvbHZlci5pc0xpYnJhcnlGaWxlKHNvdXJjZVN5bWJvbC5maWxlUGF0aCkgJiZcbiAgICAgICAgICAgIHRoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUodGFyZ2V0U3ltYm9sLmZpbGVQYXRoKSkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYXNlIGlzIGZvciBhbiBuZyBsaWJyYXJ5IGltcG9ydGluZyBzeW1ib2xzIGZyb20gYSBwbGFpbiB0cyBsaWJyYXJ5XG4gICAgICAgICAgICAvLyB0cmFuc2l0aXZlbHkuXG4gICAgICAgICAgICAvLyBOb3RlOiBXZSByZWx5IG9uIHRoZSBmYWN0IHRoYXQgd2UgZGlzY292ZXIgc3ltYm9scyBpbiB0aGUgZGlyZWN0aW9uXG4gICAgICAgICAgICAvLyBmcm9tIHNvdXJjZSBmaWxlcyB0byBsaWJyYXJ5IGZpbGVzXG4gICAgICAgICAgICB0aGlzLmltcG9ydEFzLnNldCh0YXJnZXRTeW1ib2wsIHRoaXMuZ2V0SW1wb3J0QXMoc291cmNlU3ltYm9sKSB8fCBzb3VyY2VTeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRTdGF0aWNTeW1ib2woc291cmNlU3ltYm9sLCB0YXJnZXRTeW1ib2wpO1xuICAgIH07XG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBjb250ZXh0LCBwYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yUmVjb3JkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JSZWNvcmRlcihlcnJvciwgKGNvbnRleHQgJiYgY29udGV4dC5maWxlUGF0aCkgfHwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1vZHVsZSBhbiBhYnNvbHV0ZSBwYXRoIHRvIGEgbW9kdWxlIGZpbGUuXG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmdldE1vZHVsZU1ldGFkYXRhID0gZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICB2YXIgbW9kdWxlTWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhQ2FjaGUuZ2V0KG1vZHVsZSk7XG4gICAgICAgIGlmICghbW9kdWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHZhciBtb2R1bGVNZXRhZGF0YXMgPSB0aGlzLmhvc3QuZ2V0TWV0YWRhdGFGb3IobW9kdWxlKTtcbiAgICAgICAgICAgIGlmIChtb2R1bGVNZXRhZGF0YXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4VmVyc2lvbl8xID0gLTE7XG4gICAgICAgICAgICAgICAgbW9kdWxlTWV0YWRhdGFzLmZvckVhY2goZnVuY3Rpb24gKG1kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZCAmJiBtZFsndmVyc2lvbiddID4gbWF4VmVyc2lvbl8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhWZXJzaW9uXzEgPSBtZFsndmVyc2lvbiddO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlTWV0YWRhdGEgPSBtZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtb2R1bGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZU1ldGFkYXRhID1cbiAgICAgICAgICAgICAgICAgICAgeyBfX3N5bWJvbGljOiAnbW9kdWxlJywgdmVyc2lvbjogU1VQUE9SVEVEX1NDSEVNQV9WRVJTSU9OLCBtb2R1bGU6IG1vZHVsZSwgbWV0YWRhdGE6IHt9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kdWxlTWV0YWRhdGFbJ3ZlcnNpb24nXSAhPSBTVVBQT1JURURfU0NIRU1BX1ZFUlNJT04pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gbW9kdWxlTWV0YWRhdGFbJ3ZlcnNpb24nXSA9PSAyID9cbiAgICAgICAgICAgICAgICAgICAgXCJVbnN1cHBvcnRlZCBtZXRhZGF0YSB2ZXJzaW9uIFwiICsgbW9kdWxlTWV0YWRhdGFbJ3ZlcnNpb24nXSArIFwiIGZvciBtb2R1bGUgXCIgKyBtb2R1bGUgKyBcIi4gVGhpcyBtb2R1bGUgc2hvdWxkIGJlIGNvbXBpbGVkIHdpdGggYSBuZXdlciB2ZXJzaW9uIG9mIG5nY1wiIDpcbiAgICAgICAgICAgICAgICAgICAgXCJNZXRhZGF0YSB2ZXJzaW9uIG1pc21hdGNoIGZvciBtb2R1bGUgXCIgKyB0aGlzLmhvc3QuZ2V0T3V0cHV0TmFtZShtb2R1bGUpICsgXCIsIGZvdW5kIHZlcnNpb24gXCIgKyBtb2R1bGVNZXRhZGF0YVsndmVyc2lvbiddICsgXCIsIGV4cGVjdGVkIFwiICsgU1VQUE9SVEVEX1NDSEVNQV9WRVJTSU9OO1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IobmV3IEVycm9yKGVycm9yTWVzc2FnZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YUNhY2hlLnNldChtb2R1bGUsIG1vZHVsZU1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlTWV0YWRhdGE7XG4gICAgfTtcbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuZ2V0U3ltYm9sQnlNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlLCBzeW1ib2xOYW1lLCBjb250YWluaW5nRmlsZSkge1xuICAgICAgICB2YXIgZmlsZVBhdGggPSB0aGlzLnJlc29sdmVNb2R1bGUobW9kdWxlLCBjb250YWluaW5nRmlsZSk7XG4gICAgICAgIGlmICghZmlsZVBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IobmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgbW9kdWxlIFwiICsgbW9kdWxlICsgKGNvbnRhaW5pbmdGaWxlID8gJyByZWxhdGl2ZSB0byAnICtcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3QuZ2V0T3V0cHV0TmFtZShjb250YWluaW5nRmlsZSkgOiAnJykpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRpY1N5bWJvbChcIkVSUk9SOlwiICsgbW9kdWxlLCBzeW1ib2xOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0aWNTeW1ib2woZmlsZVBhdGgsIHN5bWJvbE5hbWUpO1xuICAgIH07XG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmVNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlLCBjb250YWluaW5nRmlsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG9zdC5tb2R1bGVOYW1lVG9GaWxlTmFtZShtb2R1bGUsIGNvbnRhaW5pbmdGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIG1vZHVsZSAnXCIgKyBtb2R1bGUgKyBcIicgcmVsYXRpdmUgdG8gZmlsZSBcIiArIGNvbnRhaW5pbmdGaWxlKTtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoZSwgdW5kZWZpbmVkLCBjb250YWluaW5nRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljU3ltYm9sUmVzb2x2ZXI7XG59KCkpO1xuLy8gUmVtb3ZlIGV4dHJhIHVuZGVyc2NvcmUgZnJvbSBlc2NhcGVkIGlkZW50aWZpZXIuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2Jsb2IvbWFzdGVyL3NyYy9jb21waWxlci91dGlsaXRpZXMudHNcbmZ1bmN0aW9uIHVuZXNjYXBlSWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXIuc3RhcnRzV2l0aCgnX19fJykgPyBpZGVudGlmaWVyLnN1YnN0cigxKSA6IGlkZW50aWZpZXI7XG59XG5mdW5jdGlvbiB1bndyYXBSZXNvbHZlZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLl9fc3ltYm9saWMgPT09ICdyZXNvbHZlZCcpIHtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhLnN5bWJvbDtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVTdW1tYXJpZXMoc3JjRmlsZU5hbWUsIGZvckppdEN0eCwgc3VtbWFyeVJlc29sdmVyLCBzeW1ib2xSZXNvbHZlciwgc3ltYm9scywgdHlwZXMsIGNyZWF0ZUV4dGVybmFsU3ltYm9sUmVleHBvcnRzKSB7XG4gICAgaWYgKGNyZWF0ZUV4dGVybmFsU3ltYm9sUmVleHBvcnRzID09PSB2b2lkIDApIHsgY3JlYXRlRXh0ZXJuYWxTeW1ib2xSZWV4cG9ydHMgPSBmYWxzZTsgfVxuICAgIHZhciB0b0pzb25TZXJpYWxpemVyID0gbmV3IFRvSnNvblNlcmlhbGl6ZXIoc3ltYm9sUmVzb2x2ZXIsIHN1bW1hcnlSZXNvbHZlciwgc3JjRmlsZU5hbWUpO1xuICAgIC8vIGZvciBzeW1ib2xzLCB3ZSB1c2UgZXZlcnl0aGluZyBleGNlcHQgZm9yIHRoZSBjbGFzcyBtZXRhZGF0YSBpdHNlbGZcbiAgICAvLyAod2Uga2VlcCB0aGUgc3RhdGljcyB0aG91Z2gpLCBhcyB0aGUgY2xhc3MgbWV0YWRhdGEgaXMgY29udGFpbmVkIGluIHRoZVxuICAgIC8vIENvbXBpbGVUeXBlU3VtbWFyeS5cbiAgICBzeW1ib2xzLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmVkU3ltYm9sKSB7IHJldHVybiB0b0pzb25TZXJpYWxpemVyLmFkZFN1bW1hcnkoeyBzeW1ib2w6IHJlc29sdmVkU3ltYm9sLnN5bWJvbCwgbWV0YWRhdGE6IHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIH0pOyB9KTtcbiAgICAvLyBBZGQgdHlwZSBzdW1tYXJpZXMuXG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHN1bW1hcnkgPSBfYS5zdW1tYXJ5LCBtZXRhZGF0YSA9IF9hLm1ldGFkYXRhO1xuICAgICAgICB0b0pzb25TZXJpYWxpemVyLmFkZFN1bW1hcnkoeyBzeW1ib2w6IHN1bW1hcnkudHlwZS5yZWZlcmVuY2UsIG1ldGFkYXRhOiB1bmRlZmluZWQsIHR5cGU6IHN1bW1hcnkgfSk7XG4gICAgfSk7XG4gICAgdmFyIF9hID0gdG9Kc29uU2VyaWFsaXplci5zZXJpYWxpemUoY3JlYXRlRXh0ZXJuYWxTeW1ib2xSZWV4cG9ydHMpLCBqc29uID0gX2EuanNvbiwgZXhwb3J0QXMgPSBfYS5leHBvcnRBcztcbiAgICBpZiAoZm9ySml0Q3R4KSB7XG4gICAgICAgIHZhciBmb3JKaXRTZXJpYWxpemVyXzEgPSBuZXcgRm9ySml0U2VyaWFsaXplcihmb3JKaXRDdHgsIHN5bWJvbFJlc29sdmVyLCBzdW1tYXJ5UmVzb2x2ZXIpO1xuICAgICAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHN1bW1hcnkgPSBfYS5zdW1tYXJ5LCBtZXRhZGF0YSA9IF9hLm1ldGFkYXRhO1xuICAgICAgICAgICAgZm9ySml0U2VyaWFsaXplcl8xLmFkZFNvdXJjZVR5cGUoc3VtbWFyeSwgbWV0YWRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdG9Kc29uU2VyaWFsaXplci51bnByb2Nlc3NlZFN5bWJvbFN1bW1hcmllc0J5U3ltYm9sLmZvckVhY2goZnVuY3Rpb24gKHN1bW1hcnkpIHtcbiAgICAgICAgICAgIGlmIChzdW1tYXJ5UmVzb2x2ZXIuaXNMaWJyYXJ5RmlsZShzdW1tYXJ5LnN5bWJvbC5maWxlUGF0aCkgJiYgc3VtbWFyeS50eXBlKSB7XG4gICAgICAgICAgICAgICAgZm9ySml0U2VyaWFsaXplcl8xLmFkZExpYlR5cGUoc3VtbWFyeS50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvckppdFNlcmlhbGl6ZXJfMS5zZXJpYWxpemUoZXhwb3J0QXMpO1xuICAgIH1cbiAgICByZXR1cm4geyBqc29uOiBqc29uLCBleHBvcnRBczogZXhwb3J0QXMgfTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplU3VtbWFyaWVzKHN5bWJvbENhY2hlLCBzdW1tYXJ5UmVzb2x2ZXIsIGxpYnJhcnlGaWxlTmFtZSwganNvbikge1xuICAgIHZhciBkZXNlcmlhbGl6ZXIgPSBuZXcgRnJvbUpzb25EZXNlcmlhbGl6ZXIoc3ltYm9sQ2FjaGUsIHN1bW1hcnlSZXNvbHZlcik7XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplci5kZXNlcmlhbGl6ZShsaWJyYXJ5RmlsZU5hbWUsIGpzb24pO1xufVxuZnVuY3Rpb24gY3JlYXRlRm9ySml0U3R1YihvdXRwdXRDdHgsIHJlZmVyZW5jZSkge1xuICAgIHJldHVybiBjcmVhdGVTdW1tYXJ5Rm9ySml0RnVuY3Rpb24ob3V0cHV0Q3R4LCByZWZlcmVuY2UsIE5VTExfRVhQUik7XG59XG5mdW5jdGlvbiBjcmVhdGVTdW1tYXJ5Rm9ySml0RnVuY3Rpb24ob3V0cHV0Q3R4LCByZWZlcmVuY2UsIHZhbHVlKSB7XG4gICAgdmFyIGZuTmFtZSA9IHN1bW1hcnlGb3JKaXROYW1lKHJlZmVyZW5jZS5uYW1lKTtcbiAgICBvdXRwdXRDdHguc3RhdGVtZW50cy5wdXNoKGZuKFtdLCBbbmV3IFJldHVyblN0YXRlbWVudCh2YWx1ZSldLCBuZXcgQXJyYXlUeXBlKERZTkFNSUNfVFlQRSkpLnRvRGVjbFN0bXQoZm5OYW1lLCBbXG4gICAgICAgIFN0bXRNb2RpZmllci5GaW5hbCwgU3RtdE1vZGlmaWVyLkV4cG9ydGVkXG4gICAgXSkpO1xufVxudmFyIFRvSnNvblNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRvSnNvblNlcmlhbGl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVG9Kc29uU2VyaWFsaXplcihzeW1ib2xSZXNvbHZlciwgc3VtbWFyeVJlc29sdmVyLCBzcmNGaWxlTmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zeW1ib2xSZXNvbHZlciA9IHN5bWJvbFJlc29sdmVyO1xuICAgICAgICBfdGhpcy5zdW1tYXJ5UmVzb2x2ZXIgPSBzdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIF90aGlzLnNyY0ZpbGVOYW1lID0gc3JjRmlsZU5hbWU7XG4gICAgICAgIC8vIE5vdGU6IFRoaXMgb25seSBjb250YWlucyBzeW1ib2xzIHdpdGhvdXQgbWVtYmVycy5cbiAgICAgICAgX3RoaXMuc3ltYm9scyA9IFtdO1xuICAgICAgICBfdGhpcy5pbmRleEJ5U3ltYm9sID0gbmV3IE1hcCgpO1xuICAgICAgICBfdGhpcy5yZWV4cG9ydGVkQnkgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFRoaXMgbm93IGNvbnRhaW5zIGEgYF9fc3ltYm9sOiBudW1iZXJgIGluIHRoZSBwbGFjZSBvZlxuICAgICAgICAvLyBTdGF0aWNTeW1ib2xzLCBidXQgb3RoZXJ3aXNlIGhhcyB0aGUgc2FtZSBzaGFwZSBhcyB0aGUgb3JpZ2luYWwgb2JqZWN0cy5cbiAgICAgICAgX3RoaXMucHJvY2Vzc2VkU3VtbWFyeUJ5U3ltYm9sID0gbmV3IE1hcCgpO1xuICAgICAgICBfdGhpcy5wcm9jZXNzZWRTdW1tYXJpZXMgPSBbXTtcbiAgICAgICAgX3RoaXMudW5wcm9jZXNzZWRTeW1ib2xTdW1tYXJpZXNCeVN5bWJvbCA9IG5ldyBNYXAoKTtcbiAgICAgICAgX3RoaXMubW9kdWxlTmFtZSA9IHN5bWJvbFJlc29sdmVyLmdldEtub3duTW9kdWxlTmFtZShzcmNGaWxlTmFtZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVG9Kc29uU2VyaWFsaXplci5wcm90b3R5cGUuYWRkU3VtbWFyeSA9IGZ1bmN0aW9uIChzdW1tYXJ5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1bnByb2Nlc3NlZFN1bW1hcnkgPSB0aGlzLnVucHJvY2Vzc2VkU3ltYm9sU3VtbWFyaWVzQnlTeW1ib2wuZ2V0KHN1bW1hcnkuc3ltYm9sKTtcbiAgICAgICAgdmFyIHByb2Nlc3NlZFN1bW1hcnkgPSB0aGlzLnByb2Nlc3NlZFN1bW1hcnlCeVN5bWJvbC5nZXQoc3VtbWFyeS5zeW1ib2wpO1xuICAgICAgICBpZiAoIXVucHJvY2Vzc2VkU3VtbWFyeSkge1xuICAgICAgICAgICAgdW5wcm9jZXNzZWRTdW1tYXJ5ID0geyBzeW1ib2w6IHN1bW1hcnkuc3ltYm9sLCBtZXRhZGF0YTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICB0aGlzLnVucHJvY2Vzc2VkU3ltYm9sU3VtbWFyaWVzQnlTeW1ib2wuc2V0KHN1bW1hcnkuc3ltYm9sLCB1bnByb2Nlc3NlZFN1bW1hcnkpO1xuICAgICAgICAgICAgcHJvY2Vzc2VkU3VtbWFyeSA9IHsgc3ltYm9sOiB0aGlzLnByb2Nlc3NWYWx1ZShzdW1tYXJ5LnN5bWJvbCwgMCAvKiBOb25lICovKSB9O1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWRTdW1tYXJpZXMucHVzaChwcm9jZXNzZWRTdW1tYXJ5KTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkU3VtbWFyeUJ5U3ltYm9sLnNldChzdW1tYXJ5LnN5bWJvbCwgcHJvY2Vzc2VkU3VtbWFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1bnByb2Nlc3NlZFN1bW1hcnkubWV0YWRhdGEgJiYgc3VtbWFyeS5tZXRhZGF0YSkge1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhXzEgPSBzdW1tYXJ5Lm1ldGFkYXRhIHx8IHt9O1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhXzEuX19zeW1ib2xpYyA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgIC8vIEZvciBjbGFzc2VzLCB3ZSBrZWVwIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZWlyIGNsYXNzIGRlY29yYXRvcnMuXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBrZWVwIGUuZy4gdGhlIGN0b3IgYXJncywgbWV0aG9kIG5hbWVzLCBtZXRob2QgZGVjb3JhdG9yc1xuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGNsYXNzIGNhbiBiZSBleHRlbmRlZCBpbiBhbm90aGVyIGNvbXBpbGF0aW9uIHVuaXQuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3Qga2VlcCB0aGUgY2xhc3MgZGVjb3JhdG9ycyBhc1xuICAgICAgICAgICAgICAgIC8vIDEpIHRoZXkgcmVmZXIgdG8gZGF0YVxuICAgICAgICAgICAgICAgIC8vICAgdGhhdCBzaG91bGQgbm90IGNhdXNlIGEgcmVidWlsZCBvZiBkb3duc3RyZWFtIGNvbXBpbGF0aW9uIHVuaXRzXG4gICAgICAgICAgICAgICAgLy8gICAoZS5nLiBpbmxpbmUgdGVtcGxhdGVzIG9mIEBDb21wb25lbnQsIG9yIEBOZ01vZHVsZS5kZWNsYXJhdGlvbnMpXG4gICAgICAgICAgICAgICAgLy8gMikgdGhlaXIgZGF0YSBpcyBhbHJlYWR5IGNhcHR1cmVkIGluIFR5cGVTdW1tYXJpZXMsIGUuZy4gRGlyZWN0aXZlU3VtbWFyeS5cbiAgICAgICAgICAgICAgICB2YXIgY2xvbmVfMSA9IHt9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG1ldGFkYXRhXzEpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wTmFtZSAhPT0gJ2RlY29yYXRvcnMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZV8xW3Byb3BOYW1lXSA9IG1ldGFkYXRhXzFbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFfMSA9IGNsb25lXzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0NhbGwobWV0YWRhdGFfMSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRnVuY3Rpb25DYWxsKG1ldGFkYXRhXzEpICYmICFpc01ldGhvZENhbGxPblZhcmlhYmxlKG1ldGFkYXRhXzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHN0b3JlIGNvbXBsZXggY2FsbHMgYXMgd2Ugd29uJ3QgYmUgYWJsZSB0byBzaW1wbGlmeSB0aGVtIGFueXdheXMgbGF0ZXIgb24uXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhXzEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfX3N5bWJvbGljOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0NvbXBsZXggZnVuY3Rpb24gY2FsbHMgYXJlIG5vdCBzdXBwb3J0ZWQuJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIGtlZXAgc3RvcmluZyBjdG9yIGNhbGxzIGZvciBlLmcuXG4gICAgICAgICAgICAvLyBgZXhwb3J0IGNvbnN0IHggPSBuZXcgSW5qZWN0aW9uVG9rZW4oLi4uKWBcbiAgICAgICAgICAgIHVucHJvY2Vzc2VkU3VtbWFyeS5tZXRhZGF0YSA9IG1ldGFkYXRhXzE7XG4gICAgICAgICAgICBwcm9jZXNzZWRTdW1tYXJ5Lm1ldGFkYXRhID0gdGhpcy5wcm9jZXNzVmFsdWUobWV0YWRhdGFfMSwgMSAvKiBSZXNvbHZlVmFsdWUgKi8pO1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhXzEgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnN1bW1hcnlSZXNvbHZlci5pc0xpYnJhcnlGaWxlKG1ldGFkYXRhXzEuZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uU3ltYm9sID0gdGhpcy5zeW1ib2xzW3RoaXMuaW5kZXhCeVN5bWJvbC5nZXQobWV0YWRhdGFfMSldO1xuICAgICAgICAgICAgICAgIGlmICghaXNMb3dlcmVkU3ltYm9sKGRlY2xhcmF0aW9uU3ltYm9sLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHN5bWJvbHMgdGhhdCB3ZXJlIGludHJvZHVjZWQgZHVyaW5nIGNvZGVnZW4gaW4gdGhlIHVzZXIgZmlsZSBjYW4gaGF2ZSBhIHJlZXhwb3J0XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGEgdXNlciB1c2VkIGBleHBvcnQgKmAuIEhvd2V2ZXIsIHdlIGNhbid0IHJlbHkgb24gdGhpcyBhcyB0c2lja2xlIHdpbGwgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIC8vIGBleHBvcnQgKmAgaW50byBuYW1lZCBleHBvcnRzLCB1c2luZyBvbmx5IHRoZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSB0eXBlY2hlY2tlci5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXMgd2UgaW50cm9kdWNlIHRoZSBuZXcgc3ltYm9scyBhZnRlciB0eXBlY2hlY2ssIFRzaWNrbGUgZG9lcyBub3Qga25vdyBhYm91dCB0aGVtLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgb21pdHMgdGhlbSB3aGVuIGV4cGFuZGluZyBgZXhwb3J0ICpgLlxuICAgICAgICAgICAgICAgICAgICAvLyBTbyB3ZSBoYXZlIHRvIGtlZXAgcmVleHBvcnRpbmcgdGhlc2Ugc3ltYm9scyBtYW51YWxseSB2aWEgLm5nZmFjdG9yeSBmaWxlcy5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWV4cG9ydGVkQnkuc2V0KGRlY2xhcmF0aW9uU3ltYm9sLCBzdW1tYXJ5LnN5bWJvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdW5wcm9jZXNzZWRTdW1tYXJ5LnR5cGUgJiYgc3VtbWFyeS50eXBlKSB7XG4gICAgICAgICAgICB1bnByb2Nlc3NlZFN1bW1hcnkudHlwZSA9IHN1bW1hcnkudHlwZTtcbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIGRvbid0IGFkZCB0aGUgc3VtbWFyaWVzIG9mIGFsbCByZWZlcmVuY2VkIHN5bWJvbHMgYXMgZm9yIHRoZSBSZXNvbHZlZFN5bWJvbHMsXG4gICAgICAgICAgICAvLyBhcyB0aGUgdHlwZSBzdW1tYXJpZXMgYWxyZWFkeSBjb250YWluIHRoZSB0cmFuc2l0aXZlIGRhdGEgdGhhdCB0aGV5IHJlcXVpcmVcbiAgICAgICAgICAgIC8vIChpbiBhIG1pbmltYWwgd2F5KS5cbiAgICAgICAgICAgIHByb2Nlc3NlZFN1bW1hcnkudHlwZSA9IHRoaXMucHJvY2Vzc1ZhbHVlKHN1bW1hcnkudHlwZSwgMCAvKiBOb25lICovKTtcbiAgICAgICAgICAgIC8vIGV4Y2VwdCBmb3IgcmVleHBvcnRlZCBkaXJlY3RpdmVzIC8gcGlwZXMsIHNvIHdlIG5lZWQgdG8gc3RvcmVcbiAgICAgICAgICAgIC8vIHRoZWlyIHN1bW1hcmllcyBleHBsaWNpdGx5LlxuICAgICAgICAgICAgaWYgKHN1bW1hcnkudHlwZS5zdW1tYXJ5S2luZCA9PT0gQ29tcGlsZVN1bW1hcnlLaW5kLk5nTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5nTW9kdWxlU3VtbWFyeSA9IHN1bW1hcnkudHlwZTtcbiAgICAgICAgICAgICAgICBuZ01vZHVsZVN1bW1hcnkuZXhwb3J0ZWREaXJlY3RpdmVzLmNvbmNhdChuZ01vZHVsZVN1bW1hcnkuZXhwb3J0ZWRQaXBlcykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IGlkLnJlZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnN1bW1hcnlSZXNvbHZlci5pc0xpYnJhcnlGaWxlKHN5bWJvbC5maWxlUGF0aCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFfdGhpcy51bnByb2Nlc3NlZFN5bWJvbFN1bW1hcmllc0J5U3ltYm9sLmhhcyhzeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VtbWFyeV8xID0gX3RoaXMuc3VtbWFyeVJlc29sdmVyLnJlc29sdmVTdW1tYXJ5KHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VtbWFyeV8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkU3VtbWFyeShzdW1tYXJ5XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjcmVhdGVFeHRlcm5hbFN5bWJvbFJlZXhwb3J0cyBXaGV0aGVyIGV4dGVybmFsIHN0YXRpYyBzeW1ib2xzIHNob3VsZCBiZSByZS1leHBvcnRlZC5cbiAgICAgKiBUaGlzIGNhbiBiZSBlbmFibGVkIGlmIGV4dGVybmFsIHN5bWJvbHMgc2hvdWxkIGJlIHJlLWV4cG9ydGVkIGJ5IHRoZSBjdXJyZW50IG1vZHVsZSBpblxuICAgICAqIG9yZGVyIHRvIGF2b2lkIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBtb2R1bGUgZGVwZW5kZW5jaWVzIHdoaWNoIGNhbiBicmVhayBzdHJpY3QgZGVwZW5kZW5jeVxuICAgICAqIGVuZm9yY2VtZW50cyAoYXMgaW4gR29vZ2xlMykuIFJlYWQgbW9yZSBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yNTY0NFxuICAgICAqL1xuICAgIFRvSnNvblNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChjcmVhdGVFeHRlcm5hbFN5bWJvbFJlZXhwb3J0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZXhwb3J0QXMgPSBbXTtcbiAgICAgICAgdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBtb2R1bGVOYW1lOiB0aGlzLm1vZHVsZU5hbWUsXG4gICAgICAgICAgICBzdW1tYXJpZXM6IHRoaXMucHJvY2Vzc2VkU3VtbWFyaWVzLFxuICAgICAgICAgICAgc3ltYm9sczogdGhpcy5zeW1ib2xzLm1hcChmdW5jdGlvbiAoc3ltYm9sLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHN5bWJvbC5hc3NlcnROb01lbWJlcnMoKTtcbiAgICAgICAgICAgICAgICB2YXIgaW1wb3J0QXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnN1bW1hcnlSZXNvbHZlci5pc0xpYnJhcnlGaWxlKHN5bWJvbC5maWxlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZXhwb3J0U3ltYm9sID0gX3RoaXMucmVleHBvcnRlZEJ5LmdldChzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVleHBvcnRTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlIGdpdmVuIGV4dGVybmFsIHN0YXRpYyBzeW1ib2wgaXMgYWxyZWFkeSBtYW51YWxseSBleHBvcnRlZCBieSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZXIsIHdlIGp1c3QgcHJveHkgdGhlIGV4dGVybmFsIHN0YXRpYyBzeW1ib2wgcmVmZXJlbmNlIHRvIHRoZSBtYW51YWwgZXhwb3J0LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIEFPVCBjb21waWxlciBpbXBvcnRzIHRoZSBleHRlcm5hbCBzeW1ib2wgdGhyb3VnaCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZXIgZXhwb3J0IGFuZCBkb2VzIG5vdCBpbnRyb2R1Y2UgYW5vdGhlciBkZXBlbmRlbmN5IHdoaWNoIGlzIG5vdCBuZWVkZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRBcyA9IF90aGlzLmluZGV4QnlTeW1ib2wuZ2V0KHJlZXhwb3J0U3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjcmVhdGVFeHRlcm5hbFN5bWJvbFJlZXhwb3J0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB0aGUgZ2l2ZW4gZXh0ZXJuYWwgc3RhdGljIHN5bWJvbCBpcyAqbm90KiBtYW51YWxseSBleHBvcnRlZCBieVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHVzZXIsIGFuZCB3ZSBtYW51YWxseSBjcmVhdGUgYSByZS1leHBvcnQgaW4gdGhlIGZhY3RvcnkgZmlsZSBzbyB0aGF0IHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBpbnRyb2R1Y2UgYW5vdGhlciBtb2R1bGUgZGVwZW5kZW5jeS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBydW5uaW5nIHdpdGhpblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmF6ZWwgc28gdGhhdCB0aGUgQU9UIGNvbXBpbGVyIGRvZXMgbm90IGludHJvZHVjZSBhbnkgbW9kdWxlIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggY2FuIGJyZWFrIHRoZSBzdHJpY3QgZGVwZW5kZW5jeSBlbmZvcmNlbWVudC4gKGUuZy4gYXMgaW4gR29vZ2xlMylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgbW9yZSBhYm91dCB0aGlzIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzI1NjQ0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VtbWFyeSA9IF90aGlzLnVucHJvY2Vzc2VkU3ltYm9sU3VtbWFyaWVzQnlTeW1ib2wuZ2V0KHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN1bW1hcnkgfHwgIXN1bW1hcnkubWV0YWRhdGEgfHwgc3VtbWFyeS5tZXRhZGF0YS5fX3N5bWJvbGljICE9PSAnaW50ZXJmYWNlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydEFzID0gc3ltYm9sLm5hbWUgKyBcIl9cIiArIGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzLnB1c2goeyBzeW1ib2w6IHN5bWJvbCwgZXhwb3J0QXM6IGltcG9ydEFzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIF9fc3ltYm9sOiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogc3ltYm9sLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYXRoOiBfdGhpcy5zdW1tYXJ5UmVzb2x2ZXIudG9TdW1tYXJ5RmlsZU5hbWUoc3ltYm9sLmZpbGVQYXRoLCBfdGhpcy5zcmNGaWxlTmFtZSksXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydEFzOiBpbXBvcnRBc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsganNvbjoganNvbiwgZXhwb3J0QXM6IGV4cG9ydEFzIH07XG4gICAgfTtcbiAgICBUb0pzb25TZXJpYWxpemVyLnByb3RvdHlwZS5wcm9jZXNzVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCB0aGlzLCBmbGFncyk7XG4gICAgfTtcbiAgICBUb0pzb25TZXJpYWxpemVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgdmFyIGJhc2VTeW1ib2wgPSB0aGlzLnN5bWJvbFJlc29sdmVyLmdldFN0YXRpY1N5bWJvbCh2YWx1ZS5maWxlUGF0aCwgdmFsdWUubmFtZSk7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnZpc2l0U3RhdGljU3ltYm9sKGJhc2VTeW1ib2wsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIHsgX19zeW1ib2w6IGluZGV4LCBtZW1iZXJzOiB2YWx1ZS5tZW1iZXJzIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0cmlwIGxpbmUgYW5kIGNoYXJhY3RlciBudW1iZXJzIGZyb20gbmdzdW1tYXJpZXMuXG4gICAgICogRW1pdHRpbmcgdGhlbSBjYXVzZXMgd2hpdGUgc3BhY2VzIGNoYW5nZXMgdG8gcmV0cmlnZ2VyIHVwc3RyZWFtXG4gICAgICogcmVjb21waWxhdGlvbnMgaW4gYmF6ZWwuXG4gICAgICogVE9ETzogZmluZCBvdXQgYSB3YXkgdG8gaGF2ZSBsaW5lIGFuZCBjaGFyYWN0ZXIgbnVtYmVycyBpbiBlcnJvcnMgd2l0aG91dFxuICAgICAqIGV4Y2Vzc2l2ZSByZWNvbXBpbGF0aW9uIGluIGJhemVsLlxuICAgICAqL1xuICAgIFRvSnNvblNlcmlhbGl6ZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwID0gZnVuY3Rpb24gKG1hcCwgY29udGV4dCkge1xuICAgICAgICBpZiAobWFwWydfX3N5bWJvbGljJ10gPT09ICdyZXNvbHZlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdFZhbHVlKG1hcFsnc3ltYm9sJ10sIHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXBbJ19fc3ltYm9saWMnXSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgZGVsZXRlIG1hcFsnbGluZSddO1xuICAgICAgICAgICAgZGVsZXRlIG1hcFsnY2hhcmFjdGVyJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAuY2FsbCh0aGlzLCBtYXAsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBudWxsIGlmIHRoZSBvcHRpb25zLnJlc29sdmVWYWx1ZSBpcyB0cnVlLCBhbmQgdGhlIHN1bW1hcnkgZm9yIHRoZSBzeW1ib2xcbiAgICAgKiByZXNvbHZlZCB0byBhIHR5cGUgb3IgY291bGQgbm90IGJlIHJlc29sdmVkLlxuICAgICAqL1xuICAgIFRvSnNvblNlcmlhbGl6ZXIucHJvdG90eXBlLnZpc2l0U3RhdGljU3ltYm9sID0gZnVuY3Rpb24gKGJhc2VTeW1ib2wsIGZsYWdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXhCeVN5bWJvbC5nZXQoYmFzZVN5bWJvbCk7XG4gICAgICAgIHZhciBzdW1tYXJ5ID0gbnVsbDtcbiAgICAgICAgaWYgKGZsYWdzICYgMSAvKiBSZXNvbHZlVmFsdWUgKi8gJiZcbiAgICAgICAgICAgIHRoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUoYmFzZVN5bWJvbC5maWxlUGF0aCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVucHJvY2Vzc2VkU3ltYm9sU3VtbWFyaWVzQnlTeW1ib2wuaGFzKGJhc2VTeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHN1bW1hcnkgZm9yIHRoaXMgc3ltYm9sIHdhcyBhbHJlYWR5IGFkZGVkXG4gICAgICAgICAgICAgICAgLy8gLT4gbm90aGluZyB0byBkby5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdW1tYXJ5ID0gdGhpcy5sb2FkU3VtbWFyeShiYXNlU3ltYm9sKTtcbiAgICAgICAgICAgIGlmIChzdW1tYXJ5ICYmIHN1bW1hcnkubWV0YWRhdGEgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc3VtbWFyeSBpcyBhIHJlZXhwb3J0XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnZpc2l0U3RhdGljU3ltYm9sKHN1bW1hcnkubWV0YWRhdGEsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgc3VtbWFyeSBhcyBpdCBpcyBqdXN0IGEgcmVleHBvcnQsIHNvIHdlIGRvbid0IHdhbnQgdG8gc3RvcmUgaXQuXG4gICAgICAgICAgICAgICAgc3VtbWFyeSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gTm90ZTogPT0gb24gcHVycG9zZSB0byBjb21wYXJlIHdpdGggdW5kZWZpbmVkIVxuICAgICAgICAgICAgLy8gTm8gc3VtbWFyeSBhbmQgdGhlIHN5bWJvbCBpcyBhbHJlYWR5IGFkZGVkIC0+IG5vdGhpbmcgdG8gZG8uXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogPT0gb24gcHVycG9zZSB0byBjb21wYXJlIHdpdGggdW5kZWZpbmVkIVxuICAgICAgICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLnN5bWJvbHMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5zeW1ib2xzLnB1c2goYmFzZVN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleEJ5U3ltYm9sLnNldChiYXNlU3ltYm9sLCBpbmRleCk7XG4gICAgICAgIGlmIChzdW1tYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLmFkZFN1bW1hcnkoc3VtbWFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgVG9Kc29uU2VyaWFsaXplci5wcm90b3R5cGUubG9hZFN1bW1hcnkgPSBmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgICAgIHZhciBzdW1tYXJ5ID0gdGhpcy5zdW1tYXJ5UmVzb2x2ZXIucmVzb2x2ZVN1bW1hcnkoc3ltYm9sKTtcbiAgICAgICAgaWYgKCFzdW1tYXJ5KSB7XG4gICAgICAgICAgICAvLyBzb21lIHN5bWJvbHMgbWlnaHQgb3JpZ2luYXRlIGZyb20gYSBwbGFpbiB0eXBlc2NyaXB0IGxpYnJhcnlcbiAgICAgICAgICAgIC8vIHRoYXQganVzdCBleHBvcnRlZCAuZC50cyBhbmQgLm1ldGFkYXRhLmpzb24gZmlsZXMsIGkuZS4gd2hlcmUgbm8gc3VtbWFyeVxuICAgICAgICAgICAgLy8gZmlsZXMgd2VyZSBjcmVhdGVkLlxuICAgICAgICAgICAgdmFyIHJlc29sdmVkU3ltYm9sID0gdGhpcy5zeW1ib2xSZXNvbHZlci5yZXNvbHZlU3ltYm9sKHN5bWJvbCk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICBzdW1tYXJ5ID0geyBzeW1ib2w6IHJlc29sdmVkU3ltYm9sLnN5bWJvbCwgbWV0YWRhdGE6IHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bW1hcnk7XG4gICAgfTtcbiAgICByZXR1cm4gVG9Kc29uU2VyaWFsaXplcjtcbn0oVmFsdWVUcmFuc2Zvcm1lcikpO1xudmFyIEZvckppdFNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRm9ySml0U2VyaWFsaXplcihvdXRwdXRDdHgsIHN5bWJvbFJlc29sdmVyLCBzdW1tYXJ5UmVzb2x2ZXIpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRDdHggPSBvdXRwdXRDdHg7XG4gICAgICAgIHRoaXMuc3ltYm9sUmVzb2x2ZXIgPSBzeW1ib2xSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5zdW1tYXJ5UmVzb2x2ZXIgPSBzdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIH1cbiAgICBGb3JKaXRTZXJpYWxpemVyLnByb3RvdHlwZS5hZGRTb3VyY2VUeXBlID0gZnVuY3Rpb24gKHN1bW1hcnksIG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKHsgc3VtbWFyeTogc3VtbWFyeSwgbWV0YWRhdGE6IG1ldGFkYXRhLCBpc0xpYnJhcnk6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgRm9ySml0U2VyaWFsaXplci5wcm90b3R5cGUuYWRkTGliVHlwZSA9IGZ1bmN0aW9uIChzdW1tYXJ5KSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKHsgc3VtbWFyeTogc3VtbWFyeSwgbWV0YWRhdGE6IG51bGwsIGlzTGlicmFyeTogdHJ1ZSB9KTtcbiAgICB9O1xuICAgIEZvckppdFNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChleHBvcnRBc0Fycikge1xuICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYiwgZV8zLCBfYztcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV4cG9ydEFzQnlTeW1ib2wgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBleHBvcnRBc0Fycl8xID0gX192YWx1ZXMoZXhwb3J0QXNBcnIpLCBleHBvcnRBc0Fycl8xXzEgPSBleHBvcnRBc0Fycl8xLm5leHQoKTsgIWV4cG9ydEFzQXJyXzFfMS5kb25lOyBleHBvcnRBc0Fycl8xXzEgPSBleHBvcnRBc0Fycl8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBfZCA9IGV4cG9ydEFzQXJyXzFfMS52YWx1ZSwgc3ltYm9sID0gX2Quc3ltYm9sLCBleHBvcnRBcyA9IF9kLmV4cG9ydEFzO1xuICAgICAgICAgICAgICAgIGV4cG9ydEFzQnlTeW1ib2wuc2V0KHN5bWJvbCwgZXhwb3J0QXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb3J0QXNBcnJfMV8xICYmICFleHBvcnRBc0Fycl8xXzEuZG9uZSAmJiAoX2EgPSBleHBvcnRBc0Fycl8xLnJldHVybikpIF9hLmNhbGwoZXhwb3J0QXNBcnJfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5nTW9kdWxlU3ltYm9scyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9lID0gX192YWx1ZXModGhpcy5kYXRhKSwgX2YgPSBfZS5uZXh0KCk7ICFfZi5kb25lOyBfZiA9IF9lLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBfZyA9IF9mLnZhbHVlLCBzdW1tYXJ5ID0gX2cuc3VtbWFyeSwgbWV0YWRhdGEgPSBfZy5tZXRhZGF0YSwgaXNMaWJyYXJ5ID0gX2cuaXNMaWJyYXJ5O1xuICAgICAgICAgICAgICAgIGlmIChzdW1tYXJ5LnN1bW1hcnlLaW5kID09PSBDb21waWxlU3VtbWFyeUtpbmQuTmdNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29sbGVjdCB0aGUgc3ltYm9scyB0aGF0IHJlZmVyIHRvIE5nTW9kdWxlIGNsYXNzZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHdlIGNhbid0IGp1c3QgcmVseSBvbiBgc3VtbWFyeS50eXBlLnN1bW1hcnlLaW5kYCB0byBkZXRlcm1pbmUgdGhpcyBhc1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBhZGQgdGhlIHN1bW1hcmllcyBvZiBhbGwgcmVmZXJlbmNlZCBzeW1ib2xzIHdoZW4gd2Ugc2VyaWFsaXplIHR5cGUgc3VtbWFyaWVzLlxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgc2VyaWFsaXplU3VtbWFyaWVzIGZvciBkZXRhaWxzLlxuICAgICAgICAgICAgICAgICAgICBuZ01vZHVsZVN5bWJvbHMuYWRkKHN1bW1hcnkudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kU3VtbWFyeSA9IHN1bW1hcnk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaCA9IChlXzMgPSB2b2lkIDAsIF9fdmFsdWVzKG1vZFN1bW1hcnkubW9kdWxlcykpLCBfaiA9IF9oLm5leHQoKTsgIV9qLmRvbmU7IF9qID0gX2gubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZCA9IF9qLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5nTW9kdWxlU3ltYm9scy5hZGQobW9kLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaiAmJiAhX2ouZG9uZSAmJiAoX2MgPSBfaC5yZXR1cm4pKSBfYy5jYWxsKF9oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzTGlicmFyeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm5OYW1lID0gc3VtbWFyeUZvckppdE5hbWUoc3VtbWFyeS50eXBlLnJlZmVyZW5jZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlU3VtbWFyeUZvckppdEZ1bmN0aW9uKHRoaXMub3V0cHV0Q3R4LCBzdW1tYXJ5LnR5cGUucmVmZXJlbmNlLCB0aGlzLnNlcmlhbGl6ZVN1bW1hcnlXaXRoRGVwcyhzdW1tYXJ5LCBtZXRhZGF0YSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYiA9IF9lLnJldHVybikpIF9iLmNhbGwoX2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIG5nTW9kdWxlU3ltYm9scy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZVN5bWJvbCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN1bW1hcnlSZXNvbHZlci5pc0xpYnJhcnlGaWxlKG5nTW9kdWxlU3ltYm9sLmZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICAgIHZhciBleHBvcnRBcyA9IGV4cG9ydEFzQnlTeW1ib2wuZ2V0KG5nTW9kdWxlU3ltYm9sKSB8fCBuZ01vZHVsZVN5bWJvbC5uYW1lO1xuICAgICAgICAgICAgICAgIHZhciBqaXRFeHBvcnRBc05hbWUgPSBzdW1tYXJ5Rm9ySml0TmFtZShleHBvcnRBcyk7XG4gICAgICAgICAgICAgICAgX3RoaXMub3V0cHV0Q3R4LnN0YXRlbWVudHMucHVzaCh2YXJpYWJsZShqaXRFeHBvcnRBc05hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5zZXQoX3RoaXMuc2VyaWFsaXplU3VtbWFyeVJlZihuZ01vZHVsZVN5bWJvbCkpXG4gICAgICAgICAgICAgICAgICAgIC50b0RlY2xTdG10KG51bGwsIFtTdG10TW9kaWZpZXIuRXhwb3J0ZWRdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRm9ySml0U2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplU3VtbWFyeVdpdGhEZXBzID0gZnVuY3Rpb24gKHN1bW1hcnksIG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBleHByZXNzaW9ucyA9IFt0aGlzLnNlcmlhbGl6ZVN1bW1hcnkoc3VtbWFyeSldO1xuICAgICAgICB2YXIgcHJvdmlkZXJzID0gW107XG4gICAgICAgIGlmIChtZXRhZGF0YSBpbnN0YW5jZW9mIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoLmFwcGx5KGV4cHJlc3Npb25zLCBfX3NwcmVhZChcbiAgICAgICAgICAgIC8vIEZvciBkaXJlY3RpdmVzIC8gcGlwZXMsIHdlIG9ubHkgYWRkIHRoZSBkZWNsYXJlZCBvbmVzLFxuICAgICAgICAgICAgLy8gYW5kIHJlbHkgb24gdHJhbnNpdGl2ZWx5IGltcG9ydGluZyBOZ01vZHVsZXMgdG8gZ2V0IHRoZSB0cmFuc2l0aXZlXG4gICAgICAgICAgICAvLyBzdW1tYXJpZXMuXG4gICAgICAgICAgICBtZXRhZGF0YS5kZWNsYXJlZERpcmVjdGl2ZXMuY29uY2F0KG1ldGFkYXRhLmRlY2xhcmVkUGlwZXMpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZS5yZWZlcmVuY2U7IH0pXG4gICAgICAgICAgICAgICAgLy8gRm9yIG1vZHVsZXMsXG4gICAgICAgICAgICAgICAgLy8gd2UgYWxzbyBhZGQgdGhlIHN1bW1hcmllcyBmb3IgbW9kdWxlc1xuICAgICAgICAgICAgICAgIC8vIGZyb20gbGlicmFyaWVzLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgb2sgYXMgd2UgcHJvZHVjZSByZWV4cG9ydHMgZm9yIGFsbCB0cmFuc2l0aXZlIG1vZHVsZXMuXG4gICAgICAgICAgICAgICAgLmNvbmNhdChtZXRhZGF0YS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLnJlZmVyZW5jZTsgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIHJlZiAhPT0gbWV0YWRhdGEudHlwZS5yZWZlcmVuY2U7IH0pKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gX3RoaXMuc2VyaWFsaXplU3VtbWFyeVJlZihyZWYpOyB9KSkpO1xuICAgICAgICAgICAgLy8gTm90ZTogV2UgZG9uJ3QgdXNlIGBOZ01vZHVsZVN1bW1hcnkucHJvdmlkZXJzYCwgYXMgdGhhdCBvbmUgaXMgdHJhbnNpdGl2ZSxcbiAgICAgICAgICAgIC8vIGFuZCB3ZSBhbHJlYWR5IGhhdmUgdHJhbnNpdGl2ZSBtb2R1bGVzLlxuICAgICAgICAgICAgcHJvdmlkZXJzID0gbWV0YWRhdGEucHJvdmlkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN1bW1hcnkuc3VtbWFyeUtpbmQgPT09IENvbXBpbGVTdW1tYXJ5S2luZC5EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIHZhciBkaXJTdW1tYXJ5ID0gc3VtbWFyeTtcbiAgICAgICAgICAgIHByb3ZpZGVycyA9IGRpclN1bW1hcnkucHJvdmlkZXJzLmNvbmNhdChkaXJTdW1tYXJ5LnZpZXdQcm92aWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IFdlIGNhbid0IGp1c3QgcmVmZXIgdG8gdGhlIGBuZ3N1bW1hcnkudHNgIGZpbGVzIGZvciBgdXNlQ2xhc3NgIHByb3ZpZGVycyAoYXMgd2UgZG8gZm9yXG4gICAgICAgIC8vIGRlY2xhcmVkRGlyZWN0aXZlcyAvIGRlY2xhcmVkUGlwZXMpLCBhcyB3ZSBhbGxvd1xuICAgICAgICAvLyBwcm92aWRlcnMgd2l0aG91dCBjdG9yIGFyZ3VtZW50cyB0byBza2lwIHRoZSBgQEluamVjdGFibGVgIGRlY29yYXRvcixcbiAgICAgICAgLy8gaS5lLiB3ZSBkaWRuJ3QgZ2VuZXJhdGUgLm5nc3VtbWFyeS50cyBmaWxlcyBmb3IgdGhlc2UuXG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2guYXBwbHkoZXhwcmVzc2lvbnMsIF9fc3ByZWFkKHByb3ZpZGVycy5maWx0ZXIoZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiAhIXByb3ZpZGVyLnVzZUNsYXNzOyB9KS5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiBfdGhpcy5zZXJpYWxpemVTdW1tYXJ5KHtcbiAgICAgICAgICAgIHN1bW1hcnlLaW5kOiBDb21waWxlU3VtbWFyeUtpbmQuSW5qZWN0YWJsZSwgdHlwZTogcHJvdmlkZXIudXNlQ2xhc3NcbiAgICAgICAgfSk7IH0pKSk7XG4gICAgICAgIHJldHVybiBsaXRlcmFsQXJyKGV4cHJlc3Npb25zKTtcbiAgICB9O1xuICAgIEZvckppdFNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVN1bW1hcnlSZWYgPSBmdW5jdGlvbiAodHlwZVN5bWJvbCkge1xuICAgICAgICB2YXIgaml0SW1wb3J0ZWRTeW1ib2wgPSB0aGlzLnN5bWJvbFJlc29sdmVyLmdldFN0YXRpY1N5bWJvbChzdW1tYXJ5Rm9ySml0RmlsZU5hbWUodHlwZVN5bWJvbC5maWxlUGF0aCksIHN1bW1hcnlGb3JKaXROYW1lKHR5cGVTeW1ib2wubmFtZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRDdHguaW1wb3J0RXhwcihqaXRJbXBvcnRlZFN5bWJvbCk7XG4gICAgfTtcbiAgICBGb3JKaXRTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVTdW1tYXJ5ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIG91dHB1dEN0eCA9IHRoaXMub3V0cHV0Q3R4O1xuICAgICAgICB2YXIgVHJhbnNmb3JtZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBUcmFuc2Zvcm1lcigpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEFycmF5ID0gZnVuY3Rpb24gKGFyciwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoYXJyLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIHZpc2l0VmFsdWUoZW50cnksIF90aGlzLCBjb250ZXh0KTsgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcCA9IGZ1bmN0aW9uIChtYXAsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcEV4cHIoT2JqZWN0LmtleXMobWFwKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbmV3IExpdGVyYWxNYXBFbnRyeShrZXksIHZpc2l0VmFsdWUobWFwW2tleV0sIF90aGlzLCBjb250ZXh0KSwgZmFsc2UpOyB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJpbWl0aXZlID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7IHJldHVybiBsaXRlcmFsKHZhbHVlKTsgfTtcbiAgICAgICAgICAgIFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXRDdHguaW1wb3J0RXhwcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIFN0YXRlOiBFbmNvdW50ZXJlZCB2YWx1ZSBcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybWVyO1xuICAgICAgICB9KCkpO1xuICAgICAgICByZXR1cm4gdmlzaXRWYWx1ZShkYXRhLCBuZXcgVHJhbnNmb3JtZXIoKSwgbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gRm9ySml0U2VyaWFsaXplcjtcbn0oKSk7XG52YXIgRnJvbUpzb25EZXNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZyb21Kc29uRGVzZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZyb21Kc29uRGVzZXJpYWxpemVyKHN5bWJvbENhY2hlLCBzdW1tYXJ5UmVzb2x2ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3ltYm9sQ2FjaGUgPSBzeW1ib2xDYWNoZTtcbiAgICAgICAgX3RoaXMuc3VtbWFyeVJlc29sdmVyID0gc3VtbWFyeVJlc29sdmVyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZyb21Kc29uRGVzZXJpYWxpemVyLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChsaWJyYXJ5RmlsZU5hbWUsIGpzb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICB2YXIgYWxsSW1wb3J0QXMgPSBbXTtcbiAgICAgICAgdGhpcy5zeW1ib2xzID0gZGF0YS5zeW1ib2xzLm1hcChmdW5jdGlvbiAoc2VyaWFsaXplZFN5bWJvbCkgeyByZXR1cm4gX3RoaXMuc3ltYm9sQ2FjaGUuZ2V0KF90aGlzLnN1bW1hcnlSZXNvbHZlci5mcm9tU3VtbWFyeUZpbGVOYW1lKHNlcmlhbGl6ZWRTeW1ib2wuZmlsZVBhdGgsIGxpYnJhcnlGaWxlTmFtZSksIHNlcmlhbGl6ZWRTeW1ib2wubmFtZSk7IH0pO1xuICAgICAgICBkYXRhLnN5bWJvbHMuZm9yRWFjaChmdW5jdGlvbiAoc2VyaWFsaXplZFN5bWJvbCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzeW1ib2wgPSBfdGhpcy5zeW1ib2xzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBpbXBvcnRBcyA9IHNlcmlhbGl6ZWRTeW1ib2wuaW1wb3J0QXM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGltcG9ydEFzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGFsbEltcG9ydEFzLnB1c2goeyBzeW1ib2w6IHN5bWJvbCwgaW1wb3J0QXM6IF90aGlzLnN5bWJvbHNbaW1wb3J0QXNdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGltcG9ydEFzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGFsbEltcG9ydEFzLnB1c2goeyBzeW1ib2w6IHN5bWJvbCwgaW1wb3J0QXM6IF90aGlzLnN5bWJvbENhY2hlLmdldChuZ2ZhY3RvcnlGaWxlUGF0aChsaWJyYXJ5RmlsZU5hbWUpLCBpbXBvcnRBcykgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc3VtbWFyaWVzID0gdmlzaXRWYWx1ZShkYXRhLnN1bW1hcmllcywgdGhpcywgbnVsbCk7XG4gICAgICAgIHJldHVybiB7IG1vZHVsZU5hbWU6IGRhdGEubW9kdWxlTmFtZSwgc3VtbWFyaWVzOiBzdW1tYXJpZXMsIGltcG9ydEFzOiBhbGxJbXBvcnRBcyB9O1xuICAgIH07XG4gICAgRnJvbUpzb25EZXNlcmlhbGl6ZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwID0gZnVuY3Rpb24gKG1hcCwgY29udGV4dCkge1xuICAgICAgICBpZiAoJ19fc3ltYm9sJyBpbiBtYXApIHtcbiAgICAgICAgICAgIHZhciBiYXNlU3ltYm9sID0gdGhpcy5zeW1ib2xzW21hcFsnX19zeW1ib2wnXV07XG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IG1hcFsnbWVtYmVycyddO1xuICAgICAgICAgICAgcmV0dXJuIG1lbWJlcnMubGVuZ3RoID8gdGhpcy5zeW1ib2xDYWNoZS5nZXQoYmFzZVN5bWJvbC5maWxlUGF0aCwgYmFzZVN5bWJvbC5uYW1lLCBtZW1iZXJzKSA6XG4gICAgICAgICAgICAgICAgYmFzZVN5bWJvbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwLmNhbGwodGhpcywgbWFwLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZyb21Kc29uRGVzZXJpYWxpemVyO1xufShWYWx1ZVRyYW5zZm9ybWVyKSk7XG5mdW5jdGlvbiBpc0NhbGwobWV0YWRhdGEpIHtcbiAgICByZXR1cm4gbWV0YWRhdGEgJiYgbWV0YWRhdGEuX19zeW1ib2xpYyA9PT0gJ2NhbGwnO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbkNhbGwobWV0YWRhdGEpIHtcbiAgICByZXR1cm4gaXNDYWxsKG1ldGFkYXRhKSAmJiB1bndyYXBSZXNvbHZlZE1ldGFkYXRhKG1ldGFkYXRhLmV4cHJlc3Npb24pIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sO1xufVxuZnVuY3Rpb24gaXNNZXRob2RDYWxsT25WYXJpYWJsZShtZXRhZGF0YSkge1xuICAgIHJldHVybiBpc0NhbGwobWV0YWRhdGEpICYmIG1ldGFkYXRhLmV4cHJlc3Npb24gJiYgbWV0YWRhdGEuZXhwcmVzc2lvbi5fX3N5bWJvbGljID09PSAnc2VsZWN0JyAmJlxuICAgICAgICB1bndyYXBSZXNvbHZlZE1ldGFkYXRhKG1ldGFkYXRhLmV4cHJlc3Npb24uZXhwcmVzc2lvbikgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2w7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBBb3RDb21waWxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBb3RDb21waWxlcihfY29uZmlnLCBfb3B0aW9ucywgX2hvc3QsIHJlZmxlY3RvciwgX21ldGFkYXRhUmVzb2x2ZXIsIF90ZW1wbGF0ZVBhcnNlciwgX3N0eWxlQ29tcGlsZXIsIF92aWV3Q29tcGlsZXIsIF90eXBlQ2hlY2tDb21waWxlciwgX25nTW9kdWxlQ29tcGlsZXIsIF9pbmplY3RhYmxlQ29tcGlsZXIsIF9vdXRwdXRFbWl0dGVyLCBfc3VtbWFyeVJlc29sdmVyLCBfc3ltYm9sUmVzb2x2ZXIpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgICAgICB0aGlzLl9ob3N0ID0gX2hvc3Q7XG4gICAgICAgIHRoaXMucmVmbGVjdG9yID0gcmVmbGVjdG9yO1xuICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyID0gX21ldGFkYXRhUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlUGFyc2VyID0gX3RlbXBsYXRlUGFyc2VyO1xuICAgICAgICB0aGlzLl9zdHlsZUNvbXBpbGVyID0gX3N0eWxlQ29tcGlsZXI7XG4gICAgICAgIHRoaXMuX3ZpZXdDb21waWxlciA9IF92aWV3Q29tcGlsZXI7XG4gICAgICAgIHRoaXMuX3R5cGVDaGVja0NvbXBpbGVyID0gX3R5cGVDaGVja0NvbXBpbGVyO1xuICAgICAgICB0aGlzLl9uZ01vZHVsZUNvbXBpbGVyID0gX25nTW9kdWxlQ29tcGlsZXI7XG4gICAgICAgIHRoaXMuX2luamVjdGFibGVDb21waWxlciA9IF9pbmplY3RhYmxlQ29tcGlsZXI7XG4gICAgICAgIHRoaXMuX291dHB1dEVtaXR0ZXIgPSBfb3V0cHV0RW1pdHRlcjtcbiAgICAgICAgdGhpcy5fc3VtbWFyeVJlc29sdmVyID0gX3N1bW1hcnlSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fc3ltYm9sUmVzb2x2ZXIgPSBfc3ltYm9sUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlQXN0Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2FuYWx5emVkRmlsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2FuYWx5emVkRmlsZXNGb3JJbmplY3RhYmxlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuY2xlYXJDYWNoZSgpOyB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5hbmFseXplTW9kdWxlc1N5bmMgPSBmdW5jdGlvbiAocm9vdEZpbGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhbmFseXplUmVzdWx0ID0gYW5hbHl6ZUFuZFZhbGlkYXRlTmdNb2R1bGVzKHJvb3RGaWxlcywgdGhpcy5faG9zdCwgdGhpcy5fc3ltYm9sUmVzb2x2ZXIsIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIpO1xuICAgICAgICBhbmFseXplUmVzdWx0Lm5nTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZSkgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIubG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhKG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlLCB0cnVlKTsgfSk7XG4gICAgICAgIHJldHVybiBhbmFseXplUmVzdWx0O1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLmFuYWx5emVNb2R1bGVzQXN5bmMgPSBmdW5jdGlvbiAocm9vdEZpbGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhbmFseXplUmVzdWx0ID0gYW5hbHl6ZUFuZFZhbGlkYXRlTmdNb2R1bGVzKHJvb3RGaWxlcywgdGhpcy5faG9zdCwgdGhpcy5fc3ltYm9sUmVzb2x2ZXIsIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVxuICAgICAgICAgICAgLmFsbChhbmFseXplUmVzdWx0Lm5nTW9kdWxlcy5tYXAoZnVuY3Rpb24gKG5nTW9kdWxlKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5sb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGEobmdNb2R1bGUudHlwZS5yZWZlcmVuY2UsIGZhbHNlKTsgfSkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBhbmFseXplUmVzdWx0OyB9KTtcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fYW5hbHl6ZUZpbGUgPSBmdW5jdGlvbiAoZmlsZU5hbWUpIHtcbiAgICAgICAgdmFyIGFuYWx5emVkRmlsZSA9IHRoaXMuX2FuYWx5emVkRmlsZXMuZ2V0KGZpbGVOYW1lKTtcbiAgICAgICAgaWYgKCFhbmFseXplZEZpbGUpIHtcbiAgICAgICAgICAgIGFuYWx5emVkRmlsZSA9XG4gICAgICAgICAgICAgICAgYW5hbHl6ZUZpbGUodGhpcy5faG9zdCwgdGhpcy5fc3ltYm9sUmVzb2x2ZXIsIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIsIGZpbGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2FuYWx5emVkRmlsZXMuc2V0KGZpbGVOYW1lLCBhbmFseXplZEZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmFseXplZEZpbGU7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2FuYWx5emVGaWxlRm9ySW5qZWN0YWJsZXMgPSBmdW5jdGlvbiAoZmlsZU5hbWUpIHtcbiAgICAgICAgdmFyIGFuYWx5emVkRmlsZSA9IHRoaXMuX2FuYWx5emVkRmlsZXNGb3JJbmplY3RhYmxlcy5nZXQoZmlsZU5hbWUpO1xuICAgICAgICBpZiAoIWFuYWx5emVkRmlsZSkge1xuICAgICAgICAgICAgYW5hbHl6ZWRGaWxlID0gYW5hbHl6ZUZpbGVGb3JJbmplY3RhYmxlcyh0aGlzLl9ob3N0LCB0aGlzLl9zeW1ib2xSZXNvbHZlciwgdGhpcy5fbWV0YWRhdGFSZXNvbHZlciwgZmlsZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy5fYW5hbHl6ZWRGaWxlc0ZvckluamVjdGFibGVzLnNldChmaWxlTmFtZSwgYW5hbHl6ZWRGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5hbHl6ZWRGaWxlO1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLmZpbmRHZW5lcmF0ZWRGaWxlTmFtZXMgPSBmdW5jdGlvbiAoZmlsZU5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGdlbkZpbGVOYW1lcyA9IFtdO1xuICAgICAgICB2YXIgZmlsZSA9IHRoaXMuX2FuYWx5emVGaWxlKGZpbGVOYW1lKTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGNyZWF0ZSBhIC5uZ2ZhY3RvcnkgaWYgd2UgaGF2ZSBhIGluamVjdGFibGUvZGlyZWN0aXZlL3BpcGUvTmdNb2R1bGVcbiAgICAgICAgLy8gb3IgYSByZWZlcmVuY2UgdG8gYSBub24gc291cmNlIGZpbGUuXG4gICAgICAgIC8vIE5vdGU6IFRoaXMgaXMgb3ZlcmVzdGltYXRpbmcgdGhlIHJlcXVpcmVkIC5uZ2ZhY3RvcnkgZmlsZXMgYXMgdGhlIHJlYWwgY2FsY3VsYXRpb24gaXMgaGFyZGVyLlxuICAgICAgICAvLyBPbmx5IGRvIHRoaXMgZm9yIFN0dWJFbWl0RmxhZ3MuQmFzaWMsIGFzIGFkZGluZyBhIHR5cGUgY2hlY2sgYmxvY2tcbiAgICAgICAgLy8gZG9lcyBub3QgY2hhbmdlIHRoaXMgZmlsZSAoYXMgd2UgZ2VuZXJhdGUgdHlwZSBjaGVjayBibG9ja3MgYmFzZWQgb24gTmdNb2R1bGVzKS5cbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYWxsb3dFbXB0eUNvZGVnZW5GaWxlcyB8fCBmaWxlLmRpcmVjdGl2ZXMubGVuZ3RoIHx8IGZpbGUucGlwZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICBmaWxlLmluamVjdGFibGVzLmxlbmd0aCB8fCBmaWxlLm5nTW9kdWxlcy5sZW5ndGggfHwgZmlsZS5leHBvcnRzTm9uU291cmNlRmlsZXMpIHtcbiAgICAgICAgICAgIGdlbkZpbGVOYW1lcy5wdXNoKG5nZmFjdG9yeUZpbGVQYXRoKGZpbGUuZmlsZU5hbWUsIHRydWUpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmVuYWJsZVN1bW1hcmllc0ZvckppdCkge1xuICAgICAgICAgICAgICAgIGdlbkZpbGVOYW1lcy5wdXNoKHN1bW1hcnlGb3JKaXRGaWxlTmFtZShmaWxlLmZpbGVOYW1lLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpbGVTdWZmaXggPSBub3JtYWxpemVHZW5GaWxlU3VmZml4KHNwbGl0VHlwZXNjcmlwdFN1ZmZpeChmaWxlLmZpbGVOYW1lLCB0cnVlKVsxXSk7XG4gICAgICAgIGZpbGUuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJTeW1ib2wpIHtcbiAgICAgICAgICAgIHZhciBjb21wTWV0YSA9IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5vbk5vcm1hbGl6ZWREaXJlY3RpdmVNZXRhZGF0YShkaXJTeW1ib2wpLm1ldGFkYXRhO1xuICAgICAgICAgICAgaWYgKCFjb21wTWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdGU6IGNvbXBNZXRhIGlzIGEgY29tcG9uZW50IGFuZCB0aGVyZWZvcmUgdGVtcGxhdGUgaXMgbm9uIG51bGwuXG4gICAgICAgICAgICBjb21wTWV0YS50ZW1wbGF0ZS5zdHlsZVVybHMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVVcmwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZFVybCA9IF90aGlzLl9ob3N0LnJlc291cmNlTmFtZVRvRmlsZU5hbWUoc3R5bGVVcmwsIGZpbGUuZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghbm9ybWFsaXplZFVybCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIkNvdWxkbid0IHJlc29sdmUgcmVzb3VyY2UgXCIgKyBzdHlsZVVybCArIFwiIHJlbGF0aXZlIHRvIFwiICsgZmlsZS5maWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuZWVkc1NoaW0gPSAoY29tcE1ldGEudGVtcGxhdGUuZW5jYXBzdWxhdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY29uZmlnLmRlZmF1bHRFbmNhcHN1bGF0aW9uKSA9PT0gVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQ7XG4gICAgICAgICAgICAgICAgZ2VuRmlsZU5hbWVzLnB1c2goX3N0eWxlc01vZHVsZVVybChub3JtYWxpemVkVXJsLCBuZWVkc1NoaW0sIGZpbGVTdWZmaXgpKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX29wdGlvbnMuYWxsb3dFbXB0eUNvZGVnZW5GaWxlcykge1xuICAgICAgICAgICAgICAgICAgICBnZW5GaWxlTmFtZXMucHVzaChfc3R5bGVzTW9kdWxlVXJsKG5vcm1hbGl6ZWRVcmwsICFuZWVkc1NoaW0sIGZpbGVTdWZmaXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnZW5GaWxlTmFtZXM7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuZW1pdEJhc2ljU3R1YiA9IGZ1bmN0aW9uIChnZW5GaWxlTmFtZSwgb3JpZ2luYWxGaWxlTmFtZSkge1xuICAgICAgICB2YXIgb3V0cHV0Q3R4ID0gdGhpcy5fY3JlYXRlT3V0cHV0Q29udGV4dChnZW5GaWxlTmFtZSk7XG4gICAgICAgIGlmIChnZW5GaWxlTmFtZS5lbmRzV2l0aCgnLm5nZmFjdG9yeS50cycpKSB7XG4gICAgICAgICAgICBpZiAoIW9yaWdpbmFsRmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gZXJyb3I6IHJlcXVpcmUgdGhlIG9yaWdpbmFsIGZpbGUgZm9yIC5uZ2ZhY3RvcnkudHMgc3R1YnMuIEZpbGU6IFwiICsgZ2VuRmlsZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRmlsZSA9IHRoaXMuX2FuYWx5emVGaWxlKG9yaWdpbmFsRmlsZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlTmdGYWN0b3J5U3R1YihvdXRwdXRDdHgsIG9yaWdpbmFsRmlsZSwgMSAvKiBCYXNpYyAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2VuRmlsZU5hbWUuZW5kc1dpdGgoJy5uZ3N1bW1hcnkudHMnKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZW5hYmxlU3VtbWFyaWVzRm9ySml0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcmlnaW5hbEZpbGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBlcnJvcjogcmVxdWlyZSB0aGUgb3JpZ2luYWwgZmlsZSBmb3IgLm5nc3VtbWFyeS50cyBzdHVicy4gRmlsZTogXCIgKyBnZW5GaWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEZpbGUgPSB0aGlzLl9hbmFseXplRmlsZShvcmlnaW5hbEZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICBfY3JlYXRlRW1wdHlTdHViKG91dHB1dEN0eCk7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxGaWxlLm5nTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgZXhwb3J0cyB0aGF0IHVzZXIgY29kZSBjYW4gcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZvckppdFN0dWIob3V0cHV0Q3R4LCBuZ01vZHVsZS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2VuRmlsZU5hbWUuZW5kc1dpdGgoJy5uZ3N0eWxlLnRzJykpIHtcbiAgICAgICAgICAgIF9jcmVhdGVFbXB0eVN0dWIob3V0cHV0Q3R4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBmb3IgdGhlIHN0dWJzLCB3ZSBkb24ndCBuZWVkIGEgcHJvcGVydHkgc3JjRmlsZVVybCxcbiAgICAgICAgLy8gYXMgbGF0ZXIgb24gaW4gZW1pdEFsbEltcGxzIHdlIHdpbGwgY3JlYXRlIHRoZSBwcm9wZXIgR2VuZXJhdGVkRmlsZXMgd2l0aCB0aGVcbiAgICAgICAgLy8gY29ycmVjdCBzcmNGaWxlVXJsLlxuICAgICAgICAvLyBUaGlzIGlzIGdvb2QgYXMgZS5nLiBmb3IgLm5nc3R5bGUudHMgZmlsZXMgd2UgY2FuJ3QgZGVyaXZlXG4gICAgICAgIC8vIHRoZSB1cmwgb2YgY29tcG9uZW50cyBiYXNlZCBvbiB0aGUgZ2VuRmlsZVVybC5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvZGVnZW5Tb3VyY2VNb2R1bGUoJ3Vua25vd24nLCBvdXRwdXRDdHgpO1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLmVtaXRUeXBlQ2hlY2tTdHViID0gZnVuY3Rpb24gKGdlbkZpbGVOYW1lLCBvcmlnaW5hbEZpbGVOYW1lKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbEZpbGUgPSB0aGlzLl9hbmFseXplRmlsZShvcmlnaW5hbEZpbGVOYW1lKTtcbiAgICAgICAgdmFyIG91dHB1dEN0eCA9IHRoaXMuX2NyZWF0ZU91dHB1dENvbnRleHQoZ2VuRmlsZU5hbWUpO1xuICAgICAgICBpZiAoZ2VuRmlsZU5hbWUuZW5kc1dpdGgoJy5uZ2ZhY3RvcnkudHMnKSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlTmdGYWN0b3J5U3R1YihvdXRwdXRDdHgsIG9yaWdpbmFsRmlsZSwgMiAvKiBUeXBlQ2hlY2sgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXRDdHguc3RhdGVtZW50cy5sZW5ndGggPiAwID9cbiAgICAgICAgICAgIHRoaXMuX2NvZGVnZW5Tb3VyY2VNb2R1bGUob3JpZ2luYWxGaWxlLmZpbGVOYW1lLCBvdXRwdXRDdHgpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUubG9hZEZpbGVzQXN5bmMgPSBmdW5jdGlvbiAoZmlsZU5hbWVzLCB0c0ZpbGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmaWxlcyA9IGZpbGVOYW1lcy5tYXAoZnVuY3Rpb24gKGZpbGVOYW1lKSB7IHJldHVybiBfdGhpcy5fYW5hbHl6ZUZpbGUoZmlsZU5hbWUpOyB9KTtcbiAgICAgICAgdmFyIGxvYWRpbmdQcm9taXNlcyA9IFtdO1xuICAgICAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7IHJldHVybiBmaWxlLm5nTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRpbmdQcm9taXNlcy5wdXNoKF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmxvYWROZ01vZHVsZURpcmVjdGl2ZUFuZFBpcGVNZXRhZGF0YShuZ01vZHVsZS50eXBlLnJlZmVyZW5jZSwgZmFsc2UpKTtcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICB2YXIgYW5hbHl6ZWRJbmplY3RhYmxlcyA9IHRzRmlsZXMubWFwKGZ1bmN0aW9uICh0c0ZpbGUpIHsgcmV0dXJuIF90aGlzLl9hbmFseXplRmlsZUZvckluamVjdGFibGVzKHRzRmlsZSk7IH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobG9hZGluZ1Byb21pc2VzKS50aGVuKGZ1bmN0aW9uIChfKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgYW5hbHl6ZWRNb2R1bGVzOiBtZXJnZUFuZFZhbGlkYXRlTmdGaWxlcyhmaWxlcyksXG4gICAgICAgICAgICBhbmFseXplZEluamVjdGFibGVzOiBhbmFseXplZEluamVjdGFibGVzLFxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUubG9hZEZpbGVzU3luYyA9IGZ1bmN0aW9uIChmaWxlTmFtZXMsIHRzRmlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZpbGVzID0gZmlsZU5hbWVzLm1hcChmdW5jdGlvbiAoZmlsZU5hbWUpIHsgcmV0dXJuIF90aGlzLl9hbmFseXplRmlsZShmaWxlTmFtZSk7IH0pO1xuICAgICAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7IHJldHVybiBmaWxlLm5nTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZSkgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIubG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhKG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlLCB0cnVlKTsgfSk7IH0pO1xuICAgICAgICB2YXIgYW5hbHl6ZWRJbmplY3RhYmxlcyA9IHRzRmlsZXMubWFwKGZ1bmN0aW9uICh0c0ZpbGUpIHsgcmV0dXJuIF90aGlzLl9hbmFseXplRmlsZUZvckluamVjdGFibGVzKHRzRmlsZSk7IH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYW5hbHl6ZWRNb2R1bGVzOiBtZXJnZUFuZFZhbGlkYXRlTmdGaWxlcyhmaWxlcyksXG4gICAgICAgICAgICBhbmFseXplZEluamVjdGFibGVzOiBhbmFseXplZEluamVjdGFibGVzLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jcmVhdGVOZ0ZhY3RvcnlTdHViID0gZnVuY3Rpb24gKG91dHB1dEN0eCwgZmlsZSwgZW1pdEZsYWdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb21wb25lbnRJZCA9IDA7XG4gICAgICAgIGZpbGUubmdNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlTWV0YSwgbmdNb2R1bGVJbmRleCkge1xuICAgICAgICAgICAgLy8gTm90ZTogdGhlIGNvZGUgYmVsb3cgbmVlZHMgdG8gZXhlY3V0ZWQgZm9yIFN0dWJFbWl0RmxhZ3MuQmFzaWMgYW5kIFN0dWJFbWl0RmxhZ3MuVHlwZUNoZWNrLFxuICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgY2hhbmdlIHRoZSAubmdmYWN0b3J5IGZpbGUgdG9vIG11Y2ggd2hlbiBhZGRpbmcgdGhlIHR5cGUtY2hlY2sgYmxvY2suXG4gICAgICAgICAgICAvLyBjcmVhdGUgZXhwb3J0cyB0aGF0IHVzZXIgY29kZSBjYW4gcmVmZXJlbmNlXG4gICAgICAgICAgICBfdGhpcy5fbmdNb2R1bGVDb21waWxlci5jcmVhdGVTdHViKG91dHB1dEN0eCwgbmdNb2R1bGVNZXRhLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIC8vIGFkZCByZWZlcmVuY2VzIHRvIHRoZSBzeW1ib2xzIGZyb20gdGhlIG1ldGFkYXRhLlxuICAgICAgICAgICAgLy8gVGhlc2UgY2FuIGJlIHVzZWQgYnkgdGhlIHR5cGUgY2hlY2sgYmxvY2sgZm9yIGNvbXBvbmVudHMsXG4gICAgICAgICAgICAvLyBhbmQgdGhleSBhbHNvIGNhdXNlIFR5cGVTY3JpcHQgdG8gaW5jbHVkZSB0aGVzZSBmaWxlcyBpbnRvIHRoZSBwcm9ncmFtIHRvbyxcbiAgICAgICAgICAgIC8vIHdoaWNoIHdpbGwgbWFrZSB0aGVtIHBhcnQgb2YgdGhlIGFuYWx5emVkRmlsZXMuXG4gICAgICAgICAgICB2YXIgZXh0ZXJuYWxSZWZlcmVuY2VzID0gX19zcHJlYWQobmdNb2R1bGVNZXRhLnRyYW5zaXRpdmVNb2R1bGUuZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQucmVmZXJlbmNlOyB9KSwgbmdNb2R1bGVNZXRhLnRyYW5zaXRpdmVNb2R1bGUucGlwZXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnJlZmVyZW5jZTsgfSksIG5nTW9kdWxlTWV0YS5pbXBvcnRlZE1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnR5cGUucmVmZXJlbmNlOyB9KSwgbmdNb2R1bGVNZXRhLmV4cG9ydGVkTW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0udHlwZS5yZWZlcmVuY2U7IH0pLCBfdGhpcy5fZXh0ZXJuYWxJZGVudGlmaWVyUmVmZXJlbmNlcyhbSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYsIElkZW50aWZpZXJzLkVsZW1lbnRSZWZdKSk7XG4gICAgICAgICAgICB2YXIgZXh0ZXJuYWxSZWZlcmVuY2VWYXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZXh0ZXJuYWxSZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24gKHJlZiwgdHlwZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxSZWZlcmVuY2VWYXJzLnNldChyZWYsIFwiX2RlY2xcIiArIG5nTW9kdWxlSW5kZXggKyBcIl9cIiArIHR5cGVJbmRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4dGVybmFsUmVmZXJlbmNlVmFycy5mb3JFYWNoKGZ1bmN0aW9uICh2YXJOYW1lLCByZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRDdHguc3RhdGVtZW50cy5wdXNoKHZhcmlhYmxlKHZhck5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5zZXQoTlVMTF9FWFBSLmNhc3QoRFlOQU1JQ19UWVBFKSlcbiAgICAgICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQoZXhwcmVzc2lvblR5cGUob3V0cHV0Q3R4LmltcG9ydEV4cHIocmVmZXJlbmNlLCAvKiB0eXBlUGFyYW1zICovIG51bGwsIC8qIHVzZVN1bW1hcmllcyAqLyBmYWxzZSkpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlbWl0RmxhZ3MgJiAyIC8qIFR5cGVDaGVjayAqLykge1xuICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgdHlwZS1jaGVjayBibG9jayBmb3IgYWxsIGNvbXBvbmVudHMgb2YgdGhlIE5nTW9kdWxlXG4gICAgICAgICAgICAgICAgbmdNb2R1bGVNZXRhLmRlY2xhcmVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJJZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcE1ldGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YShkaXJJZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50SWQrKztcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZVR5cGVDaGVja0Jsb2NrKG91dHB1dEN0eCwgY29tcE1ldGEudHlwZS5yZWZlcmVuY2UubmFtZSArIFwiX0hvc3RfXCIgKyBjb21wb25lbnRJZCwgbmdNb2R1bGVNZXRhLCBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRIb3N0Q29tcG9uZW50TWV0YWRhdGEoY29tcE1ldGEpLCBbY29tcE1ldGEudHlwZV0sIGV4dGVybmFsUmVmZXJlbmNlVmFycyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9jcmVhdGVUeXBlQ2hlY2tCbG9jayhvdXRwdXRDdHgsIGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlLm5hbWUgKyBcIl9cIiArIGNvbXBvbmVudElkLCBuZ01vZHVsZU1ldGEsIGNvbXBNZXRhLCBuZ01vZHVsZU1ldGEudHJhbnNpdGl2ZU1vZHVsZS5kaXJlY3RpdmVzLCBleHRlcm5hbFJlZmVyZW5jZVZhcnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dHB1dEN0eC5zdGF0ZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgX2NyZWF0ZUVtcHR5U3R1YihvdXRwdXRDdHgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2V4dGVybmFsSWRlbnRpZmllclJlZmVyZW5jZXMgPSBmdW5jdGlvbiAocmVmZXJlbmNlcykge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgcmVmZXJlbmNlc18xID0gX192YWx1ZXMocmVmZXJlbmNlcyksIHJlZmVyZW5jZXNfMV8xID0gcmVmZXJlbmNlc18xLm5leHQoKTsgIXJlZmVyZW5jZXNfMV8xLmRvbmU7IHJlZmVyZW5jZXNfMV8xID0gcmVmZXJlbmNlc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciByZWZlcmVuY2UgPSByZWZlcmVuY2VzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBjcmVhdGVUb2tlbkZvckV4dGVybmFsUmVmZXJlbmNlKHRoaXMucmVmbGVjdG9yLCByZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5pZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRva2VuLmlkZW50aWZpZXIucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChyZWZlcmVuY2VzXzFfMSAmJiAhcmVmZXJlbmNlc18xXzEuZG9uZSAmJiAoX2EgPSByZWZlcmVuY2VzXzEucmV0dXJuKSkgX2EuY2FsbChyZWZlcmVuY2VzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NyZWF0ZVR5cGVDaGVja0Jsb2NrID0gZnVuY3Rpb24gKGN0eCwgY29tcG9uZW50SWQsIG1vZHVsZU1ldGEsIGNvbXBNZXRhLCBkaXJlY3RpdmVzLCBleHRlcm5hbFJlZmVyZW5jZVZhcnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLl9wYXJzZVRlbXBsYXRlKGNvbXBNZXRhLCBtb2R1bGVNZXRhLCBkaXJlY3RpdmVzKSwgcGFyc2VkVGVtcGxhdGUgPSBfYi50ZW1wbGF0ZSwgdXNlZFBpcGVzID0gX2IucGlwZXM7XG4gICAgICAgIChfYSA9IGN0eC5zdGF0ZW1lbnRzKS5wdXNoLmFwcGx5KF9hLCBfX3NwcmVhZCh0aGlzLl90eXBlQ2hlY2tDb21waWxlci5jb21waWxlQ29tcG9uZW50KGNvbXBvbmVudElkLCBjb21wTWV0YSwgcGFyc2VkVGVtcGxhdGUsIHVzZWRQaXBlcywgZXh0ZXJuYWxSZWZlcmVuY2VWYXJzLCBjdHgpKSk7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuZW1pdE1lc3NhZ2VCdW5kbGUgPSBmdW5jdGlvbiAoYW5hbHl6ZVJlc3VsdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIGh0bWxQYXJzZXIgPSBuZXcgSHRtbFBhcnNlcigpO1xuICAgICAgICAvLyBUT0RPKHZpY2IpOiBpbXBsaWNpdCB0YWdzICYgYXR0cmlidXRlc1xuICAgICAgICB2YXIgbWVzc2FnZUJ1bmRsZSA9IG5ldyBNZXNzYWdlQnVuZGxlKGh0bWxQYXJzZXIsIFtdLCB7fSwgbG9jYWxlKTtcbiAgICAgICAgYW5hbHl6ZVJlc3VsdC5maWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICB2YXIgY29tcE1ldGFzID0gW107XG4gICAgICAgICAgICBmaWxlLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBkaXJNZXRhID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpck1ldGEgJiYgZGlyTWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wTWV0YXMucHVzaChkaXJNZXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbXBNZXRhcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wTWV0YSkge1xuICAgICAgICAgICAgICAgIHZhciBodG1sID0gY29tcE1ldGEudGVtcGxhdGUudGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgLy8gVGVtcGxhdGUgVVJMIHBvaW50cyB0byBlaXRoZXIgYW4gSFRNTCBvciBUUyBmaWxlIGRlcGVuZGluZyBvbiB3aGV0aGVyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGZpbGUgaXMgdXNlZCB3aXRoIGB0ZW1wbGF0ZVVybDpgIG9yIGB0ZW1wbGF0ZTpgLCByZXNwZWN0aXZlbHkuXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlVXJsID0gY29tcE1ldGEudGVtcGxhdGUudGVtcGxhdGVVcmw7XG4gICAgICAgICAgICAgICAgdmFyIGludGVycG9sYXRpb25Db25maWcgPSBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheShjb21wTWV0YS50ZW1wbGF0ZS5pbnRlcnBvbGF0aW9uKTtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIF9fc3ByZWFkKG1lc3NhZ2VCdW5kbGUudXBkYXRlRnJvbVRlbXBsYXRlKGh0bWwsIHRlbXBsYXRlVXJsLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUudG9TdHJpbmcoKTsgfSkuam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlQnVuZGxlO1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLmVtaXRBbGxQYXJ0aWFsTW9kdWxlcyA9IGZ1bmN0aW9uIChfYSwgcjNGaWxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZSA9IF9hLm5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUsIGZpbGVzID0gX2EuZmlsZXM7XG4gICAgICAgIHZhciBjb250ZXh0TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0TWFwLmhhcyhmaWxlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0TWFwLnNldChmaWxlTmFtZSwgX3RoaXMuX2NyZWF0ZU91dHB1dENvbnRleHQoZmlsZU5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0TWFwLmdldChmaWxlTmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlUGFydGlhbE1vZHVsZShmaWxlLmZpbGVOYW1lLCBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLCBmaWxlLmRpcmVjdGl2ZXMsIGZpbGUucGlwZXMsIGZpbGUubmdNb2R1bGVzLCBmaWxlLmluamVjdGFibGVzLCBnZXRDb250ZXh0KGZpbGUuZmlsZU5hbWUpKTsgfSk7XG4gICAgICAgIHIzRmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkgeyByZXR1cm4gX3RoaXMuX2NvbXBpbGVTaGFsbG93TW9kdWxlcyhmaWxlLmZpbGVOYW1lLCBmaWxlLnNoYWxsb3dNb2R1bGVzLCBnZXRDb250ZXh0KGZpbGUuZmlsZU5hbWUpKTsgfSk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGNvbnRleHRNYXAudmFsdWVzKCkpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiAoe1xuICAgICAgICAgICAgZmlsZU5hbWU6IGNvbnRleHQuZ2VuRmlsZVBhdGgsXG4gICAgICAgICAgICBzdGF0ZW1lbnRzOiBfX3NwcmVhZChjb250ZXh0LmNvbnN0YW50UG9vbC5zdGF0ZW1lbnRzLCBjb250ZXh0LnN0YXRlbWVudHMpLFxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVTaGFsbG93TW9kdWxlcyA9IGZ1bmN0aW9uIChmaWxlTmFtZSwgc2hhbGxvd01vZHVsZXMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2hhbGxvd01vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlKSB7IHJldHVybiBjb21waWxlTmdNb2R1bGVGcm9tUmVuZGVyMihjb250ZXh0LCBtb2R1bGUsIF90aGlzLl9pbmplY3RhYmxlQ29tcGlsZXIpOyB9KTtcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZVBhcnRpYWxNb2R1bGUgPSBmdW5jdGlvbiAoZmlsZU5hbWUsIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBuZ01vZHVsZXMsIGluamVjdGFibGVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIHNjaGVtYVJlZ2lzdHJ5ID0gbmV3IERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpO1xuICAgICAgICB2YXIgaG9zdEJpbmRpbmdQYXJzZXIgPSBuZXcgQmluZGluZ1BhcnNlcih0aGlzLl90ZW1wbGF0ZVBhcnNlci5leHByZXNzaW9uUGFyc2VyLCBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHLCBzY2hlbWFSZWdpc3RyeSwgW10sIGVycm9ycyk7XG4gICAgICAgIC8vIFByb2Nlc3MgYWxsIGNvbXBvbmVudHMgYW5kIGRpcmVjdGl2ZXNcbiAgICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlTWV0YWRhdGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YShkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmVNZXRhZGF0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBtb2R1bGUgPSBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLmdldChkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgICAgICBtb2R1bGUgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJDYW5ub3QgZGV0ZXJtaW5lIHRoZSBtb2R1bGUgZm9yIGNvbXBvbmVudCAnXCIgKyBpZGVudGlmaWVyTmFtZShkaXJlY3RpdmVNZXRhZGF0YS50eXBlKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgaHRtbEFzdCA9IGRpcmVjdGl2ZU1ldGFkYXRhLnRlbXBsYXRlLmh0bWxBc3Q7XG4gICAgICAgICAgICAgICAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZXMgPSBkaXJlY3RpdmVNZXRhZGF0YS50ZW1wbGF0ZS5wcmVzZXJ2ZVdoaXRlc3BhY2VzO1xuICAgICAgICAgICAgICAgIGlmICghcHJlc2VydmVXaGl0ZXNwYWNlcykge1xuICAgICAgICAgICAgICAgICAgICBodG1sQXN0ID0gcmVtb3ZlV2hpdGVzcGFjZXMoaHRtbEFzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZW5kZXIzQXN0ID0gaHRtbEFzdFRvUmVuZGVyM0FzdChodG1sQXN0LnJvb3ROb2RlcywgaG9zdEJpbmRpbmdQYXJzZXIpO1xuICAgICAgICAgICAgICAgIC8vIE1hcCBvZiBTdGF0aWNUeXBlIGJ5IGRpcmVjdGl2ZSBzZWxlY3RvcnNcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlVHlwZUJ5U2VsXzEgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZXNfMSA9IG1vZHVsZS50cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZVN1bW1hcnkoZGlyLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXNfMS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZS5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlVHlwZUJ5U2VsXzEuc2V0KGRpcmVjdGl2ZS5zZWxlY3RvciwgZGlyZWN0aXZlLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIE1hcCBvZiBTdGF0aWNUeXBlIGJ5IHBpcGUgbmFtZXNcbiAgICAgICAgICAgICAgICB2YXIgcGlwZVR5cGVCeU5hbWVfMSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICB2YXIgcGlwZXNfMSA9IG1vZHVsZS50cmFuc2l0aXZlTW9kdWxlLnBpcGVzLm1hcChmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0UGlwZVN1bW1hcnkocGlwZS5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgICAgICAgICBwaXBlc18xLmZvckVhY2goZnVuY3Rpb24gKHBpcGUpIHsgcGlwZVR5cGVCeU5hbWVfMS5zZXQocGlwZS5uYW1lLCBwaXBlLnR5cGUucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgICAgICAgICAgY29tcGlsZUNvbXBvbmVudEZyb21SZW5kZXIyKGNvbnRleHQsIGRpcmVjdGl2ZU1ldGFkYXRhLCByZW5kZXIzQXN0LCBfdGhpcy5yZWZsZWN0b3IsIGhvc3RCaW5kaW5nUGFyc2VyLCBkaXJlY3RpdmVUeXBlQnlTZWxfMSwgcGlwZVR5cGVCeU5hbWVfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21waWxlRGlyZWN0aXZlRnJvbVJlbmRlcjIoY29udGV4dCwgZGlyZWN0aXZlTWV0YWRhdGEsIF90aGlzLnJlZmxlY3RvciwgaG9zdEJpbmRpbmdQYXJzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBwaXBlTWV0YWRhdGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRQaXBlTWV0YWRhdGEocGlwZVR5cGUpO1xuICAgICAgICAgICAgaWYgKHBpcGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbXBpbGVQaXBlRnJvbVJlbmRlcjIoY29udGV4dCwgcGlwZU1ldGFkYXRhLCBfdGhpcy5yZWZsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaW5qZWN0YWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5qZWN0YWJsZSkgeyByZXR1cm4gX3RoaXMuX2luamVjdGFibGVDb21waWxlci5jb21waWxlKGluamVjdGFibGUsIGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5lbWl0QWxsUGFydGlhbE1vZHVsZXMyID0gZnVuY3Rpb24gKGZpbGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFVzaW5nIHJlZHVjZSBsaWtlIHRoaXMgaXMgYSBzZWxlY3QgbWFueSBwYXR0ZXJuICh3aGVyZSBtYXAgaXMgYSBzZWxlY3QgcGF0dGVybilcbiAgICAgICAgcmV0dXJuIGZpbGVzLnJlZHVjZShmdW5jdGlvbiAociwgZmlsZSkge1xuICAgICAgICAgICAgci5wdXNoLmFwcGx5KHIsIF9fc3ByZWFkKF90aGlzLl9lbWl0UGFydGlhbE1vZHVsZTIoZmlsZS5maWxlTmFtZSwgZmlsZS5pbmplY3RhYmxlcykpKTtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9LCBbXSk7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2VtaXRQYXJ0aWFsTW9kdWxlMiA9IGZ1bmN0aW9uIChmaWxlTmFtZSwgaW5qZWN0YWJsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9jcmVhdGVPdXRwdXRDb250ZXh0KGZpbGVOYW1lKTtcbiAgICAgICAgaW5qZWN0YWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5qZWN0YWJsZSkgeyByZXR1cm4gX3RoaXMuX2luamVjdGFibGVDb21waWxlci5jb21waWxlKGluamVjdGFibGUsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgaWYgKGNvbnRleHQuc3RhdGVtZW50cyAmJiBjb250ZXh0LnN0YXRlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFt7IGZpbGVOYW1lOiBmaWxlTmFtZSwgc3RhdGVtZW50czogX19zcHJlYWQoY29udGV4dC5jb25zdGFudFBvb2wuc3RhdGVtZW50cywgY29udGV4dC5zdGF0ZW1lbnRzKSB9XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuZW1pdEFsbEltcGxzID0gZnVuY3Rpb24gKGFuYWx5emVSZXN1bHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUgPSBhbmFseXplUmVzdWx0Lm5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUsIGZpbGVzID0gYW5hbHl6ZVJlc3VsdC5maWxlcztcbiAgICAgICAgdmFyIHNvdXJjZU1vZHVsZXMgPSBmaWxlcy5tYXAoZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlSW1wbEZpbGUoZmlsZS5maWxlTmFtZSwgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZSwgZmlsZS5kaXJlY3RpdmVzLCBmaWxlLnBpcGVzLCBmaWxlLm5nTW9kdWxlcywgZmlsZS5pbmplY3RhYmxlcyk7IH0pO1xuICAgICAgICByZXR1cm4gZmxhdHRlbihzb3VyY2VNb2R1bGVzKTtcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUltcGxGaWxlID0gZnVuY3Rpb24gKHNyY0ZpbGVVcmwsIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBuZ01vZHVsZXMsIGluamVjdGFibGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmaWxlU3VmZml4ID0gbm9ybWFsaXplR2VuRmlsZVN1ZmZpeChzcGxpdFR5cGVzY3JpcHRTdWZmaXgoc3JjRmlsZVVybCwgdHJ1ZSlbMV0pO1xuICAgICAgICB2YXIgZ2VuZXJhdGVkRmlsZXMgPSBbXTtcbiAgICAgICAgdmFyIG91dHB1dEN0eCA9IHRoaXMuX2NyZWF0ZU91dHB1dENvbnRleHQobmdmYWN0b3J5RmlsZVBhdGgoc3JjRmlsZVVybCwgdHJ1ZSkpO1xuICAgICAgICBnZW5lcmF0ZWRGaWxlcy5wdXNoLmFwcGx5KGdlbmVyYXRlZEZpbGVzLCBfX3NwcmVhZCh0aGlzLl9jcmVhdGVTdW1tYXJ5KHNyY0ZpbGVVcmwsIGRpcmVjdGl2ZXMsIHBpcGVzLCBuZ01vZHVsZXMsIGluamVjdGFibGVzLCBvdXRwdXRDdHgpKSk7XG4gICAgICAgIC8vIGNvbXBpbGUgYWxsIG5nIG1vZHVsZXNcbiAgICAgICAgbmdNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlTWV0YSkgeyByZXR1cm4gX3RoaXMuX2NvbXBpbGVNb2R1bGUob3V0cHV0Q3R4LCBuZ01vZHVsZU1ldGEpOyB9KTtcbiAgICAgICAgLy8gY29tcGlsZSBjb21wb25lbnRzXG4gICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICAgICAgdmFyIGNvbXBNZXRhID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoZGlyVHlwZSk7XG4gICAgICAgICAgICBpZiAoIWNvbXBNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5nTW9kdWxlID0gbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZS5nZXQoZGlyVHlwZSk7XG4gICAgICAgICAgICBpZiAoIW5nTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgRXJyb3I6IGNhbm5vdCBkZXRlcm1pbmUgdGhlIG1vZHVsZSBmb3IgY29tcG9uZW50IFwiICsgaWRlbnRpZmllck5hbWUoY29tcE1ldGEudHlwZSkgKyBcIiFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb21waWxlIHN0eWxlc1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudFN0eWxlc2hlZXQgPSBfdGhpcy5fc3R5bGVDb21waWxlci5jb21waWxlQ29tcG9uZW50KG91dHB1dEN0eCwgY29tcE1ldGEpO1xuICAgICAgICAgICAgLy8gTm90ZTogY29tcE1ldGEgaXMgYSBjb21wb25lbnQgYW5kIHRoZXJlZm9yZSB0ZW1wbGF0ZSBpcyBub24gbnVsbC5cbiAgICAgICAgICAgIGNvbXBNZXRhLnRlbXBsYXRlLmV4dGVybmFsU3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVzaGVldE1ldGEpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBmaWxsIG5vbiBzaGltIGFuZCBzaGltIHN0eWxlIGZpbGVzIGFzIHRoZXkgbWlnaHRcbiAgICAgICAgICAgICAgICAvLyBiZSBzaGFyZWQgYnkgY29tcG9uZW50IHdpdGggYW5kIHdpdGhvdXQgVmlld0VuY2Fwc3VsYXRpb24uXG4gICAgICAgICAgICAgICAgdmFyIHNoaW0gPSBfdGhpcy5fc3R5bGVDb21waWxlci5uZWVkc1N0eWxlU2hpbShjb21wTWV0YSk7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVkRmlsZXMucHVzaChfdGhpcy5fY29kZWdlblN0eWxlcyhzcmNGaWxlVXJsLCBjb21wTWV0YSwgc3R5bGVzaGVldE1ldGEsIHNoaW0sIGZpbGVTdWZmaXgpKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX29wdGlvbnMuYWxsb3dFbXB0eUNvZGVnZW5GaWxlcykge1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRGaWxlcy5wdXNoKF90aGlzLl9jb2RlZ2VuU3R5bGVzKHNyY0ZpbGVVcmwsIGNvbXBNZXRhLCBzdHlsZXNoZWV0TWV0YSwgIXNoaW0sIGZpbGVTdWZmaXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGNvbXBpbGUgY29tcG9uZW50c1xuICAgICAgICAgICAgdmFyIGNvbXBWaWV3VmFycyA9IF90aGlzLl9jb21waWxlQ29tcG9uZW50KG91dHB1dEN0eCwgY29tcE1ldGEsIG5nTW9kdWxlLCBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXMsIGNvbXBvbmVudFN0eWxlc2hlZXQsIGZpbGVTdWZmaXgpO1xuICAgICAgICAgICAgX3RoaXMuX2NvbXBpbGVDb21wb25lbnRGYWN0b3J5KG91dHB1dEN0eCwgY29tcE1ldGEsIG5nTW9kdWxlLCBmaWxlU3VmZml4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvdXRwdXRDdHguc3RhdGVtZW50cy5sZW5ndGggPiAwIHx8IHRoaXMuX29wdGlvbnMuYWxsb3dFbXB0eUNvZGVnZW5GaWxlcykge1xuICAgICAgICAgICAgdmFyIHNyY01vZHVsZSA9IHRoaXMuX2NvZGVnZW5Tb3VyY2VNb2R1bGUoc3JjRmlsZVVybCwgb3V0cHV0Q3R4KTtcbiAgICAgICAgICAgIGdlbmVyYXRlZEZpbGVzLnVuc2hpZnQoc3JjTW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVkRmlsZXM7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NyZWF0ZVN1bW1hcnkgPSBmdW5jdGlvbiAoc3JjRmlsZU5hbWUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBuZ01vZHVsZXMsIGluamVjdGFibGVzLCBuZ0ZhY3RvcnlDdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN5bWJvbFN1bW1hcmllcyA9IHRoaXMuX3N5bWJvbFJlc29sdmVyLmdldFN5bWJvbHNPZihzcmNGaWxlTmFtZSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHN5bWJvbCkgeyByZXR1cm4gX3RoaXMuX3N5bWJvbFJlc29sdmVyLnJlc29sdmVTeW1ib2woc3ltYm9sKTsgfSk7XG4gICAgICAgIHZhciB0eXBlRGF0YSA9IF9fc3ByZWFkKG5nTW9kdWxlcy5tYXAoZnVuY3Rpb24gKG1ldGEpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzdW1tYXJ5OiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZVN1bW1hcnkobWV0YS50eXBlLnJlZmVyZW5jZSksXG4gICAgICAgICAgICBtZXRhZGF0YTogX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShtZXRhLnR5cGUucmVmZXJlbmNlKVxuICAgICAgICB9KTsgfSksIGRpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzdW1tYXJ5OiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVTdW1tYXJ5KHJlZiksXG4gICAgICAgICAgICBtZXRhZGF0YTogX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEocmVmKVxuICAgICAgICB9KTsgfSksIHBpcGVzLm1hcChmdW5jdGlvbiAocmVmKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc3VtbWFyeTogX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0UGlwZVN1bW1hcnkocmVmKSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRQaXBlTWV0YWRhdGEocmVmKVxuICAgICAgICB9KTsgfSksIGluamVjdGFibGVzLm1hcChmdW5jdGlvbiAocmVmKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc3VtbWFyeTogX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0SW5qZWN0YWJsZVN1bW1hcnkocmVmLnN5bWJvbCksXG4gICAgICAgICAgICBtZXRhZGF0YTogX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0SW5qZWN0YWJsZVN1bW1hcnkocmVmLnN5bWJvbCkudHlwZVxuICAgICAgICB9KTsgfSkpO1xuICAgICAgICB2YXIgZm9ySml0T3V0cHV0Q3R4ID0gdGhpcy5fb3B0aW9ucy5lbmFibGVTdW1tYXJpZXNGb3JKaXQgP1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlT3V0cHV0Q29udGV4dChzdW1tYXJ5Rm9ySml0RmlsZU5hbWUoc3JjRmlsZU5hbWUsIHRydWUpKSA6XG4gICAgICAgICAgICBudWxsO1xuICAgICAgICB2YXIgX2EgPSBzZXJpYWxpemVTdW1tYXJpZXMoc3JjRmlsZU5hbWUsIGZvckppdE91dHB1dEN0eCwgdGhpcy5fc3VtbWFyeVJlc29sdmVyLCB0aGlzLl9zeW1ib2xSZXNvbHZlciwgc3ltYm9sU3VtbWFyaWVzLCB0eXBlRGF0YSwgdGhpcy5fb3B0aW9ucy5jcmVhdGVFeHRlcm5hbFN5bWJvbEZhY3RvcnlSZWV4cG9ydHMpLCBqc29uID0gX2EuanNvbiwgZXhwb3J0QXMgPSBfYS5leHBvcnRBcztcbiAgICAgICAgZXhwb3J0QXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIG5nRmFjdG9yeUN0eC5zdGF0ZW1lbnRzLnB1c2godmFyaWFibGUoZW50cnkuZXhwb3J0QXMpLnNldChuZ0ZhY3RvcnlDdHguaW1wb3J0RXhwcihlbnRyeS5zeW1ib2wpKS50b0RlY2xTdG10KG51bGwsIFtcbiAgICAgICAgICAgICAgICBTdG10TW9kaWZpZXIuRXhwb3J0ZWRcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzdW1tYXJ5SnNvbiA9IG5ldyBHZW5lcmF0ZWRGaWxlKHNyY0ZpbGVOYW1lLCBzdW1tYXJ5RmlsZU5hbWUoc3JjRmlsZU5hbWUpLCBqc29uKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtzdW1tYXJ5SnNvbl07XG4gICAgICAgIGlmIChmb3JKaXRPdXRwdXRDdHgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuX2NvZGVnZW5Tb3VyY2VNb2R1bGUoc3JjRmlsZU5hbWUsIGZvckppdE91dHB1dEN0eCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVNb2R1bGUgPSBmdW5jdGlvbiAob3V0cHV0Q3R4LCBuZ01vZHVsZSkge1xuICAgICAgICB2YXIgcHJvdmlkZXJzID0gW107XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmxvY2FsZSkge1xuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRMb2NhbGUgPSB0aGlzLl9vcHRpb25zLmxvY2FsZS5yZXBsYWNlKC9fL2csICctJyk7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdG9rZW46IGNyZWF0ZVRva2VuRm9yRXh0ZXJuYWxSZWZlcmVuY2UodGhpcy5yZWZsZWN0b3IsIElkZW50aWZpZXJzLkxPQ0FMRV9JRCksXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6IG5vcm1hbGl6ZWRMb2NhbGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5pMThuRm9ybWF0KSB7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdG9rZW46IGNyZWF0ZVRva2VuRm9yRXh0ZXJuYWxSZWZlcmVuY2UodGhpcy5yZWZsZWN0b3IsIElkZW50aWZpZXJzLlRSQU5TTEFUSU9OU19GT1JNQVQpLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB0aGlzLl9vcHRpb25zLmkxOG5Gb3JtYXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25nTW9kdWxlQ29tcGlsZXIuY29tcGlsZShvdXRwdXRDdHgsIG5nTW9kdWxlLCBwcm92aWRlcnMpO1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlQ29tcG9uZW50RmFjdG9yeSA9IGZ1bmN0aW9uIChvdXRwdXRDdHgsIGNvbXBNZXRhLCBuZ01vZHVsZSwgZmlsZVN1ZmZpeCkge1xuICAgICAgICB2YXIgaG9zdE1ldGEgPSB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldEhvc3RDb21wb25lbnRNZXRhZGF0YShjb21wTWV0YSk7XG4gICAgICAgIHZhciBob3N0Vmlld0ZhY3RvcnlWYXIgPSB0aGlzLl9jb21waWxlQ29tcG9uZW50KG91dHB1dEN0eCwgaG9zdE1ldGEsIG5nTW9kdWxlLCBbY29tcE1ldGEudHlwZV0sIG51bGwsIGZpbGVTdWZmaXgpXG4gICAgICAgICAgICAudmlld0NsYXNzVmFyO1xuICAgICAgICB2YXIgY29tcEZhY3RvcnlWYXIgPSBjb21wb25lbnRGYWN0b3J5TmFtZShjb21wTWV0YS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgIHZhciBpbnB1dHNFeHBycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBjb21wTWV0YS5pbnB1dHMpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZU5hbWUgPSBjb21wTWV0YS5pbnB1dHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgLy8gRG9uJ3QgcXVvdGUgc28gdGhhdCB0aGUga2V5IGdldHMgbWluaWZpZWQuLi5cbiAgICAgICAgICAgIGlucHV0c0V4cHJzLnB1c2gobmV3IExpdGVyYWxNYXBFbnRyeShwcm9wTmFtZSwgbGl0ZXJhbCh0ZW1wbGF0ZU5hbWUpLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRzRXhwcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29tcE1ldGEub3V0cHV0cykge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlTmFtZSA9IGNvbXBNZXRhLm91dHB1dHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgLy8gRG9uJ3QgcXVvdGUgc28gdGhhdCB0aGUga2V5IGdldHMgbWluaWZpZWQuLi5cbiAgICAgICAgICAgIG91dHB1dHNFeHBycy5wdXNoKG5ldyBMaXRlcmFsTWFwRW50cnkocHJvcE5hbWUsIGxpdGVyYWwodGVtcGxhdGVOYW1lKSwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRDdHguc3RhdGVtZW50cy5wdXNoKHZhcmlhYmxlKGNvbXBGYWN0b3J5VmFyKVxuICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKElkZW50aWZpZXJzLmNyZWF0ZUNvbXBvbmVudEZhY3RvcnkpLmNhbGxGbihbXG4gICAgICAgICAgICBsaXRlcmFsKGNvbXBNZXRhLnNlbGVjdG9yKSwgb3V0cHV0Q3R4LmltcG9ydEV4cHIoY29tcE1ldGEudHlwZS5yZWZlcmVuY2UpLFxuICAgICAgICAgICAgdmFyaWFibGUoaG9zdFZpZXdGYWN0b3J5VmFyKSwgbmV3IExpdGVyYWxNYXBFeHByKGlucHV0c0V4cHJzKSxcbiAgICAgICAgICAgIG5ldyBMaXRlcmFsTWFwRXhwcihvdXRwdXRzRXhwcnMpLFxuICAgICAgICAgICAgbGl0ZXJhbEFycihjb21wTWV0YS50ZW1wbGF0ZS5uZ0NvbnRlbnRTZWxlY3RvcnMubWFwKGZ1bmN0aW9uIChzZWxlY3RvcikgeyByZXR1cm4gbGl0ZXJhbChzZWxlY3Rvcik7IH0pKVxuICAgICAgICBdKSlcbiAgICAgICAgICAgIC50b0RlY2xTdG10KGltcG9ydFR5cGUoSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeSwgW2V4cHJlc3Npb25UeXBlKG91dHB1dEN0eC5pbXBvcnRFeHByKGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlKSldLCBbVHlwZU1vZGlmaWVyLkNvbnN0XSksIFtTdG10TW9kaWZpZXIuRmluYWwsIFN0bXRNb2RpZmllci5FeHBvcnRlZF0pKTtcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChvdXRwdXRDdHgsIGNvbXBNZXRhLCBuZ01vZHVsZSwgZGlyZWN0aXZlSWRlbnRpZmllcnMsIGNvbXBvbmVudFN0eWxlcywgZmlsZVN1ZmZpeCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9wYXJzZVRlbXBsYXRlKGNvbXBNZXRhLCBuZ01vZHVsZSwgZGlyZWN0aXZlSWRlbnRpZmllcnMpLCBwYXJzZWRUZW1wbGF0ZSA9IF9hLnRlbXBsYXRlLCB1c2VkUGlwZXMgPSBfYS5waXBlcztcbiAgICAgICAgdmFyIHN0eWxlc0V4cHIgPSBjb21wb25lbnRTdHlsZXMgPyB2YXJpYWJsZShjb21wb25lbnRTdHlsZXMuc3R5bGVzVmFyKSA6IGxpdGVyYWxBcnIoW10pO1xuICAgICAgICB2YXIgdmlld1Jlc3VsdCA9IHRoaXMuX3ZpZXdDb21waWxlci5jb21waWxlQ29tcG9uZW50KG91dHB1dEN0eCwgY29tcE1ldGEsIHBhcnNlZFRlbXBsYXRlLCBzdHlsZXNFeHByLCB1c2VkUGlwZXMpO1xuICAgICAgICBpZiAoY29tcG9uZW50U3R5bGVzKSB7XG4gICAgICAgICAgICBfcmVzb2x2ZVN0eWxlU3RhdGVtZW50cyh0aGlzLl9zeW1ib2xSZXNvbHZlciwgY29tcG9uZW50U3R5bGVzLCB0aGlzLl9zdHlsZUNvbXBpbGVyLm5lZWRzU3R5bGVTaGltKGNvbXBNZXRhKSwgZmlsZVN1ZmZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXdSZXN1bHQ7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX3BhcnNlVGVtcGxhdGUgPSBmdW5jdGlvbiAoY29tcE1ldGEsIG5nTW9kdWxlLCBkaXJlY3RpdmVJZGVudGlmaWVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGVBc3RDYWNoZS5oYXMoY29tcE1ldGEudHlwZS5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVBc3RDYWNoZS5nZXQoY29tcE1ldGEudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2VzID0gY29tcE1ldGEudGVtcGxhdGUucHJlc2VydmVXaGl0ZXNwYWNlcztcbiAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVJZGVudGlmaWVycy5tYXAoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlU3VtbWFyeShkaXIucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgIHZhciBwaXBlcyA9IG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUucGlwZXMubWFwKGZ1bmN0aW9uIChwaXBlKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRQaXBlU3VtbWFyeShwaXBlLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fdGVtcGxhdGVQYXJzZXIucGFyc2UoY29tcE1ldGEsIGNvbXBNZXRhLnRlbXBsYXRlLmh0bWxBc3QsIGRpcmVjdGl2ZXMsIHBpcGVzLCBuZ01vZHVsZS5zY2hlbWFzLCB0ZW1wbGF0ZVNvdXJjZVVybChuZ01vZHVsZS50eXBlLCBjb21wTWV0YSwgY29tcE1ldGEudGVtcGxhdGUpLCBwcmVzZXJ2ZVdoaXRlc3BhY2VzKTtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVBc3RDYWNoZS5zZXQoY29tcE1ldGEudHlwZS5yZWZlcmVuY2UsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NyZWF0ZU91dHB1dENvbnRleHQgPSBmdW5jdGlvbiAoZ2VuRmlsZVBhdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGltcG9ydEV4cHIkMSA9IGZ1bmN0aW9uIChzeW1ib2wsIHR5cGVQYXJhbXMsIHVzZVN1bW1hcmllcykge1xuICAgICAgICAgICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKHVzZVN1bW1hcmllcyA9PT0gdm9pZCAwKSB7IHVzZVN1bW1hcmllcyA9IHRydWU7IH1cbiAgICAgICAgICAgIGlmICghKHN5bWJvbCBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogdW5rbm93biBpZGVudGlmaWVyIFwiICsgSlNPTi5zdHJpbmdpZnkoc3ltYm9sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJpdHkgPSBfdGhpcy5fc3ltYm9sUmVzb2x2ZXIuZ2V0VHlwZUFyaXR5KHN5bWJvbCkgfHwgMDtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLl9zeW1ib2xSZXNvbHZlci5nZXRJbXBvcnRBcyhzeW1ib2wsIHVzZVN1bW1hcmllcykgfHwgc3ltYm9sLCBmaWxlUGF0aCA9IF9hLmZpbGVQYXRoLCBuYW1lID0gX2EubmFtZSwgbWVtYmVycyA9IF9hLm1lbWJlcnM7XG4gICAgICAgICAgICB2YXIgaW1wb3J0TW9kdWxlID0gX3RoaXMuX2ZpbGVOYW1lVG9Nb2R1bGVOYW1lKGZpbGVQYXRoLCBnZW5GaWxlUGF0aCk7XG4gICAgICAgICAgICAvLyBJdCBzaG91bGQgYmUgZ29vZCBlbm91Z2ggdG8gY29tcGFyZSBmaWxlUGF0aCB0byBnZW5GaWxlUGF0aCBhbmQgaWYgdGhleSBhcmUgZXF1YWxcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgc2VsZiByZWZlcmVuY2UuIEhvd2V2ZXIsIG5nZmFjdG9yeSBmaWxlcyBnZW5lcmF0ZSB0byAudHMgYnV0IHRoZWlyXG4gICAgICAgICAgICAvLyBzeW1ib2xzIGhhdmUgLmQudHMgc28gYSBzaW1wbGUgY29tcGFyZSBpcyBpbnN1ZmZpY2llbnQuIFRoZXkgc2hvdWxkIGJlIGNhbm9uaWNhbFxuICAgICAgICAgICAgLy8gYW5kIGlzIHRyYWNrZWQgYnkgIzE3NzA1LlxuICAgICAgICAgICAgdmFyIHNlbGZSZWZlcmVuY2UgPSBfdGhpcy5fZmlsZU5hbWVUb01vZHVsZU5hbWUoZ2VuRmlsZVBhdGgsIGdlbkZpbGVQYXRoKTtcbiAgICAgICAgICAgIHZhciBtb2R1bGVOYW1lID0gaW1wb3J0TW9kdWxlID09PSBzZWxmUmVmZXJlbmNlID8gbnVsbCA6IGltcG9ydE1vZHVsZTtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBpbiBhIHR5cGUgZXhwcmVzc2lvbiB0aGF0IHJlZmVycyB0byBhIGdlbmVyaWMgdHlwZSB0aGVuIHN1cHBseVxuICAgICAgICAgICAgLy8gdGhlIHJlcXVpcmVkIHR5cGUgcGFyYW1ldGVycy4gSWYgdGhlcmUgd2VyZSBub3QgZW5vdWdoIHR5cGUgcGFyYW1ldGVyc1xuICAgICAgICAgICAgLy8gc3VwcGxpZWQsIHN1cHBseSBhbnkgYXMgdGhlIHR5cGUuIE91dHNpZGUgYSB0eXBlIGV4cHJlc3Npb24gdGhlIHJlZmVyZW5jZVxuICAgICAgICAgICAgLy8gc2hvdWxkIG5vdCBzdXBwbHkgdHlwZSBwYXJhbWV0ZXJzIGFuZCBiZSB0cmVhdGVkIGFzIGEgc2ltcGxlIHZhbHVlIHJlZmVyZW5jZVxuICAgICAgICAgICAgLy8gdG8gdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGl0c2VsZi5cbiAgICAgICAgICAgIHZhciBzdXBwbGllZFR5cGVQYXJhbXMgPSB0eXBlUGFyYW1zIHx8IFtdO1xuICAgICAgICAgICAgdmFyIG1pc3NpbmdUeXBlUGFyYW1zQ291bnQgPSBhcml0eSAtIHN1cHBsaWVkVHlwZVBhcmFtcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYWxsVHlwZVBhcmFtcyA9IHN1cHBsaWVkVHlwZVBhcmFtcy5jb25jYXQobmV3IEFycmF5KG1pc3NpbmdUeXBlUGFyYW1zQ291bnQpLmZpbGwoRFlOQU1JQ19UWVBFKSk7XG4gICAgICAgICAgICByZXR1cm4gbWVtYmVycy5yZWR1Y2UoZnVuY3Rpb24gKGV4cHIsIG1lbWJlck5hbWUpIHsgcmV0dXJuIGV4cHIucHJvcChtZW1iZXJOYW1lKTsgfSwgaW1wb3J0RXhwcihuZXcgRXh0ZXJuYWxSZWZlcmVuY2UobW9kdWxlTmFtZSwgbmFtZSwgbnVsbCksIGFsbFR5cGVQYXJhbXMpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdGVtZW50czogW10sIGdlbkZpbGVQYXRoOiBnZW5GaWxlUGF0aCwgaW1wb3J0RXhwcjogaW1wb3J0RXhwciQxLCBjb25zdGFudFBvb2w6IG5ldyBDb25zdGFudFBvb2woKSB9O1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9maWxlTmFtZVRvTW9kdWxlTmFtZSA9IGZ1bmN0aW9uIChpbXBvcnRlZEZpbGVQYXRoLCBjb250YWluaW5nRmlsZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1bW1hcnlSZXNvbHZlci5nZXRLbm93bk1vZHVsZU5hbWUoaW1wb3J0ZWRGaWxlUGF0aCkgfHxcbiAgICAgICAgICAgIHRoaXMuX3N5bWJvbFJlc29sdmVyLmdldEtub3duTW9kdWxlTmFtZShpbXBvcnRlZEZpbGVQYXRoKSB8fFxuICAgICAgICAgICAgdGhpcy5faG9zdC5maWxlTmFtZVRvTW9kdWxlTmFtZShpbXBvcnRlZEZpbGVQYXRoLCBjb250YWluaW5nRmlsZVBhdGgpO1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jb2RlZ2VuU3R5bGVzID0gZnVuY3Rpb24gKHNyY0ZpbGVVcmwsIGNvbXBNZXRhLCBzdHlsZXNoZWV0TWV0YWRhdGEsIGlzU2hpbW1lZCwgZmlsZVN1ZmZpeCkge1xuICAgICAgICB2YXIgb3V0cHV0Q3R4ID0gdGhpcy5fY3JlYXRlT3V0cHV0Q29udGV4dChfc3R5bGVzTW9kdWxlVXJsKHN0eWxlc2hlZXRNZXRhZGF0YS5tb2R1bGVVcmwsIGlzU2hpbW1lZCwgZmlsZVN1ZmZpeCkpO1xuICAgICAgICB2YXIgY29tcGlsZWRTdHlsZXNoZWV0ID0gdGhpcy5fc3R5bGVDb21waWxlci5jb21waWxlU3R5bGVzKG91dHB1dEN0eCwgY29tcE1ldGEsIHN0eWxlc2hlZXRNZXRhZGF0YSwgaXNTaGltbWVkKTtcbiAgICAgICAgX3Jlc29sdmVTdHlsZVN0YXRlbWVudHModGhpcy5fc3ltYm9sUmVzb2x2ZXIsIGNvbXBpbGVkU3R5bGVzaGVldCwgaXNTaGltbWVkLCBmaWxlU3VmZml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvZGVnZW5Tb3VyY2VNb2R1bGUoc3JjRmlsZVVybCwgb3V0cHV0Q3R4KTtcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY29kZWdlblNvdXJjZU1vZHVsZSA9IGZ1bmN0aW9uIChzcmNGaWxlVXJsLCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0ZWRGaWxlKHNyY0ZpbGVVcmwsIGN0eC5nZW5GaWxlUGF0aCwgY3R4LnN0YXRlbWVudHMpO1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLmxpc3RMYXp5Um91dGVzID0gZnVuY3Rpb24gKGVudHJ5Um91dGUsIGFuYWx5emVkTW9kdWxlcykge1xuICAgICAgICB2YXIgZV8yLCBfYSwgZV8zLCBfYjtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoZW50cnlSb3V0ZSkge1xuICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHBhcnNlTGF6eVJvdXRlKGVudHJ5Um91dGUsIHRoaXMucmVmbGVjdG9yKS5yZWZlcmVuY2VkTW9kdWxlO1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0TGF6eVJvdXRlKHN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYW5hbHl6ZWRNb2R1bGVzKSB7XG4gICAgICAgICAgICB2YXIgYWxsTGF6eVJvdXRlcyA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKGFuYWx5emVkTW9kdWxlcy5uZ01vZHVsZXMpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZ01vZHVsZSA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF6eVJvdXRlcyA9IGxpc3RMYXp5Um91dGVzKG5nTW9kdWxlLCB0aGlzLnJlZmxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsYXp5Um91dGVzXzEgPSAoZV8zID0gdm9pZCAwLCBfX3ZhbHVlcyhsYXp5Um91dGVzKSksIGxhenlSb3V0ZXNfMV8xID0gbGF6eVJvdXRlc18xLm5leHQoKTsgIWxhenlSb3V0ZXNfMV8xLmRvbmU7IGxhenlSb3V0ZXNfMV8xID0gbGF6eVJvdXRlc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXp5Um91dGUgPSBsYXp5Um91dGVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxMYXp5Um91dGVzLnB1c2gobGF6eVJvdXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhenlSb3V0ZXNfMV8xICYmICFsYXp5Um91dGVzXzFfMS5kb25lICYmIChfYiA9IGxhenlSb3V0ZXNfMS5yZXR1cm4pKSBfYi5jYWxsKGxhenlSb3V0ZXNfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWxsTGF6eVJvdXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVpdGhlciByb3V0ZSBvciBhbmFseXplZE1vZHVsZXMgaGFzIHRvIGJlIHNwZWNpZmllZCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmlzaXRMYXp5Um91dGUoc3ltYm9sLCBzZWVuUm91dGVzLCBhbGxMYXp5Um91dGVzKSB7XG4gICAgICAgICAgICB2YXIgZV80LCBfYTtcbiAgICAgICAgICAgIGlmIChzZWVuUm91dGVzID09PSB2b2lkIDApIHsgc2VlblJvdXRlcyA9IG5ldyBTZXQoKTsgfVxuICAgICAgICAgICAgaWYgKGFsbExhenlSb3V0ZXMgPT09IHZvaWQgMCkgeyBhbGxMYXp5Um91dGVzID0gW107IH1cbiAgICAgICAgICAgIC8vIFN1cHBvcnQgcG9pbnRpbmcgdG8gZGVmYXVsdCBleHBvcnRzLCBidXQgc3RvcCByZWN1cnNpbmcgdGhlcmUsXG4gICAgICAgICAgICAvLyBhcyB0aGUgU3RhdGljUmVmbGVjdG9yIGRvZXMgbm90IHlldCBzdXBwb3J0IGRlZmF1bHQgZXhwb3J0cy5cbiAgICAgICAgICAgIGlmIChzZWVuUm91dGVzLmhhcyhzeW1ib2wpIHx8ICFzeW1ib2wubmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbGxMYXp5Um91dGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VlblJvdXRlcy5hZGQoc3ltYm9sKTtcbiAgICAgICAgICAgIHZhciBsYXp5Um91dGVzID0gbGlzdExhenlSb3V0ZXMoc2VsZi5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKHN5bWJvbCwgdHJ1ZSksIHNlbGYucmVmbGVjdG9yKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbGF6eVJvdXRlc18yID0gX192YWx1ZXMobGF6eVJvdXRlcyksIGxhenlSb3V0ZXNfMl8xID0gbGF6eVJvdXRlc18yLm5leHQoKTsgIWxhenlSb3V0ZXNfMl8xLmRvbmU7IGxhenlSb3V0ZXNfMl8xID0gbGF6eVJvdXRlc18yLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF6eVJvdXRlID0gbGF6eVJvdXRlc18yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGFsbExhenlSb3V0ZXMucHVzaChsYXp5Um91dGUpO1xuICAgICAgICAgICAgICAgICAgICB2aXNpdExhenlSb3V0ZShsYXp5Um91dGUucmVmZXJlbmNlZE1vZHVsZSwgc2VlblJvdXRlcywgYWxsTGF6eVJvdXRlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXp5Um91dGVzXzJfMSAmJiAhbGF6eVJvdXRlc18yXzEuZG9uZSAmJiAoX2EgPSBsYXp5Um91dGVzXzIucmV0dXJuKSkgX2EuY2FsbChsYXp5Um91dGVzXzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWxsTGF6eVJvdXRlcztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFvdENvbXBpbGVyO1xufSgpKTtcbmZ1bmN0aW9uIF9jcmVhdGVFbXB0eVN0dWIob3V0cHV0Q3R4KSB7XG4gICAgLy8gTm90ZTogV2UgbmVlZCB0byBwcm9kdWNlIGF0IGxlYXN0IG9uZSBpbXBvcnQgc3RhdGVtZW50IHNvIHRoYXRcbiAgICAvLyBUeXBlU2NyaXB0IGtub3dzIHRoYXQgdGhlIGZpbGUgaXMgYW4gZXM2IG1vZHVsZS4gT3RoZXJ3aXNlIG91ciBnZW5lcmF0ZWRcbiAgICAvLyBleHBvcnRzIC8gaW1wb3J0cyB3b24ndCBiZSBlbWl0dGVkIHByb3Blcmx5IGJ5IFR5cGVTY3JpcHQuXG4gICAgb3V0cHV0Q3R4LnN0YXRlbWVudHMucHVzaChpbXBvcnRFeHByKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnkpLnRvU3RtdCgpKTtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlU3R5bGVTdGF0ZW1lbnRzKHN5bWJvbFJlc29sdmVyLCBjb21waWxlUmVzdWx0LCBuZWVkc1NoaW0sIGZpbGVTdWZmaXgpIHtcbiAgICBjb21waWxlUmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgZGVwLnNldFZhbHVlKHN5bWJvbFJlc29sdmVyLmdldFN0YXRpY1N5bWJvbChfc3R5bGVzTW9kdWxlVXJsKGRlcC5tb2R1bGVVcmwsIG5lZWRzU2hpbSwgZmlsZVN1ZmZpeCksIGRlcC5uYW1lKSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBfc3R5bGVzTW9kdWxlVXJsKHN0eWxlc2hlZXRVcmwsIHNoaW0sIHN1ZmZpeCkge1xuICAgIHJldHVybiBcIlwiICsgc3R5bGVzaGVldFVybCArIChzaGltID8gJy5zaGltJyA6ICcnKSArIFwiLm5nc3R5bGVcIiArIHN1ZmZpeDtcbn1cbmZ1bmN0aW9uIGFuYWx5emVOZ01vZHVsZXMoZmlsZU5hbWVzLCBob3N0LCBzdGF0aWNTeW1ib2xSZXNvbHZlciwgbWV0YWRhdGFSZXNvbHZlcikge1xuICAgIHZhciBmaWxlcyA9IF9hbmFseXplRmlsZXNJbmNsdWRpbmdOb25Qcm9ncmFtRmlsZXMoZmlsZU5hbWVzLCBob3N0LCBzdGF0aWNTeW1ib2xSZXNvbHZlciwgbWV0YWRhdGFSZXNvbHZlcik7XG4gICAgcmV0dXJuIG1lcmdlQW5hbHl6ZWRGaWxlcyhmaWxlcyk7XG59XG5mdW5jdGlvbiBhbmFseXplQW5kVmFsaWRhdGVOZ01vZHVsZXMoZmlsZU5hbWVzLCBob3N0LCBzdGF0aWNTeW1ib2xSZXNvbHZlciwgbWV0YWRhdGFSZXNvbHZlcikge1xuICAgIHJldHVybiB2YWxpZGF0ZUFuYWx5emVkTW9kdWxlcyhhbmFseXplTmdNb2R1bGVzKGZpbGVOYW1lcywgaG9zdCwgc3RhdGljU3ltYm9sUmVzb2x2ZXIsIG1ldGFkYXRhUmVzb2x2ZXIpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQW5hbHl6ZWRNb2R1bGVzKGFuYWx5emVkTW9kdWxlcykge1xuICAgIGlmIChhbmFseXplZE1vZHVsZXMuc3ltYm9sc01pc3NpbmdNb2R1bGUgJiYgYW5hbHl6ZWRNb2R1bGVzLnN5bWJvbHNNaXNzaW5nTW9kdWxlLmxlbmd0aCkge1xuICAgICAgICB2YXIgbWVzc2FnZXMgPSBhbmFseXplZE1vZHVsZXMuc3ltYm9sc01pc3NpbmdNb2R1bGUubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJDYW5ub3QgZGV0ZXJtaW5lIHRoZSBtb2R1bGUgZm9yIGNsYXNzIFwiICsgcy5uYW1lICsgXCIgaW4gXCIgKyBzLmZpbGVQYXRoICsgXCIhIEFkZCBcIiArIHMubmFtZSArIFwiIHRvIHRoZSBOZ01vZHVsZSB0byBmaXggaXQuXCI7XG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihtZXNzYWdlcy5qb2luKCdcXG4nKSk7XG4gICAgfVxuICAgIHJldHVybiBhbmFseXplZE1vZHVsZXM7XG59XG4vLyBBbmFseXplcyBhbGwgb2YgdGhlIHByb2dyYW0gZmlsZXMsXG4vLyBpbmNsdWRpbmcgZmlsZXMgdGhhdCBhcmUgbm90IHBhcnQgb2YgdGhlIHByb2dyYW1cbi8vIGJ1dCBhcmUgcmVmZXJlbmNlZCBieSBhbiBOZ01vZHVsZS5cbmZ1bmN0aW9uIF9hbmFseXplRmlsZXNJbmNsdWRpbmdOb25Qcm9ncmFtRmlsZXMoZmlsZU5hbWVzLCBob3N0LCBzdGF0aWNTeW1ib2xSZXNvbHZlciwgbWV0YWRhdGFSZXNvbHZlcikge1xuICAgIHZhciBzZWVuRmlsZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGZpbGVzID0gW107XG4gICAgdmFyIHZpc2l0RmlsZSA9IGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgICAgICBpZiAoc2VlbkZpbGVzLmhhcyhmaWxlTmFtZSkgfHwgIWhvc3QuaXNTb3VyY2VGaWxlKGZpbGVOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNlZW5GaWxlcy5hZGQoZmlsZU5hbWUpO1xuICAgICAgICB2YXIgYW5hbHl6ZWRGaWxlID0gYW5hbHl6ZUZpbGUoaG9zdCwgc3RhdGljU3ltYm9sUmVzb2x2ZXIsIG1ldGFkYXRhUmVzb2x2ZXIsIGZpbGVOYW1lKTtcbiAgICAgICAgZmlsZXMucHVzaChhbmFseXplZEZpbGUpO1xuICAgICAgICBhbmFseXplZEZpbGUubmdNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlKSB7XG4gICAgICAgICAgICBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kTWV0YSkgeyByZXR1cm4gdmlzaXRGaWxlKG1vZE1ldGEucmVmZXJlbmNlLmZpbGVQYXRoKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZmlsZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGVOYW1lKSB7IHJldHVybiB2aXNpdEZpbGUoZmlsZU5hbWUpOyB9KTtcbiAgICByZXR1cm4gZmlsZXM7XG59XG5mdW5jdGlvbiBhbmFseXplRmlsZShob3N0LCBzdGF0aWNTeW1ib2xSZXNvbHZlciwgbWV0YWRhdGFSZXNvbHZlciwgZmlsZU5hbWUpIHtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IFtdO1xuICAgIHZhciBwaXBlcyA9IFtdO1xuICAgIHZhciBpbmplY3RhYmxlcyA9IFtdO1xuICAgIHZhciBuZ01vZHVsZXMgPSBbXTtcbiAgICB2YXIgaGFzRGVjb3JhdG9ycyA9IHN0YXRpY1N5bWJvbFJlc29sdmVyLmhhc0RlY29yYXRvcnMoZmlsZU5hbWUpO1xuICAgIHZhciBleHBvcnRzTm9uU291cmNlRmlsZXMgPSBmYWxzZTtcbiAgICAvLyBEb24ndCBhbmFseXplIC5kLnRzIGZpbGVzIHRoYXQgaGF2ZSBubyBkZWNvcmF0b3JzIGFzIGEgc2hvcnRjdXRcbiAgICAvLyB0byBzcGVlZCB1cCB0aGUgYW5hbHlzaXMuIFRoaXMgcHJldmVudHMgdXMgZnJvbVxuICAgIC8vIHJlc29sdmluZyB0aGUgcmVmZXJlbmNlcyBpbiB0aGVzZSBmaWxlcy5cbiAgICAvLyBOb3RlOiBleHBvcnRzTm9uU291cmNlRmlsZXMgaXMgb25seSBuZWVkZWQgd2hlbiBjb21waWxpbmcgd2l0aCBzdW1tYXJpZXMsXG4gICAgLy8gd2hpY2ggaXMgbm90IHRoZSBjYXNlIHdoZW4gLmQudHMgZmlsZXMgYXJlIHRyZWF0ZWQgYXMgaW5wdXQgZmlsZXMuXG4gICAgaWYgKCFmaWxlTmFtZS5lbmRzV2l0aCgnLmQudHMnKSB8fCBoYXNEZWNvcmF0b3JzKSB7XG4gICAgICAgIHN0YXRpY1N5bWJvbFJlc29sdmVyLmdldFN5bWJvbHNPZihmaWxlTmFtZSkuZm9yRWFjaChmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZWRTeW1ib2wgPSBzdGF0aWNTeW1ib2xSZXNvbHZlci5yZXNvbHZlU3ltYm9sKHN5bWJvbCk7XG4gICAgICAgICAgICB2YXIgc3ltYm9sTWV0YSA9IHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhO1xuICAgICAgICAgICAgaWYgKCFzeW1ib2xNZXRhIHx8IHN5bWJvbE1ldGEuX19zeW1ib2xpYyA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpc05nU3ltYm9sID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3ltYm9sTWV0YS5fX3N5bWJvbGljID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhUmVzb2x2ZXIuaXNEaXJlY3RpdmUoc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgICAgICBpc05nU3ltYm9sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlcy5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGFkYXRhUmVzb2x2ZXIuaXNQaXBlKHN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNOZ1N5bWJvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBpcGVzLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0YWRhdGFSZXNvbHZlci5pc05nTW9kdWxlKHN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5nTW9kdWxlID0gbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKHN5bWJvbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmdNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTmdTeW1ib2wgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmdNb2R1bGVzLnB1c2gobmdNb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGFkYXRhUmVzb2x2ZXIuaXNJbmplY3RhYmxlKHN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNOZ1N5bWJvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmplY3RhYmxlID0gbWV0YWRhdGFSZXNvbHZlci5nZXRJbmplY3RhYmxlTWV0YWRhdGEoc3ltYm9sLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmplY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmplY3RhYmxlcy5wdXNoKGluamVjdGFibGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc05nU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0c05vblNvdXJjZUZpbGVzID1cbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0c05vblNvdXJjZUZpbGVzIHx8IGlzVmFsdWVFeHBvcnRpbmdOb25Tb3VyY2VGaWxlKGhvc3QsIHN5bWJvbE1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZU5hbWU6IGZpbGVOYW1lLCBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLCBwaXBlczogcGlwZXMsIG5nTW9kdWxlczogbmdNb2R1bGVzLCBpbmplY3RhYmxlczogaW5qZWN0YWJsZXMsIGV4cG9ydHNOb25Tb3VyY2VGaWxlczogZXhwb3J0c05vblNvdXJjZUZpbGVzLFxuICAgIH07XG59XG5mdW5jdGlvbiBhbmFseXplRmlsZUZvckluamVjdGFibGVzKGhvc3QsIHN0YXRpY1N5bWJvbFJlc29sdmVyLCBtZXRhZGF0YVJlc29sdmVyLCBmaWxlTmFtZSkge1xuICAgIHZhciBpbmplY3RhYmxlcyA9IFtdO1xuICAgIHZhciBzaGFsbG93TW9kdWxlcyA9IFtdO1xuICAgIGlmIChzdGF0aWNTeW1ib2xSZXNvbHZlci5oYXNEZWNvcmF0b3JzKGZpbGVOYW1lKSkge1xuICAgICAgICBzdGF0aWNTeW1ib2xSZXNvbHZlci5nZXRTeW1ib2xzT2YoZmlsZU5hbWUpLmZvckVhY2goZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVkU3ltYm9sID0gc3RhdGljU3ltYm9sUmVzb2x2ZXIucmVzb2x2ZVN5bWJvbChzeW1ib2wpO1xuICAgICAgICAgICAgdmFyIHN5bWJvbE1ldGEgPSByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YTtcbiAgICAgICAgICAgIGlmICghc3ltYm9sTWV0YSB8fCBzeW1ib2xNZXRhLl9fc3ltYm9saWMgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3ltYm9sTWV0YS5fX3N5bWJvbGljID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhUmVzb2x2ZXIuaXNJbmplY3RhYmxlKHN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluamVjdGFibGUgPSBtZXRhZGF0YVJlc29sdmVyLmdldEluamVjdGFibGVNZXRhZGF0YShzeW1ib2wsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluamVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluamVjdGFibGVzLnB1c2goaW5qZWN0YWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0YWRhdGFSZXNvbHZlci5pc05nTW9kdWxlKHN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZHVsZSA9IG1ldGFkYXRhUmVzb2x2ZXIuZ2V0U2hhbGxvd01vZHVsZU1ldGFkYXRhKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWxsb3dNb2R1bGVzLnB1c2gobW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IGZpbGVOYW1lOiBmaWxlTmFtZSwgaW5qZWN0YWJsZXM6IGluamVjdGFibGVzLCBzaGFsbG93TW9kdWxlczogc2hhbGxvd01vZHVsZXMgfTtcbn1cbmZ1bmN0aW9uIGlzVmFsdWVFeHBvcnRpbmdOb25Tb3VyY2VGaWxlKGhvc3QsIG1ldGFkYXRhKSB7XG4gICAgdmFyIGV4cG9ydHNOb25Tb3VyY2VGaWxlcyA9IGZhbHNlO1xuICAgIHZhciBWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBWaXNpdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIFZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbiAoYXJyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHZpc2l0VmFsdWUodiwgX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAgPSBmdW5jdGlvbiAobWFwLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHZpc2l0VmFsdWUobWFwW2tleV0sIF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJpbWl0aXZlID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7IH07XG4gICAgICAgIFZpc2l0b3IucHJvdG90eXBlLnZpc2l0T3RoZXIgPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCAmJiAhaG9zdC5pc1NvdXJjZUZpbGUodmFsdWUuZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0c05vblNvdXJjZUZpbGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZpc2l0b3I7XG4gICAgfSgpKTtcbiAgICB2aXNpdFZhbHVlKG1ldGFkYXRhLCBuZXcgVmlzaXRvcigpLCBudWxsKTtcbiAgICByZXR1cm4gZXhwb3J0c05vblNvdXJjZUZpbGVzO1xufVxuZnVuY3Rpb24gbWVyZ2VBbmFseXplZEZpbGVzKGFuYWx5emVkRmlsZXMpIHtcbiAgICB2YXIgYWxsTmdNb2R1bGVzID0gW107XG4gICAgdmFyIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUgPSBuZXcgTWFwKCk7XG4gICAgdmFyIGFsbFBpcGVzQW5kRGlyZWN0aXZlcyA9IG5ldyBTZXQoKTtcbiAgICBhbmFseXplZEZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGFmKSB7XG4gICAgICAgIGFmLm5nTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZSkge1xuICAgICAgICAgICAgYWxsTmdNb2R1bGVzLnB1c2gobmdNb2R1bGUpO1xuICAgICAgICAgICAgbmdNb2R1bGUuZGVjbGFyZWREaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGQpIHsgcmV0dXJuIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUuc2V0KGQucmVmZXJlbmNlLCBuZ01vZHVsZSk7IH0pO1xuICAgICAgICAgICAgbmdNb2R1bGUuZGVjbGFyZWRQaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7IHJldHVybiBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLnNldChwLnJlZmVyZW5jZSwgbmdNb2R1bGUpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFmLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gYWxsUGlwZXNBbmREaXJlY3RpdmVzLmFkZChkKTsgfSk7XG4gICAgICAgIGFmLnBpcGVzLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIGFsbFBpcGVzQW5kRGlyZWN0aXZlcy5hZGQocCk7IH0pO1xuICAgIH0pO1xuICAgIHZhciBzeW1ib2xzTWlzc2luZ01vZHVsZSA9IFtdO1xuICAgIGFsbFBpcGVzQW5kRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgaWYgKCFuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLmhhcyhyZWYpKSB7XG4gICAgICAgICAgICBzeW1ib2xzTWlzc2luZ01vZHVsZS5wdXNoKHJlZik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZ01vZHVsZXM6IGFsbE5nTW9kdWxlcyxcbiAgICAgICAgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZTogbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZSxcbiAgICAgICAgc3ltYm9sc01pc3NpbmdNb2R1bGU6IHN5bWJvbHNNaXNzaW5nTW9kdWxlLFxuICAgICAgICBmaWxlczogYW5hbHl6ZWRGaWxlc1xuICAgIH07XG59XG5mdW5jdGlvbiBtZXJnZUFuZFZhbGlkYXRlTmdGaWxlcyhmaWxlcykge1xuICAgIHJldHVybiB2YWxpZGF0ZUFuYWx5emVkTW9kdWxlcyhtZXJnZUFuYWx5emVkRmlsZXMoZmlsZXMpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEZPUk1BVFRFRF9NRVNTQUdFID0gJ25nRm9ybWF0dGVkTWVzc2FnZSc7XG5mdW5jdGlvbiBpbmRlbnRTdHIobGV2ZWwpIHtcbiAgICBpZiAobGV2ZWwgPD0gMClcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGlmIChsZXZlbCA8IDYpXG4gICAgICAgIHJldHVybiBbJycsICcgJywgJyAgJywgJyAgICcsICcgICAgJywgJyAgICAgJ11bbGV2ZWxdO1xuICAgIHZhciBoYWxmID0gaW5kZW50U3RyKE1hdGguZmxvb3IobGV2ZWwgLyAyKSk7XG4gICAgcmV0dXJuIGhhbGYgKyBoYWxmICsgKGxldmVsICUgMiA9PT0gMSA/ICcgJyA6ICcnKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdENoYWluKGNoYWluLCBpbmRlbnQpIHtcbiAgICBpZiAoaW5kZW50ID09PSB2b2lkIDApIHsgaW5kZW50ID0gMDsgfVxuICAgIGlmICghY2hhaW4pXG4gICAgICAgIHJldHVybiAnJztcbiAgICB2YXIgcG9zaXRpb24gPSBjaGFpbi5wb3NpdGlvbiA/XG4gICAgICAgIGNoYWluLnBvc2l0aW9uLmZpbGVOYW1lICsgXCIoXCIgKyAoY2hhaW4ucG9zaXRpb24ubGluZSArIDEpICsgXCIsXCIgKyAoY2hhaW4ucG9zaXRpb24uY29sdW1uICsgMSkgKyBcIilcIiA6XG4gICAgICAgICcnO1xuICAgIHZhciBwcmVmaXggPSBwb3NpdGlvbiAmJiBpbmRlbnQgPT09IDAgPyBwb3NpdGlvbiArIFwiOiBcIiA6ICcnO1xuICAgIHZhciBwb3N0Zml4ID0gcG9zaXRpb24gJiYgaW5kZW50ICE9PSAwID8gXCIgYXQgXCIgKyBwb3NpdGlvbiA6ICcnO1xuICAgIHZhciBtZXNzYWdlID0gXCJcIiArIHByZWZpeCArIGNoYWluLm1lc3NhZ2UgKyBwb3N0Zml4O1xuICAgIHJldHVybiBcIlwiICsgaW5kZW50U3RyKGluZGVudCkgKyBtZXNzYWdlICsgKChjaGFpbi5uZXh0ICYmICgnXFxuJyArIGZvcm1hdENoYWluKGNoYWluLm5leHQsIGluZGVudCArIDIpKSkgfHwgJycpO1xufVxuZnVuY3Rpb24gZm9ybWF0dGVkRXJyb3IoY2hhaW4pIHtcbiAgICB2YXIgbWVzc2FnZSA9IGZvcm1hdENoYWluKGNoYWluKSArICcuJztcbiAgICB2YXIgZXJyb3IgPSBzeW50YXhFcnJvcihtZXNzYWdlKTtcbiAgICBlcnJvcltGT1JNQVRURURfTUVTU0FHRV0gPSB0cnVlO1xuICAgIGVycm9yLmNoYWluID0gY2hhaW47XG4gICAgZXJyb3IucG9zaXRpb24gPSBjaGFpbi5wb3NpdGlvbjtcbiAgICByZXR1cm4gZXJyb3I7XG59XG5mdW5jdGlvbiBpc0Zvcm1hdHRlZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuICEhZXJyb3JbRk9STUFUVEVEX01FU1NBR0VdO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQU5HVUxBUl9DT1JFID0gJ0Bhbmd1bGFyL2NvcmUnO1xudmFyIEFOR1VMQVJfUk9VVEVSID0gJ0Bhbmd1bGFyL3JvdXRlcic7XG52YXIgSElEREVOX0tFWSA9IC9eXFwkLipcXCQkLztcbnZhciBJR05PUkUgPSB7XG4gICAgX19zeW1ib2xpYzogJ2lnbm9yZSdcbn07XG52YXIgVVNFX1ZBTFVFJDEgPSAndXNlVmFsdWUnO1xudmFyIFBST1ZJREUgPSAncHJvdmlkZSc7XG52YXIgUkVGRVJFTkNFX1NFVCA9IG5ldyBTZXQoW1VTRV9WQUxVRSQxLCAndXNlRmFjdG9yeScsICdkYXRhJywgJ2lkJywgJ2xvYWRDaGlsZHJlbiddKTtcbnZhciBUWVBFR1VBUkRfUE9TVEZJWCA9ICdUeXBlR3VhcmQnO1xudmFyIFVTRV9JRiA9ICdVc2VJZic7XG5mdW5jdGlvbiBzaG91bGRJZ25vcmUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuX19zeW1ib2xpYyA9PSAnaWdub3JlJztcbn1cbi8qKlxuICogQSBzdGF0aWMgcmVmbGVjdG9yIGltcGxlbWVudHMgZW5vdWdoIG9mIHRoZSBSZWZsZWN0b3IgQVBJIHRoYXQgaXMgbmVjZXNzYXJ5IHRvIGNvbXBpbGVcbiAqIHRlbXBsYXRlcyBzdGF0aWNhbGx5LlxuICovXG52YXIgU3RhdGljUmVmbGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRpY1JlZmxlY3RvcihzdW1tYXJ5UmVzb2x2ZXIsIHN5bWJvbFJlc29sdmVyLCBrbm93bk1ldGFkYXRhQ2xhc3Nlcywga25vd25NZXRhZGF0YUZ1bmN0aW9ucywgZXJyb3JSZWNvcmRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoa25vd25NZXRhZGF0YUNsYXNzZXMgPT09IHZvaWQgMCkgeyBrbm93bk1ldGFkYXRhQ2xhc3NlcyA9IFtdOyB9XG4gICAgICAgIGlmIChrbm93bk1ldGFkYXRhRnVuY3Rpb25zID09PSB2b2lkIDApIHsga25vd25NZXRhZGF0YUZ1bmN0aW9ucyA9IFtdOyB9XG4gICAgICAgIHRoaXMuc3VtbWFyeVJlc29sdmVyID0gc3VtbWFyeVJlc29sdmVyO1xuICAgICAgICB0aGlzLnN5bWJvbFJlc29sdmVyID0gc3ltYm9sUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuZXJyb3JSZWNvcmRlciA9IGVycm9yUmVjb3JkZXI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNoYWxsb3dBbm5vdGF0aW9uQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucHJvcGVydHlDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tZXRob2RDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdGF0aWNDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb252ZXJzaW9uTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlc29sdmVkRXh0ZXJuYWxSZWZlcmVuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25Gb3JQYXJlbnRDbGFzc1dpdGhTdW1tYXJ5S2luZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplQ29udmVyc2lvbk1hcCgpO1xuICAgICAgICBrbm93bk1ldGFkYXRhQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChrYykgeyByZXR1cm4gX3RoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3RvcihfdGhpcy5nZXRTdGF0aWNTeW1ib2woa2MuZmlsZVBhdGgsIGtjLm5hbWUpLCBrYy5jdG9yKTsgfSk7XG4gICAgICAgIGtub3duTWV0YWRhdGFGdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoa2YpIHsgcmV0dXJuIF90aGlzLl9yZWdpc3RlckZ1bmN0aW9uKF90aGlzLmdldFN0YXRpY1N5bWJvbChrZi5maWxlUGF0aCwga2YubmFtZSksIGtmLmZuKTsgfSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkZvclBhcmVudENsYXNzV2l0aFN1bW1hcnlLaW5kLnNldChDb21waWxlU3VtbWFyeUtpbmQuRGlyZWN0aXZlLCBbY3JlYXRlRGlyZWN0aXZlLCBjcmVhdGVDb21wb25lbnRdKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uRm9yUGFyZW50Q2xhc3NXaXRoU3VtbWFyeUtpbmQuc2V0KENvbXBpbGVTdW1tYXJ5S2luZC5QaXBlLCBbY3JlYXRlUGlwZV0pO1xuICAgICAgICB0aGlzLmFubm90YXRpb25Gb3JQYXJlbnRDbGFzc1dpdGhTdW1tYXJ5S2luZC5zZXQoQ29tcGlsZVN1bW1hcnlLaW5kLk5nTW9kdWxlLCBbY3JlYXRlTmdNb2R1bGVdKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uRm9yUGFyZW50Q2xhc3NXaXRoU3VtbWFyeUtpbmQuc2V0KENvbXBpbGVTdW1tYXJ5S2luZC5JbmplY3RhYmxlLCBbY3JlYXRlSW5qZWN0YWJsZSwgY3JlYXRlUGlwZSwgY3JlYXRlRGlyZWN0aXZlLCBjcmVhdGVDb21wb25lbnQsIGNyZWF0ZU5nTW9kdWxlXSk7XG4gICAgfVxuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuY29tcG9uZW50TW9kdWxlVXJsID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgdmFyIHN0YXRpY1N5bWJvbCA9IHRoaXMuZmluZFN5bWJvbERlY2xhcmF0aW9uKHR5cGVPckZ1bmMpO1xuICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2xSZXNvbHZlci5nZXRSZXNvdXJjZVBhdGgoc3RhdGljU3ltYm9sKTtcbiAgICB9O1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlZiwgY29udGFpbmluZ0ZpbGUpIHtcbiAgICAgICAgdmFyIGtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFjb250YWluaW5nRmlsZSkge1xuICAgICAgICAgICAga2V5ID0gcmVmLm1vZHVsZU5hbWUgKyBcIjpcIiArIHJlZi5uYW1lO1xuICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uU3ltYm9sXzEgPSB0aGlzLnJlc29sdmVkRXh0ZXJuYWxSZWZlcmVuY2VzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uU3ltYm9sXzEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uU3ltYm9sXzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZlN5bWJvbCA9IHRoaXMuc3ltYm9sUmVzb2x2ZXIuZ2V0U3ltYm9sQnlNb2R1bGUocmVmLm1vZHVsZU5hbWUsIHJlZi5uYW1lLCBjb250YWluaW5nRmlsZSk7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvblN5bWJvbCA9IHRoaXMuZmluZFN5bWJvbERlY2xhcmF0aW9uKHJlZlN5bWJvbCk7XG4gICAgICAgIGlmICghY29udGFpbmluZ0ZpbGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sUmVzb2x2ZXIucmVjb3JkTW9kdWxlTmFtZUZvckZpbGVOYW1lKHJlZlN5bWJvbC5maWxlUGF0aCwgcmVmLm1vZHVsZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy5zeW1ib2xSZXNvbHZlci5yZWNvcmRJbXBvcnRBcyhkZWNsYXJhdGlvblN5bWJvbCwgcmVmU3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkRXh0ZXJuYWxSZWZlcmVuY2VzLnNldChrZXksIGRlY2xhcmF0aW9uU3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjbGFyYXRpb25TeW1ib2w7XG4gICAgfTtcbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmZpbmREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChtb2R1bGVVcmwsIG5hbWUsIGNvbnRhaW5pbmdGaWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRTeW1ib2xEZWNsYXJhdGlvbih0aGlzLnN5bWJvbFJlc29sdmVyLmdldFN5bWJvbEJ5TW9kdWxlKG1vZHVsZVVybCwgbmFtZSwgY29udGFpbmluZ0ZpbGUpKTtcbiAgICB9O1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUudHJ5RmluZERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG1vZHVsZVVybCwgbmFtZSwgY29udGFpbmluZ0ZpbGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sUmVzb2x2ZXIuaWdub3JlRXJyb3JzRm9yKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZpbmREZWNsYXJhdGlvbihtb2R1bGVVcmwsIG5hbWUsIGNvbnRhaW5pbmdGaWxlKTsgfSk7XG4gICAgfTtcbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmZpbmRTeW1ib2xEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgdmFyIHJlc29sdmVkU3ltYm9sID0gdGhpcy5zeW1ib2xSZXNvbHZlci5yZXNvbHZlU3ltYm9sKHN5bWJvbCk7XG4gICAgICAgIGlmIChyZXNvbHZlZFN5bWJvbCkge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVkTWV0YWRhdGEgPSByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZE1ldGFkYXRhICYmIHJlc29sdmVkTWV0YWRhdGEuX19zeW1ib2xpYyA9PT0gJ3Jlc29sdmVkJykge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkTWV0YWRhdGEgPSByZXNvbHZlZE1ldGFkYXRhLnN5bWJvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNvbHZlZE1ldGFkYXRhIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZFN5bWJvbERlY2xhcmF0aW9uKHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ltYm9sO1xuICAgIH07XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS50cnlBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFJlY29yZGVyID0gdGhpcy5lcnJvclJlY29yZGVyO1xuICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIgPSBmdW5jdGlvbiAoZXJyb3IsIGZpbGVOYW1lKSB7IH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbm5vdGF0aW9ucyh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JSZWNvcmRlciA9IG9yaWdpbmFsUmVjb3JkZXI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuYW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5ub3RhdGlvbnModHlwZSwgZnVuY3Rpb24gKHR5cGUsIGRlY29yYXRvcnMpIHsgcmV0dXJuIF90aGlzLnNpbXBsaWZ5KHR5cGUsIGRlY29yYXRvcnMpOyB9LCB0aGlzLmFubm90YXRpb25DYWNoZSk7XG4gICAgfTtcbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnNoYWxsb3dBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbm5vdGF0aW9ucyh0eXBlLCBmdW5jdGlvbiAodHlwZSwgZGVjb3JhdG9ycykgeyByZXR1cm4gX3RoaXMuc2ltcGxpZnkodHlwZSwgZGVjb3JhdG9ycywgdHJ1ZSk7IH0sIHRoaXMuc2hhbGxvd0Fubm90YXRpb25DYWNoZSk7XG4gICAgfTtcbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLl9hbm5vdGF0aW9ucyA9IGZ1bmN0aW9uICh0eXBlLCBzaW1wbGlmeSwgYW5ub3RhdGlvbkNhY2hlKSB7XG4gICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25DYWNoZS5nZXQodHlwZSk7XG4gICAgICAgIGlmICghYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIGFubm90YXRpb25zID0gW107XG4gICAgICAgICAgICB2YXIgY2xhc3NNZXRhZGF0YSA9IHRoaXMuZ2V0VHlwZU1ldGFkYXRhKHR5cGUpO1xuICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSB0aGlzLmZpbmRQYXJlbnRUeXBlKHR5cGUsIGNsYXNzTWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKHBhcmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50QW5ub3RhdGlvbnMgPSB0aGlzLmFubm90YXRpb25zKHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgICAgIGFubm90YXRpb25zLnB1c2guYXBwbHkoYW5ub3RhdGlvbnMsIF9fc3ByZWFkKHBhcmVudEFubm90YXRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3duQW5ub3RhdGlvbnNfMSA9IFtdO1xuICAgICAgICAgICAgaWYgKGNsYXNzTWV0YWRhdGFbJ2RlY29yYXRvcnMnXSkge1xuICAgICAgICAgICAgICAgIG93bkFubm90YXRpb25zXzEgPSBzaW1wbGlmeSh0eXBlLCBjbGFzc01ldGFkYXRhWydkZWNvcmF0b3JzJ10pO1xuICAgICAgICAgICAgICAgIGlmIChvd25Bbm5vdGF0aW9uc18xKSB7XG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25zLnB1c2guYXBwbHkoYW5ub3RhdGlvbnMsIF9fc3ByZWFkKG93bkFubm90YXRpb25zXzEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50VHlwZSAmJiAhdGhpcy5zdW1tYXJ5UmVzb2x2ZXIuaXNMaWJyYXJ5RmlsZSh0eXBlLmZpbGVQYXRoKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUocGFyZW50VHlwZS5maWxlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VtbWFyeSA9IHRoaXMuc3VtbWFyeVJlc29sdmVyLnJlc29sdmVTdW1tYXJ5KHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzdW1tYXJ5ICYmIHN1bW1hcnkudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWlyZWRBbm5vdGF0aW9uVHlwZXMgPSB0aGlzLmFubm90YXRpb25Gb3JQYXJlbnRDbGFzc1dpdGhTdW1tYXJ5S2luZC5nZXQoc3VtbWFyeS50eXBlLnN1bW1hcnlLaW5kKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVIYXNSZXF1aXJlZEFubm90YXRpb24gPSByZXF1aXJlZEFubm90YXRpb25UeXBlcy5zb21lKGZ1bmN0aW9uIChyZXF1aXJlZFR5cGUpIHsgcmV0dXJuIG93bkFubm90YXRpb25zXzEuc29tZShmdW5jdGlvbiAoYW5uKSB7IHJldHVybiByZXF1aXJlZFR5cGUuaXNUeXBlT2YoYW5uKTsgfSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVIYXNSZXF1aXJlZEFubm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoZm9ybWF0TWV0YWRhdGFFcnJvcihtZXRhZGF0YUVycm9yKFwiQ2xhc3MgXCIgKyB0eXBlLm5hbWUgKyBcIiBpbiBcIiArIHR5cGUuZmlsZVBhdGggKyBcIiBleHRlbmRzIGZyb20gYSBcIiArIENvbXBpbGVTdW1tYXJ5S2luZFtzdW1tYXJ5LnR5cGUuc3VtbWFyeUtpbmRdICsgXCIgaW4gYW5vdGhlciBjb21waWxhdGlvbiB1bml0IHdpdGhvdXQgZHVwbGljYXRpbmcgdGhlIGRlY29yYXRvclwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN1bW1hcnkgKi8gdW5kZWZpbmVkLCBcIlBsZWFzZSBhZGQgYSBcIiArIHJlcXVpcmVkQW5ub3RhdGlvblR5cGVzLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZS5uZ01ldGFkYXRhTmFtZTsgfSkuam9pbignIG9yICcpICsgXCIgZGVjb3JhdG9yIHRvIHRoZSBjbGFzc1wiKSwgdHlwZSksIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5ub3RhdGlvbkNhY2hlLnNldCh0eXBlLCBhbm5vdGF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGFubikgeyByZXR1cm4gISFhbm47IH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5ub3RhdGlvbnM7XG4gICAgfTtcbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnByb3BNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9wTWV0YWRhdGEgPSB0aGlzLnByb3BlcnR5Q2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIXByb3BNZXRhZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTWV0YWRhdGEgPSB0aGlzLmdldFR5cGVNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgIHByb3BNZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSB0aGlzLmZpbmRQYXJlbnRUeXBlKHR5cGUsIGNsYXNzTWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKHBhcmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50UHJvcE1ldGFkYXRhXzEgPSB0aGlzLnByb3BNZXRhZGF0YShwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJlbnRQcm9wTWV0YWRhdGFfMSkuZm9yRWFjaChmdW5jdGlvbiAocGFyZW50UHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wTWV0YWRhdGFbcGFyZW50UHJvcF0gPSBwYXJlbnRQcm9wTWV0YWRhdGFfMVtwYXJlbnRQcm9wXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtZW1iZXJzXzEgPSBjbGFzc01ldGFkYXRhWydtZW1iZXJzJ10gfHwge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhtZW1iZXJzXzEpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BEYXRhID0gbWVtYmVyc18xW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IHByb3BEYXRhXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWydfX3N5bWJvbGljJ10gPT0gJ3Byb3BlcnR5JyB8fCBhWydfX3N5bWJvbGljJ10gPT0gJ21ldGhvZCc7IH0pO1xuICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0b3JzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHByb3BNZXRhZGF0YVtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb3JhdG9ycy5wdXNoLmFwcGx5KGRlY29yYXRvcnMsIF9fc3ByZWFkKHByb3BNZXRhZGF0YVtwcm9wTmFtZV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvcE1ldGFkYXRhW3Byb3BOYW1lXSA9IGRlY29yYXRvcnM7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgJiYgcHJvcFsnZGVjb3JhdG9ycyddKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRvcnMucHVzaC5hcHBseShkZWNvcmF0b3JzLCBfX3NwcmVhZChfdGhpcy5zaW1wbGlmeSh0eXBlLCBwcm9wWydkZWNvcmF0b3JzJ10pKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5Q2FjaGUuc2V0KHR5cGUsIHByb3BNZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BNZXRhZGF0YTtcbiAgICB9O1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUucGFyYW1ldGVycyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghKHR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKG5ldyBFcnJvcihcInBhcmFtZXRlcnMgcmVjZWl2ZWQgXCIgKyBKU09OLnN0cmluZ2lmeSh0eXBlKSArIFwiIHdoaWNoIGlzIG5vdCBhIFN0YXRpY1N5bWJvbFwiKSwgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzXzEgPSB0aGlzLnBhcmFtZXRlckNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgICAgIGlmICghcGFyYW1ldGVyc18xKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTWV0YWRhdGEgPSB0aGlzLmdldFR5cGVNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHRoaXMuZmluZFBhcmVudFR5cGUodHlwZSwgY2xhc3NNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSBjbGFzc01ldGFkYXRhID8gY2xhc3NNZXRhZGF0YVsnbWVtYmVycyddIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgY3RvckRhdGEgPSBtZW1iZXJzID8gbWVtYmVyc1snX19jdG9yX18nXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGN0b3JEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdG9yID0gY3RvckRhdGEuZmluZChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVsnX19zeW1ib2xpYyddID09ICdjb25zdHJ1Y3Rvcic7IH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3UGFyYW1ldGVyVHlwZXMgPSBjdG9yWydwYXJhbWV0ZXJzJ10gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJEZWNvcmF0b3JzXzEgPSB0aGlzLnNpbXBsaWZ5KHR5cGUsIGN0b3JbJ3BhcmFtZXRlckRlY29yYXRvcnMnXSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNfMSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByYXdQYXJhbWV0ZXJUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChyYXdQYXJhbVR5cGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVzdGVkUmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1UeXBlID0gX3RoaXMudHJ5U2ltcGxpZnkodHlwZSwgcmF3UGFyYW1UeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbVR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkUmVzdWx0LnB1c2gocGFyYW1UeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0b3JzID0gcGFyYW1ldGVyRGVjb3JhdG9yc18xID8gcGFyYW1ldGVyRGVjb3JhdG9yc18xW2luZGV4XSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVjb3JhdG9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lc3RlZFJlc3VsdC5wdXNoLmFwcGx5KG5lc3RlZFJlc3VsdCwgX19zcHJlYWQoZGVjb3JhdG9ycykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyc18xLnB1c2gobmVzdGVkUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyc18xID0gdGhpcy5wYXJhbWV0ZXJzKHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtZXRlcnNfMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJDYWNoZS5zZXQodHlwZSwgcGFyYW1ldGVyc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzXzE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgb24gdHlwZSBcIiArIEpTT04uc3RyaW5naWZ5KHR5cGUpICsgXCIgd2l0aCBlcnJvciBcIiArIGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5fbWV0aG9kTmFtZXMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgbWV0aG9kTmFtZXMgPSB0aGlzLm1ldGhvZENhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFtZXRob2ROYW1lcykge1xuICAgICAgICAgICAgdmFyIGNsYXNzTWV0YWRhdGEgPSB0aGlzLmdldFR5cGVNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgIG1ldGhvZE5hbWVzID0ge307XG4gICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHRoaXMuZmluZFBhcmVudFR5cGUodHlwZSwgY2xhc3NNZXRhZGF0YSk7XG4gICAgICAgICAgICBpZiAocGFyZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRNZXRob2ROYW1lc18xID0gdGhpcy5fbWV0aG9kTmFtZXMocGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyZW50TWV0aG9kTmFtZXNfMSkuZm9yRWFjaChmdW5jdGlvbiAocGFyZW50UHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2ROYW1lc1twYXJlbnRQcm9wXSA9IHBhcmVudE1ldGhvZE5hbWVzXzFbcGFyZW50UHJvcF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWVtYmVyc18yID0gY2xhc3NNZXRhZGF0YVsnbWVtYmVycyddIHx8IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobWVtYmVyc18yKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wRGF0YSA9IG1lbWJlcnNfMltwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIGlzTWV0aG9kID0gcHJvcERhdGEuc29tZShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVsnX19zeW1ib2xpYyddID09ICdtZXRob2QnOyB9KTtcbiAgICAgICAgICAgICAgICBtZXRob2ROYW1lc1twcm9wTmFtZV0gPSBtZXRob2ROYW1lc1twcm9wTmFtZV0gfHwgaXNNZXRob2Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubWV0aG9kQ2FjaGUuc2V0KHR5cGUsIG1ldGhvZE5hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0aG9kTmFtZXM7XG4gICAgfTtcbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLl9zdGF0aWNNZW1iZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHN0YXRpY01lbWJlcnMgPSB0aGlzLnN0YXRpY0NhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFzdGF0aWNNZW1iZXJzKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NNZXRhZGF0YSA9IHRoaXMuZ2V0VHlwZU1ldGFkYXRhKHR5cGUpO1xuICAgICAgICAgICAgdmFyIHN0YXRpY01lbWJlckRhdGEgPSBjbGFzc01ldGFkYXRhWydzdGF0aWNzJ10gfHwge307XG4gICAgICAgICAgICBzdGF0aWNNZW1iZXJzID0gT2JqZWN0LmtleXMoc3RhdGljTWVtYmVyRGF0YSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRpY0NhY2hlLnNldCh0eXBlLCBzdGF0aWNNZW1iZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGljTWVtYmVycztcbiAgICB9O1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuZmluZFBhcmVudFR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY2xhc3NNZXRhZGF0YSkge1xuICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHRoaXMudHJ5U2ltcGxpZnkodHlwZSwgY2xhc3NNZXRhZGF0YVsnZXh0ZW5kcyddKTtcbiAgICAgICAgaWYgKHBhcmVudFR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRUeXBlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmhhc0xpZmVjeWNsZUhvb2sgPSBmdW5jdGlvbiAodHlwZSwgbGNQcm9wZXJ0eSkge1xuICAgICAgICBpZiAoISh0eXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihuZXcgRXJyb3IoXCJoYXNMaWZlY3ljbGVIb29rIHJlY2VpdmVkIFwiICsgSlNPTi5zdHJpbmdpZnkodHlwZSkgKyBcIiB3aGljaCBpcyBub3QgYSBTdGF0aWNTeW1ib2xcIiksIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLl9tZXRob2ROYW1lcyh0eXBlKVtsY1Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCBvbiB0eXBlIFwiICsgSlNPTi5zdHJpbmdpZnkodHlwZSkgKyBcIiB3aXRoIGVycm9yIFwiICsgZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmd1YXJkcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICBpZiAoISh0eXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihuZXcgRXJyb3IoXCJndWFyZHMgcmVjZWl2ZWQgXCIgKyBKU09OLnN0cmluZ2lmeSh0eXBlKSArIFwiIHdoaWNoIGlzIG5vdCBhIFN0YXRpY1N5bWJvbFwiKSwgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRpY01lbWJlcnMgPSB0aGlzLl9zdGF0aWNNZW1iZXJzKHR5cGUpO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzdGF0aWNNZW1iZXJzXzEgPSBfX3ZhbHVlcyhzdGF0aWNNZW1iZXJzKSwgc3RhdGljTWVtYmVyc18xXzEgPSBzdGF0aWNNZW1iZXJzXzEubmV4dCgpOyAhc3RhdGljTWVtYmVyc18xXzEuZG9uZTsgc3RhdGljTWVtYmVyc18xXzEgPSBzdGF0aWNNZW1iZXJzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHN0YXRpY01lbWJlcnNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lXzEuZW5kc1dpdGgoVFlQRUdVQVJEX1BPU1RGSVgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IG5hbWVfMS5zdWJzdHIoMCwgbmFtZV8xLmxlbmd0aCAtIFRZUEVHVUFSRF9QT1NURklYLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5LmVuZHNXaXRoKFVTRV9JRikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gbmFtZV8xLnN1YnN0cigwLCBwcm9wZXJ0eS5sZW5ndGggLSBVU0VfSUYubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gVVNFX0lGO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldFN0YXRpY1N5bWJvbCh0eXBlLmZpbGVQYXRoLCB0eXBlLm5hbWUsIFtuYW1lXzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGljTWVtYmVyc18xXzEgJiYgIXN0YXRpY01lbWJlcnNfMV8xLmRvbmUgJiYgKF9hID0gc3RhdGljTWVtYmVyc18xLnJldHVybikpIF9hLmNhbGwoc3RhdGljTWVtYmVyc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHR5cGUsIGN0b3IpIHtcbiAgICAgICAgdGhpcy5jb252ZXJzaW9uTWFwLnNldCh0eXBlLCBmdW5jdGlvbiAoY29udGV4dCwgYXJncykgeyByZXR1cm4gbmV3IChjdG9yLmJpbmQuYXBwbHkoY3RvciwgX19zcHJlYWQoW3ZvaWQgMF0sIGFyZ3MpKSkoKTsgfSk7XG4gICAgfTtcbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLl9yZWdpc3RlckZ1bmN0aW9uID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gICAgICAgIHRoaXMuY29udmVyc2lvbk1hcC5zZXQodHlwZSwgZnVuY3Rpb24gKGNvbnRleHQsIGFyZ3MpIHsgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0pO1xuICAgIH07XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5pbml0aWFsaXplQ29udmVyc2lvbk1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0luamVjdGFibGUnKSwgY3JlYXRlSW5qZWN0YWJsZSk7XG4gICAgICAgIHRoaXMuaW5qZWN0aW9uVG9rZW4gPSB0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdJbmplY3Rpb25Ub2tlbicpO1xuICAgICAgICB0aGlzLm9wYXF1ZVRva2VuID0gdGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnT3BhcXVlVG9rZW4nKTtcbiAgICAgICAgdGhpcy5ST1VURVMgPSB0aGlzLnRyeUZpbmREZWNsYXJhdGlvbihBTkdVTEFSX1JPVVRFUiwgJ1JPVVRFUycpO1xuICAgICAgICB0aGlzLkFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMgPVxuICAgICAgICAgICAgdGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUycpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnSG9zdCcpLCBjcmVhdGVIb3N0KTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ1NlbGYnKSwgY3JlYXRlU2VsZik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdTa2lwU2VsZicpLCBjcmVhdGVTa2lwU2VsZik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdJbmplY3QnKSwgY3JlYXRlSW5qZWN0KTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ09wdGlvbmFsJyksIGNyZWF0ZU9wdGlvbmFsKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0F0dHJpYnV0ZScpLCBjcmVhdGVBdHRyaWJ1dGUpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnQ29udGVudENoaWxkJyksIGNyZWF0ZUNvbnRlbnRDaGlsZCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdDb250ZW50Q2hpbGRyZW4nKSwgY3JlYXRlQ29udGVudENoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ1ZpZXdDaGlsZCcpLCBjcmVhdGVWaWV3Q2hpbGQpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnVmlld0NoaWxkcmVuJyksIGNyZWF0ZVZpZXdDaGlsZHJlbik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdJbnB1dCcpLCBjcmVhdGVJbnB1dCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdPdXRwdXQnKSwgY3JlYXRlT3V0cHV0KTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ1BpcGUnKSwgY3JlYXRlUGlwZSk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdIb3N0QmluZGluZycpLCBjcmVhdGVIb3N0QmluZGluZyk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdIb3N0TGlzdGVuZXInKSwgY3JlYXRlSG9zdExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0RpcmVjdGl2ZScpLCBjcmVhdGVEaXJlY3RpdmUpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnQ29tcG9uZW50JyksIGNyZWF0ZUNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdOZ01vZHVsZScpLCBjcmVhdGVOZ01vZHVsZSk7XG4gICAgICAgIC8vIE5vdGU6IFNvbWUgbWV0YWRhdGEgY2xhc3NlcyBjYW4gYmUgdXNlZCBkaXJlY3RseSB3aXRoIFByb3ZpZGVyLmRlcHMuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdIb3N0JyksIGNyZWF0ZUhvc3QpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnU2VsZicpLCBjcmVhdGVTZWxmKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ1NraXBTZWxmJyksIGNyZWF0ZVNraXBTZWxmKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ09wdGlvbmFsJyksIGNyZWF0ZU9wdGlvbmFsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldFN0YXRpY1N5bWJvbCBwcm9kdWNlcyBhIFR5cGUgd2hvc2UgbWV0YWRhdGEgaXMga25vd24gYnV0IHdob3NlIGltcGxlbWVudGF0aW9uIGlzIG5vdCBsb2FkZWQuXG4gICAgICogQWxsIHR5cGVzIHBhc3NlZCB0byB0aGUgU3RhdGljUmVzb2x2ZXIgc2hvdWxkIGJlIHBzZXVkby10eXBlcyByZXR1cm5lZCBieSB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZWNsYXJhdGlvbkZpbGUgdGhlIGFic29sdXRlIHBhdGggb2YgdGhlIGZpbGUgd2hlcmUgdGhlIHN5bWJvbCBpcyBkZWNsYXJlZFxuICAgICAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSB0eXBlLlxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuZ2V0U3RhdGljU3ltYm9sID0gZnVuY3Rpb24gKGRlY2xhcmF0aW9uRmlsZSwgbmFtZSwgbWVtYmVycykge1xuICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2xSZXNvbHZlci5nZXRTdGF0aWNTeW1ib2woZGVjbGFyYXRpb25GaWxlLCBuYW1lLCBtZW1iZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNpbXBsaWZ5IGJ1dCBkaXNjYXJkIGFueSBlcnJvcnNcbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnRyeVNpbXBsaWZ5ID0gZnVuY3Rpb24gKGNvbnRleHQsIHZhbHVlKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFJlY29yZGVyID0gdGhpcy5lcnJvclJlY29yZGVyO1xuICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIgPSBmdW5jdGlvbiAoZXJyb3IsIGZpbGVOYW1lKSB7IH07XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNpbXBsaWZ5KGNvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5lcnJvclJlY29yZGVyID0gb3JpZ2luYWxSZWNvcmRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnNpbXBsaWZ5ID0gZnVuY3Rpb24gKGNvbnRleHQsIHZhbHVlLCBsYXp5KSB7XG4gICAgICAgIGlmIChsYXp5ID09PSB2b2lkIDApIHsgbGF6eSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNjb3BlID0gQmluZGluZ1Njb3BlJDEuZW1wdHk7XG4gICAgICAgIHZhciBjYWxsaW5nID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgcm9vdENvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICBmdW5jdGlvbiBzaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCB2YWx1ZSwgZGVwdGgsIHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVSZWZlcmVuY2VWYWx1ZShzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZWRTeW1ib2wgPSBzZWxmLnN5bWJvbFJlc29sdmVyLnJlc29sdmVTeW1ib2woc3RhdGljU3ltYm9sKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRTeW1ib2wgPyByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzaW1wbGlmeUVhZ2VybHkodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnlJbkNvbnRleHQoY29udGV4dCwgdmFsdWUsIGRlcHRoLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNpbXBsaWZ5TGF6aWx5KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5SW5Db250ZXh0KGNvbnRleHQsIHZhbHVlLCBkZXB0aCwgcmVmZXJlbmNlcyArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gc2ltcGxpZnlOZXN0ZWQobmVzdGVkQ29udGV4dCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobmVzdGVkQ29udGV4dCA9PT0gY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY29udGV4dCBoYXNuJ3QgY2hhbmdlZCBsZXQgdGhlIGV4Y2VwdGlvbiBwcm9wYWdhdGUgdW5tb2RpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5SW5Db250ZXh0KG5lc3RlZENvbnRleHQsIHZhbHVlLCBkZXB0aCArIDEsIHJlZmVyZW5jZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnlJbkNvbnRleHQobmVzdGVkQ29udGV4dCwgdmFsdWUsIGRlcHRoICsgMSwgcmVmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01ldGFkYXRhRXJyb3IoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb3BhZ2F0ZSB0aGUgbWVzc2FnZSB0ZXh0IHVwIGJ1dCBhZGQgYSBtZXNzYWdlIHRvIHRoZSBjaGFpbiB0aGF0IGV4cGxhaW5zIGhvdyB3ZSBnb3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmNoYWluIGltcGxpZXMgZS5zeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdW1tYXJ5TXNnID0gZS5jaGFpbiA/ICdyZWZlcmVuY2VzIFxcJycgKyBlLnN5bWJvbC5uYW1lICsgJ1xcJycgOiBlcnJvclN1bW1hcnkoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VtbWFyeSA9IFwiJ1wiICsgbmVzdGVkQ29udGV4dC5uYW1lICsgXCInIFwiICsgc3VtbWFyeU1zZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFpbiA9IHsgbWVzc2FnZTogc3VtbWFyeSwgcG9zaXRpb246IGUucG9zaXRpb24sIG5leHQ6IGUuY2hhaW4gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oY2h1Y2tqKTogcmV0cmlldmUgdGhlIHBvc2l0aW9uIGluZm9ybWF0aW9uIGluZGlyZWN0bHkgZnJvbSB0aGUgY29sbGVjdG9ycyBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXAgaWYgdGhlIG1ldGFkYXRhIGlzIGZyb20gYSAudHMgZmlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZHZpc2U6IGUuYWR2aXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGUuY29udGV4dCwgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbDogbmVzdGVkQ29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBwcm9iYWJseSBhbiBpbnRlcm5hbCBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzaW1wbGlmeUNhbGwoZnVuY3Rpb25TeW1ib2wsIHRhcmdldEZ1bmN0aW9uLCBhcmdzLCB0YXJnZXRFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEZ1bmN0aW9uICYmIHRhcmdldEZ1bmN0aW9uWydfX3N5bWJvbGljJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGluZy5nZXQoZnVuY3Rpb25TeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUmVjdXJzaW9uIGlzIG5vdCBzdXBwb3J0ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IFwiY2FsbGVkICdcIiArIGZ1bmN0aW9uU3ltYm9sLm5hbWUgKyBcIicgcmVjdXJzaXZlbHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGFyZ2V0RnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uU3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlXzEgPSB0YXJnZXRGdW5jdGlvblsndmFsdWUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZV8xICYmIChkZXB0aCAhPSAwIHx8IHZhbHVlXzEuX19zeW1ib2xpYyAhPSAnZXJyb3InKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gdGFyZ2V0RnVuY3Rpb25bJ3BhcmFtZXRlcnMnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSB0YXJnZXRGdW5jdGlvbi5kZWZhdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gc2ltcGxpZnlOZXN0ZWQoY29udGV4dCwgYXJnKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBzaG91bGRJZ25vcmUoYXJnKSA/IHVuZGVmaW5lZCA6IGFyZzsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRzICYmIGRlZmF1bHRzLmxlbmd0aCA+IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaC5hcHBseShhcmdzLCBfX3NwcmVhZChkZWZhdWx0cy5zbGljZShhcmdzLmxlbmd0aCkubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc2ltcGxpZnkodmFsdWUpOyB9KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsaW5nLnNldChmdW5jdGlvblN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uU2NvcGUgPSBCaW5kaW5nU2NvcGUkMS5idWlsZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblNjb3BlLmRlZmluZShwYXJhbWV0ZXJzW2ldLCBhcmdzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gZnVuY3Rpb25TY29wZS5kb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdF8xID0gc2ltcGxpZnlOZXN0ZWQoZnVuY3Rpb25TeW1ib2wsIHZhbHVlXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBvbGRTY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGluZy5kZWxldGUoZnVuY3Rpb25TeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBkZXB0aCBpcyAwIHdlIGFyZSBldmFsdWF0aW5nIHRoZSB0b3AgbGV2ZWwgZXhwcmVzc2lvbiB0aGF0IGlzIGRlc2NyaWJpbmcgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBkZWNvcmF0b3IuIEluIHRoaXMgY2FzZSwgaXQgaXMgYSBkZWNvcmF0b3Igd2UgZG9uJ3QgdW5kZXJzdGFuZCwgc3VjaCBhcyBhIGN1c3RvbVxuICAgICAgICAgICAgICAgICAgICAvLyBub24tYW5ndWxhciBkZWNvcmF0b3IsIGFuZCB3ZSBzaG91bGQganVzdCBpZ25vcmUgaXQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJR05PUkU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RXhwcmVzc2lvbiAmJiB0YXJnZXRFeHByZXNzaW9uLl9fc3ltYm9saWMgPT0gJ3Jlc29sdmVkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHRhcmdldEV4cHJlc3Npb24ubGluZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IHRhcmdldEV4cHJlc3Npb24uY2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSB0YXJnZXRFeHByZXNzaW9uLmZpbGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUgIT0gbnVsbCAmJiBsaW5lICE9IG51bGwgJiYgY2hhcmFjdGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0geyBmaWxlTmFtZTogZmlsZU5hbWUsIGxpbmU6IGxpbmUsIGNvbHVtbjogY2hhcmFjdGVyIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IEZVTkNUSU9OX0NBTExfTk9UX1NVUFBPUlRFRCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogZnVuY3Rpb25TeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0YXJnZXRGdW5jdGlvbiwgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzaW1wbGlmeShleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVfMiwgX2EsIGVfMywgX2I7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKGV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRfMiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhleHByZXNzaW9uKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX2QudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGEgc3ByZWFkIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLl9fc3ltYm9saWMgPT09ICdzcHJlYWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbGwgd2l0aCByZWZlcmVuY2VzIGFzIDAgYmVjYXVzZSB3ZSByZXF1aXJlIHRoZSBhY3R1YWwgdmFsdWUgYW5kIGNhbm5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0b2xlcmF0ZSBhIHJlZmVyZW5jZSBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ByZWFkQXJyYXkgPSBzaW1wbGlmeUVhZ2VybHkoaXRlbS5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3ByZWFkQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHNwcmVhZEFycmF5XzEgPSAoZV8zID0gdm9pZCAwLCBfX3ZhbHVlcyhzcHJlYWRBcnJheSkpLCBzcHJlYWRBcnJheV8xXzEgPSBzcHJlYWRBcnJheV8xLm5leHQoKTsgIXNwcmVhZEFycmF5XzFfMS5kb25lOyBzcHJlYWRBcnJheV8xXzEgPSBzcHJlYWRBcnJheV8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ByZWFkSXRlbSA9IHNwcmVhZEFycmF5XzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XzIucHVzaChzcHJlYWRJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwcmVhZEFycmF5XzFfMSAmJiAhc3ByZWFkQXJyYXlfMV8xLmRvbmUgJiYgKF9iID0gc3ByZWFkQXJyYXlfMS5yZXR1cm4pKSBfYi5jYWxsKHNwcmVhZEFycmF5XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVfMiA9IHNpbXBsaWZ5KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmUodmFsdWVfMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdF8yLnB1c2godmFsdWVfMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3Agc2ltcGxpZmljYXRpb24gYXQgYnVpbHRpbiBzeW1ib2xzIG9yIGlmIHdlIGFyZSBpbiBhIHJlZmVyZW5jZSBjb250ZXh0IGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc3ltYm9sIGRvZXNuJ3QgaGF2ZSBtZW1iZXJzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gc2VsZi5pbmplY3Rpb25Ub2tlbiB8fCBzZWxmLmNvbnZlcnNpb25NYXAuaGFzKGV4cHJlc3Npb24pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAocmVmZXJlbmNlcyA+IDAgJiYgIWV4cHJlc3Npb24ubWVtYmVycy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0aWNTeW1ib2wgPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uVmFsdWUgPSByZXNvbHZlUmVmZXJlbmNlVmFsdWUoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvblZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnlOZXN0ZWQoc3RhdGljU3ltYm9sLCBkZWNsYXJhdGlvblZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0aWNTeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25bJ19fc3ltYm9saWMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRpY1N5bWJvbCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwcmVzc2lvblsnX19zeW1ib2xpYyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmlub3AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ2xlZnQnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmUobGVmdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gc2ltcGxpZnkoZXhwcmVzc2lvblsncmlnaHQnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmUocmlnaHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHJlc3Npb25bJ29wZXJhdG9yJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAmJiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3x8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCB8fCByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0IHwgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCBeIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgJiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA9PSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAhPSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAhPT0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA8IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA8PSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA+PSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzw8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA8PCByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz4+JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA+PiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAtIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgKiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0IC8gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAlIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ2NvbmRpdGlvbiddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ3RoZW5FeHByZXNzaW9uJ10pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsaWZ5KGV4cHJlc3Npb25bJ2Vsc2VFeHByZXNzaW9uJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYW5kID0gc2ltcGxpZnkoZXhwcmVzc2lvblsnb3BlcmFuZCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZShvcGVyYW5kKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHJlc3Npb25bJ29wZXJhdG9yJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1vcGVyYW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFvcGVyYW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnfic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIH5vcGVyYW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2luZGV4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4VGFyZ2V0ID0gc2ltcGxpZnlFYWdlcmx5KGV4cHJlc3Npb25bJ2V4cHJlc3Npb24nXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHNpbXBsaWZ5RWFnZXJseShleHByZXNzaW9uWydpbmRleCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4VGFyZ2V0ICYmIGlzUHJpbWl0aXZlKGluZGV4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleFRhcmdldFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZW1iZXIgPSBleHByZXNzaW9uWydtZW1iZXInXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdENvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0VGFyZ2V0ID0gc2ltcGxpZnkoZXhwcmVzc2lvblsnZXhwcmVzc2lvbiddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdFRhcmdldCBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSBzZWxlY3RUYXJnZXQubWVtYmVycy5jb25jYXQobWVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdENvbnRleHQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZ2V0U3RhdGljU3ltYm9sKHNlbGVjdFRhcmdldC5maWxlUGF0aCwgc2VsZWN0VGFyZ2V0Lm5hbWUsIG1lbWJlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uVmFsdWUgPSByZXNvbHZlUmVmZXJlbmNlVmFsdWUoc2VsZWN0Q29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRpb25WYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5TmVzdGVkKHNlbGVjdENvbnRleHQsIGRlY2xhcmF0aW9uVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdFRhcmdldCAmJiBpc1ByaW1pdGl2ZShtZW1iZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5TmVzdGVkKHNlbGVjdENvbnRleHQsIHNlbGVjdFRhcmdldFttZW1iZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVmZXJlbmNlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogVGhpcyBvbmx5IGhhcyB0byBkZWFsIHdpdGggdmFyaWFibGUgcmVmZXJlbmNlcywgYXMgc3ltYm9sIHJlZmVyZW5jZXMgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiZWVuIGNvbnZlcnRlZCBpbnRvICdyZXNvbHZlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIFN0YXRpY1N5bWJvbFJlc29sdmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8yID0gZXhwcmVzc2lvblsnbmFtZSddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWxWYWx1ZSA9IHNjb3BlLnJlc29sdmUobmFtZV8yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsVmFsdWUgIT0gQmluZGluZ1Njb3BlJDEubWlzc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVzb2x2ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5KGV4cHJlc3Npb24uc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYW4gZXJyb3IgaXMgcmVwb3J0ZWQgZXZhbHVhdGluZyB0aGUgc3ltYm9sIHJlY29yZCB0aGUgcG9zaXRpb24gb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWZlcmVuY2UgaW4gdGhlIGVycm9yIHNvIGl0IGNhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmUgcmVwb3J0ZWQgaW4gdGhlIGVycm9yIG1lc3NhZ2UgZ2VuZXJhdGVkIGZyb20gdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc01ldGFkYXRhRXJyb3IoZSkgJiYgZXhwcmVzc2lvbi5maWxlTmFtZSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5saW5lICE9IG51bGwgJiYgZXhwcmVzc2lvbi5jaGFyYWN0ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBleHByZXNzaW9uLmZpbGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBleHByZXNzaW9uLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogZXhwcmVzc2lvbi5jaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduZXcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NhbGwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGZ1bmN0aW9uIGlzIGEgYnVpbHQtaW4gY29udmVyc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNTeW1ib2wgPSBzaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCBleHByZXNzaW9uWydleHByZXNzaW9uJ10sIGRlcHRoICsgMSwgLyogcmVmZXJlbmNlcyAqLyAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRpY1N5bWJvbCBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRpY1N5bWJvbCA9PT0gc2VsZi5pbmplY3Rpb25Ub2tlbiB8fCBzdGF0aWNTeW1ib2wgPT09IHNlbGYub3BhcXVlVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBzb21lYm9keSBjYWxscyBuZXcgSW5qZWN0aW9uVG9rZW4sIGRvbid0IGNyZWF0ZSBhbiBJbmplY3Rpb25Ub2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgcmF0aGVyIHJldHVybiB0aGUgc3ltYm9sIHRvIHdoaWNoIHRoZSBJbmplY3Rpb25Ub2tlbiBpcyBhc3NpZ25lZCB0by5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGFxdWVUb2tlbiBpcyBzdXBwb3J0ZWQgdG9vIGFzIGl0IGlzIHJlcXVpcmVkIGJ5IHRoZSBsYW5ndWFnZSBzZXJ2aWNlIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VwcG9ydCB2NCBhbmQgcHJpb3IgdmVyc2lvbnMgb2YgQW5ndWxhci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdFeHByZXNzaW9ucyA9IGV4cHJlc3Npb25bJ2FyZ3VtZW50cyddIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRlciA9IHNlbGYuY29udmVyc2lvbk1hcC5nZXQoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ0V4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBzaW1wbGlmeU5lc3RlZChjb250ZXh0LCBhcmcpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHNob3VsZElnbm9yZShhcmcpID8gdW5kZWZpbmVkIDogYXJnOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydGVyKGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBmdW5jdGlvbiBpcyBvbmUgd2UgY2FuIHNpbXBsaWZ5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRGdW5jdGlvbiA9IHJlc29sdmVSZWZlcmVuY2VWYWx1ZShzdGF0aWNTeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeUNhbGwoc3RhdGljU3ltYm9sLCB0YXJnZXRGdW5jdGlvbiwgYXJnRXhwcmVzc2lvbnMsIGV4cHJlc3Npb25bJ2V4cHJlc3Npb24nXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElHTk9SRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZXhwcmVzc2lvbi5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvblsnbGluZSddICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogZXhwcmVzc2lvbi5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBleHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBleHByZXNzaW9uWydmaWxlTmFtZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBleHByZXNzaW9uWydsaW5lJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogZXhwcmVzc2lvblsnY2hhcmFjdGVyJ11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLCBjb250ZXh0OiBleHByZXNzaW9uLmNvbnRleHQgfSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElHTk9SRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXBTdHJpbmdNYXAoZXhwcmVzc2lvbiwgZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUkVGRVJFTkNFX1NFVC5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gVVNFX1ZBTFVFJDEgJiYgUFJPVklERSBpbiBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcm92aWRlciBleHByZXNzaW9uLCBjaGVjayBmb3Igc3BlY2lhbCB0b2tlbnMgdGhhdCBuZWVkIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkdXJpbmcgYW5hbHlzaXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm92aWRlID0gc2ltcGxpZnkoZXhwcmVzc2lvbi5wcm92aWRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3ZpZGUgPT09IHNlbGYuUk9VVEVTIHx8IHByb3ZpZGUgPT0gc2VsZi5BTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeUxhemlseSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIElHTk9SRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNpbXBsaWZ5SW5Db250ZXh0KGNvbnRleHQsIHZhbHVlLCAwLCBsYXp5ID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcnJvclJlY29yZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGZvcm1hdE1ldGFkYXRhRXJyb3IoZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmdldFR5cGVNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciByZXNvbHZlZFN5bWJvbCA9IHRoaXMuc3ltYm9sUmVzb2x2ZXIucmVzb2x2ZVN5bWJvbCh0eXBlKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkU3ltYm9sICYmIHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhID8gcmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEgOlxuICAgICAgICAgICAgeyBfX3N5bWJvbGljOiAnY2xhc3MnIH07XG4gICAgfTtcbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBjb250ZXh0LCBwYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yUmVjb3JkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JSZWNvcmRlcihmb3JtYXRNZXRhZGF0YUVycm9yKGVycm9yLCBjb250ZXh0KSwgKGNvbnRleHQgJiYgY29udGV4dC5maWxlUGF0aCkgfHwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChfYSwgcmVwb3J0aW5nQ29udGV4dCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IF9hLm1lc3NhZ2UsIHN1bW1hcnkgPSBfYS5zdW1tYXJ5LCBhZHZpc2UgPSBfYS5hZHZpc2UsIHBvc2l0aW9uID0gX2EucG9zaXRpb24sIGNvbnRleHQgPSBfYS5jb250ZXh0LCB2YWx1ZSA9IF9hLnZhbHVlLCBzeW1ib2wgPSBfYS5zeW1ib2wsIGNoYWluID0gX2EuY2hhaW47XG4gICAgICAgIHRoaXMucmVwb3J0RXJyb3IobWV0YWRhdGFFcnJvcihtZXNzYWdlLCBzdW1tYXJ5LCBhZHZpc2UsIHBvc2l0aW9uLCBzeW1ib2wsIGNvbnRleHQsIGNoYWluKSwgcmVwb3J0aW5nQ29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljUmVmbGVjdG9yO1xufSgpKTtcbnZhciBNRVRBREFUQV9FUlJPUiA9ICduZ01ldGFkYXRhRXJyb3InO1xuZnVuY3Rpb24gbWV0YWRhdGFFcnJvcihtZXNzYWdlLCBzdW1tYXJ5LCBhZHZpc2UsIHBvc2l0aW9uLCBzeW1ib2wsIGNvbnRleHQsIGNoYWluKSB7XG4gICAgdmFyIGVycm9yID0gc3ludGF4RXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3JbTUVUQURBVEFfRVJST1JdID0gdHJ1ZTtcbiAgICBpZiAoYWR2aXNlKVxuICAgICAgICBlcnJvci5hZHZpc2UgPSBhZHZpc2U7XG4gICAgaWYgKHBvc2l0aW9uKVxuICAgICAgICBlcnJvci5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIGlmIChzdW1tYXJ5KVxuICAgICAgICBlcnJvci5zdW1tYXJ5ID0gc3VtbWFyeTtcbiAgICBpZiAoY29udGV4dClcbiAgICAgICAgZXJyb3IuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgaWYgKGNoYWluKVxuICAgICAgICBlcnJvci5jaGFpbiA9IGNoYWluO1xuICAgIGlmIChzeW1ib2wpXG4gICAgICAgIGVycm9yLnN5bWJvbCA9IHN5bWJvbDtcbiAgICByZXR1cm4gZXJyb3I7XG59XG5mdW5jdGlvbiBpc01ldGFkYXRhRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gISFlcnJvcltNRVRBREFUQV9FUlJPUl07XG59XG52YXIgUkVGRVJFTkNFX1RPX05PTkVYUE9SVEVEX0NMQVNTID0gJ1JlZmVyZW5jZSB0byBub24tZXhwb3J0ZWQgY2xhc3MnO1xudmFyIFZBUklBQkxFX05PVF9JTklUSUFMSVpFRCA9ICdWYXJpYWJsZSBub3QgaW5pdGlhbGl6ZWQnO1xudmFyIERFU1RSVUNUVVJFX05PVF9TVVBQT1JURUQgPSAnRGVzdHJ1Y3R1cmluZyBub3Qgc3VwcG9ydGVkJztcbnZhciBDT1VMRF9OT1RfUkVTT0xWRV9UWVBFID0gJ0NvdWxkIG5vdCByZXNvbHZlIHR5cGUnO1xudmFyIEZVTkNUSU9OX0NBTExfTk9UX1NVUFBPUlRFRCA9ICdGdW5jdGlvbiBjYWxsIG5vdCBzdXBwb3J0ZWQnO1xudmFyIFJFRkVSRU5DRV9UT19MT0NBTF9TWU1CT0wgPSAnUmVmZXJlbmNlIHRvIGEgbG9jYWwgc3ltYm9sJztcbnZhciBMQU1CREFfTk9UX1NVUFBPUlRFRCA9ICdMYW1iZGEgbm90IHN1cHBvcnRlZCc7XG5mdW5jdGlvbiBleHBhbmRlZE1lc3NhZ2UobWVzc2FnZSwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobWVzc2FnZSkge1xuICAgICAgICBjYXNlIFJFRkVSRU5DRV9UT19OT05FWFBPUlRFRF9DTEFTUzpcbiAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUmVmZXJlbmNlcyB0byBhIG5vbi1leHBvcnRlZCBjbGFzcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBkZWNvcmF0b3JzIGJ1dCBcIiArIGNvbnRleHQuY2xhc3NOYW1lICsgXCIgd2FzIHJlZmVyZW5jZWQuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBWQVJJQUJMRV9OT1RfSU5JVElBTElaRUQ6XG4gICAgICAgICAgICByZXR1cm4gJ09ubHkgaW5pdGlhbGl6ZWQgdmFyaWFibGVzIGFuZCBjb25zdGFudHMgY2FuIGJlIHJlZmVyZW5jZWQgaW4gZGVjb3JhdG9ycyBiZWNhdXNlIHRoZSB2YWx1ZSBvZiB0aGlzIHZhcmlhYmxlIGlzIG5lZWRlZCBieSB0aGUgdGVtcGxhdGUgY29tcGlsZXInO1xuICAgICAgICBjYXNlIERFU1RSVUNUVVJFX05PVF9TVVBQT1JURUQ6XG4gICAgICAgICAgICByZXR1cm4gJ1JlZmVyZW5jaW5nIGFuIGV4cG9ydGVkIGRlc3RydWN0dXJlZCB2YXJpYWJsZSBvciBjb25zdGFudCBpcyBub3Qgc3VwcG9ydGVkIGluIGRlY29yYXRvcnMgYW5kIHRoaXMgdmFsdWUgaXMgbmVlZGVkIGJ5IHRoZSB0ZW1wbGF0ZSBjb21waWxlcic7XG4gICAgICAgIGNhc2UgQ09VTERfTk9UX1JFU09MVkVfVFlQRTpcbiAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQudHlwZU5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJDb3VsZCBub3QgcmVzb2x2ZSB0eXBlIFwiICsgY29udGV4dC50eXBlTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEZVTkNUSU9OX0NBTExfTk9UX1NVUFBPUlRFRDpcbiAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQubmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkZ1bmN0aW9uIGNhbGxzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGRlY29yYXRvcnMgYnV0ICdcIiArIGNvbnRleHQubmFtZSArIFwiJyB3YXMgY2FsbGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ0Z1bmN0aW9uIGNhbGxzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGRlY29yYXRvcnMnO1xuICAgICAgICBjYXNlIFJFRkVSRU5DRV9UT19MT0NBTF9TWU1CT0w6XG4gICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSZWZlcmVuY2UgdG8gYSBsb2NhbCAobm9uLWV4cG9ydGVkKSBzeW1ib2xzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGRlY29yYXRvcnMgYnV0ICdcIiArIGNvbnRleHQubmFtZSArIFwiJyB3YXMgcmVmZXJlbmNlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTEFNQkRBX05PVF9TVVBQT1JURUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJGdW5jdGlvbiBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCBpbiBkZWNvcmF0b3JzXCI7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gbWVzc2FnZUFkdmlzZShtZXNzYWdlLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChtZXNzYWdlKSB7XG4gICAgICAgIGNhc2UgUkVGRVJFTkNFX1RPX05PTkVYUE9SVEVEX0NMQVNTOlxuICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJDb25zaWRlciBleHBvcnRpbmcgJ1wiICsgY29udGV4dC5jbGFzc05hbWUgKyBcIidcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIERFU1RSVUNUVVJFX05PVF9TVVBQT1JURUQ6XG4gICAgICAgICAgICByZXR1cm4gJ0NvbnNpZGVyIHNpbXBsaWZ5aW5nIHRvIGF2b2lkIGRlc3RydWN0dXJpbmcnO1xuICAgICAgICBjYXNlIFJFRkVSRU5DRV9UT19MT0NBTF9TWU1CT0w6XG4gICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJDb25zaWRlciBleHBvcnRpbmcgJ1wiICsgY29udGV4dC5uYW1lICsgXCInXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMQU1CREFfTk9UX1NVUFBPUlRFRDpcbiAgICAgICAgICAgIHJldHVybiBcIkNvbnNpZGVyIGNoYW5naW5nIHRoZSBmdW5jdGlvbiBleHByZXNzaW9uIGludG8gYW4gZXhwb3J0ZWQgZnVuY3Rpb25cIjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGVycm9yU3VtbWFyeShlcnJvcikge1xuICAgIGlmIChlcnJvci5zdW1tYXJ5KSB7XG4gICAgICAgIHJldHVybiBlcnJvci5zdW1tYXJ5O1xuICAgIH1cbiAgICBzd2l0Y2ggKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgY2FzZSBSRUZFUkVOQ0VfVE9fTk9ORVhQT1JURURfQ0xBU1M6XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29udGV4dCAmJiBlcnJvci5jb250ZXh0LmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInJlZmVyZW5jZXMgbm9uLWV4cG9ydGVkIGNsYXNzIFwiICsgZXJyb3IuY29udGV4dC5jbGFzc05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBWQVJJQUJMRV9OT1RfSU5JVElBTElaRUQ6XG4gICAgICAgICAgICByZXR1cm4gJ2lzIG5vdCBpbml0aWFsaXplZCc7XG4gICAgICAgIGNhc2UgREVTVFJVQ1RVUkVfTk9UX1NVUFBPUlRFRDpcbiAgICAgICAgICAgIHJldHVybiAnaXMgYSBkZXN0cnVjdHVyZWQgdmFyaWFibGUnO1xuICAgICAgICBjYXNlIENPVUxEX05PVF9SRVNPTFZFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gJ2NvdWxkIG5vdCBiZSByZXNvbHZlZCc7XG4gICAgICAgIGNhc2UgRlVOQ1RJT05fQ0FMTF9OT1RfU1VQUE9SVEVEOlxuICAgICAgICAgICAgaWYgKGVycm9yLmNvbnRleHQgJiYgZXJyb3IuY29udGV4dC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY2FsbHMgJ1wiICsgZXJyb3IuY29udGV4dC5uYW1lICsgXCInXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJjYWxscyBhIGZ1bmN0aW9uXCI7XG4gICAgICAgIGNhc2UgUkVGRVJFTkNFX1RPX0xPQ0FMX1NZTUJPTDpcbiAgICAgICAgICAgIGlmIChlcnJvci5jb250ZXh0ICYmIGVycm9yLmNvbnRleHQubmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInJlZmVyZW5jZXMgbG9jYWwgdmFyaWFibGUgXCIgKyBlcnJvci5jb250ZXh0Lm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJyZWZlcmVuY2VzIGEgbG9jYWwgdmFyaWFibGVcIjtcbiAgICB9XG4gICAgcmV0dXJuICdjb250YWlucyB0aGUgZXJyb3InO1xufVxuZnVuY3Rpb24gbWFwU3RyaW5nTWFwKGlucHV0LCB0cmFuc2Zvcm0pIHtcbiAgICBpZiAoIWlucHV0KVxuICAgICAgICByZXR1cm4ge307XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGlucHV0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdHJhbnNmb3JtKGlucHV0W2tleV0sIGtleSk7XG4gICAgICAgIGlmICghc2hvdWxkSWdub3JlKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKEhJRERFTl9LRVkudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCB7IGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNQcmltaXRpdmUobykge1xuICAgIHJldHVybiBvID09PSBudWxsIHx8ICh0eXBlb2YgbyAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbyAhPT0gJ29iamVjdCcpO1xufVxudmFyIEJpbmRpbmdTY29wZSQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJpbmRpbmdTY29wZSgpIHtcbiAgICB9XG4gICAgQmluZGluZ1Njb3BlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlZmluZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudC5zaXplID4gMCA/IG5ldyBQb3B1bGF0ZWRTY29wZShjdXJyZW50KSA6IEJpbmRpbmdTY29wZS5lbXB0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEJpbmRpbmdTY29wZS5taXNzaW5nID0ge307XG4gICAgQmluZGluZ1Njb3BlLmVtcHR5ID0geyByZXNvbHZlOiBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gQmluZGluZ1Njb3BlLm1pc3Npbmc7IH0gfTtcbiAgICByZXR1cm4gQmluZGluZ1Njb3BlO1xufSgpKTtcbnZhciBQb3B1bGF0ZWRTY29wZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUG9wdWxhdGVkU2NvcGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUG9wdWxhdGVkU2NvcGUoYmluZGluZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYmluZGluZ3MgPSBiaW5kaW5ncztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQb3B1bGF0ZWRTY29wZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmdzLmhhcyhuYW1lKSA/IHRoaXMuYmluZGluZ3MuZ2V0KG5hbWUpIDogQmluZGluZ1Njb3BlJDEubWlzc2luZztcbiAgICB9O1xuICAgIHJldHVybiBQb3B1bGF0ZWRTY29wZTtcbn0oQmluZGluZ1Njb3BlJDEpKTtcbmZ1bmN0aW9uIGZvcm1hdE1ldGFkYXRhTWVzc2FnZUNoYWluKGNoYWluLCBhZHZpc2UpIHtcbiAgICB2YXIgZXhwYW5kZWQgPSBleHBhbmRlZE1lc3NhZ2UoY2hhaW4ubWVzc2FnZSwgY2hhaW4uY29udGV4dCk7XG4gICAgdmFyIG5lc3RpbmcgPSBjaGFpbi5zeW1ib2wgPyBcIiBpbiAnXCIgKyBjaGFpbi5zeW1ib2wubmFtZSArIFwiJ1wiIDogJyc7XG4gICAgdmFyIG1lc3NhZ2UgPSBcIlwiICsgZXhwYW5kZWQgKyBuZXN0aW5nO1xuICAgIHZhciBwb3NpdGlvbiA9IGNoYWluLnBvc2l0aW9uO1xuICAgIHZhciBuZXh0ID0gY2hhaW4ubmV4dCA/XG4gICAgICAgIGZvcm1hdE1ldGFkYXRhTWVzc2FnZUNoYWluKGNoYWluLm5leHQsIGFkdmlzZSkgOlxuICAgICAgICBhZHZpc2UgPyB7IG1lc3NhZ2U6IGFkdmlzZSB9IDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UsIHBvc2l0aW9uOiBwb3NpdGlvbiwgbmV4dDogbmV4dCB9O1xufVxuZnVuY3Rpb24gZm9ybWF0TWV0YWRhdGFFcnJvcihlLCBjb250ZXh0KSB7XG4gICAgaWYgKGlzTWV0YWRhdGFFcnJvcihlKSkge1xuICAgICAgICAvLyBQcm9kdWNlIGEgZm9ybWF0dGVkIHZlcnNpb24gb2YgdGhlIGFuZCBsZWF2aW5nIGVub3VnaCBpbmZvcm1hdGlvbiBpbiB0aGUgb3JpZ2luYWwgZXJyb3JcbiAgICAgICAgLy8gdG8gcmVjb3ZlciB0aGUgZm9ybWF0dGluZyBpbmZvcm1hdGlvbiB0byBldmVudHVhbGx5IHByb2R1Y2UgYSBkaWFnbm9zdGljIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGUucG9zaXRpb247XG4gICAgICAgIHZhciBjaGFpbiA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiRXJyb3IgZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGUgb2YgJ1wiICsgY29udGV4dC5uYW1lICsgXCInXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICBuZXh0OiB7IG1lc3NhZ2U6IGUubWVzc2FnZSwgbmV4dDogZS5jaGFpbiwgY29udGV4dDogZS5jb250ZXh0LCBzeW1ib2w6IGUuc3ltYm9sIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFkdmlzZSA9IGUuYWR2aXNlIHx8IG1lc3NhZ2VBZHZpc2UoZS5tZXNzYWdlLCBlLmNvbnRleHQpO1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVkRXJyb3IoZm9ybWF0TWV0YWRhdGFNZXNzYWdlQ2hhaW4oY2hhaW4sIGFkdmlzZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEFvdFN1bW1hcnlSZXNvbHZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBb3RTdW1tYXJ5UmVzb2x2ZXIoaG9zdCwgc3RhdGljU3ltYm9sQ2FjaGUpIHtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5zdGF0aWNTeW1ib2xDYWNoZSA9IHN0YXRpY1N5bWJvbENhY2hlO1xuICAgICAgICAvLyBOb3RlOiB0aGlzIHdpbGwgb25seSBjb250YWluIFN0YXRpY1N5bWJvbHMgd2l0aG91dCBtZW1iZXJzIVxuICAgICAgICB0aGlzLnN1bW1hcnlDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5sb2FkZWRGaWxlUGF0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE5vdGU6IHRoaXMgd2lsbCBvbmx5IGNvbnRhaW4gU3RhdGljU3ltYm9scyB3aXRob3V0IG1lbWJlcnMhXG4gICAgICAgIHRoaXMuaW1wb3J0QXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMua25vd25GaWxlTmFtZVRvTW9kdWxlTmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIEFvdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuaXNMaWJyYXJ5RmlsZSA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIHN0cmlwIHRoZSAubmdmYWN0b3J5LiBmaWxlIHBhdGgsXG4gICAgICAgIC8vIHNvIHRoaXMgbWV0aG9kIGFsc28gd29ya3MgZm9yIGdlbmVyYXRlZCBmaWxlc1xuICAgICAgICAvLyAoZm9yIHdoaWNoIGhvc3QuaXNTb3VyY2VGaWxlIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZSkuXG4gICAgICAgIHJldHVybiAhdGhpcy5ob3N0LmlzU291cmNlRmlsZShzdHJpcEdlbmVyYXRlZEZpbGVTdWZmaXgoZmlsZVBhdGgpKTtcbiAgICB9O1xuICAgIEFvdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUudG9TdW1tYXJ5RmlsZU5hbWUgPSBmdW5jdGlvbiAoZmlsZVBhdGgsIHJlZmVycmluZ1NyY0ZpbGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvc3QudG9TdW1tYXJ5RmlsZU5hbWUoZmlsZVBhdGgsIHJlZmVycmluZ1NyY0ZpbGVOYW1lKTtcbiAgICB9O1xuICAgIEFvdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuZnJvbVN1bW1hcnlGaWxlTmFtZSA9IGZ1bmN0aW9uIChmaWxlTmFtZSwgcmVmZXJyaW5nTGliRmlsZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdC5mcm9tU3VtbWFyeUZpbGVOYW1lKGZpbGVOYW1lLCByZWZlcnJpbmdMaWJGaWxlTmFtZSk7XG4gICAgfTtcbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmVTdW1tYXJ5ID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICB2YXIgcm9vdFN5bWJvbCA9IHN0YXRpY1N5bWJvbC5tZW1iZXJzLmxlbmd0aCA/XG4gICAgICAgICAgICB0aGlzLnN0YXRpY1N5bWJvbENhY2hlLmdldChzdGF0aWNTeW1ib2wuZmlsZVBhdGgsIHN0YXRpY1N5bWJvbC5uYW1lKSA6XG4gICAgICAgICAgICBzdGF0aWNTeW1ib2w7XG4gICAgICAgIHZhciBzdW1tYXJ5ID0gdGhpcy5zdW1tYXJ5Q2FjaGUuZ2V0KHJvb3RTeW1ib2wpO1xuICAgICAgICBpZiAoIXN1bW1hcnkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRTdW1tYXJ5RmlsZShzdGF0aWNTeW1ib2wuZmlsZVBhdGgpO1xuICAgICAgICAgICAgc3VtbWFyeSA9IHRoaXMuc3VtbWFyeUNhY2hlLmdldChzdGF0aWNTeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocm9vdFN5bWJvbCA9PT0gc3RhdGljU3ltYm9sICYmIHN1bW1hcnkpIHx8IG51bGw7XG4gICAgfTtcbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmdldFN5bWJvbHNPZiA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICBpZiAodGhpcy5fbG9hZFN1bW1hcnlGaWxlKGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zdW1tYXJ5Q2FjaGUua2V5cygpKS5maWx0ZXIoZnVuY3Rpb24gKHN5bWJvbCkgeyByZXR1cm4gc3ltYm9sLmZpbGVQYXRoID09PSBmaWxlUGF0aDsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmdldEltcG9ydEFzID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICBzdGF0aWNTeW1ib2wuYXNzZXJ0Tm9NZW1iZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmltcG9ydEFzLmdldChzdGF0aWNTeW1ib2wpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBmaWxlIHBhdGggdG8gYSBtb2R1bGUgbmFtZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIGBpbXBvcnRgLlxuICAgICAqL1xuICAgIEFvdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuZ2V0S25vd25Nb2R1bGVOYW1lID0gZnVuY3Rpb24gKGltcG9ydGVkRmlsZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua25vd25GaWxlTmFtZVRvTW9kdWxlTmFtZXMuZ2V0KGltcG9ydGVkRmlsZVBhdGgpIHx8IG51bGw7XG4gICAgfTtcbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmFkZFN1bW1hcnkgPSBmdW5jdGlvbiAoc3VtbWFyeSkgeyB0aGlzLnN1bW1hcnlDYWNoZS5zZXQoc3VtbWFyeS5zeW1ib2wsIHN1bW1hcnkpOyB9O1xuICAgIEFvdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuX2xvYWRTdW1tYXJ5RmlsZSA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaGFzU3VtbWFyeSA9IHRoaXMubG9hZGVkRmlsZVBhdGhzLmdldChmaWxlUGF0aCk7XG4gICAgICAgIGlmIChoYXNTdW1tYXJ5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNTdW1tYXJ5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBqc29uID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNMaWJyYXJ5RmlsZShmaWxlUGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBzdW1tYXJ5RmlsZVBhdGggPSBzdW1tYXJ5RmlsZU5hbWUoZmlsZVBhdGgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBqc29uID0gdGhpcy5ob3N0LmxvYWRTdW1tYXJ5KHN1bW1hcnlGaWxlUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIHN1bW1hcnkgZmlsZSBcIiArIHN1bW1hcnlGaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoYXNTdW1tYXJ5ID0ganNvbiAhPSBudWxsO1xuICAgICAgICB0aGlzLmxvYWRlZEZpbGVQYXRocy5zZXQoZmlsZVBhdGgsIGhhc1N1bW1hcnkpO1xuICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgICAgdmFyIF9hID0gZGVzZXJpYWxpemVTdW1tYXJpZXModGhpcy5zdGF0aWNTeW1ib2xDYWNoZSwgdGhpcywgZmlsZVBhdGgsIGpzb24pLCBtb2R1bGVOYW1lID0gX2EubW9kdWxlTmFtZSwgc3VtbWFyaWVzID0gX2Euc3VtbWFyaWVzLCBpbXBvcnRBcyA9IF9hLmltcG9ydEFzO1xuICAgICAgICAgICAgc3VtbWFyaWVzLmZvckVhY2goZnVuY3Rpb24gKHN1bW1hcnkpIHsgcmV0dXJuIF90aGlzLnN1bW1hcnlDYWNoZS5zZXQoc3VtbWFyeS5zeW1ib2wsIHN1bW1hcnkpOyB9KTtcbiAgICAgICAgICAgIGlmIChtb2R1bGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rbm93bkZpbGVOYW1lVG9Nb2R1bGVOYW1lcy5zZXQoZmlsZVBhdGgsIG1vZHVsZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1wb3J0QXMuZm9yRWFjaChmdW5jdGlvbiAoaW1wb3J0QXMpIHsgX3RoaXMuaW1wb3J0QXMuc2V0KGltcG9ydEFzLnN5bWJvbCwgaW1wb3J0QXMuaW1wb3J0QXMpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzU3VtbWFyeTtcbiAgICB9O1xuICAgIHJldHVybiBBb3RTdW1tYXJ5UmVzb2x2ZXI7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBjcmVhdGVBb3RVcmxSZXNvbHZlcihob3N0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzb2x2ZTogZnVuY3Rpb24gKGJhc2VQYXRoLCB1cmwpIHtcbiAgICAgICAgICAgIHZhciBmaWxlUGF0aCA9IGhvc3QucmVzb3VyY2VOYW1lVG9GaWxlTmFtZSh1cmwsIGJhc2VQYXRoKTtcbiAgICAgICAgICAgIGlmICghZmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIkNvdWxkbid0IHJlc29sdmUgcmVzb3VyY2UgXCIgKyB1cmwgKyBcIiBmcm9tIFwiICsgYmFzZVBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbGVQYXRoO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBBb3RDb21waWxlciBiYXNlZCBvbiBvcHRpb25zIGFuZCBhIGhvc3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFvdENvbXBpbGVyKGNvbXBpbGVySG9zdCwgb3B0aW9ucywgZXJyb3JDb2xsZWN0b3IpIHtcbiAgICB2YXIgdHJhbnNsYXRpb25zID0gb3B0aW9ucy50cmFuc2xhdGlvbnMgfHwgJyc7XG4gICAgdmFyIHVybFJlc29sdmVyID0gY3JlYXRlQW90VXJsUmVzb2x2ZXIoY29tcGlsZXJIb3N0KTtcbiAgICB2YXIgc3ltYm9sQ2FjaGUgPSBuZXcgU3RhdGljU3ltYm9sQ2FjaGUoKTtcbiAgICB2YXIgc3VtbWFyeVJlc29sdmVyID0gbmV3IEFvdFN1bW1hcnlSZXNvbHZlcihjb21waWxlckhvc3QsIHN5bWJvbENhY2hlKTtcbiAgICB2YXIgc3ltYm9sUmVzb2x2ZXIgPSBuZXcgU3RhdGljU3ltYm9sUmVzb2x2ZXIoY29tcGlsZXJIb3N0LCBzeW1ib2xDYWNoZSwgc3VtbWFyeVJlc29sdmVyKTtcbiAgICB2YXIgc3RhdGljUmVmbGVjdG9yID0gbmV3IFN0YXRpY1JlZmxlY3RvcihzdW1tYXJ5UmVzb2x2ZXIsIHN5bWJvbFJlc29sdmVyLCBbXSwgW10sIGVycm9yQ29sbGVjdG9yKTtcbiAgICB2YXIgaHRtbFBhcnNlcjtcbiAgICBpZiAoISFvcHRpb25zLmVuYWJsZUl2eSkge1xuICAgICAgICAvLyBJdnkgaGFuZGxlcyBpMThuIGF0IHRoZSBjb21waWxlciBsZXZlbCBzbyB3ZSBtdXN0IHVzZSBhIHJlZ3VsYXIgcGFyc2VyXG4gICAgICAgIGh0bWxQYXJzZXIgPSBuZXcgSHRtbFBhcnNlcigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaHRtbFBhcnNlciA9IG5ldyBJMThOSHRtbFBhcnNlcihuZXcgSHRtbFBhcnNlcigpLCB0cmFuc2xhdGlvbnMsIG9wdGlvbnMuaTE4bkZvcm1hdCwgb3B0aW9ucy5taXNzaW5nVHJhbnNsYXRpb24sIGNvbnNvbGUpO1xuICAgIH1cbiAgICB2YXIgY29uZmlnID0gbmV3IENvbXBpbGVyQ29uZmlnKHtcbiAgICAgICAgZGVmYXVsdEVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkLFxuICAgICAgICB1c2VKaXQ6IGZhbHNlLFxuICAgICAgICBtaXNzaW5nVHJhbnNsYXRpb246IG9wdGlvbnMubWlzc2luZ1RyYW5zbGF0aW9uLFxuICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZXMsXG4gICAgICAgIHN0cmljdEluamVjdGlvblBhcmFtZXRlcnM6IG9wdGlvbnMuc3RyaWN0SW5qZWN0aW9uUGFyYW1ldGVycyxcbiAgICB9KTtcbiAgICB2YXIgbm9ybWFsaXplciA9IG5ldyBEaXJlY3RpdmVOb3JtYWxpemVyKHsgZ2V0OiBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBjb21waWxlckhvc3QubG9hZFJlc291cmNlKHVybCk7IH0gfSwgdXJsUmVzb2x2ZXIsIGh0bWxQYXJzZXIsIGNvbmZpZyk7XG4gICAgdmFyIGV4cHJlc3Npb25QYXJzZXIgPSBuZXcgUGFyc2VyJDEobmV3IExleGVyKCkpO1xuICAgIHZhciBlbGVtZW50U2NoZW1hUmVnaXN0cnkgPSBuZXcgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCk7XG4gICAgdmFyIHRtcGxQYXJzZXIgPSBuZXcgVGVtcGxhdGVQYXJzZXIoY29uZmlnLCBzdGF0aWNSZWZsZWN0b3IsIGV4cHJlc3Npb25QYXJzZXIsIGVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgaHRtbFBhcnNlciwgY29uc29sZSwgW10pO1xuICAgIHZhciByZXNvbHZlciA9IG5ldyBDb21waWxlTWV0YWRhdGFSZXNvbHZlcihjb25maWcsIGh0bWxQYXJzZXIsIG5ldyBOZ01vZHVsZVJlc29sdmVyKHN0YXRpY1JlZmxlY3RvciksIG5ldyBEaXJlY3RpdmVSZXNvbHZlcihzdGF0aWNSZWZsZWN0b3IpLCBuZXcgUGlwZVJlc29sdmVyKHN0YXRpY1JlZmxlY3RvciksIHN1bW1hcnlSZXNvbHZlciwgZWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBub3JtYWxpemVyLCBjb25zb2xlLCBzeW1ib2xDYWNoZSwgc3RhdGljUmVmbGVjdG9yLCBlcnJvckNvbGxlY3Rvcik7XG4gICAgLy8gVE9ETyh2aWNiKTogZG8gbm90IHBhc3Mgb3B0aW9ucy5pMThuRm9ybWF0IGhlcmVcbiAgICB2YXIgdmlld0NvbXBpbGVyID0gbmV3IFZpZXdDb21waWxlcihzdGF0aWNSZWZsZWN0b3IpO1xuICAgIHZhciB0eXBlQ2hlY2tDb21waWxlciA9IG5ldyBUeXBlQ2hlY2tDb21waWxlcihvcHRpb25zLCBzdGF0aWNSZWZsZWN0b3IpO1xuICAgIHZhciBjb21waWxlciA9IG5ldyBBb3RDb21waWxlcihjb25maWcsIG9wdGlvbnMsIGNvbXBpbGVySG9zdCwgc3RhdGljUmVmbGVjdG9yLCByZXNvbHZlciwgdG1wbFBhcnNlciwgbmV3IFN0eWxlQ29tcGlsZXIodXJsUmVzb2x2ZXIpLCB2aWV3Q29tcGlsZXIsIHR5cGVDaGVja0NvbXBpbGVyLCBuZXcgTmdNb2R1bGVDb21waWxlcihzdGF0aWNSZWZsZWN0b3IpLCBuZXcgSW5qZWN0YWJsZUNvbXBpbGVyKHN0YXRpY1JlZmxlY3RvciwgISFvcHRpb25zLmVuYWJsZUl2eSksIG5ldyBUeXBlU2NyaXB0RW1pdHRlcigpLCBzdW1tYXJ5UmVzb2x2ZXIsIHN5bWJvbFJlc29sdmVyKTtcbiAgICByZXR1cm4geyBjb21waWxlcjogY29tcGlsZXIsIHJlZmxlY3Rvcjogc3RhdGljUmVmbGVjdG9yIH07XG59XG5cbnZhciBTdW1tYXJ5UmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3VtbWFyeVJlc29sdmVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gU3VtbWFyeVJlc29sdmVyO1xufSgpKTtcbnZhciBKaXRTdW1tYXJ5UmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSml0U3VtbWFyeVJlc29sdmVyKCkge1xuICAgICAgICB0aGlzLl9zdW1tYXJpZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIEppdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuaXNMaWJyYXJ5RmlsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIEppdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUudG9TdW1tYXJ5RmlsZU5hbWUgPSBmdW5jdGlvbiAoZmlsZU5hbWUpIHsgcmV0dXJuIGZpbGVOYW1lOyB9O1xuICAgIEppdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuZnJvbVN1bW1hcnlGaWxlTmFtZSA9IGZ1bmN0aW9uIChmaWxlTmFtZSkgeyByZXR1cm4gZmlsZU5hbWU7IH07XG4gICAgSml0U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlU3VtbWFyeSA9IGZ1bmN0aW9uIChyZWZlcmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1bW1hcmllcy5nZXQocmVmZXJlbmNlKSB8fCBudWxsO1xuICAgIH07XG4gICAgSml0U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5nZXRTeW1ib2xzT2YgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICBKaXRTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmdldEltcG9ydEFzID0gZnVuY3Rpb24gKHJlZmVyZW5jZSkgeyByZXR1cm4gcmVmZXJlbmNlOyB9O1xuICAgIEppdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuZ2V0S25vd25Nb2R1bGVOYW1lID0gZnVuY3Rpb24gKGZpbGVOYW1lKSB7IHJldHVybiBudWxsOyB9O1xuICAgIEppdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuYWRkU3VtbWFyeSA9IGZ1bmN0aW9uIChzdW1tYXJ5KSB7IHRoaXMuX3N1bW1hcmllcy5zZXQoc3VtbWFyeS5zeW1ib2wsIHN1bW1hcnkpOyB9O1xuICAgIHJldHVybiBKaXRTdW1tYXJ5UmVzb2x2ZXI7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBpbnRlcnByZXRTdGF0ZW1lbnRzKHN0YXRlbWVudHMsIHJlZmxlY3Rvcikge1xuICAgIHZhciBjdHggPSBuZXcgX0V4ZWN1dGlvbkNvbnRleHQobnVsbCwgbnVsbCwgbnVsbCwgbmV3IE1hcCgpKTtcbiAgICB2YXIgdmlzaXRvciA9IG5ldyBTdGF0ZW1lbnRJbnRlcnByZXRlcihyZWZsZWN0b3IpO1xuICAgIHZpc2l0b3IudmlzaXRBbGxTdGF0ZW1lbnRzKHN0YXRlbWVudHMsIGN0eCk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGN0eC5leHBvcnRzLmZvckVhY2goZnVuY3Rpb24gKGV4cG9ydE5hbWUpIHsgcmVzdWx0W2V4cG9ydE5hbWVdID0gY3R4LnZhcnMuZ2V0KGV4cG9ydE5hbWUpOyB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHModmFyTmFtZXMsIHZhclZhbHVlcywgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKSB7XG4gICAgdmFyIGNoaWxkQ3R4ID0gY3R4LmNyZWF0ZUNoaWxkV2lodExvY2FsVmFycygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hpbGRDdHgudmFycy5zZXQodmFyTmFtZXNbaV0sIHZhclZhbHVlc1tpXSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB2aXNpdG9yLnZpc2l0QWxsU3RhdGVtZW50cyhzdGF0ZW1lbnRzLCBjaGlsZEN0eCk7XG4gICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdC52YWx1ZSA6IG51bGw7XG59XG52YXIgX0V4ZWN1dGlvbkNvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX0V4ZWN1dGlvbkNvbnRleHQocGFyZW50LCBpbnN0YW5jZSwgY2xhc3NOYW1lLCB2YXJzKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgICAgICB0aGlzLmV4cG9ydHMgPSBbXTtcbiAgICB9XG4gICAgX0V4ZWN1dGlvbkNvbnRleHQucHJvdG90eXBlLmNyZWF0ZUNoaWxkV2lodExvY2FsVmFycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfRXhlY3V0aW9uQ29udGV4dCh0aGlzLCB0aGlzLmluc3RhbmNlLCB0aGlzLmNsYXNzTmFtZSwgbmV3IE1hcCgpKTtcbiAgICB9O1xuICAgIHJldHVybiBfRXhlY3V0aW9uQ29udGV4dDtcbn0oKSk7XG52YXIgUmV0dXJuVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmV0dXJuVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gUmV0dXJuVmFsdWU7XG59KCkpO1xuZnVuY3Rpb24gY3JlYXRlRHluYW1pY0NsYXNzKF9jbGFzc1N0bXQsIF9jdHgsIF92aXNpdG9yKSB7XG4gICAgdmFyIHByb3BlcnR5RGVzY3JpcHRvcnMgPSB7fTtcbiAgICBfY2xhc3NTdG10LmdldHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZ2V0dGVyKSB7XG4gICAgICAgIC8vIE5vdGU6IHVzZSBgZnVuY3Rpb25gIGluc3RlYWQgb2YgYXJyb3cgZnVuY3Rpb24gdG8gY2FwdHVyZSBgdGhpc2BcbiAgICAgICAgcHJvcGVydHlEZXNjcmlwdG9yc1tnZXR0ZXIubmFtZV0gPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlQ3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KF9jdHgsIHRoaXMsIF9jbGFzc1N0bXQubmFtZSwgX2N0eC52YXJzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHMoW10sIFtdLCBnZXR0ZXIuYm9keSwgaW5zdGFuY2VDdHgsIF92aXNpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBfY2xhc3NTdG10Lm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHZhciBwYXJhbU5hbWVzID0gbWV0aG9kLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAgICAgLy8gTm90ZTogdXNlIGBmdW5jdGlvbmAgaW5zdGVhZCBvZiBhcnJvdyBmdW5jdGlvbiB0byBjYXB0dXJlIGB0aGlzYFxuICAgICAgICBwcm9wZXJ0eURlc2NyaXB0b3JzW21ldGhvZC5uYW1lXSA9IHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VDdHggPSBuZXcgX0V4ZWN1dGlvbkNvbnRleHQoX2N0eCwgdGhpcywgX2NsYXNzU3RtdC5uYW1lLCBfY3R4LnZhcnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyhwYXJhbU5hbWVzLCBhcmdzLCBtZXRob2QuYm9keSwgaW5zdGFuY2VDdHgsIF92aXNpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgY3RvclBhcmFtTmFtZXMgPSBfY2xhc3NTdG10LmNvbnN0cnVjdG9yTWV0aG9kLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAvLyBOb3RlOiB1c2UgYGZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGFycm93IGZ1bmN0aW9uIHRvIGNhcHR1cmUgYHRoaXNgXG4gICAgdmFyIGN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluc3RhbmNlQ3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KF9jdHgsIHRoaXMsIF9jbGFzc1N0bXQubmFtZSwgX2N0eC52YXJzKTtcbiAgICAgICAgX2NsYXNzU3RtdC5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHsgX3RoaXNbZmllbGQubmFtZV0gPSB1bmRlZmluZWQ7IH0pO1xuICAgICAgICBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyhjdG9yUGFyYW1OYW1lcywgYXJncywgX2NsYXNzU3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5ib2R5LCBpbnN0YW5jZUN0eCwgX3Zpc2l0b3IpO1xuICAgIH07XG4gICAgdmFyIHN1cGVyQ2xhc3MgPSBfY2xhc3NTdG10LnBhcmVudCA/IF9jbGFzc1N0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbihfdmlzaXRvciwgX2N0eCkgOiBPYmplY3Q7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlLCBwcm9wZXJ0eURlc2NyaXB0b3JzKTtcbiAgICByZXR1cm4gY3Rvcjtcbn1cbnZhciBTdGF0ZW1lbnRJbnRlcnByZXRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZW1lbnRJbnRlcnByZXRlcihyZWZsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5yZWZsZWN0b3IgPSByZWZsZWN0b3I7XG4gICAgfVxuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS5kZWJ1Z0FzdCA9IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGRlYnVnT3V0cHV0QXN0QXNUeXBlU2NyaXB0KGFzdCk7IH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHZhciBpbml0aWFsVmFsdWUgPSBzdG10LnZhbHVlID8gc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY3R4LnZhcnMuc2V0KHN0bXQubmFtZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgaWYgKHN0bXQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLkV4cG9ydGVkKSkge1xuICAgICAgICAgICAgY3R4LmV4cG9ydHMucHVzaChzdG10Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0V3JpdGVWYXJFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB2YXIgY3VyckN0eCA9IGN0eDtcbiAgICAgICAgd2hpbGUgKGN1cnJDdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN1cnJDdHgudmFycy5oYXMoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGN1cnJDdHgudmFycy5zZXQoZXhwci5uYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyckN0eCA9IGN1cnJDdHgucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBkZWNsYXJlZCB2YXJpYWJsZSBcIiArIGV4cHIubmFtZSk7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRXcmFwcGVkTm9kZUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW50ZXJwcmV0IGEgV3JhcHBlZE5vZGVFeHByLicpO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0VHlwZW9mRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnRlcnByZXQgYSBUeXBlb2ZFeHByJyk7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgdmFyTmFtZSA9IGFzdC5uYW1lO1xuICAgICAgICBpZiAoYXN0LmJ1aWx0aW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoIChhc3QuYnVpbHRpbikge1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5TdXBlcjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihjdHguaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5UaGlzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaEVycm9yOlxuICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gQ0FUQ0hfRVJST1JfVkFSJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaFN0YWNrOlxuICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gQ0FUQ0hfU1RBQ0tfVkFSJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiB2YXJpYWJsZSBcIiArIGFzdC5idWlsdGluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VyckN0eCA9IGN0eDtcbiAgICAgICAgd2hpbGUgKGN1cnJDdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN1cnJDdHgudmFycy5oYXModmFyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyckN0eC52YXJzLmdldCh2YXJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJDdHggPSBjdXJyQ3R4LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgZGVjbGFyZWQgdmFyaWFibGUgXCIgKyB2YXJOYW1lKTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIGluZGV4ID0gZXhwci5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIHZhbHVlID0gZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmVjZWl2ZXJbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFdyaXRlUHJvcEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciByZWNlaXZlciA9IGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJlY2VpdmVyW2V4cHIubmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0SW52b2tlTWV0aG9kRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoZXhwci5hcmdzLCBjdHgpO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAoZXhwci5idWlsdGluICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXhwci5idWlsdGluKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5OlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlci5jb25jYXQuYXBwbHkocmVjZWl2ZXIsIF9fc3ByZWFkKGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyLnN1YnNjcmliZSh7IG5leHQ6IGFyZ3NbMF0gfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5CaW5kOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlci5iaW5kLmFwcGx5KHJlY2VpdmVyLCBfX3NwcmVhZChhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiBtZXRob2QgXCIgKyBleHByLmJ1aWx0aW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXJbZXhwci5uYW1lXS5hcHBseShyZWNlaXZlciwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoc3RtdC5hcmdzLCBjdHgpO1xuICAgICAgICB2YXIgZm5FeHByID0gc3RtdC5mbjtcbiAgICAgICAgaWYgKGZuRXhwciBpbnN0YW5jZW9mIFJlYWRWYXJFeHByICYmIGZuRXhwci5idWlsdGluID09PSBCdWlsdGluVmFyLlN1cGVyKSB7XG4gICAgICAgICAgICBjdHguaW5zdGFuY2UuY29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yLmFwcGx5KGN0eC5pbnN0YW5jZSwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmbiA9IHN0bXQuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFJldHVyblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmV0dXJuVmFsdWUoc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KSk7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgY2xhenogPSBjcmVhdGVEeW5hbWljQ2xhc3Moc3RtdCwgY3R4LCB0aGlzKTtcbiAgICAgICAgY3R4LnZhcnMuc2V0KHN0bXQubmFtZSwgY2xhenopO1xuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRXhwb3J0ZWQpKSB7XG4gICAgICAgICAgICBjdHguZXhwb3J0cy5wdXNoKHN0bXQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdElmU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdG10LmZhbHNlQ2FzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5ib2R5U3RtdHMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEN0eCA9IGN0eC5jcmVhdGVDaGlsZFdpaHRMb2NhbFZhcnMoKTtcbiAgICAgICAgICAgIGNoaWxkQ3R4LnZhcnMuc2V0KENBVENIX0VSUk9SX1ZBUiQyLCBlKTtcbiAgICAgICAgICAgIGNoaWxkQ3R4LnZhcnMuc2V0KENBVENIX1NUQUNLX1ZBUiQyLCBlLnN0YWNrKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNhdGNoU3RtdHMsIGNoaWxkQ3R4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0VGhyb3dTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB0aHJvdyBzdG10LmVycm9yLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRKU0RvY0NvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjdHgpO1xuICAgICAgICB2YXIgY2xhenogPSBhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICByZXR1cm4gbmV3IChjbGF6ei5iaW5kLmFwcGx5KGNsYXp6LCBfX3NwcmVhZChbdm9pZCAwXSwgYXJncykpKSgpO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgcmV0dXJuIGFzdC52YWx1ZTsgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShhc3QudmFsdWUpO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGlmIChhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN0LnRydWVDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdC5mYWxzZUNhc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzdC5mYWxzZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXROb3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHJldHVybiAhYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEFzc2VydE5vdE51bGxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHJldHVybiBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgcGFyYW1OYW1lcyA9IGFzdC5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0ubmFtZTsgfSk7XG4gICAgICAgIHJldHVybiBfZGVjbGFyZUZuKHBhcmFtTmFtZXMsIGFzdC5zdGF0ZW1lbnRzLCBjdHgsIHRoaXMpO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIHBhcmFtTmFtZXMgPSBzdG10LnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAgICAgY3R4LnZhcnMuc2V0KHN0bXQubmFtZSwgX2RlY2xhcmVGbihwYXJhbU5hbWVzLCBzdG10LnN0YXRlbWVudHMsIGN0eCwgdGhpcykpO1xuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRXhwb3J0ZWQpKSB7XG4gICAgICAgICAgICBjdHguZXhwb3J0cy5wdXNoKHN0bXQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxocyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzdC5saHMudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9O1xuICAgICAgICB2YXIgcmhzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gYXN0LnJocy52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH07XG4gICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkVxdWFsczpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPT0gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPT09IHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICE9IHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICE9PSByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQW5kOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAmJiByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuT3I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpIHx8IHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5QbHVzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSArIHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NaW51czpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgLSByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRGl2aWRlOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAvIHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NdWx0aXBseTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgKiByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTW9kdWxvOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAlIHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPCByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpIDw9IHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpID4gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFsczpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPj0gcmhzKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3IgXCIgKyBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRSZWFkUHJvcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICByZXN1bHQgPSByZWNlaXZlclthc3QubmFtZV07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRSZWFkS2V5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHZhciBwcm9wID0gYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICByZXR1cm4gcmVjZWl2ZXJbcHJvcF07XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmVudHJpZXMsIGN0eCk7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGFzdC5lbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiByZXN1bHRbZW50cnkua2V5XSA9IGVudHJ5LnZhbHVlLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY3R4KTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRDb21tYUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LnBhcnRzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRBbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHByZXNzaW9ucywgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9KTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RhdGVtZW50cywgY3R4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0bXQgPSBzdGF0ZW1lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbCA9IHN0bXQudmlzaXRTdGF0ZW1lbnQodGhpcywgY3R4KTtcbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBSZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVtZW50SW50ZXJwcmV0ZXI7XG59KCkpO1xuZnVuY3Rpb24gX2RlY2xhcmVGbih2YXJOYW1lcywgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHModmFyTmFtZXMsIGFyZ3MsIHN0YXRlbWVudHMsIGN0eCwgdmlzaXRvcik7XG4gICAgfTtcbn1cbnZhciBDQVRDSF9FUlJPUl9WQVIkMiA9ICdlcnJvcic7XG52YXIgQ0FUQ0hfU1RBQ0tfVkFSJDIgPSAnc3RhY2snO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEFuIGludGVybmFsIG1vZHVsZSBvZiB0aGUgQW5ndWxhciBjb21waWxlciB0aGF0IGJlZ2lucyB3aXRoIGNvbXBvbmVudCB0eXBlcyxcbiAqIGV4dHJhY3RzIHRlbXBsYXRlcywgYW5kIGV2ZW50dWFsbHkgcHJvZHVjZXMgYSBjb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBjb21wb25lbnRcbiAqIHJlYWR5IGZvciBsaW5raW5nIGludG8gYW4gYXBwbGljYXRpb24uXG4gKlxuICogQHNlY3VyaXR5ICBXaGVuIGNvbXBpbGluZyB0ZW1wbGF0ZXMgYXQgcnVudGltZSwgeW91IG11c3QgZW5zdXJlIHRoYXQgdGhlIGVudGlyZSB0ZW1wbGF0ZSBjb21lc1xuICogZnJvbSBhIHRydXN0ZWQgc291cmNlLiBBdHRhY2tlci1jb250cm9sbGVkIGRhdGEgaW50cm9kdWNlZCBieSBhIHRlbXBsYXRlIGNvdWxkIGV4cG9zZSB5b3VyXG4gKiBhcHBsaWNhdGlvbiB0byBYU1Mgcmlza3MuICBGb3IgbW9yZSBkZXRhaWwsIHNlZSB0aGUgW1NlY3VyaXR5IEd1aWRlXShodHRwOi8vZy5jby9uZy9zZWN1cml0eSkuXG4gKi9cbnZhciBKaXRDb21waWxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKaXRDb21waWxlcihfbWV0YWRhdGFSZXNvbHZlciwgX3RlbXBsYXRlUGFyc2VyLCBfc3R5bGVDb21waWxlciwgX3ZpZXdDb21waWxlciwgX25nTW9kdWxlQ29tcGlsZXIsIF9zdW1tYXJ5UmVzb2x2ZXIsIF9yZWZsZWN0b3IsIF9qaXRFdmFsdWF0b3IsIF9jb21waWxlckNvbmZpZywgX2NvbnNvbGUsIGdldEV4dHJhTmdNb2R1bGVQcm92aWRlcnMpIHtcbiAgICAgICAgdGhpcy5fbWV0YWRhdGFSZXNvbHZlciA9IF9tZXRhZGF0YVJlc29sdmVyO1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZVBhcnNlciA9IF90ZW1wbGF0ZVBhcnNlcjtcbiAgICAgICAgdGhpcy5fc3R5bGVDb21waWxlciA9IF9zdHlsZUNvbXBpbGVyO1xuICAgICAgICB0aGlzLl92aWV3Q29tcGlsZXIgPSBfdmlld0NvbXBpbGVyO1xuICAgICAgICB0aGlzLl9uZ01vZHVsZUNvbXBpbGVyID0gX25nTW9kdWxlQ29tcGlsZXI7XG4gICAgICAgIHRoaXMuX3N1bW1hcnlSZXNvbHZlciA9IF9zdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgICAgIHRoaXMuX2ppdEV2YWx1YXRvciA9IF9qaXRFdmFsdWF0b3I7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVyQ29uZmlnID0gX2NvbXBpbGVyQ29uZmlnO1xuICAgICAgICB0aGlzLl9jb25zb2xlID0gX2NvbnNvbGU7XG4gICAgICAgIHRoaXMuZ2V0RXh0cmFOZ01vZHVsZVByb3ZpZGVycyA9IGdldEV4dHJhTmdNb2R1bGVQcm92aWRlcnM7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWRIb3N0VGVtcGxhdGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWREaXJlY3RpdmVXcmFwcGVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fc2hhcmVkU3R5bGVzaGVldENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fYWRkZWRBb3RTdW1tYXJpZXMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiBTeW5jQXN5bmMuYXNzZXJ0U3luYyh0aGlzLl9jb21waWxlTW9kdWxlQW5kQ29tcG9uZW50cyhtb2R1bGVUeXBlLCB0cnVlKSk7XG4gICAgfTtcbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9jb21waWxlTW9kdWxlQW5kQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBmYWxzZSkpO1xuICAgIH07XG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiBTeW5jQXN5bmMuYXNzZXJ0U3luYyh0aGlzLl9jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50cyhtb2R1bGVUeXBlLCB0cnVlKSk7XG4gICAgfTtcbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHMobW9kdWxlVHlwZSwgZmFsc2UpKTtcbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5nZXRDb21wb25lbnRGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgc3VtbWFyeSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlU3VtbWFyeShjb21wb25lbnQpO1xuICAgICAgICByZXR1cm4gc3VtbWFyeS5jb21wb25lbnRGYWN0b3J5O1xuICAgIH07XG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLmxvYWRBb3RTdW1tYXJpZXMgPSBmdW5jdGlvbiAoc3VtbWFyaWVzKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgICAgICB0aGlzLl9hZGRBb3RTdW1tYXJpZXMoc3VtbWFyaWVzKTtcbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fYWRkQW90U3VtbWFyaWVzID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLl9hZGRlZEFvdFN1bW1hcmllcy5oYXMoZm4pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWRkZWRBb3RTdW1tYXJpZXMuYWRkKGZuKTtcbiAgICAgICAgdmFyIHN1bW1hcmllcyA9IGZuKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VtbWFyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBzdW1tYXJpZXNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQW90U3VtbWFyaWVzKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdW1tYXJ5ID0gZW50cnk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3VtbWFyeVJlc29sdmVyLmFkZFN1bW1hcnkoeyBzeW1ib2w6IHN1bW1hcnkudHlwZS5yZWZlcmVuY2UsIG1ldGFkYXRhOiBudWxsLCB0eXBlOiBzdW1tYXJ5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuaGFzQW90U3VtbWFyeSA9IGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuICEhdGhpcy5fc3VtbWFyeVJlc29sdmVyLnJlc29sdmVTdW1tYXJ5KHJlZik7IH07XG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9maWx0ZXJKaXRJZGVudGlmaWVycyA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGlkcy5tYXAoZnVuY3Rpb24gKG1vZCkgeyByZXR1cm4gbW9kLnJlZmVyZW5jZTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuICFfdGhpcy5oYXNBb3RTdW1tYXJ5KHJlZik7IH0pO1xuICAgIH07XG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlTW9kdWxlQW5kQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCBpc1N5bmMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFN5bmNBc3luYy50aGVuKHRoaXMuX2xvYWRNb2R1bGVzKG1vZHVsZVR5cGUsIGlzU3luYyksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9jb21waWxlQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY29tcGlsZU1vZHVsZShtb2R1bGVUeXBlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGlzU3luYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gU3luY0FzeW5jLnRoZW4odGhpcy5fbG9hZE1vZHVsZXMobW9kdWxlVHlwZSwgaXNTeW5jKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudEZhY3RvcmllcyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMuX2NvbXBpbGVDb21wb25lbnRzKG1vZHVsZVR5cGUsIGNvbXBvbmVudEZhY3Rvcmllcyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5nTW9kdWxlRmFjdG9yeTogX3RoaXMuX2NvbXBpbGVNb2R1bGUobW9kdWxlVHlwZSksXG4gICAgICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yaWVzOiBjb21wb25lbnRGYWN0b3JpZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9sb2FkTW9kdWxlcyA9IGZ1bmN0aW9uIChtYWluTW9kdWxlLCBpc1N5bmMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxvYWRpbmcgPSBbXTtcbiAgICAgICAgdmFyIG1haW5OZ01vZHVsZSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShtYWluTW9kdWxlKTtcbiAgICAgICAgLy8gTm90ZTogZm9yIHJ1bnRpbWUgY29tcGlsYXRpb24sIHdlIHdhbnQgdG8gdHJhbnNpdGl2ZWx5IGNvbXBpbGUgYWxsIG1vZHVsZXMsXG4gICAgICAgIC8vIHNvIHdlIGFsc28gbmVlZCB0byBsb2FkIHRoZSBkZWNsYXJlZCBkaXJlY3RpdmVzIC8gcGlwZXMgZm9yIGFsbCBuZXN0ZWQgbW9kdWxlcy5cbiAgICAgICAgdGhpcy5fZmlsdGVySml0SWRlbnRpZmllcnMobWFpbk5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcykuZm9yRWFjaChmdW5jdGlvbiAobmVzdGVkTmdNb2R1bGUpIHtcbiAgICAgICAgICAgIC8vIGdldE5nTW9kdWxlTWV0YWRhdGEgb25seSByZXR1cm5zIG51bGwgaWYgdGhlIHZhbHVlIHBhc3NlZCBpbiBpcyBub3QgYW4gTmdNb2R1bGVcbiAgICAgICAgICAgIHZhciBtb2R1bGVNZXRhID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShuZXN0ZWROZ01vZHVsZSk7XG4gICAgICAgICAgICBfdGhpcy5fZmlsdGVySml0SWRlbnRpZmllcnMobW9kdWxlTWV0YS5kZWNsYXJlZERpcmVjdGl2ZXMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIubG9hZERpcmVjdGl2ZU1ldGFkYXRhKG1vZHVsZU1ldGEudHlwZS5yZWZlcmVuY2UsIHJlZiwgaXNTeW5jKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5fZmlsdGVySml0SWRlbnRpZmllcnMobW9kdWxlTWV0YS5kZWNsYXJlZFBpcGVzKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE9yTG9hZFBpcGVNZXRhZGF0YShyZWYpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBTeW5jQXN5bmMuYWxsKGxvYWRpbmcpO1xuICAgIH07XG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgdmFyIG5nTW9kdWxlRmFjdG9yeSA9IHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZS5nZXQobW9kdWxlVHlwZSk7XG4gICAgICAgIGlmICghbmdNb2R1bGVGYWN0b3J5KSB7XG4gICAgICAgICAgICB2YXIgbW9kdWxlTWV0YSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgIC8vIEFsd2F5cyBwcm92aWRlIGEgYm91bmQgQ29tcGlsZXJcbiAgICAgICAgICAgIHZhciBleHRyYVByb3ZpZGVycyA9IHRoaXMuZ2V0RXh0cmFOZ01vZHVsZVByb3ZpZGVycyhtb2R1bGVNZXRhLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHZhciBvdXRwdXRDdHggPSBjcmVhdGVPdXRwdXRDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgY29tcGlsZVJlc3VsdCA9IHRoaXMuX25nTW9kdWxlQ29tcGlsZXIuY29tcGlsZShvdXRwdXRDdHgsIG1vZHVsZU1ldGEsIGV4dHJhUHJvdmlkZXJzKTtcbiAgICAgICAgICAgIG5nTW9kdWxlRmFjdG9yeSA9IHRoaXMuX2ludGVycHJldE9ySml0KG5nTW9kdWxlSml0VXJsKG1vZHVsZU1ldGEpLCBvdXRwdXRDdHguc3RhdGVtZW50cylbY29tcGlsZVJlc3VsdC5uZ01vZHVsZUZhY3RvcnlWYXJdO1xuICAgICAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLnNldChtb2R1bGVNZXRhLnR5cGUucmVmZXJlbmNlLCBuZ01vZHVsZUZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZ01vZHVsZUZhY3Rvcnk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb21wb25lbnRzID0gZnVuY3Rpb24gKG1haW5Nb2R1bGUsIGFsbENvbXBvbmVudEZhY3Rvcmllcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbmdNb2R1bGUgPSB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobWFpbk1vZHVsZSk7XG4gICAgICAgIHZhciBtb2R1bGVCeUppdERpcmVjdGl2ZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIHRlbXBsYXRlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIHRyYW5zSml0TW9kdWxlcyA9IHRoaXMuX2ZpbHRlckppdElkZW50aWZpZXJzKG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcyk7XG4gICAgICAgIHRyYW5zSml0TW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChsb2NhbE1vZCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsTW9kdWxlTWV0YSA9IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobG9jYWxNb2QpO1xuICAgICAgICAgICAgX3RoaXMuX2ZpbHRlckppdElkZW50aWZpZXJzKGxvY2FsTW9kdWxlTWV0YS5kZWNsYXJlZERpcmVjdGl2ZXMpLmZvckVhY2goZnVuY3Rpb24gKGRpclJlZikge1xuICAgICAgICAgICAgICAgIG1vZHVsZUJ5Sml0RGlyZWN0aXZlLnNldChkaXJSZWYsIGxvY2FsTW9kdWxlTWV0YSk7XG4gICAgICAgICAgICAgICAgdmFyIGRpck1ldGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YShkaXJSZWYpO1xuICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcy5hZGQoX3RoaXMuX2NyZWF0ZUNvbXBpbGVkVGVtcGxhdGUoZGlyTWV0YSwgbG9jYWxNb2R1bGVNZXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxDb21wb25lbnRGYWN0b3JpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShkaXJNZXRhLnR5cGUucmVmZXJlbmNlLCBsb2NhbE1vZHVsZU1ldGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLmFkZCh0ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxDb21wb25lbnRGYWN0b3JpZXMucHVzaChkaXJNZXRhLmNvbXBvbmVudEZhY3RvcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cmFuc0ppdE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxNb2QpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbE1vZHVsZU1ldGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKGxvY2FsTW9kKTtcbiAgICAgICAgICAgIF90aGlzLl9maWx0ZXJKaXRJZGVudGlmaWVycyhsb2NhbE1vZHVsZU1ldGEuZGVjbGFyZWREaXJlY3RpdmVzKS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJSZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlyTWV0YSA9IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKGRpclJlZik7XG4gICAgICAgICAgICAgICAgaWYgKGRpck1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyTWV0YS5lbnRyeUNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnlDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kdWxlTWV0YSA9IG1vZHVsZUJ5Sml0RGlyZWN0aXZlLmdldChlbnRyeUNvbXBvbmVudFR5cGUuY29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShlbnRyeUNvbXBvbmVudFR5cGUuY29tcG9uZW50VHlwZSwgbW9kdWxlTWV0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvY2FsTW9kdWxlTWV0YS5lbnRyeUNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnlDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5oYXNBb3RTdW1tYXJ5KGVudHJ5Q29tcG9uZW50VHlwZS5jb21wb25lbnRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kdWxlTWV0YSA9IG1vZHVsZUJ5Sml0RGlyZWN0aXZlLmdldChlbnRyeUNvbXBvbmVudFR5cGUuY29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcy5hZGQoX3RoaXMuX2NyZWF0ZUNvbXBpbGVkSG9zdFRlbXBsYXRlKGVudHJ5Q29tcG9uZW50VHlwZS5jb21wb25lbnRUeXBlLCBtb2R1bGVNZXRhKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0ZW1wbGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAodGVtcGxhdGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlVGVtcGxhdGUodGVtcGxhdGUpOyB9KTtcbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlRm9yID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5jbGVhckNhY2hlRm9yKHR5cGUpO1xuICAgICAgICB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE5vdGU6IGRvbid0IGNsZWFyIHRoZSBfYWRkZWRBb3RTdW1tYXJpZXMsIGFzIHRoZXkgZG9uJ3QgY2hhbmdlIVxuICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLmNsZWFyKCk7XG4gICAgfTtcbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2NyZWF0ZUNvbXBpbGVkSG9zdFRlbXBsYXRlID0gZnVuY3Rpb24gKGNvbXBUeXBlLCBuZ01vZHVsZSkge1xuICAgICAgICBpZiAoIW5nTW9kdWxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wb25lbnQgXCIgKyBzdHJpbmdpZnkoY29tcFR5cGUpICsgXCIgaXMgbm90IHBhcnQgb2YgYW55IE5nTW9kdWxlIG9yIHRoZSBtb2R1bGUgaGFzIG5vdCBiZWVuIGltcG9ydGVkIGludG8geW91ciBtb2R1bGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21waWxlZFRlbXBsYXRlID0gdGhpcy5fY29tcGlsZWRIb3N0VGVtcGxhdGVDYWNoZS5nZXQoY29tcFR5cGUpO1xuICAgICAgICBpZiAoIWNvbXBpbGVkVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHZhciBjb21wTWV0YSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoY29tcFR5cGUpO1xuICAgICAgICAgICAgYXNzZXJ0Q29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgICAgIHZhciBob3N0TWV0YSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0SG9zdENvbXBvbmVudE1ldGFkYXRhKGNvbXBNZXRhLCBjb21wTWV0YS5jb21wb25lbnRGYWN0b3J5LnZpZXdEZWZGYWN0b3J5KTtcbiAgICAgICAgICAgIGNvbXBpbGVkVGVtcGxhdGUgPVxuICAgICAgICAgICAgICAgIG5ldyBDb21waWxlZFRlbXBsYXRlKHRydWUsIGNvbXBNZXRhLnR5cGUsIGhvc3RNZXRhLCBuZ01vZHVsZSwgW2NvbXBNZXRhLnR5cGVdKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuc2V0KGNvbXBUeXBlLCBjb21waWxlZFRlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGlsZWRUZW1wbGF0ZTtcbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fY3JlYXRlQ29tcGlsZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChjb21wTWV0YSwgbmdNb2R1bGUpIHtcbiAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuZ2V0KGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgaWYgKCFjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICBhc3NlcnRDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgICAgY29tcGlsZWRUZW1wbGF0ZSA9IG5ldyBDb21waWxlZFRlbXBsYXRlKGZhbHNlLCBjb21wTWV0YS50eXBlLCBjb21wTWV0YSwgbmdNb2R1bGUsIG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUuZGlyZWN0aXZlcyk7XG4gICAgICAgICAgICB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuc2V0KGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlLCBjb21waWxlZFRlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGlsZWRUZW1wbGF0ZTtcbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZVRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5pc0NvbXBpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBNZXRhID0gdGVtcGxhdGUuY29tcE1ldGE7XG4gICAgICAgIHZhciBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBvdXRwdXRDb250ZXh0ID0gY3JlYXRlT3V0cHV0Q29udGV4dCgpO1xuICAgICAgICB2YXIgY29tcG9uZW50U3R5bGVzaGVldCA9IHRoaXMuX3N0eWxlQ29tcGlsZXIuY29tcGlsZUNvbXBvbmVudChvdXRwdXRDb250ZXh0LCBjb21wTWV0YSk7XG4gICAgICAgIGNvbXBNZXRhLnRlbXBsYXRlLmV4dGVybmFsU3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVzaGVldE1ldGEpIHtcbiAgICAgICAgICAgIHZhciBjb21waWxlZFN0eWxlc2hlZXQgPSBfdGhpcy5fc3R5bGVDb21waWxlci5jb21waWxlU3R5bGVzKGNyZWF0ZU91dHB1dENvbnRleHQoKSwgY29tcE1ldGEsIHN0eWxlc2hlZXRNZXRhKTtcbiAgICAgICAgICAgIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybC5zZXQoc3R5bGVzaGVldE1ldGEubW9kdWxlVXJsLCBjb21waWxlZFN0eWxlc2hlZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVN0eWxlc0NvbXBpbGVSZXN1bHQoY29tcG9uZW50U3R5bGVzaGVldCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKTtcbiAgICAgICAgdmFyIHBpcGVzID0gdGVtcGxhdGUubmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5waXBlcy5tYXAoZnVuY3Rpb24gKHBpcGUpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldFBpcGVTdW1tYXJ5KHBpcGUucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3BhcnNlVGVtcGxhdGUoY29tcE1ldGEsIHRlbXBsYXRlLm5nTW9kdWxlLCB0ZW1wbGF0ZS5kaXJlY3RpdmVzKSwgcGFyc2VkVGVtcGxhdGUgPSBfYS50ZW1wbGF0ZSwgdXNlZFBpcGVzID0gX2EucGlwZXM7XG4gICAgICAgIHZhciBjb21waWxlUmVzdWx0ID0gdGhpcy5fdmlld0NvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQob3V0cHV0Q29udGV4dCwgY29tcE1ldGEsIHBhcnNlZFRlbXBsYXRlLCB2YXJpYWJsZShjb21wb25lbnRTdHlsZXNoZWV0LnN0eWxlc1ZhciksIHVzZWRQaXBlcyk7XG4gICAgICAgIHZhciBldmFsUmVzdWx0ID0gdGhpcy5faW50ZXJwcmV0T3JKaXQodGVtcGxhdGVKaXRVcmwodGVtcGxhdGUubmdNb2R1bGUudHlwZSwgdGVtcGxhdGUuY29tcE1ldGEpLCBvdXRwdXRDb250ZXh0LnN0YXRlbWVudHMpO1xuICAgICAgICB2YXIgdmlld0NsYXNzID0gZXZhbFJlc3VsdFtjb21waWxlUmVzdWx0LnZpZXdDbGFzc1Zhcl07XG4gICAgICAgIHZhciByZW5kZXJlclR5cGUgPSBldmFsUmVzdWx0W2NvbXBpbGVSZXN1bHQucmVuZGVyZXJUeXBlVmFyXTtcbiAgICAgICAgdGVtcGxhdGUuY29tcGlsZWQodmlld0NsYXNzLCByZW5kZXJlclR5cGUpO1xuICAgIH07XG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9wYXJzZVRlbXBsYXRlID0gZnVuY3Rpb24gKGNvbXBNZXRhLCBuZ01vZHVsZSwgZGlyZWN0aXZlSWRlbnRpZmllcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gTm90ZTogISBpcyBvayBoZXJlIGFzIGNvbXBvbmVudHMgYWx3YXlzIGhhdmUgYSB0ZW1wbGF0ZS5cbiAgICAgICAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZXMgPSBjb21wTWV0YS50ZW1wbGF0ZS5wcmVzZXJ2ZVdoaXRlc3BhY2VzO1xuICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZUlkZW50aWZpZXJzLm1hcChmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVTdW1tYXJ5KGRpci5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgdmFyIHBpcGVzID0gbmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5waXBlcy5tYXAoZnVuY3Rpb24gKHBpcGUpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldFBpcGVTdW1tYXJ5KHBpcGUucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZVBhcnNlci5wYXJzZShjb21wTWV0YSwgY29tcE1ldGEudGVtcGxhdGUuaHRtbEFzdCwgZGlyZWN0aXZlcywgcGlwZXMsIG5nTW9kdWxlLnNjaGVtYXMsIHRlbXBsYXRlU291cmNlVXJsKG5nTW9kdWxlLnR5cGUsIGNvbXBNZXRhLCBjb21wTWV0YS50ZW1wbGF0ZSksIHByZXNlcnZlV2hpdGVzcGFjZXMpO1xuICAgIH07XG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9yZXNvbHZlU3R5bGVzQ29tcGlsZVJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXN1bHQuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCwgaSkge1xuICAgICAgICAgICAgdmFyIG5lc3RlZENvbXBpbGVSZXN1bHQgPSBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwuZ2V0KGRlcC5tb2R1bGVVcmwpO1xuICAgICAgICAgICAgdmFyIG5lc3RlZFN0eWxlc0FyciA9IF90aGlzLl9yZXNvbHZlQW5kRXZhbFN0eWxlc0NvbXBpbGVSZXN1bHQobmVzdGVkQ29tcGlsZVJlc3VsdCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKTtcbiAgICAgICAgICAgIGRlcC5zZXRWYWx1ZShuZXN0ZWRTdHlsZXNBcnIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fcmVzb2x2ZUFuZEV2YWxTdHlsZXNDb21waWxlUmVzdWx0ID0gZnVuY3Rpb24gKHJlc3VsdCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVTdHlsZXNDb21waWxlUmVzdWx0KHJlc3VsdCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVycHJldE9ySml0KHNoYXJlZFN0eWxlc2hlZXRKaXRVcmwocmVzdWx0Lm1ldGEsIHRoaXMuX3NoYXJlZFN0eWxlc2hlZXRDb3VudCsrKSwgcmVzdWx0Lm91dHB1dEN0eC5zdGF0ZW1lbnRzKVtyZXN1bHQuc3R5bGVzVmFyXTtcbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5faW50ZXJwcmV0T3JKaXQgPSBmdW5jdGlvbiAoc291cmNlVXJsLCBzdGF0ZW1lbnRzKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29tcGlsZXJDb25maWcudXNlSml0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJwcmV0U3RhdGVtZW50cyhzdGF0ZW1lbnRzLCB0aGlzLl9yZWZsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ppdEV2YWx1YXRvci5ldmFsdWF0ZVN0YXRlbWVudHMoc291cmNlVXJsLCBzdGF0ZW1lbnRzLCB0aGlzLl9yZWZsZWN0b3IsIHRoaXMuX2NvbXBpbGVyQ29uZmlnLmppdERldk1vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSml0Q29tcGlsZXI7XG59KCkpO1xudmFyIENvbXBpbGVkVGVtcGxhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGlsZWRUZW1wbGF0ZShpc0hvc3QsIGNvbXBUeXBlLCBjb21wTWV0YSwgbmdNb2R1bGUsIGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgdGhpcy5pc0hvc3QgPSBpc0hvc3Q7XG4gICAgICAgIHRoaXMuY29tcFR5cGUgPSBjb21wVHlwZTtcbiAgICAgICAgdGhpcy5jb21wTWV0YSA9IGNvbXBNZXRhO1xuICAgICAgICB0aGlzLm5nTW9kdWxlID0gbmdNb2R1bGU7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgICAgIHRoaXMuX3ZpZXdDbGFzcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNDb21waWxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBDb21waWxlZFRlbXBsYXRlLnByb3RvdHlwZS5jb21waWxlZCA9IGZ1bmN0aW9uICh2aWV3Q2xhc3MsIHJlbmRlcmVyVHlwZSkge1xuICAgICAgICB0aGlzLl92aWV3Q2xhc3MgPSB2aWV3Q2xhc3M7XG4gICAgICAgIHRoaXMuY29tcE1ldGEuY29tcG9uZW50Vmlld1R5cGUuc2V0RGVsZWdhdGUodmlld0NsYXNzKTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiByZW5kZXJlclR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcE1ldGEucmVuZGVyZXJUeXBlW3Byb3BdID0gcmVuZGVyZXJUeXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNDb21waWxlZCA9IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZWRUZW1wbGF0ZTtcbn0oKSk7XG5mdW5jdGlvbiBhc3NlcnRDb21wb25lbnQobWV0YSkge1xuICAgIGlmICghbWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29tcGlsZSAnXCIgKyBpZGVudGlmaWVyTmFtZShtZXRhLnR5cGUpICsgXCInIGJlY2F1c2UgaXQgaXMgbm90IGEgY29tcG9uZW50LlwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVPdXRwdXRDb250ZXh0KCkge1xuICAgIHZhciBpbXBvcnRFeHByJDEgPSBmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBpbXBvcnRFeHByKHsgbmFtZTogaWRlbnRpZmllck5hbWUoc3ltYm9sKSwgbW9kdWxlTmFtZTogbnVsbCwgcnVudGltZTogc3ltYm9sIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHsgc3RhdGVtZW50czogW10sIGdlbkZpbGVQYXRoOiAnJywgaW1wb3J0RXhwcjogaW1wb3J0RXhwciQxLCBjb25zdGFudFBvb2w6IG5ldyBDb25zdGFudFBvb2woKSB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFByb3ZpZGVzIGFjY2VzcyB0byByZWZsZWN0aW9uIGRhdGEgYWJvdXQgc3ltYm9scyB0aGF0IHRoZSBjb21waWxlciBuZWVkcy5cbiAqL1xudmFyIENvbXBpbGVSZWZsZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGlsZVJlZmxlY3RvcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVSZWZsZWN0b3I7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIENyZWF0ZSBhIHtAbGluayBVcmxSZXNvbHZlcn0gd2l0aCBubyBwYWNrYWdlIHByZWZpeC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVXJsUmVzb2x2ZXJXaXRob3V0UGFja2FnZVByZWZpeCgpIHtcbiAgICByZXR1cm4gbmV3IFVybFJlc29sdmVyKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVPZmZsaW5lQ29tcGlsZVVybFJlc29sdmVyKCkge1xuICAgIHJldHVybiBuZXcgVXJsUmVzb2x2ZXIoJy4nKTtcbn1cbnZhciBVcmxSZXNvbHZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVcmxSZXNvbHZlckltcGwoX3BhY2thZ2VQcmVmaXgpIHtcbiAgICAgICAgaWYgKF9wYWNrYWdlUHJlZml4ID09PSB2b2lkIDApIHsgX3BhY2thZ2VQcmVmaXggPSBudWxsOyB9XG4gICAgICAgIHRoaXMuX3BhY2thZ2VQcmVmaXggPSBfcGFja2FnZVByZWZpeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdGhlIGB1cmxgIGdpdmVuIHRoZSBgYmFzZVVybGA6XG4gICAgICogLSB3aGVuIHRoZSBgdXJsYCBpcyBudWxsLCB0aGUgYGJhc2VVcmxgIGlzIHJldHVybmVkLFxuICAgICAqIC0gaWYgYHVybGAgaXMgcmVsYXRpdmUgKCdwYXRoL3RvL2hlcmUnLCAnLi9wYXRoL3RvL2hlcmUnKSwgdGhlIHJlc29sdmVkIHVybCBpcyBhIGNvbWJpbmF0aW9uIG9mXG4gICAgICogYGJhc2VVcmxgIGFuZCBgdXJsYCxcbiAgICAgKiAtIGlmIGB1cmxgIGlzIGFic29sdXRlIChpdCBoYXMgYSBzY2hlbWU6ICdodHRwOi8vJywgJ2h0dHBzOi8vJyBvciBzdGFydCB3aXRoICcvJyksIHRoZSBgdXJsYCBpc1xuICAgICAqIHJldHVybmVkIGFzIGlzIChpZ25vcmluZyB0aGUgYGJhc2VVcmxgKVxuICAgICAqL1xuICAgIFVybFJlc29sdmVySW1wbC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChiYXNlVXJsLCB1cmwpIHtcbiAgICAgICAgdmFyIHJlc29sdmVkVXJsID0gdXJsO1xuICAgICAgICBpZiAoYmFzZVVybCAhPSBudWxsICYmIGJhc2VVcmwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZWRVcmwgPSBfcmVzb2x2ZVVybChiYXNlVXJsLCByZXNvbHZlZFVybCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc29sdmVkUGFydHMgPSBfc3BsaXQocmVzb2x2ZWRVcmwpO1xuICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy5fcGFja2FnZVByZWZpeDtcbiAgICAgICAgaWYgKHByZWZpeCAhPSBudWxsICYmIHJlc29sdmVkUGFydHMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgcmVzb2x2ZWRQYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXSA9PSAncGFja2FnZScpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gcmVzb2x2ZWRQYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XG4gICAgICAgICAgICBwcmVmaXggPSBwcmVmaXgucmVwbGFjZSgvXFwvKyQvLCAnJyk7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwvKy8sICcnKTtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBcIi9cIiArIHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkVXJsO1xuICAgIH07XG4gICAgcmV0dXJuIFVybFJlc29sdmVySW1wbDtcbn0oKSk7XG4vKipcbiAqIEV4dHJhY3QgdGhlIHNjaGVtZSBvZiBhIFVSTC5cbiAqL1xuZnVuY3Rpb24gZ2V0VXJsU2NoZW1lKHVybCkge1xuICAgIHZhciBtYXRjaCA9IF9zcGxpdCh1cmwpO1xuICAgIHJldHVybiAobWF0Y2ggJiYgbWF0Y2hbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0pIHx8ICcnO1xufVxuLy8gVGhlIGNvZGUgYmVsb3cgaXMgYWRhcHRlZCBmcm9tIFRyYWNldXI6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3RyYWNldXItY29tcGlsZXIvYmxvYi85NTExYzFkYWZhOTcyYmYwZGUxMjAyYThhODYzYmFkMDJmMGY5NWE4L3NyYy9ydW50aW1lL3VybC5qc1xuLyoqXG4gKiBCdWlsZHMgYSBVUkkgc3RyaW5nIGZyb20gYWxyZWFkeS1lbmNvZGVkIHBhcnRzLlxuICpcbiAqIE5vIGVuY29kaW5nIGlzIHBlcmZvcm1lZC4gIEFueSBjb21wb25lbnQgbWF5IGJlIG9taXR0ZWQgYXMgZWl0aGVyIG51bGwgb3JcbiAqIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gb3B0X3NjaGVtZSBUaGUgc2NoZW1lIHN1Y2ggYXMgJ2h0dHAnLlxuICogQHBhcmFtIG9wdF91c2VySW5mbyBUaGUgdXNlciBuYW1lIGJlZm9yZSB0aGUgJ0AnLlxuICogQHBhcmFtIG9wdF9kb21haW4gVGhlIGRvbWFpbiBzdWNoIGFzICd3d3cuZ29vZ2xlLmNvbScsIGFscmVhZHlcbiAqICAgICBVUkktZW5jb2RlZC5cbiAqIEBwYXJhbSBvcHRfcG9ydCBUaGUgcG9ydCBudW1iZXIuXG4gKiBAcGFyYW0gb3B0X3BhdGggVGhlIHBhdGgsIGFscmVhZHkgVVJJLWVuY29kZWQuICBJZiBpdCBpcyBub3RcbiAqICAgICBlbXB0eSwgaXQgbXVzdCBiZWdpbiB3aXRoIGEgc2xhc2guXG4gKiBAcGFyYW0gb3B0X3F1ZXJ5RGF0YSBUaGUgVVJJLWVuY29kZWQgcXVlcnkgZGF0YS5cbiAqIEBwYXJhbSBvcHRfZnJhZ21lbnQgVGhlIFVSSS1lbmNvZGVkIGZyYWdtZW50IGlkZW50aWZpZXIuXG4gKiBAcmV0dXJuIFRoZSBmdWxseSBjb21iaW5lZCBVUkkuXG4gKi9cbmZ1bmN0aW9uIF9idWlsZEZyb21FbmNvZGVkUGFydHMob3B0X3NjaGVtZSwgb3B0X3VzZXJJbmZvLCBvcHRfZG9tYWluLCBvcHRfcG9ydCwgb3B0X3BhdGgsIG9wdF9xdWVyeURhdGEsIG9wdF9mcmFnbWVudCkge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBpZiAob3B0X3NjaGVtZSAhPSBudWxsKSB7XG4gICAgICAgIG91dC5wdXNoKG9wdF9zY2hlbWUgKyAnOicpO1xuICAgIH1cbiAgICBpZiAob3B0X2RvbWFpbiAhPSBudWxsKSB7XG4gICAgICAgIG91dC5wdXNoKCcvLycpO1xuICAgICAgICBpZiAob3B0X3VzZXJJbmZvICE9IG51bGwpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKG9wdF91c2VySW5mbyArICdAJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0LnB1c2gob3B0X2RvbWFpbik7XG4gICAgICAgIGlmIChvcHRfcG9ydCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvdXQucHVzaCgnOicgKyBvcHRfcG9ydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdF9wYXRoICE9IG51bGwpIHtcbiAgICAgICAgb3V0LnB1c2gob3B0X3BhdGgpO1xuICAgIH1cbiAgICBpZiAob3B0X3F1ZXJ5RGF0YSAhPSBudWxsKSB7XG4gICAgICAgIG91dC5wdXNoKCc/JyArIG9wdF9xdWVyeURhdGEpO1xuICAgIH1cbiAgICBpZiAob3B0X2ZyYWdtZW50ICE9IG51bGwpIHtcbiAgICAgICAgb3V0LnB1c2goJyMnICsgb3B0X2ZyYWdtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbn1cbi8qKlxuICogQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGJyZWFraW5nIGEgVVJJIGludG8gaXRzIGNvbXBvbmVudCBwYXJ0cy5cbiAqXG4gKiB7QGxpbmsgaHR0cDovL3d3dy5nYml2LmNvbS9wcm90b2NvbHMvdXJpL3JmYy9yZmMzOTg2Lmh0bWwjUkZDMjIzNH0gc2F5c1xuICogQXMgdGhlIFwiZmlyc3QtbWF0Y2gtd2luc1wiIGFsZ29yaXRobSBpcyBpZGVudGljYWwgdG8gdGhlIFwiZ3JlZWR5XCJcbiAqIGRpc2FtYmlndWF0aW9uIG1ldGhvZCB1c2VkIGJ5IFBPU0lYIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGl0IGlzIG5hdHVyYWwgYW5kXG4gKiBjb21tb25wbGFjZSB0byB1c2UgYSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIHBhcnNpbmcgdGhlIHBvdGVudGlhbCBmaXZlXG4gKiBjb21wb25lbnRzIG9mIGEgVVJJIHJlZmVyZW5jZS5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGxpbmUgaXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgYnJlYWtpbmctZG93biBhXG4gKiB3ZWxsLWZvcm1lZCBVUkkgcmVmZXJlbmNlIGludG8gaXRzIGNvbXBvbmVudHMuXG4gKlxuICogPHByZT5cbiAqIF4oKFteOi8/I10rKTopPygvLyhbXi8/I10qKSk/KFtePyNdKikoXFw/KFteI10qKSk/KCMoLiopKT9cbiAqICAxMiAgICAgICAgICAgIDMgIDQgICAgICAgICAgNSAgICAgICA2ICA3ICAgICAgICA4IDlcbiAqIDwvcHJlPlxuICpcbiAqIFRoZSBudW1iZXJzIGluIHRoZSBzZWNvbmQgbGluZSBhYm92ZSBhcmUgb25seSB0byBhc3Npc3QgcmVhZGFiaWxpdHk7IHRoZXlcbiAqIGluZGljYXRlIHRoZSByZWZlcmVuY2UgcG9pbnRzIGZvciBlYWNoIHN1YmV4cHJlc3Npb24gKGkuZS4sIGVhY2ggcGFpcmVkXG4gKiBwYXJlbnRoZXNpcykuIFdlIHJlZmVyIHRvIHRoZSB2YWx1ZSBtYXRjaGVkIGZvciBzdWJleHByZXNzaW9uIDxuPiBhcyAkPG4+LlxuICogRm9yIGV4YW1wbGUsIG1hdGNoaW5nIHRoZSBhYm92ZSBleHByZXNzaW9uIHRvXG4gKiA8cHJlPlxuICogICAgIGh0dHA6Ly93d3cuaWNzLnVjaS5lZHUvcHViL2lldGYvdXJpLyNSZWxhdGVkXG4gKiA8L3ByZT5cbiAqIHJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZyBzdWJleHByZXNzaW9uIG1hdGNoZXM6XG4gKiA8cHJlPlxuICogICAgJDEgPSBodHRwOlxuICogICAgJDIgPSBodHRwXG4gKiAgICAkMyA9IC8vd3d3Lmljcy51Y2kuZWR1XG4gKiAgICAkNCA9IHd3dy5pY3MudWNpLmVkdVxuICogICAgJDUgPSAvcHViL2lldGYvdXJpL1xuICogICAgJDYgPSA8dW5kZWZpbmVkPlxuICogICAgJDcgPSA8dW5kZWZpbmVkPlxuICogICAgJDggPSAjUmVsYXRlZFxuICogICAgJDkgPSBSZWxhdGVkXG4gKiA8L3ByZT5cbiAqIHdoZXJlIDx1bmRlZmluZWQ+IGluZGljYXRlcyB0aGF0IHRoZSBjb21wb25lbnQgaXMgbm90IHByZXNlbnQsIGFzIGlzIHRoZVxuICogY2FzZSBmb3IgdGhlIHF1ZXJ5IGNvbXBvbmVudCBpbiB0aGUgYWJvdmUgZXhhbXBsZS4gVGhlcmVmb3JlLCB3ZSBjYW5cbiAqIGRldGVybWluZSB0aGUgdmFsdWUgb2YgdGhlIGZpdmUgY29tcG9uZW50cyBhc1xuICogPHByZT5cbiAqICAgIHNjaGVtZSAgICA9ICQyXG4gKiAgICBhdXRob3JpdHkgPSAkNFxuICogICAgcGF0aCAgICAgID0gJDVcbiAqICAgIHF1ZXJ5ICAgICA9ICQ3XG4gKiAgICBmcmFnbWVudCAgPSAkOVxuICogPC9wcmU+XG4gKlxuICogVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBoYXMgYmVlbiBtb2RpZmllZCBzbGlnaHRseSB0byBleHBvc2UgdGhlXG4gKiB1c2VySW5mbywgZG9tYWluLCBhbmQgcG9ydCBzZXBhcmF0ZWx5IGZyb20gdGhlIGF1dGhvcml0eS5cbiAqIFRoZSBtb2RpZmllZCB2ZXJzaW9uIHlpZWxkc1xuICogPHByZT5cbiAqICAgICQxID0gaHR0cCAgICAgICAgICAgICAgc2NoZW1lXG4gKiAgICAkMiA9IDx1bmRlZmluZWQ+ICAgICAgIHVzZXJJbmZvIC1cXFxuICogICAgJDMgPSB3d3cuaWNzLnVjaS5lZHUgICBkb21haW4gICAgIHwgYXV0aG9yaXR5XG4gKiAgICAkNCA9IDx1bmRlZmluZWQ+ICAgICAgIHBvcnQgICAgIC0vXG4gKiAgICAkNSA9IC9wdWIvaWV0Zi91cmkvICAgIHBhdGhcbiAqICAgICQ2ID0gPHVuZGVmaW5lZD4gICAgICAgcXVlcnkgd2l0aG91dCA/XG4gKiAgICAkNyA9IFJlbGF0ZWQgICAgICAgICAgIGZyYWdtZW50IHdpdGhvdXQgI1xuICogPC9wcmU+XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIF9zcGxpdFJlID0gbmV3IFJlZ0V4cCgnXicgK1xuICAgICcoPzonICtcbiAgICAnKFteOi8/Iy5dKyknICsgLy8gc2NoZW1lIC0gaWdub3JlIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgIC8vIHVzZWQgYnkgb3RoZXIgVVJMIHBhcnRzIHN1Y2ggYXMgOixcbiAgICAvLyA/LCAvLCAjLCBhbmQgLlxuICAgICc6KT8nICtcbiAgICAnKD86Ly8nICtcbiAgICAnKD86KFteLz8jXSopQCk/JyArIC8vIHVzZXJJbmZvXG4gICAgJyhbXFxcXHdcXFxcZFxcXFwtXFxcXHUwMTAwLVxcXFx1ZmZmZi4lXSopJyArIC8vIGRvbWFpbiAtIHJlc3RyaWN0IHRvIGxldHRlcnMsXG4gICAgLy8gZGlnaXRzLCBkYXNoZXMsIGRvdHMsIHBlcmNlbnRcbiAgICAvLyBlc2NhcGVzLCBhbmQgdW5pY29kZSBjaGFyYWN0ZXJzLlxuICAgICcoPzo6KFswLTldKykpPycgKyAvLyBwb3J0XG4gICAgJyk/JyArXG4gICAgJyhbXj8jXSspPycgKyAvLyBwYXRoXG4gICAgJyg/OlxcXFw/KFteI10qKSk/JyArIC8vIHF1ZXJ5XG4gICAgJyg/OiMoLiopKT8nICsgLy8gZnJhZ21lbnRcbiAgICAnJCcpO1xuLyoqXG4gKiBUaGUgaW5kZXggb2YgZWFjaCBVUkkgY29tcG9uZW50IGluIHRoZSByZXR1cm4gdmFsdWUgb2YgZ29vZy51cmkudXRpbHMuc3BsaXQuXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG52YXIgX0NvbXBvbmVudEluZGV4O1xuKGZ1bmN0aW9uIChfQ29tcG9uZW50SW5kZXgpIHtcbiAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiU2NoZW1lXCJdID0gMV0gPSBcIlNjaGVtZVwiO1xuICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJVc2VySW5mb1wiXSA9IDJdID0gXCJVc2VySW5mb1wiO1xuICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJEb21haW5cIl0gPSAzXSA9IFwiRG9tYWluXCI7XG4gICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIlBvcnRcIl0gPSA0XSA9IFwiUG9ydFwiO1xuICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJQYXRoXCJdID0gNV0gPSBcIlBhdGhcIjtcbiAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiUXVlcnlEYXRhXCJdID0gNl0gPSBcIlF1ZXJ5RGF0YVwiO1xuICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJGcmFnbWVudFwiXSA9IDddID0gXCJGcmFnbWVudFwiO1xufSkoX0NvbXBvbmVudEluZGV4IHx8IChfQ29tcG9uZW50SW5kZXggPSB7fSkpO1xuLyoqXG4gKiBTcGxpdHMgYSBVUkkgaW50byBpdHMgY29tcG9uZW50IHBhcnRzLlxuICpcbiAqIEVhY2ggY29tcG9uZW50IGNhbiBiZSBhY2Nlc3NlZCB2aWEgdGhlIGNvbXBvbmVudCBpbmRpY2VzOyBmb3IgZXhhbXBsZTpcbiAqIDxwcmU+XG4gKiBnb29nLnVyaS51dGlscy5zcGxpdChzb21lU3RyKVtnb29nLnVyaS51dGlscy5Db21wb250ZW50SW5kZXguUVVFUllfREFUQV07XG4gKiA8L3ByZT5cbiAqXG4gKiBAcGFyYW0gdXJpIFRoZSBVUkkgc3RyaW5nIHRvIGV4YW1pbmUuXG4gKiBAcmV0dXJuIEVhY2ggY29tcG9uZW50IHN0aWxsIFVSSS1lbmNvZGVkLlxuICogICAgIEVhY2ggY29tcG9uZW50IHRoYXQgaXMgcHJlc2VudCB3aWxsIGNvbnRhaW4gdGhlIGVuY29kZWQgdmFsdWUsIHdoZXJlYXNcbiAqICAgICBjb21wb25lbnRzIHRoYXQgYXJlIG5vdCBwcmVzZW50IHdpbGwgYmUgdW5kZWZpbmVkIG9yIGVtcHR5LCBkZXBlbmRpbmdcbiAqICAgICBvbiB0aGUgYnJvd3NlcidzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpbXBsZW1lbnRhdGlvbi4gIE5ldmVyIG51bGwsIHNpbmNlXG4gKiAgICAgYXJiaXRyYXJ5IHN0cmluZ3MgbWF5IHN0aWxsIGxvb2sgbGlrZSBwYXRoIG5hbWVzLlxuICovXG5mdW5jdGlvbiBfc3BsaXQodXJpKSB7XG4gICAgcmV0dXJuIHVyaS5tYXRjaChfc3BsaXRSZSk7XG59XG4vKipcbiAgKiBSZW1vdmVzIGRvdCBzZWdtZW50cyBpbiBnaXZlbiBwYXRoIGNvbXBvbmVudCwgYXMgZGVzY3JpYmVkIGluXG4gICogUkZDIDM5ODYsIHNlY3Rpb24gNS4yLjQuXG4gICpcbiAgKiBAcGFyYW0gcGF0aCBBIG5vbi1lbXB0eSBwYXRoIGNvbXBvbmVudC5cbiAgKiBAcmV0dXJuIFBhdGggY29tcG9uZW50IHdpdGggcmVtb3ZlZCBkb3Qgc2VnbWVudHMuXG4gICovXG5mdW5jdGlvbiBfcmVtb3ZlRG90U2VnbWVudHMocGF0aCkge1xuICAgIGlmIChwYXRoID09ICcvJylcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICB2YXIgbGVhZGluZ1NsYXNoID0gcGF0aFswXSA9PSAnLycgPyAnLycgOiAnJztcbiAgICB2YXIgdHJhaWxpbmdTbGFzaCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJy8nID8gJy8nIDogJyc7XG4gICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICB2YXIgdXAgPSAwO1xuICAgIGZvciAodmFyIHBvcyA9IDA7IHBvcyA8IHNlZ21lbnRzLmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1twb3NdO1xuICAgICAgICBzd2l0Y2ggKHNlZ21lbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy4uJzpcbiAgICAgICAgICAgICAgICBpZiAob3V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXArKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG91dC5wdXNoKHNlZ21lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChsZWFkaW5nU2xhc2ggPT0gJycpIHtcbiAgICAgICAgd2hpbGUgKHVwLS0gPiAwKSB7XG4gICAgICAgICAgICBvdXQudW5zaGlmdCgnLi4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIG91dC5wdXNoKCcuJyk7XG4gICAgfVxuICAgIHJldHVybiBsZWFkaW5nU2xhc2ggKyBvdXQuam9pbignLycpICsgdHJhaWxpbmdTbGFzaDtcbn1cbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgdGhlIHBhcnRzIGZyb20gc3BsaXQgYW5kIGNhbm9uaWNhbGl6ZXMgdGhlIHBhdGggcGFydFxuICogYW5kIHRoZW4gam9pbnMgYWxsIHRoZSBwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKSB7XG4gICAgdmFyIHBhdGggPSBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XG4gICAgcGF0aCA9IHBhdGggPT0gbnVsbCA/ICcnIDogX3JlbW92ZURvdFNlZ21lbnRzKHBhdGgpO1xuICAgIHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXSA9IHBhdGg7XG4gICAgcmV0dXJuIF9idWlsZEZyb21FbmNvZGVkUGFydHMocGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0sIHBhcnRzW19Db21wb25lbnRJbmRleC5Vc2VySW5mb10sIHBhcnRzW19Db21wb25lbnRJbmRleC5Eb21haW5dLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUG9ydF0sIHBhdGgsIHBhcnRzW19Db21wb25lbnRJbmRleC5RdWVyeURhdGFdLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguRnJhZ21lbnRdKTtcbn1cbi8qKlxuICogUmVzb2x2ZXMgYSBVUkwuXG4gKiBAcGFyYW0gYmFzZSBUaGUgVVJMIGFjdGluZyBhcyB0aGUgYmFzZSBVUkwuXG4gKiBAcGFyYW0gdG8gVGhlIFVSTCB0byByZXNvbHZlLlxuICovXG5mdW5jdGlvbiBfcmVzb2x2ZVVybChiYXNlLCB1cmwpIHtcbiAgICB2YXIgcGFydHMgPSBfc3BsaXQoZW5jb2RlVVJJKHVybCkpO1xuICAgIHZhciBiYXNlUGFydHMgPSBfc3BsaXQoYmFzZSk7XG4gICAgaWYgKHBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIF9qb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXSA9IGJhc2VQYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IF9Db21wb25lbnRJbmRleC5TY2hlbWU7IGkgPD0gX0NvbXBvbmVudEluZGV4LlBvcnQ7IGkrKykge1xuICAgICAgICBpZiAocGFydHNbaV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFydHNbaV0gPSBiYXNlUGFydHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXVswXSA9PSAnLycpIHtcbiAgICAgICAgcmV0dXJuIF9qb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XG4gICAgfVxuICAgIHZhciBwYXRoID0gYmFzZVBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcbiAgICBpZiAocGF0aCA9PSBudWxsKVxuICAgICAgICBwYXRoID0gJy8nO1xuICAgIHZhciBpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgaW5kZXggKyAxKSArIHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcbiAgICBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF0gPSBwYXRoO1xuICAgIHJldHVybiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgRXh0cmFjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4dHJhY3Rvcihob3N0LCBzdGF0aWNTeW1ib2xSZXNvbHZlciwgbWVzc2FnZUJ1bmRsZSwgbWV0YWRhdGFSZXNvbHZlcikge1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLnN0YXRpY1N5bWJvbFJlc29sdmVyID0gc3RhdGljU3ltYm9sUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMubWVzc2FnZUJ1bmRsZSA9IG1lc3NhZ2VCdW5kbGU7XG4gICAgICAgIHRoaXMubWV0YWRhdGFSZXNvbHZlciA9IG1ldGFkYXRhUmVzb2x2ZXI7XG4gICAgfVxuICAgIEV4dHJhY3Rvci5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uIChyb290RmlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gYW5hbHl6ZUFuZFZhbGlkYXRlTmdNb2R1bGVzKHJvb3RGaWxlcywgdGhpcy5ob3N0LCB0aGlzLnN0YXRpY1N5bWJvbFJlc29sdmVyLCB0aGlzLm1ldGFkYXRhUmVzb2x2ZXIpLCBmaWxlcyA9IF9hLmZpbGVzLCBuZ01vZHVsZXMgPSBfYS5uZ01vZHVsZXM7XG4gICAgICAgIHJldHVybiBQcm9taXNlXG4gICAgICAgICAgICAuYWxsKG5nTW9kdWxlcy5tYXAoZnVuY3Rpb24gKG5nTW9kdWxlKSB7IHJldHVybiBfdGhpcy5tZXRhZGF0YVJlc29sdmVyLmxvYWROZ01vZHVsZURpcmVjdGl2ZUFuZFBpcGVNZXRhZGF0YShuZ01vZHVsZS50eXBlLnJlZmVyZW5jZSwgZmFsc2UpOyB9KSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcE1ldGFzID0gW107XG4gICAgICAgICAgICAgICAgZmlsZS5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpck1ldGEgPSBfdGhpcy5tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyTWV0YSAmJiBkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wTWV0YXMucHVzaChkaXJNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbXBNZXRhcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wTWV0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IGNvbXBNZXRhLnRlbXBsYXRlLnRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICAvLyBUZW1wbGF0ZSBVUkwgcG9pbnRzIHRvIGVpdGhlciBhbiBIVE1MIG9yIFRTIGZpbGUgZGVwZW5kaW5nIG9uXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhlIGZpbGUgaXMgdXNlZCB3aXRoIGB0ZW1wbGF0ZVVybDpgIG9yIGB0ZW1wbGF0ZTpgLFxuICAgICAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHkuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVVybCA9IGNvbXBNZXRhLnRlbXBsYXRlLnRlbXBsYXRlVXJsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IEludGVycG9sYXRpb25Db25maWcuZnJvbUFycmF5KGNvbXBNZXRhLnRlbXBsYXRlLmludGVycG9sYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIF9fc3ByZWFkKF90aGlzLm1lc3NhZ2VCdW5kbGUudXBkYXRlRnJvbVRlbXBsYXRlKGh0bWwsIHRlbXBsYXRlVXJsLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRvU3RyaW5nKCk7IH0pLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5tZXNzYWdlQnVuZGxlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEV4dHJhY3Rvci5jcmVhdGUgPSBmdW5jdGlvbiAoaG9zdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBodG1sUGFyc2VyID0gbmV3IEh0bWxQYXJzZXIoKTtcbiAgICAgICAgdmFyIHVybFJlc29sdmVyID0gY3JlYXRlQW90VXJsUmVzb2x2ZXIoaG9zdCk7XG4gICAgICAgIHZhciBzeW1ib2xDYWNoZSA9IG5ldyBTdGF0aWNTeW1ib2xDYWNoZSgpO1xuICAgICAgICB2YXIgc3VtbWFyeVJlc29sdmVyID0gbmV3IEFvdFN1bW1hcnlSZXNvbHZlcihob3N0LCBzeW1ib2xDYWNoZSk7XG4gICAgICAgIHZhciBzdGF0aWNTeW1ib2xSZXNvbHZlciA9IG5ldyBTdGF0aWNTeW1ib2xSZXNvbHZlcihob3N0LCBzeW1ib2xDYWNoZSwgc3VtbWFyeVJlc29sdmVyKTtcbiAgICAgICAgdmFyIHN0YXRpY1JlZmxlY3RvciA9IG5ldyBTdGF0aWNSZWZsZWN0b3Ioc3VtbWFyeVJlc29sdmVyLCBzdGF0aWNTeW1ib2xSZXNvbHZlcik7XG4gICAgICAgIHZhciBjb25maWcgPSBuZXcgQ29tcGlsZXJDb25maWcoeyBkZWZhdWx0RW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQsIHVzZUppdDogZmFsc2UgfSk7XG4gICAgICAgIHZhciBub3JtYWxpemVyID0gbmV3IERpcmVjdGl2ZU5vcm1hbGl6ZXIoeyBnZXQ6IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIGhvc3QubG9hZFJlc291cmNlKHVybCk7IH0gfSwgdXJsUmVzb2x2ZXIsIGh0bWxQYXJzZXIsIGNvbmZpZyk7XG4gICAgICAgIHZhciBlbGVtZW50U2NoZW1hUmVnaXN0cnkgPSBuZXcgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCk7XG4gICAgICAgIHZhciByZXNvbHZlciA9IG5ldyBDb21waWxlTWV0YWRhdGFSZXNvbHZlcihjb25maWcsIGh0bWxQYXJzZXIsIG5ldyBOZ01vZHVsZVJlc29sdmVyKHN0YXRpY1JlZmxlY3RvciksIG5ldyBEaXJlY3RpdmVSZXNvbHZlcihzdGF0aWNSZWZsZWN0b3IpLCBuZXcgUGlwZVJlc29sdmVyKHN0YXRpY1JlZmxlY3RvciksIHN1bW1hcnlSZXNvbHZlciwgZWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBub3JtYWxpemVyLCBjb25zb2xlLCBzeW1ib2xDYWNoZSwgc3RhdGljUmVmbGVjdG9yKTtcbiAgICAgICAgLy8gVE9ETyh2aWNiKTogaW1wbGljaXQgdGFncyAmIGF0dHJpYnV0ZXNcbiAgICAgICAgdmFyIG1lc3NhZ2VCdW5kbGUgPSBuZXcgTWVzc2FnZUJ1bmRsZShodG1sUGFyc2VyLCBbXSwge30sIGxvY2FsZSk7XG4gICAgICAgIHZhciBleHRyYWN0b3IgPSBuZXcgRXh0cmFjdG9yKGhvc3QsIHN0YXRpY1N5bWJvbFJlc29sdmVyLCBtZXNzYWdlQnVuZGxlLCByZXNvbHZlcik7XG4gICAgICAgIHJldHVybiB7IGV4dHJhY3RvcjogZXh0cmFjdG9yLCBzdGF0aWNSZWZsZWN0b3I6IHN0YXRpY1JlZmxlY3RvciB9O1xuICAgIH07XG4gICAgcmV0dXJuIEV4dHJhY3Rvcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBQcm9jZXNzZXMgYFRhcmdldGBzIHdpdGggYSBnaXZlbiBzZXQgb2YgZGlyZWN0aXZlcyBhbmQgcGVyZm9ybXMgYSBiaW5kaW5nIG9wZXJhdGlvbiwgd2hpY2hcbiAqIHJldHVybnMgYW4gb2JqZWN0IHNpbWlsYXIgdG8gVHlwZVNjcmlwdCdzIGB0cy5UeXBlQ2hlY2tlcmAgdGhhdCBjb250YWlucyBrbm93bGVkZ2UgYWJvdXQgdGhlXG4gKiB0YXJnZXQuXG4gKi9cbnZhciBSM1RhcmdldEJpbmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSM1RhcmdldEJpbmRlcihkaXJlY3RpdmVNYXRjaGVyKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlTWF0Y2hlciA9IGRpcmVjdGl2ZU1hdGNoZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBiaW5kaW5nIG9wZXJhdGlvbiBvbiB0aGUgZ2l2ZW4gYFRhcmdldGAgYW5kIHJldHVybiBhIGBCb3VuZFRhcmdldGAgd2hpY2ggY29udGFpbnNcbiAgICAgKiBtZXRhZGF0YSBhYm91dCB0aGUgdHlwZXMgcmVmZXJlbmNlZCBpbiB0aGUgdGVtcGxhdGUuXG4gICAgICovXG4gICAgUjNUYXJnZXRCaW5kZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICghdGFyZ2V0LnRlbXBsYXRlKSB7XG4gICAgICAgICAgICAvLyBUT0RPKGFseGh1Yik6IGhhbmRsZSB0YXJnZXRzIHdoaWNoIGNvbnRhaW4gdGhpbmdzIGxpa2UgSG9zdEJpbmRpbmdzLCBldGMuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpbmRpbmcgd2l0aG91dCBhIHRlbXBsYXRlIG5vdCB5ZXQgc3VwcG9ydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyc3QsIHBhcnNlIHRoZSB0ZW1wbGF0ZSBpbnRvIGEgYFNjb3BlYCBzdHJ1Y3R1cmUuIFRoaXMgb3BlcmF0aW9uIGNhcHR1cmVzIHRoZSBzeW50YWN0aWNcbiAgICAgICAgLy8gc2NvcGVzIGluIHRoZSB0ZW1wbGF0ZSBhbmQgbWFrZXMgdGhlbSBhdmFpbGFibGUgZm9yIGxhdGVyIHVzZS5cbiAgICAgICAgdmFyIHNjb3BlID0gU2NvcGUuYXBwbHkodGFyZ2V0LnRlbXBsYXRlKTtcbiAgICAgICAgLy8gTmV4dCwgcGVyZm9ybSBkaXJlY3RpdmUgbWF0Y2hpbmcgb24gdGhlIHRlbXBsYXRlIHVzaW5nIHRoZSBgRGlyZWN0aXZlQmluZGVyYC4gVGhpcyByZXR1cm5zOlxuICAgICAgICAvLyAgIC0gZGlyZWN0aXZlczogTWFwIG9mIG5vZGVzIChlbGVtZW50cyAmIG5nLXRlbXBsYXRlcykgdG8gdGhlIGRpcmVjdGl2ZXMgb24gdGhlbS5cbiAgICAgICAgLy8gICAtIGJpbmRpbmdzOiBNYXAgb2YgaW5wdXRzLCBvdXRwdXRzLCBhbmQgYXR0cmlidXRlcyB0byB0aGUgZGlyZWN0aXZlL2VsZW1lbnQgdGhhdCBjbGFpbXNcbiAgICAgICAgLy8gICAgIHRoZW0uIFRPRE8oYWx4aHViKTogaGFuZGxlIG11bHRpcGxlIGRpcmVjdGl2ZXMgY2xhaW1pbmcgYW4gaW5wdXQvb3V0cHV0L2V0Yy5cbiAgICAgICAgLy8gICAtIHJlZmVyZW5jZXM6IE1hcCBvZiAjcmVmZXJlbmNlcyB0byB0aGVpciB0YXJnZXRzLlxuICAgICAgICB2YXIgX2EgPSBEaXJlY3RpdmVCaW5kZXIuYXBwbHkodGFyZ2V0LnRlbXBsYXRlLCB0aGlzLmRpcmVjdGl2ZU1hdGNoZXIpLCBkaXJlY3RpdmVzID0gX2EuZGlyZWN0aXZlcywgYmluZGluZ3MgPSBfYS5iaW5kaW5ncywgcmVmZXJlbmNlcyA9IF9hLnJlZmVyZW5jZXM7XG4gICAgICAgIC8vIEZpbmFsbHksIHJ1biB0aGUgVGVtcGxhdGVCaW5kZXIgdG8gYmluZCByZWZlcmVuY2VzLCB2YXJpYWJsZXMsIGFuZCBvdGhlciBlbnRpdGllcyB3aXRoaW4gdGhlXG4gICAgICAgIC8vIHRlbXBsYXRlLiBUaGlzIGV4dHJhY3RzIGFsbCB0aGUgbWV0YWRhdGEgdGhhdCBkb2Vzbid0IGRlcGVuZCBvbiBkaXJlY3RpdmUgbWF0Y2hpbmcuXG4gICAgICAgIHZhciBfYiA9IFRlbXBsYXRlQmluZGVyLmFwcGx5KHRhcmdldC50ZW1wbGF0ZSwgc2NvcGUpLCBleHByZXNzaW9ucyA9IF9iLmV4cHJlc3Npb25zLCBzeW1ib2xzID0gX2Iuc3ltYm9scywgbmVzdGluZ0xldmVsID0gX2IubmVzdGluZ0xldmVsLCB1c2VkUGlwZXMgPSBfYi51c2VkUGlwZXM7XG4gICAgICAgIHJldHVybiBuZXcgUjNCb3VuZFRhcmdldCh0YXJnZXQsIGRpcmVjdGl2ZXMsIGJpbmRpbmdzLCByZWZlcmVuY2VzLCBleHByZXNzaW9ucywgc3ltYm9scywgbmVzdGluZ0xldmVsLCB1c2VkUGlwZXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFIzVGFyZ2V0QmluZGVyO1xufSgpKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGJpbmRpbmcgc2NvcGUgd2l0aGluIGEgdGVtcGxhdGUuXG4gKlxuICogQW55IHZhcmlhYmxlcywgcmVmZXJlbmNlcywgb3Igb3RoZXIgbmFtZWQgZW50aXRpZXMgZGVjbGFyZWQgd2l0aGluIHRoZSB0ZW1wbGF0ZSB3aWxsXG4gKiBiZSBjYXB0dXJlZCBhbmQgYXZhaWxhYmxlIGJ5IG5hbWUgaW4gYG5hbWVkRW50aXRpZXNgLiBBZGRpdGlvbmFsbHksIGNoaWxkIHRlbXBsYXRlcyB3aWxsXG4gKiBiZSBhbmFseXplZCBhbmQgaGF2ZSB0aGVpciBjaGlsZCBgU2NvcGVgcyBhdmFpbGFibGUgaW4gYGNoaWxkU2NvcGVzYC5cbiAqL1xudmFyIFNjb3BlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjb3BlKHBhcmVudFNjb3BlKSB7XG4gICAgICAgIHRoaXMucGFyZW50U2NvcGUgPSBwYXJlbnRTY29wZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWVkIG1lbWJlcnMgb2YgdGhlIGBTY29wZWAsIHN1Y2ggYXMgYFJlZmVyZW5jZWBzIG9yIGBWYXJpYWJsZWBzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lZEVudGl0aWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hpbGQgYFNjb3BlYHMgZm9yIGltbWVkaWF0ZWx5IG5lc3RlZCBgVGVtcGxhdGVgcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRTY29wZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYSB0ZW1wbGF0ZSAoZWl0aGVyIGFzIGEgYFRlbXBsYXRlYCBzdWItdGVtcGxhdGUgd2l0aCB2YXJpYWJsZXMsIG9yIGEgcGxhaW4gYXJyYXkgb2ZcbiAgICAgKiB0ZW1wbGF0ZSBgTm9kZWBzKSBhbmQgY29uc3RydWN0IGl0cyBgU2NvcGVgLlxuICAgICAqL1xuICAgIFNjb3BlLmFwcGx5ID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBzY29wZSA9IG5ldyBTY29wZSgpO1xuICAgICAgICBzY29wZS5pbmdlc3QodGVtcGxhdGUpO1xuICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gcHJvY2VzcyB0aGUgdGVtcGxhdGUgYW5kIHBvcHVsYXRlIHRoZSBgU2NvcGVgLlxuICAgICAqL1xuICAgIFNjb3BlLnByb3RvdHlwZS5pbmdlc3QgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRlbXBsYXRlIGluc3RhbmNlb2YgVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIC8vIFZhcmlhYmxlcyBvbiBhbiA8bmctdGVtcGxhdGU+IGFyZSBkZWZpbmVkIGluIHRoZSBpbm5lciBzY29wZS5cbiAgICAgICAgICAgIHRlbXBsYXRlLnZhcmlhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBfdGhpcy52aXNpdFZhcmlhYmxlKG5vZGUpOyB9KTtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIG5vZGVzIG9mIHRoZSB0ZW1wbGF0ZS5cbiAgICAgICAgICAgIHRlbXBsYXRlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIG92ZXJhcmNoaW5nIGBUZW1wbGF0ZWAgaW5zdGFuY2UsIHNvIHByb2Nlc3MgdGhlIG5vZGVzIGRpcmVjdGx5LlxuICAgICAgICAgICAgdGVtcGxhdGUuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTY29wZS5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gYEVsZW1lbnRgcyBpbiB0aGUgdGVtcGxhdGUgbWF5IGhhdmUgYFJlZmVyZW5jZWBzIHdoaWNoIGFyZSBjYXB0dXJlZCBpbiB0aGUgc2NvcGUuXG4gICAgICAgIGVsZW1lbnQucmVmZXJlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBfdGhpcy52aXNpdFJlZmVyZW5jZShub2RlKTsgfSk7XG4gICAgICAgIC8vIFJlY3Vyc2UgaW50byB0aGUgYEVsZW1lbnRgJ3MgY2hpbGRyZW4uXG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgIH07XG4gICAgU2NvcGUucHJvdG90eXBlLnZpc2l0VGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gUmVmZXJlbmNlcyBvbiBhIDxuZy10ZW1wbGF0ZT4gYXJlIGRlZmluZWQgaW4gdGhlIG91dGVyIHNjb3BlLCBzbyBjYXB0dXJlIHRoZW0gYmVmb3JlXG4gICAgICAgIC8vIHByb2Nlc3NpbmcgdGhlIHRlbXBsYXRlJ3MgY2hpbGQgc2NvcGUuXG4gICAgICAgIHRlbXBsYXRlLnJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gX3RoaXMudmlzaXRSZWZlcmVuY2Uobm9kZSk7IH0pO1xuICAgICAgICAvLyBOZXh0LCBjcmVhdGUgYW4gaW5uZXIgc2NvcGUgYW5kIHByb2Nlc3MgdGhlIHRlbXBsYXRlIHdpdGhpbiBpdC5cbiAgICAgICAgdmFyIHNjb3BlID0gbmV3IFNjb3BlKHRoaXMpO1xuICAgICAgICBzY29wZS5pbmdlc3QodGVtcGxhdGUpO1xuICAgICAgICB0aGlzLmNoaWxkU2NvcGVzLnNldCh0ZW1wbGF0ZSwgc2NvcGUpO1xuICAgIH07XG4gICAgU2NvcGUucHJvdG90eXBlLnZpc2l0VmFyaWFibGUgPSBmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICAgICAgLy8gRGVjbGFyZSB0aGUgdmFyaWFibGUgaWYgaXQncyBub3QgYWxyZWFkeS5cbiAgICAgICAgdGhpcy5tYXliZURlY2xhcmUodmFyaWFibGUpO1xuICAgIH07XG4gICAgU2NvcGUucHJvdG90eXBlLnZpc2l0UmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlZmVyZW5jZSkge1xuICAgICAgICAvLyBEZWNsYXJlIHRoZSB2YXJpYWJsZSBpZiBpdCdzIG5vdCBhbHJlYWR5LlxuICAgICAgICB0aGlzLm1heWJlRGVjbGFyZShyZWZlcmVuY2UpO1xuICAgIH07XG4gICAgLy8gVW51c2VkIHZpc2l0b3JzLlxuICAgIFNjb3BlLnByb3RvdHlwZS52aXNpdENvbnRlbnQgPSBmdW5jdGlvbiAoY29udGVudCkgeyB9O1xuICAgIFNjb3BlLnByb3RvdHlwZS52aXNpdEJvdW5kQXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHIpIHsgfTtcbiAgICBTY29wZS5wcm90b3R5cGUudmlzaXRCb3VuZEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7IH07XG4gICAgU2NvcGUucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgfTtcbiAgICBTY29wZS5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgfTtcbiAgICBTY29wZS5wcm90b3R5cGUudmlzaXRUZXh0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHIpIHsgfTtcbiAgICBTY29wZS5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1KSB7IH07XG4gICAgU2NvcGUucHJvdG90eXBlLm1heWJlRGVjbGFyZSA9IGZ1bmN0aW9uICh0aGluZykge1xuICAgICAgICAvLyBEZWNsYXJlIHNvbWV0aGluZyB3aXRoIGEgbmFtZSwgYXMgbG9uZyBhcyB0aGF0IG5hbWUgaXNuJ3QgdGFrZW4uXG4gICAgICAgIGlmICghdGhpcy5uYW1lZEVudGl0aWVzLmhhcyh0aGluZy5uYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lZEVudGl0aWVzLnNldCh0aGluZy5uYW1lLCB0aGluZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvb2sgdXAgYSB2YXJpYWJsZSB3aXRoaW4gdGhpcyBgU2NvcGVgLlxuICAgICAqXG4gICAgICogVGhpcyBjYW4gcmVjdXJzZSBpbnRvIGEgcGFyZW50IGBTY29wZWAgaWYgaXQncyBhdmFpbGFibGUuXG4gICAgICovXG4gICAgU2NvcGUucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWVkRW50aXRpZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAvLyBGb3VuZCBpbiB0aGUgbG9jYWwgc2NvcGUuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lZEVudGl0aWVzLmdldChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBhcmVudFNjb3BlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE5vdCBpbiB0aGUgbG9jYWwgc2NvcGUsIGJ1dCB0aGVyZSdzIGEgcGFyZW50IHNjb3BlIHNvIGNoZWNrIHRoZXJlLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50U2NvcGUubG9va3VwKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQXQgdGhlIHRvcCBsZXZlbCBhbmQgaXQgd2Fzbid0IGZvdW5kLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2hpbGQgc2NvcGUgZm9yIGEgYFRlbXBsYXRlYC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2hvdWxkIGFsd2F5cyBiZSBkZWZpbmVkLlxuICAgICAqL1xuICAgIFNjb3BlLnByb3RvdHlwZS5nZXRDaGlsZFNjb3BlID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLmNoaWxkU2NvcGVzLmdldCh0ZW1wbGF0ZSk7XG4gICAgICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIGVycm9yOiBjaGlsZCBzY29wZSBmb3IgXCIgKyB0ZW1wbGF0ZSArIFwiIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIFNjb3BlO1xufSgpKTtcbi8qKlxuICogUHJvY2Vzc2VzIGEgdGVtcGxhdGUgYW5kIG1hdGNoZXMgZGlyZWN0aXZlcyBvbiBub2RlcyAoZWxlbWVudHMgYW5kIHRlbXBsYXRlcykuXG4gKlxuICogVXN1YWxseSB1c2VkIHZpYSB0aGUgc3RhdGljIGBhcHBseSgpYCBtZXRob2QuXG4gKi9cbnZhciBEaXJlY3RpdmVCaW5kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlyZWN0aXZlQmluZGVyKG1hdGNoZXIsIGRpcmVjdGl2ZXMsIGJpbmRpbmdzLCByZWZlcmVuY2VzKSB7XG4gICAgICAgIHRoaXMubWF0Y2hlciA9IG1hdGNoZXI7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSBiaW5kaW5ncztcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gcmVmZXJlbmNlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIHRlbXBsYXRlIChsaXN0IG9mIGBOb2RlYHMpIGFuZCBwZXJmb3JtIGRpcmVjdGl2ZSBtYXRjaGluZyBhZ2FpbnN0IGVhY2ggbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZSB0aGUgbGlzdCBvZiB0ZW1wbGF0ZSBgTm9kZWBzIHRvIG1hdGNoIChyZWN1cnNpdmVseSkuXG4gICAgICogQHBhcmFtIHNlbGVjdG9yTWF0Y2hlciBhIGBTZWxlY3Rvck1hdGNoZXJgIGNvbnRhaW5pbmcgdGhlIGRpcmVjdGl2ZXMgdGhhdCBhcmUgaW4gc2NvcGUgZm9yXG4gICAgICogdGhpcyB0ZW1wbGF0ZS5cbiAgICAgKiBAcmV0dXJucyB0aHJlZSBtYXBzIHdoaWNoIGNvbnRhaW4gaW5mb3JtYXRpb24gYWJvdXQgZGlyZWN0aXZlcyBpbiB0aGUgdGVtcGxhdGU6IHRoZVxuICAgICAqIGBkaXJlY3RpdmVzYCBtYXAgd2hpY2ggbGlzdHMgZGlyZWN0aXZlcyBtYXRjaGVkIG9uIGVhY2ggbm9kZSwgdGhlIGBiaW5kaW5nc2AgbWFwIHdoaWNoXG4gICAgICogaW5kaWNhdGVzIHdoaWNoIGRpcmVjdGl2ZXMgY2xhaW1lZCB3aGljaCBiaW5kaW5ncyAoaW5wdXRzLCBvdXRwdXRzLCBldGMpLCBhbmQgdGhlIGByZWZlcmVuY2VzYFxuICAgICAqIG1hcCB3aGljaCByZXNvbHZlcyAjcmVmZXJlbmNlcyAoYFJlZmVyZW5jZWBzKSB3aXRoaW4gdGhlIHRlbXBsYXRlIHRvIHRoZSBuYW1lZCBkaXJlY3RpdmUgb3JcbiAgICAgKiB0ZW1wbGF0ZSBub2RlLlxuICAgICAqL1xuICAgIERpcmVjdGl2ZUJpbmRlci5hcHBseSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgc2VsZWN0b3JNYXRjaGVyKSB7XG4gICAgICAgIHZhciBkaXJlY3RpdmVzID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgYmluZGluZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciByZWZlcmVuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgbWF0Y2hlciA9IG5ldyBEaXJlY3RpdmVCaW5kZXIoc2VsZWN0b3JNYXRjaGVyLCBkaXJlY3RpdmVzLCBiaW5kaW5ncywgcmVmZXJlbmNlcyk7XG4gICAgICAgIG1hdGNoZXIuaW5nZXN0KHRlbXBsYXRlKTtcbiAgICAgICAgcmV0dXJuIHsgZGlyZWN0aXZlczogZGlyZWN0aXZlcywgYmluZGluZ3M6IGJpbmRpbmdzLCByZWZlcmVuY2VzOiByZWZlcmVuY2VzIH07XG4gICAgfTtcbiAgICBEaXJlY3RpdmVCaW5kZXIucHJvdG90eXBlLmluZ2VzdCA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0ZW1wbGF0ZS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfSk7XG4gICAgfTtcbiAgICBEaXJlY3RpdmVCaW5kZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7IHRoaXMudmlzaXRFbGVtZW50T3JUZW1wbGF0ZShlbGVtZW50Lm5hbWUsIGVsZW1lbnQpOyB9O1xuICAgIERpcmVjdGl2ZUJpbmRlci5wcm90b3R5cGUudmlzaXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkgeyB0aGlzLnZpc2l0RWxlbWVudE9yVGVtcGxhdGUoJ25nLXRlbXBsYXRlJywgdGVtcGxhdGUpOyB9O1xuICAgIERpcmVjdGl2ZUJpbmRlci5wcm90b3R5cGUudmlzaXRFbGVtZW50T3JUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0YWcsIG5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gRmlyc3QsIGRldGVybWluZSB0aGUgSFRNTCBzaGFwZSBvZiB0aGUgbm9kZSBmb3IgdGhlIHB1cnBvc2Ugb2YgZGlyZWN0aXZlIG1hdGNoaW5nLlxuICAgICAgICAvLyBEbyB0aGlzIGJ5IGJ1aWxkaW5nIHVwIGEgYENzc1NlbGVjdG9yYCBmb3IgdGhlIG5vZGUuXG4gICAgICAgIHZhciBjc3NTZWxlY3RvciA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICBjc3NTZWxlY3Rvci5zZXRFbGVtZW50KHRhZyk7XG4gICAgICAgIC8vIEFkZCBhdHRyaWJ1dGVzIHRvIHRoZSBDU1Mgc2VsZWN0b3IuXG4gICAgICAgIHZhciBhdHRycyA9IGdldEF0dHJzRm9yRGlyZWN0aXZlTWF0Y2hpbmcobm9kZSk7XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgIGNzc1NlbGVjdG9yLmFkZEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAvLyBUcmVhdCB0aGUgJ2NsYXNzJyBhdHRyaWJ1dGUgc3BlY2lhbGx5LlxuICAgICAgICAgICAgaWYgKG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gdmFsdWUudHJpbSgpLnNwbGl0KC9cXHMrL2cpO1xuICAgICAgICAgICAgICAgIGNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiBjc3NTZWxlY3Rvci5hZGRDbGFzc05hbWUoY2xhc3NOYW1lKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOZXh0LCB1c2UgdGhlIGBTZWxlY3Rvck1hdGNoZXJgIHRvIGdldCB0aGUgbGlzdCBvZiBkaXJlY3RpdmVzIG9uIHRoZSBub2RlLlxuICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IFtdO1xuICAgICAgICB0aGlzLm1hdGNoZXIubWF0Y2goY3NzU2VsZWN0b3IsIGZ1bmN0aW9uIChfLCBkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZXMucHVzaChkaXJlY3RpdmUpOyB9KTtcbiAgICAgICAgaWYgKGRpcmVjdGl2ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnNldChub2RlLCBkaXJlY3RpdmVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNvbHZlIGFueSByZWZlcmVuY2VzIHRoYXQgYXJlIGNyZWF0ZWQgb24gdGhpcyBub2RlLlxuICAgICAgICBub2RlLnJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgZGlyVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIElmIHRoZSByZWZlcmVuY2UgZXhwcmVzc2lvbiBpcyBlbXB0eSwgdGhlbiBpdCBtYXRjaGVzIHRoZSBcInByaW1hcnlcIiBkaXJlY3RpdmUgb24gdGhlIG5vZGVcbiAgICAgICAgICAgIC8vIChpZiB0aGVyZSBpcyBvbmUpLiBPdGhlcndpc2UgaXQgbWF0Y2hlcyB0aGUgaG9zdCBub2RlIGl0c2VsZiAoZWl0aGVyIGFuIGVsZW1lbnQgb3JcbiAgICAgICAgICAgIC8vIDxuZy10ZW1wbGF0ZT4gbm9kZSkuXG4gICAgICAgICAgICBpZiAocmVmLnZhbHVlLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGEgcmVmZXJlbmNlIHRvIGEgY29tcG9uZW50IGlmIHRoZXJlIGlzIG9uZS5cbiAgICAgICAgICAgICAgICBkaXJUYXJnZXQgPSBkaXJlY3RpdmVzLmZpbmQoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gZGlyLmlzQ29tcG9uZW50OyB9KSB8fCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHJlZmVyZW5jZSB0byBhIGRpcmVjdGl2ZSBleHBvcnRlZCB2aWEgZXhwb3J0QXMuIE9uZSBzaG91bGQgZXhpc3QuXG4gICAgICAgICAgICAgICAgZGlyVGFyZ2V0ID1cbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlcy5maW5kKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGRpci5leHBvcnRBcyAhPT0gbnVsbCAmJiBkaXIuZXhwb3J0QXMuc29tZShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlID09PSByZWYudmFsdWU7IH0pOyB9KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBhIG1hdGNoaW5nIGRpcmVjdGl2ZSB3YXMgZm91bmQsIGFuZCBlcnJvciBpZiBpdCB3YXNuJ3QuXG4gICAgICAgICAgICAgICAgaWYgKGRpclRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGFseGh1Yik6IFJldHVybiBhbiBlcnJvciB2YWx1ZSBoZXJlIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHRlbXBsYXRlIHZhbGlkYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBlcnJvcjogZmFpbGVkIHRvIGZpbmQgZGlyZWN0aXZlIHdpdGggZXhwb3J0QXM6IFwiICsgcmVmLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlyVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyByZWZlcmVuY2UgcG9pbnRzIHRvIGEgZGlyZWN0aXZlLlxuICAgICAgICAgICAgICAgIF90aGlzLnJlZmVyZW5jZXMuc2V0KHJlZiwgeyBkaXJlY3RpdmU6IGRpclRhcmdldCwgbm9kZTogbm9kZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVmZXJlbmNlIHBvaW50cyB0byB0aGUgbm9kZSBpdHNlbGYuXG4gICAgICAgICAgICAgICAgX3RoaXMucmVmZXJlbmNlcy5zZXQocmVmLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFzc29jaWF0ZSBhdHRyaWJ1dGVzL2JpbmRpbmdzIG9uIHRoZSBub2RlIHdpdGggZGlyZWN0aXZlcyBvciB3aXRoIHRoZSBub2RlIGl0c2VsZi5cbiAgICAgICAgdmFyIHByb2Nlc3NBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICB2YXIgZGlyID0gZGlyZWN0aXZlcy5maW5kKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGRpci5pbnB1dHMuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlLm5hbWUpOyB9KTtcbiAgICAgICAgICAgIGlmIChkaXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmJpbmRpbmdzLnNldChhdHRyaWJ1dGUsIGRpcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5iaW5kaW5ncy5zZXQoYXR0cmlidXRlLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLmZvckVhY2gocHJvY2Vzc0F0dHJpYnV0ZSk7XG4gICAgICAgIG5vZGUuaW5wdXRzLmZvckVhY2gocHJvY2Vzc0F0dHJpYnV0ZSk7XG4gICAgICAgIG5vZGUub3V0cHV0cy5mb3JFYWNoKHByb2Nlc3NBdHRyaWJ1dGUpO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRlbXBsYXRlKSB7XG4gICAgICAgICAgICBub2RlLnRlbXBsYXRlQXR0cnMuZm9yRWFjaChwcm9jZXNzQXR0cmlidXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNlIGludG8gdGhlIG5vZGUncyBjaGlsZHJlbi5cbiAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMpOyB9KTtcbiAgICB9O1xuICAgIC8vIFVudXNlZCB2aXNpdG9ycy5cbiAgICBEaXJlY3RpdmVCaW5kZXIucHJvdG90eXBlLnZpc2l0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KSB7IH07XG4gICAgRGlyZWN0aXZlQmluZGVyLnByb3RvdHlwZS52aXNpdFZhcmlhYmxlID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7IH07XG4gICAgRGlyZWN0aXZlQmluZGVyLnByb3RvdHlwZS52aXNpdFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChyZWZlcmVuY2UpIHsgfTtcbiAgICBEaXJlY3RpdmVCaW5kZXIucHJvdG90eXBlLnZpc2l0VGV4dEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHsgfTtcbiAgICBEaXJlY3RpdmVCaW5kZXIucHJvdG90eXBlLnZpc2l0Qm91bmRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7IH07XG4gICAgRGlyZWN0aXZlQmluZGVyLnByb3RvdHlwZS52aXNpdEJvdW5kRXZlbnQgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7IH07XG4gICAgRGlyZWN0aXZlQmluZGVyLnByb3RvdHlwZS52aXNpdEJvdW5kQXR0cmlidXRlT3JFdmVudCA9IGZ1bmN0aW9uIChub2RlKSB7IH07XG4gICAgRGlyZWN0aXZlQmluZGVyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCkgeyB9O1xuICAgIERpcmVjdGl2ZUJpbmRlci5wcm90b3R5cGUudmlzaXRCb3VuZFRleHQgPSBmdW5jdGlvbiAodGV4dCkgeyB9O1xuICAgIERpcmVjdGl2ZUJpbmRlci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1KSB7IH07XG4gICAgcmV0dXJuIERpcmVjdGl2ZUJpbmRlcjtcbn0oKSk7XG4vKipcbiAqIFByb2Nlc3NlcyBhIHRlbXBsYXRlIGFuZCBleHRyYWN0IG1ldGFkYXRhIGFib3V0IGV4cHJlc3Npb25zIGFuZCBzeW1ib2xzIHdpdGhpbi5cbiAqXG4gKiBUaGlzIGlzIGEgY29tcGFuaW9uIHRvIHRoZSBgRGlyZWN0aXZlQmluZGVyYCB0aGF0IGRvZXNuJ3QgcmVxdWlyZSBrbm93bGVkZ2Ugb2YgZGlyZWN0aXZlcyBtYXRjaGVkXG4gKiB3aXRoaW4gdGhlIHRlbXBsYXRlIGluIG9yZGVyIHRvIG9wZXJhdGUuXG4gKlxuICogRXhwcmVzc2lvbnMgYXJlIHZpc2l0ZWQgYnkgdGhlIHN1cGVyY2xhc3MgYFJlY3Vyc2l2ZUFzdFZpc2l0b3JgLCB3aXRoIGN1c3RvbSBsb2dpYyBwcm92aWRlZFxuICogYnkgb3ZlcnJpZGRlbiBtZXRob2RzIGZyb20gdGhhdCB2aXNpdG9yLlxuICovXG52YXIgVGVtcGxhdGVCaW5kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRlbXBsYXRlQmluZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlQmluZGVyKGJpbmRpbmdzLCBzeW1ib2xzLCB1c2VkUGlwZXMsIG5lc3RpbmdMZXZlbCwgc2NvcGUsIHRlbXBsYXRlLCBsZXZlbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5iaW5kaW5ncyA9IGJpbmRpbmdzO1xuICAgICAgICBfdGhpcy5zeW1ib2xzID0gc3ltYm9scztcbiAgICAgICAgX3RoaXMudXNlZFBpcGVzID0gdXNlZFBpcGVzO1xuICAgICAgICBfdGhpcy5uZXN0aW5nTGV2ZWwgPSBuZXN0aW5nTGV2ZWw7XG4gICAgICAgIF90aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIF90aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICAgIF90aGlzLnBpcGVzVXNlZCA9IFtdO1xuICAgICAgICAvLyBTYXZlIGEgYml0IG9mIHByb2Nlc3NpbmcgdGltZSBieSBjb25zdHJ1Y3RpbmcgdGhpcyBjbG9zdXJlIGluIGFkdmFuY2UuXG4gICAgICAgIF90aGlzLnZpc2l0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgdGVtcGxhdGUgYW5kIGV4dHJhY3QgbWV0YWRhdGEgYWJvdXQgZXhwcmVzc2lvbnMgYW5kIHN5bWJvbHMgd2l0aGluLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRlbXBsYXRlIHRoZSBub2RlcyBvZiB0aGUgdGVtcGxhdGUgdG8gcHJvY2Vzc1xuICAgICAqIEBwYXJhbSBzY29wZSB0aGUgYFNjb3BlYCBvZiB0aGUgdGVtcGxhdGUgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAqIEByZXR1cm5zIHRocmVlIG1hcHMgd2hpY2ggY29udGFpbiBtZXRhZGF0YSBhYm91dCB0aGUgdGVtcGxhdGU6IGBleHByZXNzaW9uc2Agd2hpY2ggaW50ZXJwcmV0c1xuICAgICAqIHNwZWNpYWwgYEFTVGAgbm9kZXMgaW4gZXhwcmVzc2lvbnMgYXMgcG9pbnRpbmcgdG8gcmVmZXJlbmNlcyBvciB2YXJpYWJsZXMgZGVjbGFyZWQgd2l0aGluIHRoZVxuICAgICAqIHRlbXBsYXRlLCBgc3ltYm9sc2Agd2hpY2ggbWFwcyB0aG9zZSB2YXJpYWJsZXMgYW5kIHJlZmVyZW5jZXMgdG8gdGhlIG5lc3RlZCBgVGVtcGxhdGVgIHdoaWNoXG4gICAgICogZGVjbGFyZXMgdGhlbSwgaWYgYW55LCBhbmQgYG5lc3RpbmdMZXZlbGAgd2hpY2ggYXNzb2NpYXRlcyBlYWNoIGBUZW1wbGF0ZWAgd2l0aCBhIGludGVnZXJcbiAgICAgKiBuZXN0aW5nIGxldmVsIChob3cgbWFueSBsZXZlbHMgZGVlcCB3aXRoaW4gdGhlIHRlbXBsYXRlIHN0cnVjdHVyZSB0aGUgYFRlbXBsYXRlYCBpcyksIHN0YXJ0aW5nXG4gICAgICogYXQgMS5cbiAgICAgKi9cbiAgICBUZW1wbGF0ZUJpbmRlci5hcHBseSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgc2NvcGUpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgc3ltYm9scyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIG5lc3RpbmdMZXZlbCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIHVzZWRQaXBlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gVGhlIHRvcC1sZXZlbCB0ZW1wbGF0ZSBoYXMgbmVzdGluZyBsZXZlbCAwLlxuICAgICAgICB2YXIgYmluZGVyID0gbmV3IFRlbXBsYXRlQmluZGVyKGV4cHJlc3Npb25zLCBzeW1ib2xzLCB1c2VkUGlwZXMsIG5lc3RpbmdMZXZlbCwgc2NvcGUsIHRlbXBsYXRlIGluc3RhbmNlb2YgVGVtcGxhdGUgPyB0ZW1wbGF0ZSA6IG51bGwsIDApO1xuICAgICAgICBiaW5kZXIuaW5nZXN0KHRlbXBsYXRlKTtcbiAgICAgICAgcmV0dXJuIHsgZXhwcmVzc2lvbnM6IGV4cHJlc3Npb25zLCBzeW1ib2xzOiBzeW1ib2xzLCBuZXN0aW5nTGV2ZWw6IG5lc3RpbmdMZXZlbCwgdXNlZFBpcGVzOiB1c2VkUGlwZXMgfTtcbiAgICB9O1xuICAgIFRlbXBsYXRlQmluZGVyLnByb3RvdHlwZS5pbmdlc3QgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlIGluc3RhbmNlb2YgVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIC8vIEZvciA8bmctdGVtcGxhdGU+cywgcHJvY2VzcyBvbmx5IHZhcmlhYmxlcyBhbmQgY2hpbGQgbm9kZXMuIElucHV0cywgb3V0cHV0cywgdGVtcGxhdGVBdHRycyxcbiAgICAgICAgICAgIC8vIGFuZCByZWZlcmVuY2VzIHdlcmUgYWxsIHByb2Nlc3NlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIGNvbnRhaW5pbmcgdGVtcGxhdGUuXG4gICAgICAgICAgICB0ZW1wbGF0ZS52YXJpYWJsZXMuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgICAgICB0ZW1wbGF0ZS5jaGlsZHJlbi5mb3JFYWNoKHRoaXMudmlzaXROb2RlKTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgbmVzdGluZyBsZXZlbC5cbiAgICAgICAgICAgIHRoaXMubmVzdGluZ0xldmVsLnNldCh0ZW1wbGF0ZSwgdGhpcy5sZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBWaXNpdCBlYWNoIG5vZGUgZnJvbSB0aGUgdG9wLWxldmVsIHRlbXBsYXRlLlxuICAgICAgICAgICAgdGVtcGxhdGUuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlbXBsYXRlQmluZGVyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAvLyBWaXNpdCB0aGUgaW5wdXRzLCBvdXRwdXRzLCBhbmQgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgIGVsZW1lbnQuaW5wdXRzLmZvckVhY2godGhpcy52aXNpdE5vZGUpO1xuICAgICAgICBlbGVtZW50Lm91dHB1dHMuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4uZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICAvLyBGaXJzdCwgdmlzaXQgaW5wdXRzLCBvdXRwdXRzIGFuZCB0ZW1wbGF0ZSBhdHRyaWJ1dGVzIG9mIHRoZSB0ZW1wbGF0ZSBub2RlLlxuICAgICAgICB0ZW1wbGF0ZS5pbnB1dHMuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgIHRlbXBsYXRlLm91dHB1dHMuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgIHRlbXBsYXRlLnRlbXBsYXRlQXR0cnMuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgIC8vIFJlZmVyZW5jZXMgYXJlIGFsc28gZXZhbHVhdGVkIGluIHRoZSBvdXRlciBjb250ZXh0LlxuICAgICAgICB0ZW1wbGF0ZS5yZWZlcmVuY2VzLmZvckVhY2godGhpcy52aXNpdE5vZGUpO1xuICAgICAgICAvLyBOZXh0LCByZWN1cnNlIGludG8gdGhlIHRlbXBsYXRlIHVzaW5nIGl0cyBzY29wZSwgYW5kIGJ1bXBpbmcgdGhlIG5lc3RpbmcgbGV2ZWwgdXAgYnkgb25lLlxuICAgICAgICB2YXIgY2hpbGRTY29wZSA9IHRoaXMuc2NvcGUuZ2V0Q2hpbGRTY29wZSh0ZW1wbGF0ZSk7XG4gICAgICAgIHZhciBiaW5kZXIgPSBuZXcgVGVtcGxhdGVCaW5kZXIodGhpcy5iaW5kaW5ncywgdGhpcy5zeW1ib2xzLCB0aGlzLnVzZWRQaXBlcywgdGhpcy5uZXN0aW5nTGV2ZWwsIGNoaWxkU2NvcGUsIHRlbXBsYXRlLCB0aGlzLmxldmVsICsgMSk7XG4gICAgICAgIGJpbmRlci5pbmdlc3QodGVtcGxhdGUpO1xuICAgIH07XG4gICAgVGVtcGxhdGVCaW5kZXIucHJvdG90eXBlLnZpc2l0VmFyaWFibGUgPSBmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIGBWYXJpYWJsZWAgYXMgYSBzeW1ib2wgaW4gdGhlIGN1cnJlbnQgYFRlbXBsYXRlYC5cbiAgICAgICAgaWYgKHRoaXMudGVtcGxhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3ltYm9scy5zZXQodmFyaWFibGUsIHRoaXMudGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVmZXJlbmNlKSB7XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBgUmVmZXJlbmNlYCBhcyBhIHN5bWJvbCBpbiB0aGUgY3VycmVudCBgVGVtcGxhdGVgLlxuICAgICAgICBpZiAodGhpcy50ZW1wbGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zeW1ib2xzLnNldChyZWZlcmVuY2UsIHRoaXMudGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBVbnVzZWQgdGVtcGxhdGUgdmlzaXRvcnNcbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgfTtcbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHsgfTtcbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRUZXh0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkgeyB9O1xuICAgIFRlbXBsYXRlQmluZGVyLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UpIHsgfTtcbiAgICAvLyBUaGUgcmVtYWluaW5nIHZpc2l0b3JzIGFyZSBjb25jZXJuZWQgd2l0aCBwcm9jZXNzaW5nIEFTVCBleHByZXNzaW9ucyB3aXRoaW4gdGVtcGxhdGUgYmluZGluZ3NcbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRCb3VuZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHsgYXR0cmlidXRlLnZhbHVlLnZpc2l0KHRoaXMpOyB9O1xuICAgIFRlbXBsYXRlQmluZGVyLnByb3RvdHlwZS52aXNpdEJvdW5kRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHsgZXZlbnQuaGFuZGxlci52aXNpdCh0aGlzKTsgfTtcbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRCb3VuZFRleHQgPSBmdW5jdGlvbiAodGV4dCkgeyB0ZXh0LnZhbHVlLnZpc2l0KHRoaXMpOyB9O1xuICAgIFRlbXBsYXRlQmluZGVyLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudXNlZFBpcGVzLmFkZChhc3QubmFtZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0UGlwZS5jYWxsKHRoaXMsIGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvLyBUaGVzZSBmaXZlIHR5cGVzIG9mIEFTVCBleHByZXNzaW9ucyBjYW4gcmVmZXIgdG8gZXhwcmVzc2lvbiByb290cywgd2hpY2ggY291bGQgYmUgdmFyaWFibGVzXG4gICAgLy8gb3IgcmVmZXJlbmNlcyBpbiB0aGUgY3VycmVudCBzY29wZS5cbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMubWF5YmVNYXAoY29udGV4dCwgYXN0LCBhc3QubmFtZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkLmNhbGwodGhpcywgYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFRlbXBsYXRlQmluZGVyLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMubWF5YmVNYXAoY29udGV4dCwgYXN0LCBhc3QubmFtZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0U2FmZVByb3BlcnR5UmVhZC5jYWxsKHRoaXMsIGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLm1heWJlTWFwKGNvbnRleHQsIGFzdCwgYXN0Lm5hbWUpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUuY2FsbCh0aGlzLCBhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgVGVtcGxhdGVCaW5kZXIucHJvdG90eXBlLnZpc2l0TWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5tYXliZU1hcChjb250ZXh0LCBhc3QsIGFzdC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudmlzaXRNZXRob2RDYWxsLmNhbGwodGhpcywgYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFRlbXBsYXRlQmluZGVyLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLm1heWJlTWFwKGNvbnRleHQsIGFzdCwgYXN0Lm5hbWUpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsLmNhbGwodGhpcywgYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFRlbXBsYXRlQmluZGVyLnByb3RvdHlwZS5tYXliZU1hcCA9IGZ1bmN0aW9uIChzY29wZSwgYXN0LCBuYW1lKSB7XG4gICAgICAgIC8vIElmIHRoZSByZWNlaXZlciBvZiB0aGUgZXhwcmVzc2lvbiBpc24ndCB0aGUgYEltcGxpY2l0UmVjZWl2ZXJgLCB0aGlzIGlzbid0IHRoZSByb290IG9mIGFuXG4gICAgICAgIC8vIGBBU1RgIGV4cHJlc3Npb24gdGhhdCBtYXBzIHRvIGEgYFZhcmlhYmxlYCBvciBgUmVmZXJlbmNlYC5cbiAgICAgICAgaWYgKCEoYXN0LnJlY2VpdmVyIGluc3RhbmNlb2YgSW1wbGljaXRSZWNlaXZlcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBuYW1lIGV4aXN0cyBpbiB0aGUgY3VycmVudCBzY29wZS4gSWYgc28sIG1hcCBpdC4gT3RoZXJ3aXNlLCB0aGUgbmFtZSBpc1xuICAgICAgICAvLyBwcm9iYWJseSBhIHByb3BlcnR5IG9uIHRoZSB0b3AtbGV2ZWwgY29tcG9uZW50IGNvbnRleHQuXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnNjb3BlLmxvb2t1cChuYW1lKTtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5ncy5zZXQoYXN0LCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGVtcGxhdGVCaW5kZXI7XG59KFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMSkpO1xuLyoqXG4gKiBNZXRhZGF0YSBjb250YWluZXIgZm9yIGEgYFRhcmdldGAgdGhhdCBhbGxvd3MgcXVlcmllcyBmb3Igc3BlY2lmaWMgYml0cyBvZiBtZXRhZGF0YS5cbiAqXG4gKiBTZWUgYEJvdW5kVGFyZ2V0YCBmb3IgZG9jdW1lbnRhdGlvbiBvbiB0aGUgaW5kaXZpZHVhbCBtZXRob2RzLlxuICovXG52YXIgUjNCb3VuZFRhcmdldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSM0JvdW5kVGFyZ2V0KHRhcmdldCwgZGlyZWN0aXZlcywgYmluZGluZ3MsIHJlZmVyZW5jZXMsIGV4cHJUYXJnZXRzLCBzeW1ib2xzLCBuZXN0aW5nTGV2ZWwsIHVzZWRQaXBlcykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IGJpbmRpbmdzO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICB0aGlzLmV4cHJUYXJnZXRzID0gZXhwclRhcmdldHM7XG4gICAgICAgIHRoaXMuc3ltYm9scyA9IHN5bWJvbHM7XG4gICAgICAgIHRoaXMubmVzdGluZ0xldmVsID0gbmVzdGluZ0xldmVsO1xuICAgICAgICB0aGlzLnVzZWRQaXBlcyA9IHVzZWRQaXBlcztcbiAgICB9XG4gICAgUjNCb3VuZFRhcmdldC5wcm90b3R5cGUuZ2V0RGlyZWN0aXZlc09mTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGl2ZXMuZ2V0KG5vZGUpIHx8IG51bGw7XG4gICAgfTtcbiAgICBSM0JvdW5kVGFyZ2V0LnByb3RvdHlwZS5nZXRSZWZlcmVuY2VUYXJnZXQgPSBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZXMuZ2V0KHJlZikgfHwgbnVsbDtcbiAgICB9O1xuICAgIFIzQm91bmRUYXJnZXQucHJvdG90eXBlLmdldENvbnN1bWVyT2ZCaW5kaW5nID0gZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ3MuZ2V0KGJpbmRpbmcpIHx8IG51bGw7XG4gICAgfTtcbiAgICBSM0JvdW5kVGFyZ2V0LnByb3RvdHlwZS5nZXRFeHByZXNzaW9uVGFyZ2V0ID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwclRhcmdldHMuZ2V0KGV4cHIpIHx8IG51bGw7XG4gICAgfTtcbiAgICBSM0JvdW5kVGFyZ2V0LnByb3RvdHlwZS5nZXRUZW1wbGF0ZU9mU3ltYm9sID0gZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2xzLmdldChzeW1ib2wpIHx8IG51bGw7XG4gICAgfTtcbiAgICBSM0JvdW5kVGFyZ2V0LnByb3RvdHlwZS5nZXROZXN0aW5nTGV2ZWwgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHsgcmV0dXJuIHRoaXMubmVzdGluZ0xldmVsLmdldCh0ZW1wbGF0ZSkgfHwgMDsgfTtcbiAgICBSM0JvdW5kVGFyZ2V0LnByb3RvdHlwZS5nZXRVc2VkRGlyZWN0aXZlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcnMpIHsgcmV0dXJuIGRpcnMuZm9yRWFjaChmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBzZXQuYWRkKGRpcik7IH0pOyB9KTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc2V0LnZhbHVlcygpKTtcbiAgICB9O1xuICAgIFIzQm91bmRUYXJnZXQucHJvdG90eXBlLmdldFVzZWRQaXBlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5LmZyb20odGhpcy51c2VkUGlwZXMpOyB9O1xuICAgIHJldHVybiBSM0JvdW5kVGFyZ2V0O1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gVGhpcyBmaWxlIG9ubHkgcmVleHBvcnRzIGNvbnRlbnQgb2YgdGhlIGBzcmNgIGZvbGRlci4gS2VlcCBpdCB0aGF0IHdheS5cbi8vIFRoaXMgZnVuY3Rpb24gY2FsbCBoYXMgYSBnbG9iYWwgc2lkZSBlZmZlY3RzIGFuZCBwdWJsaXNoZXMgdGhlIGNvbXBpbGVyIGludG8gZ2xvYmFsIG5hbWVzcGFjZSBmb3Jcbi8vIHRoZSBsYXRlIGJpbmRpbmcgb2YgdGhlIENvbXBpbGVyIHRvIHRoZSBAYW5ndWxhci9jb3JlIGZvciBqaXQgY29tcGlsYXRpb24uXG5wdWJsaXNoRmFjYWRlKF9nbG9iYWwpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyBUaGlzIGZpbGUgb25seSByZWV4cG9ydHMgY29udGVudCBvZiB0aGUgYHNyY2AgZm9sZGVyLiBLZWVwIGl0IHRoYXQgd2F5LlxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuZXhwb3J0IHsgY29yZSwgQ29tcGlsZXJDb25maWcsIHByZXNlcnZlV2hpdGVzcGFjZXNEZWZhdWx0LCBpc0xvd2VyZWRTeW1ib2wsIGNyZWF0ZUxvd2VyZWRTeW1ib2wsIElkZW50aWZpZXJzLCBKaXRDb21waWxlciwgQ29uc3RhbnRQb29sLCBEaXJlY3RpdmVSZXNvbHZlciwgUGlwZVJlc29sdmVyLCBOZ01vZHVsZVJlc29sdmVyLCBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHLCBJbnRlcnBvbGF0aW9uQ29uZmlnLCBOZ01vZHVsZUNvbXBpbGVyLCBBcnJheVR5cGUsIEFzc2VydE5vdE51bGwsIERZTkFNSUNfVFlQRSwgQmluYXJ5T3BlcmF0b3IsIEJpbmFyeU9wZXJhdG9yRXhwciwgQnVpbHRpbk1ldGhvZCwgQnVpbHRpblR5cGUsIEJ1aWx0aW5UeXBlTmFtZSwgQnVpbHRpblZhciwgQ2FzdEV4cHIsIENsYXNzRmllbGQsIENsYXNzTWV0aG9kLCBDbGFzc1N0bXQsIENvbW1hRXhwciwgQ29tbWVudFN0bXQsIENvbmRpdGlvbmFsRXhwciwgRGVjbGFyZUZ1bmN0aW9uU3RtdCwgRGVjbGFyZVZhclN0bXQsIEV4cHJlc3Npb24sIEV4cHJlc3Npb25TdGF0ZW1lbnQsIEV4cHJlc3Npb25UeXBlLCBFeHRlcm5hbEV4cHIsIEV4dGVybmFsUmVmZXJlbmNlLCBsaXRlcmFsTWFwLCBGdW5jdGlvbkV4cHIsIElmU3RtdCwgSW5zdGFudGlhdGVFeHByLCBJbnZva2VGdW5jdGlvbkV4cHIsIEludm9rZU1ldGhvZEV4cHIsIEpTRG9jQ29tbWVudFN0bXQsIExpdGVyYWxBcnJheUV4cHIsIExpdGVyYWxFeHByLCBMaXRlcmFsTWFwRXhwciwgTWFwVHlwZSwgTm90RXhwciwgUmVhZEtleUV4cHIsIFJlYWRQcm9wRXhwciwgUmVhZFZhckV4cHIsIFJldHVyblN0YXRlbWVudCwgVGhyb3dTdG10LCBUcnlDYXRjaFN0bXQsIFR5cGUkMSBhcyBUeXBlLCBXcmFwcGVkTm9kZUV4cHIsIFdyaXRlS2V5RXhwciwgV3JpdGVQcm9wRXhwciwgV3JpdGVWYXJFeHByLCBTdG10TW9kaWZpZXIsIFN0YXRlbWVudCwgU1RSSU5HX1RZUEUsIFR5cGVvZkV4cHIsIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXMsIEVtaXR0ZXJWaXNpdG9yQ29udGV4dCwgSml0RXZhbHVhdG9yLCBWaWV3Q29tcGlsZXIsIGZpbmRTdGF0aWNRdWVyeUlkcywgc3RhdGljVmlld1F1ZXJ5SWRzLCBnZXRQYXJzZUVycm9ycywgaXNTeW50YXhFcnJvciwgc3ludGF4RXJyb3IsIFZlcnNpb24sIEJvdW5kQXR0cmlidXRlIGFzIFRtcGxBc3RCb3VuZEF0dHJpYnV0ZSwgQm91bmRFdmVudCBhcyBUbXBsQXN0Qm91bmRFdmVudCwgQm91bmRUZXh0IGFzIFRtcGxBc3RCb3VuZFRleHQsIENvbnRlbnQgYXMgVG1wbEFzdENvbnRlbnQsIEVsZW1lbnQgYXMgVG1wbEFzdEVsZW1lbnQsIFJlY3Vyc2l2ZVZpc2l0b3IgYXMgVG1wbEFzdFJlY3Vyc2l2ZVZpc2l0b3IsIFJlZmVyZW5jZSBhcyBUbXBsQXN0UmVmZXJlbmNlLCBUZW1wbGF0ZSBhcyBUbXBsQXN0VGVtcGxhdGUsIFRleHQgYXMgVG1wbEFzdFRleHQsIFRleHRBdHRyaWJ1dGUgYXMgVG1wbEFzdFRleHRBdHRyaWJ1dGUsIFZhcmlhYmxlIGFzIFRtcGxBc3RWYXJpYWJsZSwgSWRlbnRpZmllcnMkMSBhcyBSM0lkZW50aWZpZXJzLCBSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGUsIGNvbXBpbGVJbmplY3RvciwgY29tcGlsZU5nTW9kdWxlLCBjb21waWxlUGlwZUZyb21NZXRhZGF0YSwgbWFrZUJpbmRpbmdQYXJzZXIsIHBhcnNlVGVtcGxhdGUsIGNvbXBpbGVCYXNlRGVmRnJvbU1ldGFkYXRhLCBjb21waWxlQ29tcG9uZW50RnJvbU1ldGFkYXRhLCBjb21waWxlRGlyZWN0aXZlRnJvbU1ldGFkYXRhLCBwYXJzZUhvc3RCaW5kaW5ncywgdmVyaWZ5SG9zdEJpbmRpbmdzLCBwdWJsaXNoRmFjYWRlLCBWRVJTSU9OJDEgYXMgVkVSU0lPTiwgVGV4dEFzdCwgQm91bmRUZXh0QXN0LCBBdHRyQXN0LCBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdCwgQm91bmRFdmVudEFzdCwgUmVmZXJlbmNlQXN0LCBWYXJpYWJsZUFzdCwgRWxlbWVudEFzdCwgRW1iZWRkZWRUZW1wbGF0ZUFzdCwgQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdCwgRGlyZWN0aXZlQXN0LCBQcm92aWRlckFzdCwgUHJvdmlkZXJBc3RUeXBlLCBOZ0NvbnRlbnRBc3QsIE51bGxUZW1wbGF0ZVZpc2l0b3IsIFJlY3Vyc2l2ZVRlbXBsYXRlQXN0VmlzaXRvciwgdGVtcGxhdGVWaXNpdEFsbCwgc2FuaXRpemVJZGVudGlmaWVyLCBpZGVudGlmaWVyTmFtZSwgaWRlbnRpZmllck1vZHVsZVVybCwgdmlld0NsYXNzTmFtZSwgcmVuZGVyZXJUeXBlTmFtZSwgaG9zdFZpZXdDbGFzc05hbWUsIGNvbXBvbmVudEZhY3RvcnlOYW1lLCBDb21waWxlU3VtbWFyeUtpbmQsIHRva2VuTmFtZSwgdG9rZW5SZWZlcmVuY2UsIENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEsIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhLCBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEsIENvbXBpbGVQaXBlTWV0YWRhdGEsIENvbXBpbGVTaGFsbG93TW9kdWxlTWV0YWRhdGEsIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhLCBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEsIFByb3ZpZGVyTWV0YSwgZmxhdHRlbiwgdGVtcGxhdGVTb3VyY2VVcmwsIHNoYXJlZFN0eWxlc2hlZXRKaXRVcmwsIG5nTW9kdWxlSml0VXJsLCB0ZW1wbGF0ZUppdFVybCwgY3JlYXRlQW90VXJsUmVzb2x2ZXIsIGNyZWF0ZUFvdENvbXBpbGVyLCBBb3RDb21waWxlciwgYW5hbHl6ZU5nTW9kdWxlcywgYW5hbHl6ZUFuZFZhbGlkYXRlTmdNb2R1bGVzLCBhbmFseXplRmlsZSwgYW5hbHl6ZUZpbGVGb3JJbmplY3RhYmxlcywgbWVyZ2VBbmFseXplZEZpbGVzLCBHZW5lcmF0ZWRGaWxlLCB0b1R5cGVTY3JpcHQsIGZvcm1hdHRlZEVycm9yLCBpc0Zvcm1hdHRlZEVycm9yLCBTdGF0aWNSZWZsZWN0b3IsIFN0YXRpY1N5bWJvbCwgU3RhdGljU3ltYm9sQ2FjaGUsIFJlc29sdmVkU3RhdGljU3ltYm9sLCBTdGF0aWNTeW1ib2xSZXNvbHZlciwgdW5lc2NhcGVJZGVudGlmaWVyLCB1bndyYXBSZXNvbHZlZE1ldGFkYXRhLCBBb3RTdW1tYXJ5UmVzb2x2ZXIsIEFzdFBhdGgsIFN1bW1hcnlSZXNvbHZlciwgSml0U3VtbWFyeVJlc29sdmVyLCBDb21waWxlUmVmbGVjdG9yLCBjcmVhdGVVcmxSZXNvbHZlcldpdGhvdXRQYWNrYWdlUHJlZml4LCBjcmVhdGVPZmZsaW5lQ29tcGlsZVVybFJlc29sdmVyLCBVcmxSZXNvbHZlciwgZ2V0VXJsU2NoZW1lLCBSZXNvdXJjZUxvYWRlciwgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBFeHRyYWN0b3IsIEkxOE5IdG1sUGFyc2VyLCBNZXNzYWdlQnVuZGxlLCBTZXJpYWxpemVyLCBYbGlmZiwgWGxpZmYyLCBYbWIsIFh0YiwgRGlyZWN0aXZlTm9ybWFsaXplciwgUGFyc2VyRXJyb3IsIFBhcnNlU3BhbiwgQVNULCBRdW90ZSwgRW1wdHlFeHByLCBJbXBsaWNpdFJlY2VpdmVyLCBDaGFpbiwgQ29uZGl0aW9uYWwsIFByb3BlcnR5UmVhZCwgUHJvcGVydHlXcml0ZSwgU2FmZVByb3BlcnR5UmVhZCwgS2V5ZWRSZWFkLCBLZXllZFdyaXRlLCBCaW5kaW5nUGlwZSwgTGl0ZXJhbFByaW1pdGl2ZSwgTGl0ZXJhbEFycmF5LCBMaXRlcmFsTWFwLCBJbnRlcnBvbGF0aW9uLCBCaW5hcnksIFByZWZpeE5vdCwgTm9uTnVsbEFzc2VydCwgTWV0aG9kQ2FsbCwgU2FmZU1ldGhvZENhbGwsIEZ1bmN0aW9uQ2FsbCwgQWJzb2x1dGVTb3VyY2VTcGFuLCBBU1RXaXRoU291cmNlLCBUZW1wbGF0ZUJpbmRpbmcsIE51bGxBc3RWaXNpdG9yLCBSZWN1cnNpdmVBc3RWaXNpdG9yJDEgYXMgUmVjdXJzaXZlQXN0VmlzaXRvciwgQXN0VHJhbnNmb3JtZXIkMSBhcyBBc3RUcmFuc2Zvcm1lciwgQXN0TWVtb3J5RWZmaWNpZW50VHJhbnNmb3JtZXIsIHZpc2l0QXN0Q2hpbGRyZW4sIFBhcnNlZFByb3BlcnR5LCBQYXJzZWRQcm9wZXJ0eVR5cGUsIFBhcnNlZEV2ZW50LCBQYXJzZWRWYXJpYWJsZSwgQm91bmRFbGVtZW50UHJvcGVydHksIFRva2VuVHlwZSQxIGFzIFRva2VuVHlwZSwgTGV4ZXIsIFRva2VuJDEgYXMgVG9rZW4sIEVPRiwgaXNJZGVudGlmaWVyLCBpc1F1b3RlLCBTcGxpdEludGVycG9sYXRpb24sIFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0LCBQYXJzZXIkMSBhcyBQYXJzZXIsIF9QYXJzZUFTVCwgRVJST1JfQ09NUE9ORU5UX1RZUEUsIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLCBUZXh0JDMgYXMgVGV4dCwgRXhwYW5zaW9uLCBFeHBhbnNpb25DYXNlLCBBdHRyaWJ1dGUsIEVsZW1lbnQkMSBhcyBFbGVtZW50LCBDb21tZW50LCB2aXNpdEFsbCQxIGFzIHZpc2l0QWxsLCBSZWN1cnNpdmVWaXNpdG9yJDEgYXMgUmVjdXJzaXZlVmlzaXRvciwgZmluZE5vZGUsIEh0bWxQYXJzZXIsIFBhcnNlVHJlZVJlc3VsdCwgVHJlZUVycm9yLCBIdG1sVGFnRGVmaW5pdGlvbiwgZ2V0SHRtbFRhZ0RlZmluaXRpb24sIFRhZ0NvbnRlbnRUeXBlLCBzcGxpdE5zTmFtZSwgaXNOZ0NvbnRhaW5lciwgaXNOZ0NvbnRlbnQsIGlzTmdUZW1wbGF0ZSwgZ2V0TnNQcmVmaXgsIG1lcmdlTnNBbmROYW1lLCBOQU1FRF9FTlRJVElFUywgTkdTUF9VTklDT0RFLCBkZWJ1Z091dHB1dEFzdEFzVHlwZVNjcmlwdCwgVHlwZVNjcmlwdEVtaXR0ZXIsIFBhcnNlTG9jYXRpb24sIFBhcnNlU291cmNlRmlsZSwgUGFyc2VTb3VyY2VTcGFuLCBFTVBUWV9QQVJTRV9MT0NBVElPTiwgRU1QVFlfU09VUkNFX1NQQU4sIFBhcnNlRXJyb3JMZXZlbCwgUGFyc2VFcnJvciwgdHlwZVNvdXJjZVNwYW4sIHIzSml0VHlwZVNvdXJjZVNwYW4sIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgQ3NzU2VsZWN0b3IsIFNlbGVjdG9yTWF0Y2hlciwgU2VsZWN0b3JMaXN0Q29udGV4dCwgU2VsZWN0b3JDb250ZXh0LCBIT1NUX0FUVFIsIENPTlRFTlRfQVRUUiwgU3R5bGVzQ29tcGlsZURlcGVuZGVuY3ksIENvbXBpbGVkU3R5bGVzaGVldCwgU3R5bGVDb21waWxlciwgVGVtcGxhdGVQYXJzZUVycm9yLCBUZW1wbGF0ZVBhcnNlUmVzdWx0LCBUZW1wbGF0ZVBhcnNlciwgc3BsaXRDbGFzc2VzLCBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3IsIHJlbW92ZVN1bW1hcnlEdXBsaWNhdGVzLCBpc0VtcHR5RXhwcmVzc2lvbiwgY29tcGlsZUluamVjdGFibGUsIFIzVGFyZ2V0QmluZGVyLCBSM0JvdW5kVGFyZ2V0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21waWxlci5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@angular/compiler/fesm5/compiler.js\n");

/***/ })

}]);